<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>android realm</title>
    <url>/2015/05/05/android-2015-05-05-Android-Realm/</url>
    <content><![CDATA[<p>Realm is a mobile database that runs directly inside phones, tablets or wearables. This repository holds the source code for the Java version of Realm, which currently runs only on Android.</p>
<span id="more"></span>

<p>Realm是一个移动端的数据库，它可以在手机、平板。穿戴设备上运行。这个仓库的代码是一个Java版本的代码，目前只用在安卓端。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://github.com/realm/realm-java">https://github.com/realm/realm-java</a></p>
<p>导入JAR</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &#39;io.realm:realm-android:0.87.0&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Application 中配置，不配置也可以，就是默认的哦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        initRealm();</span><br><span class="line">    &#125;</span><br><span class="line">    private void initRealm()&#123;</span><br><span class="line">        RealmConfiguration configuration &#x3D; new RealmConfiguration</span><br><span class="line">                .Builder(this)</span><br><span class="line">                .name(&quot;test.realm&quot;)</span><br><span class="line">                .deleteRealmIfMigrationNeeded()</span><br><span class="line">                .schemaVersion(7).migration(new RealmMigration() &#123;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void migrate(DynamicRealm realm, long oldVersion, long newVersion) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).build();</span><br><span class="line"></span><br><span class="line">        Realm.setDefaultConfiguration(configuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建实体类，需集成RealmObject</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User  extends RealmObject&#123;</span><br><span class="line">    @PrimaryKey</span><br><span class="line">    private String id;</span><br><span class="line">    private String userName;</span><br><span class="line">    private String mobile;</span><br><span class="line"></span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName &#x3D; userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMobile() &#123;</span><br><span class="line">        return mobile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMobile(String mobile) &#123;</span><br><span class="line">        this.mobile &#x3D; mobile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在Activity中初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Realm myRealm ;</span><br><span class="line"> myRealm&#x3D; Realm.getInstance(this);</span><br></pre></td></tr></table></figure>

<p>添加数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Realm开始处理事物  方式1：</span><br><span class="line">      myRealm.beginTransaction();</span><br><span class="line">      User user &#x3D; myRealm.createObject(User.class);</span><br><span class="line">      user.setId(&quot;445115&quot;);</span><br><span class="line">      user.setMobile(&quot;44545&quot;);</span><br><span class="line">      user.setUserName(&quot;hha&quot;);</span><br><span class="line">      myRealm.commitTransaction();</span><br><span class="line">      &#x2F;&#x2F;方式2：</span><br><span class="line">User user2&#x3D;new User();</span><br><span class="line">      user2.setId(&quot;1123&quot;);</span><br><span class="line">      user2.setUserName(&quot;sss&quot;);</span><br><span class="line">      user2.setMobile(&quot;445&quot;);</span><br><span class="line">      myRealm.beginTransaction();</span><br><span class="line">      User userCopy2 &#x3D; myRealm.copyToRealm(user2);</span><br><span class="line">      myRealm.commitTransaction();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查找数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RealmResults&lt;User&gt; listUser &#x3D; myRealm.where(User.class).findAll();</span><br><span class="line"></span><br><span class="line">       StringBuilder stringBuilder&#x3D;new StringBuilder();</span><br><span class="line"></span><br><span class="line">       for(User u:listUser) &#123;</span><br><span class="line">           stringBuilder.append(u.getUserName()+&quot;--------****--------- &quot;);</span><br><span class="line">           Log.d(&quot;results1&quot;,u.getUserName());</span><br><span class="line">       &#125;</span><br><span class="line">       tv.setText(stringBuilder.toString());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/forezp/RealmJavaTest">源码下载</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">csdn博客</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android js 互调</title>
    <url>/2015/05/05/android-2015-05-05-Javascript-android-react/</url>
    <content><![CDATA[<p>最近在做原生和js端的互调的功能，自己改了个demo，给大家讲解下。</p>
<span id="more"></span>

<p>先上js代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;方法调用基本流程测试&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;helloweb&quot;&gt; </span><br><span class="line">	&lt;div id&#x3D;&quot;echoInfo&quot;&gt;如果有数据返回，会显示在这儿&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">	</span><br><span class="line">	function funFromjs()&#123;</span><br><span class="line">    	document.getElementById(&quot;helloweb&quot;).innerHTML&#x3D;&quot;HelloWebView,i&#39;m from js&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">		function echoInfo( container, obj )&#123;</span><br><span class="line">			var domContainer &#x3D; document.getElementById(&#39;echoInfo&#39;);</span><br><span class="line">			domContainer.innerHTML &#x3D; JSON.stringify( obj );</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;function windowCallback( str )&#123;</span><br><span class="line">			&#x2F;&#x2F;echoInfo( &#39;echoInfo&#39;, str );</span><br><span class="line">		&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">		 window.windowCallback &#x3D; function( str )&#123;</span><br><span class="line">		 	echoInfo( &#39;echoInfo&#39;, str );</span><br><span class="line">		 &#125;;</span><br><span class="line"></span><br><span class="line">		var MfsJSBridge &#x3D; MfsJSBridge || undefined;</span><br><span class="line">		if( undefined !&#x3D; MfsJSBridge )&#123;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;看这里</span><br><span class="line">			var params &#x3D; &#123;</span><br><span class="line">				id : 1,</span><br><span class="line">				name : &#39;测试&#39;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			var strParams &#x3D; JSON.stringify( params );</span><br><span class="line"></span><br><span class="line">			MfsJSBridge.invoke( &#39;testFunc&#39;, strParams, &#39;windowCallback&#39;);</span><br><span class="line"></span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			alert(&#39;未定义MfsJSBridge&#39;);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>android webview 设置可用javascript</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置编码</span></span><br><span class="line"> mWebView.getSettings().setDefaultTextEncodingName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> <span class="comment">//支持js</span></span><br><span class="line">mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>android 调js</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mBtn1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">              mWebView.loadUrl(<span class="string">&quot;javascript:funFromjs()&quot;</span>);<span class="comment">//其中funFromjs()为js的方法</span></span><br><span class="line">              Toast.makeText(mContext, <span class="string">&quot;调用javascript:funFromjs()&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>js调原生，原生响应时间并回调数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mWebView.addJavascriptInterface(<span class="keyword">new</span> Object()&#123;</span><br><span class="line">       	<span class="comment">//注意4.4以后加注解，位置在这个方法名上面，鉴于很多这个的例子，瞎、、写注解位置，并需要下                        //载积分写了这个</span></span><br><span class="line">        <span class="meta">@JavascriptInterface</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(String name ,String t,String callback)</span> </span>&#123;</span><br><span class="line">           	<span class="keyword">if</span>(name.equals(<span class="string">&quot;testFunc&quot;</span>))&#123; </span><br><span class="line">           	<span class="comment">//其中t 为js带过来的数据          </span></span><br><span class="line">           		Toast.makeText(mContext, t,Toast.LENGTH_LONG).show();</span><br><span class="line">           		</span><br><span class="line">           		String strJson = <span class="string">&quot;&#123;\&quot;code\&quot;:122, \&quot;msg\&quot;:\&quot;1231\&quot;, \&quot;data\&quot;:null&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">           		<span class="comment">//回调数据给js 其中callback 为android 掉js 的方法名称。</span></span><br><span class="line">           		mWebView.loadUrl(<span class="string">&quot;javascript:&quot;</span>+ callback +<span class="string">&quot;(&#x27;&quot;</span> + strJson + <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line">           	&#125;</span><br><span class="line">             <span class="comment">//  Toast.makeText(mContext, name, Toast.LENGTH_LONG).show();</span></span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;MfsJSBridge&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>代码比较简单，最主要的是 @JavascriptInterface注解的位置大家注意下。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9555368">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android design新控件</title>
    <url>/2015/05/05/android-2015-05-05-android-design/</url>
    <content><![CDATA[<p> 最近在研究android   开发的新控件，包括drawer layout ,NavigationView,CoordinatorLayout,AppBarLayout,Toolbar,TabLayout,SwipeRefreshLayout,Recyclerview等。</p>
<span id="more"></span>

<p>先上效果图：</p>
<p><img src="http://img.blog.csdn.net/20160710200140616" width = "300"  alt="图片名称" align=center />     <img src="http://img.blog.csdn.net/20160710200214538" width = "300"  alt="图片名称" align=center /><br><img src="http://img.blog.csdn.net/20160710200253055" width = "300"  alt="图片名称" align=center />   <img src="http://img.blog.csdn.net/20160710200353322" width = "300"  alt="图片名称" align=center /></p>
<p>主界面上drawlayou 和NavigationView形成抽屉效果，布局文件如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;android.support.v4.widget.DrawerLayout</span><br><span class="line">    xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/id_drawerlayout&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    &gt;</span><br><span class="line">    &lt;include layout=<span class="string">&quot;@layout/home_content&quot;</span>/&gt;</span><br><span class="line">    &lt;android.support.design.widget.NavigationView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/id_navigationview&quot;</span></span><br><span class="line">        app:itemTextColor=<span class="string">&quot;@color/selector_nav_menu_textcolor&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;left&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/android.support.design.widget.NavigationView&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.v4.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure>
<p>java代码：抽屉部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drawerLayout &#x3D; (DrawerLayout)findViewById(R.id.id_drawerlayout);</span><br><span class="line">navigationView &#x3D; (NavigationView)findViewById(R.id.id_navigationview);</span><br><span class="line"> ActionBarDrawerToggle mActionBarDrawerToggle &#x3D;</span><br><span class="line">                new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.open, R.string.close);</span><br><span class="line">        mActionBarDrawerToggle.syncState();</span><br><span class="line">        drawerLayout.setDrawerListener(mActionBarDrawerToggle);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;给NavigationView填充顶部区域，也可在xml中使用app:headerLayout&#x3D;&quot;@layout&#x2F;header_nav&quot;来设置</span><br><span class="line">        navigationView.inflateHeaderView(R.layout.header_nav);</span><br><span class="line">        View headerView &#x3D; navigationView.getHeaderView(0);</span><br><span class="line"></span><br><span class="line">        CircleImageView circleImageView &#x3D; (CircleImageView)headerView.findViewById(R.id.id_circleview);</span><br><span class="line">        Glide.with(this).load(&quot;http:&#x2F;&#x2F;pic1.nipic.com&#x2F;2008-10-30&#x2F;200810309416546_2.jpg&quot;).into(circleImageView);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;给NavigationView填充Menu菜单，也可在xml中使用app:menu&#x3D;&quot;@menu&#x2F;menu_nav&quot;来设置</span><br><span class="line">        navigationView.inflateMenu(R.menu.menu_nav);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以给navigationview 设置点击事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mNav.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123;</span><br><span class="line">            @Override public boolean onNavigationItemSelected(MenuItem menuItem) &#123;</span><br><span class="line"></span><br><span class="line">                String msgString &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">                switch (menuItem.getItemId()) &#123;</span><br><span class="line">                    case R.id.nav_menu_home:</span><br><span class="line">                        msgString &#x3D; (String) menuItem.getTitle();</span><br><span class="line">                        break;</span><br><span class="line">                    case R.id.nav_menu_categories:</span><br><span class="line">                        msgString &#x3D; (String) menuItem.getTitle();</span><br><span class="line">                        break;</span><br><span class="line">                    case R.id.nav_menu_feedback:</span><br><span class="line">                        msgString &#x3D; (String) menuItem.getTitle();</span><br><span class="line">                        break;</span><br><span class="line">                    case R.id.nav_menu_setting:</span><br><span class="line">                        msgString &#x3D; (String) menuItem.getTitle();</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Menu item点击后选中，并关闭Drawerlayout</span><br><span class="line">                menuItem.setChecked(true);</span><br><span class="line">                drawerLayout.closeDrawers();</span><br><span class="line"></span><br><span class="line">                Toast.makeText(HomeActivity.this,msgString,Toast.LENGTH_SHORT).show();</span><br><span class="line">               </span><br><span class="line">                return true;</span><br></pre></td></tr></table></figure>
<p>draw layout  和navigation view 组合可以写成非常好的抽屉效果，避免了第三方库，用原生的感觉非常棒。<br>－－－－－－－－－－抽屉部分结束－－－－－－－－－－－<br><br></br><br><br></br></p>
<p>tab layout 和view pager 实现联动效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化ViewPager的适配器，并设置给它</span><br><span class="line">       mViewPagerAdapter &#x3D; new MyViewPagerAdapter(getSupportFragmentManager(), mTitles, mFragments);</span><br><span class="line">       viewPager.setAdapter(mViewPagerAdapter);</span><br><span class="line">       &#x2F;&#x2F; 设置ViewPager最大缓存的页面个数</span><br><span class="line">       viewPager.setOffscreenPageLimit(5);</span><br><span class="line">       &#x2F;&#x2F; 给ViewPager添加页面动态监听器（为了让Toolbar中的Title可以变化相应的Tab的标题）</span><br><span class="line">       viewPager.addOnPageChangeListener(this);</span><br><span class="line"></span><br><span class="line">       tabLayout.setTabMode(MODE_SCROLLABLE);</span><br><span class="line">       &#x2F;&#x2F; 将TabLayout和ViewPager进行关联，让两者联动起来</span><br><span class="line">       tabLayout.setupWithViewPager(viewPager);</span><br><span class="line">       &#x2F;&#x2F; 设置Tablayout的Tab显示ViewPager的适配器中的getPageTitle函数获取到的标题</span><br><span class="line">       tabLayout.setTabsFromPagerAdapter(mViewPagerAdapter);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>RefreshLayout 实现下拉刷新效果:<br>布局文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">       xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;id_swiperefreshlayout&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">       app:layout_behavior&#x3D;&quot;@string&#x2F;appbar_scrolling_view_behavior&quot;</span><br><span class="line">       &gt;</span><br><span class="line"></span><br><span class="line">       &lt;!--</span><br><span class="line">               使用RecyclerView需要在build.gradle中添加</span><br><span class="line">              compile &#39;com.android.support:recyclerview-v7:23.3.0&#39;</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">           android:id&#x3D;&quot;@+id&#x2F;id_recyclerview&quot;</span><br><span class="line">           android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">           android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">           android:foregroundGravity&#x3D;&quot;center&quot;</span><br><span class="line">           &#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;android.support.v4.widget.SwipeRefreshLayout&gt;</span><br></pre></td></tr></table></figure>
<p>在fragment 实现下拉刷新接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DemoFragment extends Fragment implements SwipeRefreshLayout.OnRefreshListener&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>mSwipeRefreshLayout实现下拉是的颜色变化，和设置监听事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mSwipeRefreshLayout.setColorSchemeResources(R.color.main_blue_light, R.color.main_blue_dark);</span><br><span class="line"> mSwipeRefreshLayout.setOnRefreshListener(this);</span><br></pre></td></tr></table></figure>
<p>下拉刷新刷新数据的接口实现的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onRefresh() &#123;</span><br><span class="line"></span><br><span class="line">        new Handler().postDelayed(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">               mSwipeRefreshLayout.setRefreshing(false);&#x2F;&#x2F;关闭下拉动画</span><br><span class="line"></span><br><span class="line">                           </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>－－－－－－－－－下拉刷新结束－－－－－－－－－－</p>
<p>RecyclerView可以实现listview （横行和纵向）.gridview（横行和纵向） ,瀑布流的效果。<br>我讲解一下最简单的效果：listview的效果：<br>直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mLayoutManager &#x3D;new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false);</span><br><span class="line">mRecyclerViewAdapter &#x3D; new DemoRecyclerViewAdapter(getActivity());</span><br><span class="line">mRecyclerViewAdapter.setOnItemClickListener(this);</span><br><span class="line">            mRecyclerView.setAdapter(mRecyclerViewAdapter);</span><br><span class="line">            mRecyclerViewAdapter.setList(list);</span><br><span class="line">            mRecyclerView.setLayoutManager(mLayoutManager);</span><br><span class="line">            mRecyclerViewAdapter.notifyDataSetChanged();                        </span><br></pre></td></tr></table></figure>
<p>其中adapter 的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DemoRecyclerViewAdapter extends RecyclerView.Adapter&lt;DemoRecyclerViewHolder&gt; &#123;</span><br><span class="line">    private Context context;</span><br><span class="line">    private ArrayList&lt;ImageBean&gt; list;</span><br><span class="line">  </span><br><span class="line">    public DemoRecyclerViewAdapter(Context mContext) &#123;</span><br><span class="line">        this.context &#x3D; mContext;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public DemoRecyclerViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">        View mView&#x3D; LayoutInflater.from(context).inflate(R.layout.item_demo_adapter,parent,false);</span><br><span class="line">        DemoRecyclerViewHolder recyclerViewHolder&#x3D;new DemoRecyclerViewHolder(mView);</span><br><span class="line">        return recyclerViewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onBindViewHolder(final DemoRecyclerViewHolder holder, final int position) &#123;</span><br><span class="line">        if(mOnItemClickListener!&#x3D;null)&#123;</span><br><span class="line">            holder.itemView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onClick(View v) &#123;</span><br><span class="line">                    mOnItemClickListener.onItemClick(holder.itemView,position);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public boolean onLongClick(View v) &#123;</span><br><span class="line">                    mOnItemClickListener.onItemLongClick(holder.itemView, position);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        holder.textView.setText(list.get(position).getName());</span><br><span class="line">        Glide.with(context).load(list.get(position).getImg()).into(holder.imageView);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getItemCount() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>adapter的写法根之前BaseAdapter 很类似，需要特别注意的是:<br>加载布局文件的方法一定是这个，要不然会出现match_parent 失效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View mView&#x3D; LayoutInflater.from(context).inflate(R.layout.item_demo_adapter,parent,false);</span><br></pre></td></tr></table></figure>
<p>还有一些其他的控件如cardview 比较简单就不说了，toolbar的用法会在下次给出好的例子。</p>
<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9571175">源码下载</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android轮播图</title>
    <url>/2015/05/05/android-2015-05-05-android-galaeery/</url>
    <content><![CDATA[<p> 最近做项目，自己封装了一个图片轮播的组件，主要的思想就采用ViewPager和ScrollGater实现，图片加载用的Imageloader，也可以换其他的，比如Glide.具体封装的组件件源码，这里只说下用法，首先上布局文件。</p>
<span id="more"></span>
<img src="http://img.blog.csdn.net/20160708091623612" width = "300"  alt="图片名称" align=center />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.MainActivity&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/root&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;180dp&quot;</span></span><br><span class="line">        android:orientation=<span class="string">&quot;vertical&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">        &lt;com.example.shuffviewdemo.ShufflingView</span><br><span class="line">            android:id=<span class="string">&quot;@+id/shuffling_view&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;wrap_content&quot;</span> &gt;</span><br><span class="line">        &lt;/com.example.shuffviewdemo.ShufflingView&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 初始化ShufflingView,设置des可见，轮播的指示器在底部。设置点击事件监听。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mShufflingView = (ShufflingView) findViewById(R.id.shuffling_view);</span><br><span class="line">		mShufflingView.setContentDesVisibility(View.VISIBLE);</span><br><span class="line">		mShufflingView.setDotGravity(Gravity.BOTTOM);</span><br><span class="line">		mShufflingView.setOnItemClickListener(mOnShufflingItemClickListener);</span><br><span class="line">		bannerList = <span class="keyword">new</span> ArrayList&lt;ShufflingItemBean&gt;();</span><br><span class="line">		loadShuffingViewData();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置shufflingView 的beans接收的是一个arraylist对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ShufflingItemBean shufflingItemBean=<span class="keyword">new</span> ShufflingItemBean();</span><br><span class="line">		shufflingItemBean.setImg(<span class="string">&quot;http://img3.imgtn.bdimg.com/it/u=4227020988,3565099621&amp;fm=21&amp;gp=0.jpg&quot;</span>);</span><br><span class="line">		shufflingItemBean.setUrl(<span class="string">&quot;www.baidu.com&quot;</span>);<span class="comment">//点击跳转到webview</span></span><br><span class="line">		bannerList.add(shufflingItemBean);</span><br><span class="line">		bannerList.add(shufflingItemBean);</span><br><span class="line">		bannerList.add(shufflingItemBean);</span><br><span class="line">		mShufflingView.updateDatas(bannerList);</span><br></pre></td></tr></table></figure>

<p>shufflingView 的监听，具体的跳转和类型，根据需求组件设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">actionFromType</span><span class="params">(Context context, ShufflingItemBean item)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;-1&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;1&quot;</span>)) &#123;<span class="comment">// 交易贴</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;2&quot;</span>)) &#123;<span class="comment">// 外部链接</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;3&quot;</span>)) &#123;<span class="comment">// 资讯贴</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;4&quot;</span>)) &#123;<span class="comment">// 应援贴</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;5&quot;</span>)) &#123;<span class="comment">//</span></span><br><span class="line">			<span class="comment">//Intent intent = new Intent(context, WebViewActivity.class);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">//intent.putExtra(&quot;url&quot;,</span></span><br><span class="line">			<span class="comment">//item.getUrl());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">//intent.putExtra(&quot;type&quot;, 1);</span></span><br><span class="line">			<span class="comment">//context.startActivity(intent);</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 其他</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9570165">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android 动画</title>
    <url>/2015/05/05/android-2015-05-05-android-gif/</url>
    <content><![CDATA[<p>ObjectAnimator继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。那么既然是继承关系，说明ValueAnimator中可以使用的方法在ObjectAnimator中也是可以正常使用的，它们的用法也非常类似.</p>
<span id="more"></span>

<p>1.旋转控件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(textView, &quot;rotation&quot;, 0f, 360f);</span><br><span class="line">               animator.setDuration(5000);</span><br><span class="line">               animator.start();</span><br></pre></td></tr></table></figure>

<p>2.平移控件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float curTranslationX &#x3D; textView.getTranslationX();</span><br><span class="line">                ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(textView, &quot;translationX&quot;, curTranslationX, -500f, curTranslationX);</span><br><span class="line">                animator.setDuration(5000);</span><br><span class="line">                animator.start();</span><br></pre></td></tr></table></figure>
<p>3.放大缩小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(textView, &quot;scaleY&quot;, 1f, 3f, 1f);</span><br><span class="line">               animator.setDuration(3000);</span><br><span class="line">               animator.start();</span><br></pre></td></tr></table></figure>

<p>4.透明  控件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(textView, &quot;alpha&quot;, 1f, 0f,1f);</span><br><span class="line">              animator.setDuration(3000);</span><br><span class="line">              animator.start();</span><br></pre></td></tr></table></figure>
<p>用法确实比较简单。<br>5.组合动画<br>实现组合动画功能主要需要借助AnimatorSet这个类，这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法：<br>after(Animator anim)   将现有动画插入到传入的动画之后执行<br>after(long delay)   将现有动画延迟指定毫秒后执行<br>before(Animator anim)   将现有动画插入到传入的动画之前执行<br>with(Animator anim)   将现有动画和传入的动画同时执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator moveIn &#x3D; ObjectAnimator.ofFloat(textView, &quot;translationX&quot;, -500f, 0f);</span><br><span class="line">               ObjectAnimator rotate &#x3D; ObjectAnimator.ofFloat(textView, &quot;rotation&quot;, 0f, 360f);</span><br><span class="line">               ObjectAnimator fadeInOut &#x3D; ObjectAnimator.ofFloat(textView, &quot;alpha&quot;, 1f, 0f, 1f);</span><br><span class="line">               AnimatorSet animSet &#x3D; new AnimatorSet();</span><br><span class="line">               AnimatorSet.Builder builder&#x3D;animSet.play(rotate);</span><br><span class="line">               builder.with(fadeInOut).after(moveIn);</span><br><span class="line">               animSet.setDuration(5000);</span><br><span class="line">               animSet.start();</span><br></pre></td></tr></table></figure>

<p>布局实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:ordering&#x3D;&quot;sequentially&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:propertyName&#x3D;&quot;translationX&quot;</span><br><span class="line">        android:valueFrom&#x3D;&quot;-500&quot;</span><br><span class="line">        android:valueTo&#x3D;&quot;0&quot;</span><br><span class="line">        android:valueType&#x3D;&quot;floatType&quot; &gt;</span><br><span class="line">    &lt;&#x2F;objectAnimator&gt;</span><br><span class="line"></span><br><span class="line">    &lt;set android:ordering&#x3D;&quot;together&quot; &gt;</span><br><span class="line">        &lt;objectAnimator</span><br><span class="line">            android:duration&#x3D;&quot;3000&quot;</span><br><span class="line">            android:propertyName&#x3D;&quot;rotation&quot;</span><br><span class="line">            android:valueFrom&#x3D;&quot;0&quot;</span><br><span class="line">            android:valueTo&#x3D;&quot;360&quot;</span><br><span class="line">            android:valueType&#x3D;&quot;floatType&quot; &gt;</span><br><span class="line">        &lt;&#x2F;objectAnimator&gt;</span><br><span class="line"></span><br><span class="line">        &lt;set android:ordering&#x3D;&quot;sequentially&quot; &gt;</span><br><span class="line">            &lt;objectAnimator</span><br><span class="line">                android:duration&#x3D;&quot;1500&quot;</span><br><span class="line">                android:propertyName&#x3D;&quot;alpha&quot;</span><br><span class="line">                android:valueFrom&#x3D;&quot;1&quot;</span><br><span class="line">                android:valueTo&#x3D;&quot;0&quot;</span><br><span class="line">                android:valueType&#x3D;&quot;floatType&quot; &gt;</span><br><span class="line">            &lt;&#x2F;objectAnimator&gt;</span><br><span class="line">            &lt;objectAnimator</span><br><span class="line">                android:duration&#x3D;&quot;1500&quot;</span><br><span class="line">                android:propertyName&#x3D;&quot;alpha&quot;</span><br><span class="line">                android:valueFrom&#x3D;&quot;0&quot;</span><br><span class="line">                android:valueTo&#x3D;&quot;1&quot;</span><br><span class="line">                android:valueType&#x3D;&quot;floatType&quot; &gt;</span><br><span class="line">            &lt;&#x2F;objectAnimator&gt;</span><br><span class="line">        &lt;&#x2F;set&gt;</span><br><span class="line">    &lt;&#x2F;set&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animator animator &#x3D; AnimatorInflater.loadAnimator(MainActivity.this, R.animator.setanim);</span><br><span class="line">                animator.setTarget(textView);</span><br><span class="line">                animator.start();</span><br></pre></td></tr></table></figure>
<p>调用AnimatorInflater的loadAnimator来将XML动画文件加载进来，然后再调用setTarget()方法将这个动画设置到某一个对象上面，最后再调用start()方法启动动画就可以了，就是这么简单。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9587802">源码下载</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">csdn博客</a></p>
<p> 本文参考了 郭神的博客：<a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/43536355">http://blog.csdn.net/guolin_blog/article/details/43536355</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android最新学习资料收集</title>
    <url>/2015/05/05/android-2015-05-05-android-materials/</url>
    <content><![CDATA[<p>收集这份资料的灵感来源于我的浏览器收藏夹快爆了，后来在github 上也看到了很优秀的开源库的收集资料，非常的好，但是太过于多，也不够新，所以决定自己来做一个。原始的markdowm文件已经放到github上，欢迎<a target="_blank" rel="noopener" href="https://github.com/forezp/AndroidMaterialLatest">下载和star</a> 。这份资料我会不断的完善，也欢迎一些经验丰富的开发者可以一起来完善，直接<a target="_blank" rel="noopener" href="https://github.com/forezp/AndroidMaterialLatest/pulls">pull request</a> 或者<a target="_blank" rel="noopener" href="https://github.com/forezp/AndroidMaterialLatest/issues">issue</a>，我会定期筛选合并，有一些好的建议和意见随时<a href="#%E8%81%94%E7%B3%BB%E6%88%91">联系我</a>，欢迎转载，谢谢收藏。</p>
<span id="more"></span>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E5%AE%89%E5%8D%93%E6%B5%81%E8%A1%8C%E6%A1%86%E6%9E%B6%E6%8E%A8%E8%8D%90">安卓流行框架</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99">常用网站</a></li>
<li><a href="#%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90">博客推荐</a></li>
<li><a href="#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E8%8D%90">微信公众号推荐</a></li>
<li><a href="#%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90">书籍推荐</a></li>
<li><a href="#RxJava%E7%B3%BB%E5%88%97">RxJava系列</a></li>
<li><a href="#retrofi%E7%B3%BB%E5%88%97">retrofi系列</a></li>
<li><a href="#MVP%E7%B3%BB%E5%88%97">MVP系列</a></li>
<li><a href="#MaterialDesign%E7%B3%BB%E5%88%97">MaterialDesign系列</a></li>
<li><a href="#MVP-retrofit-rxjava-materialDesign%E7%B3%BB%E5%88%97">MVP-retrofit-rxjava-materialDesign系列</a></li>
<li><a href="#Kotlin%E7%B3%BB%E5%88%97">Kotlin系列</a></li>
<li><a href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0">开源项目学习</a></li>
<li><a href="#%E5%BC%80%E6%BA%90%E5%BA%93%E6%94%B6%E9%9B%86">开源库收集</a></li>
<li><a href="#Android%E5%BC%80%E5%8F%91%E8%80%85%E6%9D%82%E5%BF%97%E5%91%A8%E5%88%8A">Android开发者杂志周刊</a></li>
<li><a href="#%E5%B7%A5%E5%85%B7">工具</a></li>
<li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">开发环境</a></li>
<li><a href="#%E7%B4%A0%E6%9D%90">素材</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li>
<li><a href="#%E6%96%87%E6%A1%A3">文档</a></li>
<li><a href="#%E6%84%9F%E8%B0%A2">感谢</a></li>
<li><a href="#%E8%81%94%E7%B3%BB%E6%88%91">联系我</a></li>
</ul>
<p>=========================================================</p>
<h2 id="安卓流行框架"><a href="#安卓流行框架" class="headerlink" title="安卓流行框架"></a>安卓流行框架</h2><table>
<thead>
<tr>
<th>分类</th>
<th>框架名称</th>
<th>推荐理由</th>
</tr>
</thead>
<tbody><tr>
<td>缓存</td>
<td><a target="_blank" rel="noopener" href="https://github.com/JakeWharton/DiskLruCache">DiskLruCache</a></td>
<td>DiskLruCache ，JakeWharton开源，缓存神器</td>
</tr>
<tr>
<td>图片加载</td>
<td><a target="_blank" rel="noopener" href="https://github.com/bumptech/glide">Glide</a></td>
<td>可播放gif，谷歌推荐的图片加载</td>
</tr>
<tr>
<td>图片加载</td>
<td><a target="_blank" rel="noopener" href="https://github.com/facebook/fresco">Fresco</a></td>
<td>可播放gif，流畅性最好的加载框架，Facebook 出品</td>
</tr>
<tr>
<td>图片加载</td>
<td><a target="_blank" rel="noopener" href="https://github.com/square/picasso">Picasso</a></td>
<td>squre inc.开源的图片加载框架。</td>
</tr>
<tr>
<td>图片处理</td>
<td><a target="_blank" rel="noopener" href="https://github.com/wasabeef/picasso-transformations">Picasso—transformations</a></td>
<td>图片处理框架。</td>
</tr>
<tr>
<td>图片处理</td>
<td><a target="_blank" rel="noopener" href="https://github.com/wasabeef/glide-transformations">Glide—transformations</a></td>
<td>图片处理框架。</td>
</tr>
<tr>
<td>网络请求</td>
<td><a target="_blank" rel="noopener" href="https://github.com/square/okhttp">Okhttp</a></td>
<td>非常强大的一个网络请求框架。</td>
</tr>
<tr>
<td>网络请求</td>
<td><a target="_blank" rel="noopener" href="https://github.com/square/retrofit">Retrofit</a></td>
<td>基于okhttp ,squire出品，必属精品。。</td>
</tr>
<tr>
<td>网络请求</td>
<td><a target="_blank" rel="noopener" href="https://github.com/mcxiaoke/android-volley">volley</a></td>
<td>谷歌之前出品的网络框架。</td>
</tr>
<tr>
<td>数据解析</td>
<td><a target="_blank" rel="noopener" href="https://github.com/google/gson">Gson</a></td>
<td>非常好用的JSOn解析。</td>
</tr>
<tr>
<td>数据解析</td>
<td><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">jackson</a></td>
<td>这个也不错。</td>
</tr>
<tr>
<td>数据库</td>
<td><a target="_blank" rel="noopener" href="https://github.com/greenrobot/greenDAO">greendao</a></td>
<td>一个轻量、效率快的数据库。</td>
</tr>
<tr>
<td>数据库</td>
<td><a target="_blank" rel="noopener" href="https://github.com/realm/realm-java">realm</a></td>
<td>好用，替代sqlite。</td>
</tr>
<tr>
<td>数据库</td>
<td><a target="_blank" rel="noopener" href="https://github.com/satyan/sugar">Sugar</a></td>
<td>另外一个好用的数据库，个人推荐GreenDao。</td>
</tr>
<tr>
<td>依赖注入</td>
<td><a target="_blank" rel="noopener" href="https://github.com/JakeWharton/butterknife">ButterKnife</a></td>
<td>注解，让你的代码整洁，配合ButterKnife Zelezny，一键生成注解。</td>
</tr>
<tr>
<td>图表</td>
<td><a target="_blank" rel="noopener" href="https://github.com/diogobernardino/WilliamChart">WilliamChart</a></td>
<td>强大的图标库。</td>
</tr>
<tr>
<td>图表</td>
<td><a target="_blank" rel="noopener" href="https://github.com/PhilJay/MPAndroidChart">MPAndroidChart</a></td>
<td>强大的图标库。</td>
</tr>
<tr>
<td>事件总线</td>
<td><a target="_blank" rel="noopener" href="https://github.com/greenrobot/EventBus">EventBus</a></td>
<td>一个简单移动的事件总线。</td>
</tr>
<tr>
<td>事件总线</td>
<td><a target="_blank" rel="noopener" href="https://github.com/square/otto">otto</a></td>
<td>另一个简单移动的事件总线。</td>
</tr>
<tr>
<td>响应式</td>
<td><a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxJava">RXjava</a></td>
<td>响应式编程 ，功能强大，值得学习。</td>
</tr>
<tr>
<td>响应式</td>
<td><a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxAndroid">RXAndroid</a></td>
<td>响应式编程 ，功能强大，值得学习。。</td>
</tr>
<tr>
<td>响应式</td>
<td><a target="_blank" rel="noopener" href="https://github.com/JakeWharton/RxBinding">RXBinding</a></td>
<td>响应式编程 ，功能强大，值得学习。。</td>
</tr>
<tr>
<td>Log</td>
<td><a target="_blank" rel="noopener" href="https://github.com/orhanobut/logger">logger</a></td>
<td>一个logger框架。</td>
</tr>
<tr>
<td>Log</td>
<td><a target="_blank" rel="noopener" href="https://github.com/spf13/hugo">Hugo</a></td>
<td>一个logger框架。</td>
</tr>
<tr>
<td>Log</td>
<td><a target="_blank" rel="noopener" href="https://github.com/JakeWharton/timber">Timber</a></td>
<td>一个logger框架。</td>
</tr>
<tr>
<td>测试框架</td>
<td><a target="_blank" rel="noopener" href="https://github.com/mockito/mockito">mockito</a></td>
<td>一个强大的用于 Java 开发的模拟测试框架。</td>
</tr>
<tr>
<td>测试框架</td>
<td><a target="_blank" rel="noopener" href="https://github.com/RobotiumTech/robotium">robotium</a></td>
<td>是一款国外的Android自动化测试框架。</td>
</tr>
<tr>
<td>调试框架</td>
<td><a target="_blank" rel="noopener" href="https://github.com/facebook/stetho">stetho</a></td>
<td>facebook的Android调试工具Stetho。</td>
</tr>
<tr>
<td>性能优化</td>
<td><a target="_blank" rel="noopener" href="https://github.com/square/leakcanary">leakcanary</a></td>
<td>一个检查内存泄露的插件，非常的强大。</td>
</tr>
</tbody></table>
<h2 id="常用网站"><a href="#常用网站" class="headerlink" title="常用网站"></a>常用网站</h2><table>
<thead>
<tr>
<th>网站名称</th>
<th>推荐理由</th>
</tr>
</thead>
<tbody><tr>
<td><a href="google.com">Google</a></td>
<td>google搜索，让信息传遍世界</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.github.com/">Github</a></td>
<td>面向世界的代码托管平台，在GitHub，你可以十分轻易地找到海量的开源代码</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://stackoverflow.com/">StackOverFlow</a></td>
<td>一个与程序相关的IT技术问答网站</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://segmentfault.com/t/android">SegmentFault</a></td>
<td>中文的开发者社区及媒体,中国的StackOverFlow</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.oschina.net/">开源中国</a></td>
<td>开源中国社区</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://developer.android.com/">安卓开发社区</a></td>
<td>安卓官网</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://gold.xitu.io/">掘金</a></td>
<td>掘金，号称中国质量最高的技术分享社区</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.csdn.net/">csdn</a></td>
<td>CSDN，全球最大的中文IT技术社区</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.csdn.net/">泡在网上的日子</a></td>
<td>泡在网上的日子，一个正对移动开发的技术分享论坛。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://gank.io/">干货集中营</a></td>
<td>干货集中营，每日分享。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h2><table>
<thead>
<tr>
<th>博客地址</th>
<th>博主信息</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://android-developers.blogspot.com/">Android Developers Blog</a></td>
<td>Android官网博客 ，有Android 的最新资讯，要翻墙。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog">郭霖</a></td>
<td>博主郭霖是大神, 人人都称”郭神”, 是第一行代码的作者, 博主在 CSDN 上所写的文章都非常值得学习</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/lmj623565791/">张鸿洋</a></td>
<td>张鴻洋是 CSDN 博客专家, “洋神”, 他的每一篇博客都很值得大家去学习</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.daimajia.com/">代码家</a></td>
<td>Android 大神, 博主收集了很多 Android 开源库, 博主自己也做了很多开源库, 非常值得学习，另外是<a href="gank.io">gank.io</a>的组织者。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.trinea.cn/">Trinea</a></td>
<td>目前在滴滴负责 Android 客户端技术, 他是开源库项目收集达人, 你想要的开源库<a target="_blank" rel="noopener" href="https://github.com/Trinea">上面</a>都有,并且有源码解析，大家可以去关注一下, <a target="_blank" rel="noopener" href="http://p.codekk.com/">地址</a> .</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/xyz_lmn">张兴业</a></td>
<td>张兴业同样也是 CSDN 博客专家</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/lzyzsd/">大头鬼</a></td>
<td>hi大头鬼hi 是阿里巴巴集团的一名 Android 工程师, 写了一系列RXJava 资料。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://over140.cnblogs.com/">农民伯伯</a></td>
<td>资深博客写手，他的博客非常值得一看。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/singwhatiwanna">任玉刚</a></td>
<td>《安卓开发艺术探索》作者。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/Luoshengyang">罗升阳</a></td>
<td>CSDN博客专家，《安卓系统源代码情景分析》。</td>
</tr>
</tbody></table>
<h2 id="微信公众号推荐"><a href="#微信公众号推荐" class="headerlink" title="微信公众号推荐"></a>微信公众号推荐</h2><table>
<thead>
<tr>
<th>微信公众号ID</th>
<th>博主信息</th>
</tr>
</thead>
<tbody><tr>
<td>guolin_blog</td>
<td>郭霖的公众号，有每日推荐文章，《第一行代码》作者。</td>
</tr>
<tr>
<td>hongyangAndroid</td>
<td>张鸿洋的公众号。有每日推荐文字，Csdn博客专家。</td>
</tr>
<tr>
<td>AndroidDeveloper</td>
<td>他是上海薄荷科技开发主管, 他的博客分享了他从编程白痴到自学 Android 一路走过的经验, 写了一篇 <a target="_blank" rel="noopener" href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/">Android学习之路</a> 帮助了无数人, 里面还有很多好的文章非常适合新手入门,</td>
</tr>
</tbody></table>
<h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><table>
<thead>
<tr>
<th>书籍名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/25942191/">第一行代码</a></td>
<td>郭霖大杰作，适合新人</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/25762168/">Java核心技术 卷I</a></td>
<td>java入门书籍</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3360807/">Effective Java</a></td>
<td>进阶书</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/10484692/">Java并发编程</a></td>
<td>Java并发编程</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26274206/">给大忙人看的Java8</a></td>
<td>给大忙人看的Java8</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1723199/">Thinking In Java 中文版</a></td>
<td>学习Java 语言必备书籍</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26599539/">Android群英传</a></td>
<td>本书作者 @Tomcat 的猫。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://product.china-pub.com/4806147">Android开发艺术探索</a></td>
<td>由任玉刚所著.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机</a></td>
<td>不是很难 ，需要看看</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4889838/">鸟哥的Linux私房菜</a></td>
<td>太经典。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/25863515/">图解Http</a></td>
<td>让你很快上手http。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2243615/">Head First设计模式</a></td>
<td>Head First设计模式</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/5387402/">程序员修炼之道</a></td>
<td>程序员修炼之道</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://iissnan.com/progit/html/zh/ch1_0.html">Git权威指南中文手册</a></td>
<td>Git权威指南中文手册</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1139426/">数据结构与算法基础</a></td>
<td>数据结构和算法的书，比较全</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2228378/">JavaScript权威指南</a></td>
<td>JavaScript权威指南，学习js一本书差不多了</td>
</tr>
</tbody></table>
<h2 id="RxJava系列"><a href="#RxJava系列" class="headerlink" title="RxJava系列"></a>RxJava系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://mcxiaoke.gitbooks.io/rxdocs/content/">ReactiveX/RxJava文档中文版</a></td>
<td>大神们在百忙之中翻译的文档，感谢开源。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://reactivex.io/RxJava/javadoc/">ReactiveX/RxJava官方API</a></td>
<td>ReactiveX/RxJava官方API</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a></td>
<td>给 Android 开发者的 RxJava 详解 ,作者：扔物线</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/lzyzsd/article/details/41833541/">深入浅出RxJava</a></td>
<td>大头鬼写的Rxjava 系列</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.apkbus.com/forum.php?mod=viewthread&tid=257703&extra=page=1&filter=author&orderby=dateline&_dsign=43e9b95f">老罗Rxjava视频</a></td>
<td>老罗Rxjava视频</td>
</tr>
</tbody></table>
<h2 id="retrofi系列"><a href="#retrofi系列" class="headerlink" title="retrofi系列"></a>retrofi系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://square.github.io/retrofit/">官方文档</a></td>
<td>squire出品，必属精品。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0915/3460.html">Retrofit 2.0：有史以来最大的改进</a></td>
<td>泡在网上的日子，翻译。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/ljd2038/article/details/51046512">Retrofit2.0使用详解</a></td>
<td>讲解了基本的使用方法</td>
</tr>
</tbody></table>
<h2 id="MVP系列"><a href="#MVP系列" class="headerlink" title="MVP系列"></a>MVP系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0227/2503.html">Android中的MVP</a></td>
<td>泡在网上的日子翻译。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/googlesamples/android-architecture">google写的列子</a></td>
<td>google写的MvP例子。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/android10/Android-CleanArchitecture">Android-CleanArchitecture</a></td>
<td>一个适合新人的MVP例子</td>
</tr>
</tbody></table>
<h2 id="MaterialDesign系列"><a href="#MaterialDesign系列" class="headerlink" title="MaterialDesign系列"></a>MaterialDesign系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
</table>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.google.com/design/spec/material-design/introduction.html">Material Design 教程</a> |  google官方提高的materail design 指导。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/1sters/material_design_zh_2">Material Design 教程(中文版)</a> |  翻译的中文文档。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/navasmdc/MaterialDesignLibrary">Material Design Android Library </a>(Material Design 开源库) |  一些非常优秀的material design 开源库。</li>
</ul>
<h2 id="MVP-retrofit-rxjava-materialDesign系列"><a href="#MVP-retrofit-rxjava-materialDesign系列" class="headerlink" title="MVP-retrofit-rxjava-materialDesign系列"></a>MVP-retrofit-rxjava-materialDesign系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/forezp/banya">瓣呀</a></td>
<td><a target="_blank" rel="noopener" href="https://github.com/forezp/banya">瓣呀，一个基于豆瓣API仿网易音乐的开源项目（本人写的，欢迎star）</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/Freelander/Elephant">大象</a></td>
<td>一个第三放PHPHUB客户端</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/8c3898eed1bb">开发资料</a></td>
<td>开发 Material Design+RxJava+Retrofit+MVP App 参考资料</td>
</tr>
</tbody></table>
<h2 id="Kotlin系列"><a href="#Kotlin系列" class="headerlink" title="Kotlin系列"></a>Kotlin系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://www.weibo.com/ttarticle/p/show?id=2309403942933815527259">kotlin 介绍</a></td>
<td>kotlin 介绍</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://kotlinlang.org/">kotlin 官网</a></td>
<td>kotlin 官网，最新的资讯。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25289041">kotlin,网友对其评价</a></td>
<td>网友对其评价 ，很中肯。本人已经在学习，觉得如果熟练，开发速度大大提高，代码可读性也提高。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="开源项目学习"><a href="#开源项目学习" class="headerlink" title="开源项目学习"></a>开源项目学习</h2><table>
<thead>
<tr>
<th>项目名称</th>
<th>项目简介</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/google/iosched">Google I/O 2014</a></td>
<td>Google I/O Android App 使用了当时最新推出的 Material Design 设计</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/googlesamples/android-UniversalMusicPlayer">Google play music</a></td>
<td>一个跨多个平台音乐播放器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/pockethub/PocketHub">github客户端</a></td>
<td>开源者 github 团队, 支持项目的 lssues 和 Gists 并集成了新闻 feed 以便及时获取来自组织好友和资料库的更新信息, 还提供了一个用于快速访问你创建,监控以及发布 issue 面板, 可查看并将问题加到收藏夹</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/MiCode/Notes">MIUI 便签</a></td>
<td>MiCode 便签是小米便签的社区开源版, 由 MIUI 团队(ww.miui.com)发起并贡献第一批代码, 遵循 NOTICE 文件所描述的开源协议</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://git.oschina.net/oschina/android-app">oschina</a></td>
<td>开源中国社区 Android 客户端, 此开源的是 v1 版本, v2 版本将在 2015 年年中开源</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/zxing/zxing">ZXing</a></td>
<td>二维码扫描工具,市场上许多应用的二维码扫描工具都是从这个修改得到的</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/drakeet/Meizhi">Meizhi</a></td>
<td>开发者是许晓峰(Drakeet), 该 app 是数据来自代码家干货网站 <a target="_blank" rel="noopener" href="http://gank.io/">gank.io</a>, 有很多开发者都纷纷为这网站做客户端 app, 因为代码家大神开放该网站的 Api, 更重要的是该网站每天除了有干货还有漂亮妹子看呢, 该 App 使用到的技术有 RxJava + Retrofit, 代码结构非常清晰, 值得一看的开源 App.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/Curzibn/Luban">鲁班</a></td>
<td>Android图片压缩工具，仿微信朋友圈压缩策略,一个优秀的压缩图片框架</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/izzyleung/ZhihuDailyPurify">ZhihuDailyPurify </a></td>
<td>知乎日报·净化</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/forezp/banya">瓣呀</a></td>
<td><a target="_blank" rel="noopener" href="https://github.com/forezp/banya">瓣呀，一个基于豆瓣API仿网易音乐的开源项目（本人写的，欢迎star）</a></td>
</tr>
</tbody></table>
<h2 id="开源库收集"><a href="#开源库收集" class="headerlink" title="开源库收集"></a>开源库收集</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/wasabeef/awesome-android-ui">awesome-android-ui</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/wasabeef/awesome-android-libraries">awesome-android-libraries</a></li>
<li><a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/plus/list.php?tid=31">泡在网上的日子</a></li>
<li><a target="_blank" rel="noopener" href="http://alamkanak.github.io/android-libraries-and-resources/">Android Libraries and Resources </a></li>
<li><a target="_blank" rel="noopener" href="http://android-arsenal.com/">Android Arsenal </a>(一个专门收集 android 开源库的网站, 网站经常更新)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Trinea/android-open-project">Android 开源项目汇总 </a>(Trinea 大神收集的)</li>
<li><a target="_blank" rel="noopener" href="http://codekk.com/open-source-project-analysis">Android 开源项目源码分析 </a>(在懂得使用这些开源项目同时, 也应该了解当中的原理)</li>
<li><a target="_blank" rel="noopener" href="http://www.apkbus.com/forum-417-1.html">安卓巴士</a></li>
</ul>
<h2 id="Android开发者杂志周刊"><a href="#Android开发者杂志周刊" class="headerlink" title="Android开发者杂志周刊"></a>Android开发者杂志周刊</h2><table>
<thead>
<tr>
<th>周刊名</th>
<th>周刊简介</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://gank.io/">干货集中营</a></td>
<td>由 <a target="_blank" rel="noopener" href="http://blog.daimajia.com/">代码家</a> 维护更新, 分享内容有漂亮妹子, Android 干货, iOS 干货, App, 技术以外推荐, 还有休息视频</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://androidweekly.net/">Android Weekly</a></td>
<td>Android Weekly 是由Android 团队的成员和国外知名的 Android 开发者维护, 分享的都是干货。</td>
</tr>
</tbody></table>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table>
<thead>
<tr>
<th>工具名称</th>
<th>推荐理由</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/getlantern/lantern">蓝灯</a></td>
<td>Lantern ，免费翻墙神器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.bejson.com/">bejson</a></td>
<td>Json查看，Json生成实体</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://tool.lu/sql/">sql</a></td>
<td>sql语句验证</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.iconfont.cn/">矢量图</a></td>
<td>阿里巴巴的矢量图库</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://labs.rampinteractive.co.uk/android_dp_px_calculator/">dp px 转换</a></td>
<td>阿里巴巴的矢量图库</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://translate.google.cn/">谷歌翻译</a></td>
<td>谷歌翻译</td>
</tr>
</tbody></table>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><table>
<thead>
<tr>
<th>环境/工具</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://www.androiddevtools.cn/">AndroidDevTools</a></td>
<td>一个收集整理Android开发所需的Android SDK、开发中用到的工具、Android开发教程、Android设计规范，免费的设计素材的网站,很齐全，有它够用了。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://developer.android.com/sdk/index.html">Android Studio</a></td>
<td>安卓官方开发工具，基于IDEA , 比Eclipse好太多，没有用的同学赶紧转吧。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.genymotion.com/#!/download">Genymotion</a></td>
<td>安卓模拟器。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/skylot/jadx">jadx</a></td>
<td>Android 反编译神器, 不同于常见的 <a target="_blank" rel="noopener" href="https://github.com/pxb1988/dex2jar">dex2jar</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/ligi/GradleDependenciesHelperPlugin">GradleDependenciesHelperPlugin</a></td>
<td>Gradle 依赖自动补全插件</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/square/leakcanary">LeakCanary</a></td>
<td>Square开源的一个非常有用的工具,检测出内存泄的问题</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/avast/android-butterknife-zelezny">ButterKnife Zelezny</a></td>
<td>ButterKnife 生成器, 使用起来非常简单方便, 为你简写了很多代码。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/nicoulaj/idea-markdown">idea-markdown</a></td>
<td>在 AS 中编写 Markdown 文件, 可以直接预览网页显示效果</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://facebook.github.io/stetho/">Stetho</a></td>
<td>Stetho 是 Facebook 出品的一个强大的 Android 调试工具,使用该工具你可以在 Chrome Developer Tools 查看 App 的布局</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/zzz40500/GsonFormat">GsonFormat</a></td>
<td>现在大多数服务端 api 都以 json 数据格式返回, 而客户端需要根据 api 接口生成相应的实体类, 这个插件把这个过程自动化了</td>
</tr>
</tbody></table>
<h2 id="素材"><a href="#素材" class="headerlink" title="素材"></a>素材</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.iconfont.cn/">阿里巴巴矢量图</a></li>
<li><a target="_blank" rel="noopener" href="http://www.materialup.com/">Material Design设计模板与素材</a></li>
<li><a target="_blank" rel="noopener" href="https://iconstore.co/">Icon Store</a></li>
<li><a target="_blank" rel="noopener" href="https://design.google.com/icons/">Material icons</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/gztchan/awesome-design/">awesome-design</a></li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/iluwatar/java-design-patterns#model-view-presenter">java-design-patterns</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/HackathonHackers/programming-ebooks/blob/master/Java/Effective%20Java%20%282nd%20Edition%29.pdf">Effective Java</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhangerqing/article/details/8194653">Java之美[从菜鸟到高手演变]之设计模式</a></li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.fresco-cn.org/">Fresco文档</a></li>
<li><a target="_blank" rel="noopener" href="http://mrfu.me/2016/02/27/Glide_Getting_Started/">Glide 中文非官方文档</a></li>
<li><a target="_blank" rel="noopener" href="http://developer.android.com/reference/android/package-summary.html">Android 官方 API 文档</a>(网站需要翻墙)</li>
<li><a target="_blank" rel="noopener" href="http://hukai.me/android-training-course-in-chinese/index.html">Android 官方培训课程中文版</a>(Google Android 官方培训课程翻译的中文版)</li>
</ul>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul>
<li>感谢这么多伟大的开源者，感谢这么多伟大的开源公司，因为开源，世界变得更加美好。</li>
</ul>
<h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><ul>
<li>Email:<a href="mailto:&#49;&#50;&#52;&#x37;&#x34;&#x36;&#x34;&#x30;&#54;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;">&#49;&#50;&#52;&#x37;&#x34;&#x36;&#x34;&#x30;&#54;&#x40;&#113;&#x71;&#46;&#99;&#111;&#109;</a> </li>
<li>GitHub: <a target="_blank" rel="noopener" href="https://github.com/forezp">Forezp</a></li>
<li>Blog : <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">csdn blog</a></li>
<li>原文件: <a target="_blank" rel="noopener" href="https://github.com/forezp/AndroidMaterialLatest/issues">AndroidMaterialLatest</a></li>
</ul>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>拍照、选择相片</title>
    <url>/2015/05/05/android-2015-05-05-android-pic/</url>
    <content><![CDATA[<p>最近做项目需要用到拍照和选择相册照片，并显示出来imageview 上，然后压缩上传到服务器中，这本是一个非常常见的功能，但对于图片的处理确实一个技术活，稍微不注意会出现oom，图片压缩也要处理的刚刚好，不能浪费用户的流量，也不能过分的压缩使图片失真，这真的不简单，好在开源中国的安卓端app以开源，本人特意从开源中国整理了这个demo，分享给大家。</p>
<span id="more"></span>

<p>进入相册选择照片：注意6.0之后要申请运行时权限，即api23。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent;</span><br><span class="line">       <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">19</span>) &#123;</span><br><span class="line">           intent = <span class="keyword">new</span> Intent();</span><br><span class="line">           intent.setAction(Intent.ACTION_GET_CONTENT);</span><br><span class="line">           intent.setType(<span class="string">&quot;image/*&quot;</span>);</span><br><span class="line">           startActivityForResult(Intent.createChooser(intent, <span class="string">&quot;选择图片&quot;</span>), ImageUtils.REQUEST_CODE_GETIMAGE_BYSDCARD);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           intent = <span class="keyword">new</span> Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);</span><br><span class="line">           intent.setType(<span class="string">&quot;image/*&quot;</span>);</span><br><span class="line">           startActivityForResult(Intent.createChooser(intent, <span class="string">&quot;选择图片&quot;</span>), ImageUtils.REQUEST_CODE_GETIMAGE_BYSDCARD);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>或者拍照：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void toCamera() &#123;</span><br><span class="line">      &#x2F;&#x2F; 判断是否挂载了SD卡</span><br><span class="line">      String savePath &#x3D; &quot;&quot;;</span><br><span class="line">      String storageState &#x3D; Environment.getExternalStorageState();</span><br><span class="line">      if (storageState.equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">          savePath &#x3D; Environment.getExternalStorageDirectory()</span><br><span class="line">                  .getAbsolutePath() + &quot;&#x2F;oschina&#x2F;Camera&#x2F;&quot;;</span><br><span class="line">          File savedir &#x3D; new File(savePath);</span><br><span class="line">          if (!savedir.exists()) &#123;</span><br><span class="line">              savedir.mkdirs();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 没有挂载SD卡，无法保存文件</span><br><span class="line">      if (TextUtils.isEmpty(savePath)) &#123;</span><br><span class="line">         &#x2F;&#x2F; AppContext.showToastShort(&quot;无法保存照片，请检查SD卡是否挂载&quot;);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String timeStamp &#x3D; new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;).format(new Date());</span><br><span class="line">      String fileName &#x3D; timeStamp + &quot;.jpg&quot;;&#x2F;&#x2F; 照片命名</span><br><span class="line">      File out &#x3D; new File(savePath, fileName);</span><br><span class="line">      Uri uri &#x3D; Uri.fromFile(out);</span><br><span class="line">      &#x2F;&#x2F;tweet.setImageFilePath(savePath + fileName); &#x2F;&#x2F; 该照片的绝对路径</span><br><span class="line">      mPhotoPath&#x3D;savePath + fileName;</span><br><span class="line">      Intent intent &#x3D; new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">      intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);</span><br><span class="line">      startActivityForResult(intent, ImageUtils.REQUEST_CODE_GETIMAGE_BYCAMERA);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在onActivity获取图片信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">       super.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">       if (resultCode !&#x3D; Activity.RESULT_OK)</span><br><span class="line">           return;</span><br><span class="line">       if (requestCode &#x3D;&#x3D; ImageUtils.REQUEST_CODE_GETIMAGE_BYSDCARD) &#123;</span><br><span class="line">           if (data &#x3D;&#x3D; null)</span><br><span class="line">               return;</span><br><span class="line">           Uri selectedImageUri &#x3D; data.getData();</span><br><span class="line">           if (selectedImageUri !&#x3D; null) &#123;</span><br><span class="line">               String path &#x3D; ImageUtils.getImagePath(selectedImageUri, this);</span><br><span class="line">               setImageFromPath(path);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else if (requestCode &#x3D;&#x3D; ImageUtils.REQUEST_CODE_GETIMAGE_BYCAMERA) &#123;</span><br><span class="line">           &#x2F;&#x2F;setImageFromPath(tweet.getImageFilePath());</span><br><span class="line">           setImageFromPath(mPhotoPath);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过返回的uri获取图片路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 通过Uri获取文件路径</span><br><span class="line">    * 支持图片媒体,文件等</span><br><span class="line">    * &lt;p&#x2F;&gt;</span><br><span class="line">    * Author qiujuer@live.cn</span><br><span class="line">    *</span><br><span class="line">    * @param uri     Uri</span><br><span class="line">    * @param context Context</span><br><span class="line">    * @return 文件路径</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @SuppressLint(&#123;&quot;NewApi&quot;, &quot;Recycle&quot;&#125;)</span><br><span class="line">   public static String getImagePath(Uri uri, Context context) &#123;</span><br><span class="line">       String selection &#x3D; null;</span><br><span class="line">       String[] selectionArgs &#x3D; null;</span><br><span class="line">       &#x2F;&#x2F; Uri is different in versions after KITKAT (Android 4.4), we need to</span><br><span class="line">       if (Build.VERSION.SDK_INT &gt;&#x3D; 19 &amp;&amp; DocumentsContract.isDocumentUri(context.getApplicationContext(), uri)) &#123;</span><br><span class="line">           String authority &#x3D; uri.getAuthority();</span><br><span class="line">           if (&quot;com.android.externalstorage.documents&quot;.equals(authority)) &#123;</span><br><span class="line">               &#x2F;&#x2F; isExternalStorageDocument</span><br><span class="line">               final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">               final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">               return Environment.getExternalStorageDirectory() + &quot;&#x2F;&quot; + split[1];</span><br><span class="line">           &#125; else if (&quot;com.android.providers.downloads.documents&quot;.equals(authority)) &#123;</span><br><span class="line">               &#x2F;&#x2F; isDownloadsDocument</span><br><span class="line">               final String id &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">               uri &#x3D; ContentUris.withAppendedId(</span><br><span class="line">                       Uri.parse(&quot;content:&#x2F;&#x2F;downloads&#x2F;public_downloads&quot;), Long.valueOf(id));</span><br><span class="line">           &#125; else if (&quot;com.android.providers.media.documents&quot;.equals(authority)) &#123;</span><br><span class="line">               &#x2F;&#x2F; isMediaDocument</span><br><span class="line">               final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">               final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">               final String type &#x3D; split[0];</span><br><span class="line">               if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                   uri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">               &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                   uri &#x3D; MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">               &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                   uri &#x3D; MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">               &#125;</span><br><span class="line">               selection &#x3D; &quot;_id&#x3D;?&quot;;</span><br><span class="line">               selectionArgs &#x3D; new String[]&#123;</span><br><span class="line">                       split[1]</span><br><span class="line">               &#125;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">           String[] projection &#x3D; &#123;MediaStore.Images.Media.DATA&#125;;</span><br><span class="line">           Cursor cursor &#x3D; null;</span><br><span class="line">           try &#123;</span><br><span class="line">               cursor &#x3D; context.getContentResolver()</span><br><span class="line">                       .query(uri, projection, selection, selectionArgs, null);</span><br><span class="line">               if (cursor !&#x3D; null) &#123;</span><br><span class="line">                   int column_index &#x3D; cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);</span><br><span class="line">                   if (cursor.moveToFirst()) &#123;</span><br><span class="line">                       return cursor.getString(column_index);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               e.fillInStackTrace();</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               if (cursor !&#x3D; null)</span><br><span class="line">                   cursor.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">           return uri.getPath();</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>根据图片地址去获取bitmap这时需要自己传入图片的大小即高度和宽度，根据自己的需求去传。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bitmap bitmap &#x3D; BitmapCreate.bitmapFromStream(new FileInputStream(path), 512, 512);</span><br></pre></td></tr></table></figure>
<p>图片压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">   * 获取一个指定大小的bitmap&lt;br&gt;</span><br><span class="line">   * 实际调用的方法是bitmapFromByteArray(data, 0, data.length, w, h);</span><br><span class="line">   *</span><br><span class="line">   * @param is        从输入流中读取Bitmap</span><br><span class="line">   * @param reqWidth  目标宽度</span><br><span class="line">   * @param reqHeight 目标高度</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static Bitmap bitmapFromStream(InputStream is, int reqWidth,</span><br><span class="line">                                        int reqHeight) &#123;</span><br><span class="line">      if (reqHeight &#x3D;&#x3D; 0 || reqWidth &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              return BitmapFactory.decodeStream(is);</span><br><span class="line">          &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      byte[] data &#x3D; FileUtils.input2byte(is);</span><br><span class="line">      return bitmapFromByteArray(data, 0, data.length, reqWidth, reqHeight);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 获取一个指定大小的bitmap</span><br><span class="line">   *</span><br><span class="line">   * @param data      Bitmap的byte数组</span><br><span class="line">   * @param offset    image从byte数组创建的起始位置</span><br><span class="line">   * @param length    the number of bytes, 从offset处开始的长度</span><br><span class="line">   * @param reqWidth  目标宽度</span><br><span class="line">   * @param reqHeight 目标高度</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static Bitmap bitmapFromByteArray(byte[] data, int offset,</span><br><span class="line">                                           int length, int reqWidth, int reqHeight) &#123;</span><br><span class="line">      if (reqHeight &#x3D;&#x3D; 0 || reqWidth &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              return BitmapFactory.decodeByteArray(data, offset, length);</span><br><span class="line">          &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      BitmapFactory.Options options &#x3D; new BitmapFactory.Options();</span><br><span class="line">      options.inJustDecodeBounds &#x3D; true;</span><br><span class="line">      options.inPurgeable &#x3D; true;</span><br><span class="line">      BitmapFactory.decodeByteArray(data, offset, length, options);</span><br><span class="line">      options &#x3D; calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line">      return BitmapFactory.decodeByteArray(data, offset, length, options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 图片压缩处理（使用Options的方法）</span><br><span class="line">   * &lt;br&gt;</span><br><span class="line">   * &lt;b&gt;说明&lt;&#x2F;b&gt; 使用方法：</span><br><span class="line">   * 首先你要将Options的inJustDecodeBounds属性设置为true，BitmapFactory.decode一次图片 。</span><br><span class="line">   * 然后将Options连同期望的宽度和高度一起传递到到本方法中。</span><br><span class="line">   * 之后再使用本方法的返回值做参数调用BitmapFactory.decode创建图片。</span><br><span class="line">   * &lt;br&gt;</span><br><span class="line">   * &lt;b&gt;说明&lt;&#x2F;b&gt; BitmapFactory创建bitmap会尝试为已经构建的bitmap分配内存</span><br><span class="line">   * ，这时就会很容易导致OOM出现。为此每一种创建方法都提供了一个可选的Options参数</span><br><span class="line">   * ，将这个参数的inJustDecodeBounds属性设置为true就可以让解析方法禁止为bitmap分配内存</span><br><span class="line">   * ，返回值也不再是一个Bitmap对象， 而是null。虽然Bitmap是null了，但是Options的outWidth、</span><br><span class="line">   * outHeight和outMimeType属性都会被赋值。</span><br><span class="line">   *</span><br><span class="line">   * @param reqWidth  目标宽度,这里的宽高只是阀值，实际显示的图片将小于等于这个值</span><br><span class="line">   * @param reqHeight 目标高度,这里的宽高只是阀值，实际显示的图片将小于等于这个值</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static BitmapFactory.Options calculateInSampleSize(</span><br><span class="line">          final BitmapFactory.Options options, final int reqWidth,</span><br><span class="line">          final int reqHeight) &#123;</span><br><span class="line">      &#x2F;&#x2F; 源图片的高度和宽度</span><br><span class="line">      final int height &#x3D; options.outHeight;</span><br><span class="line">      final int width &#x3D; options.outWidth;</span><br><span class="line">      int inSampleSize &#x3D; 1;</span><br><span class="line">      if (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line">          &#x2F;&#x2F; 计算出实际宽高和目标宽高的比率</span><br><span class="line">          final int heightRatio &#x3D; Math.round((float) height</span><br><span class="line">                  &#x2F; (float) reqHeight);</span><br><span class="line">          final int widthRatio &#x3D; Math.round((float) width &#x2F; (float) reqWidth);</span><br><span class="line">          &#x2F;&#x2F; 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高</span><br><span class="line">          &#x2F;&#x2F; 一定都会大于等于目标的宽和高。</span><br><span class="line">          inSampleSize &#x3D; heightRatio &lt; widthRatio ? heightRatio : widthRatio;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 设置压缩比例</span><br><span class="line">      options.inSampleSize &#x3D; inSampleSize;</span><br><span class="line">      options.inJustDecodeBounds &#x3D; false;</span><br><span class="line">      return options;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>将压缩后的bitmap存在sdcard中，待会儿要上传到服务器中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 图片写入文件</span><br><span class="line">   *</span><br><span class="line">   * @param bitmap</span><br><span class="line">   *            图片</span><br><span class="line">   * @param filePath</span><br><span class="line">   *            文件路径</span><br><span class="line">   * @return 是否写入成功</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static boolean bitmapToFile(Bitmap bitmap, String filePath) &#123;</span><br><span class="line">      boolean isSuccess &#x3D; false;</span><br><span class="line">      if (bitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">          return isSuccess;</span><br><span class="line">      &#125;</span><br><span class="line">      File file &#x3D; new File(filePath.substring(0,</span><br><span class="line">              filePath.lastIndexOf(File.separator)));</span><br><span class="line">      if (!file.exists()) &#123;</span><br><span class="line">          file.mkdirs();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      OutputStream out &#x3D; null;</span><br><span class="line">      try &#123;</span><br><span class="line">          out &#x3D; new BufferedOutputStream(new FileOutputStream(filePath),</span><br><span class="line">                  8 * 1024);</span><br><span class="line">          isSuccess &#x3D; bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);</span><br><span class="line">      &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          closeIO(out);</span><br><span class="line">      &#125;</span><br><span class="line">      return isSuccess;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>将压缩后的bitmap 根据需求进一步缩放，显示在imageview上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 放大缩小图片</span><br><span class="line">    *</span><br><span class="line">    * @param bitmap</span><br><span class="line">    * @param w</span><br><span class="line">    * @param h</span><br><span class="line">    * @return</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static Bitmap zoomBitmap(Bitmap bitmap, int w, int h) &#123;</span><br><span class="line">       Bitmap newbmp &#x3D; null;</span><br><span class="line">       if (bitmap !&#x3D; null) &#123;</span><br><span class="line">           int width &#x3D; bitmap.getWidth();</span><br><span class="line">           int height &#x3D; bitmap.getHeight();</span><br><span class="line">           Matrix matrix &#x3D; new Matrix();</span><br><span class="line">           float scaleWidht &#x3D; ((float) w &#x2F; width);</span><br><span class="line">           float scaleHeight &#x3D; ((float) h &#x2F; height);</span><br><span class="line">           matrix.postScale(scaleWidht, scaleHeight);</span><br><span class="line">           newbmp &#x3D; Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix,</span><br><span class="line">                   true);</span><br><span class="line">       &#125;</span><br><span class="line">       return newbmp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在拍照的过程中，有的机型照片会倒转，这是需要处理一下即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 读取图片属性：旋转的角度</span><br><span class="line">     * @param path 图片绝对路径</span><br><span class="line">     * @return degree旋转的角度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int readPictureDegree(String path) &#123;</span><br><span class="line">        int degree  &#x3D; 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            ExifInterface exifInterface &#x3D; new ExifInterface(path);</span><br><span class="line">            int orientation &#x3D; exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);</span><br><span class="line">            switch (orientation) &#123;</span><br><span class="line">                case ExifInterface.ORIENTATION_ROTATE_90:</span><br><span class="line">                    degree &#x3D; 90;</span><br><span class="line">                    break;</span><br><span class="line">                case ExifInterface.ORIENTATION_ROTATE_180:</span><br><span class="line">                    degree &#x3D; 180;</span><br><span class="line">                    break;</span><br><span class="line">                case ExifInterface.ORIENTATION_ROTATE_270:</span><br><span class="line">                    degree &#x3D; 270;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 旋转图片</span><br><span class="line">     * @param angle</span><br><span class="line">     * @param bitmap</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Bitmap rotaingImageView(int angle , Bitmap bitmap) &#123;</span><br><span class="line">        &#x2F;&#x2F;旋转图片 动作</span><br><span class="line">        Matrix matrix &#x3D; new Matrix();</span><br><span class="line">        matrix.postRotate(angle);</span><br><span class="line">        System.out.println(&quot;angle2&#x3D;&quot; + angle);</span><br><span class="line">        &#x2F;&#x2F; 创建新的图片</span><br><span class="line">        Bitmap resizedBitmap &#x3D; Bitmap.createBitmap(bitmap, 0, 0,</span><br><span class="line">                bitmap.getWidth(), bitmap.getHeight(), matrix, true);</span><br><span class="line">        return resizedBitmap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这些代码百分之七八十来自开源中国。感谢原作者。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/forezp/SelectPicAndCamera">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android MVP</title>
    <url>/2015/05/05/android-2015-05-05-android-mvp/</url>
    <content><![CDATA[<p>##Mvp模式简介</p>
<p>衍生于MVC 模式，降低了耦合性，避免了View(Activity/Fragment)承担了所有的责任，<br>分担了UI层的职责。<br></p>
<span id="more"></span>

<p>在MVP模式里通常包含4个要素：</p>
<ul>
<li>View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity);</li>
<li>View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试;</li>
<li>Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合);</li>
<li>Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。</li>
</ul>
<h2 id="为什么要使用-MVP模式"><a href="#为什么要使用-MVP模式" class="headerlink" title="为什么要使用 MVP模式"></a>为什么要使用 MVP模式</h2><p> 在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面，<br> 并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的 职责不断增加，<br> 以致变得庞大臃肿。当我们将其中复杂的逻辑处理移至另外的一个类（Presneter）中时，Activity其实就是MVP模式中 View，<br> 它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由<br> Presenter处理）.<br></p>
<p> 在实际的开发过程中,往往需求和界面是不确定的，随着开发的不断推进，原来的很多界面基本修改得面目全非，这是许多开发者面临<br> 的一个非常头疼的问题，MVP在一定程度上了解决了这个问题。</p>
<p> ##MVP 实战<br> （0）UserBean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    </span><br><span class="line">    private int  id;</span><br><span class="line">    private String name ;</span><br><span class="line">    private String mobile ;</span><br><span class="line">    private String password;</span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getMobile() &#123;</span><br><span class="line">        return mobile;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMobile(String mobile) &#123;</span><br><span class="line">        this.mobile &#x3D; mobile;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User [id&#x3D;&quot; + id + &quot;, name&#x3D;&quot; + name + &quot;, mobile&#x3D;&quot; + mobile + &quot;, password&#x3D;&quot; + password + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> （1）IUserModel 用户登录model接口 <br><br> 需要实现其接口，一般是读取网络数据，并存在JavaBean 中，并对javabean 有set和get的读写权限。<br> <br><br> 一般为了需要一个Listerner 来监听网络请求读写数据的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public interface IUserModel &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 用户登录接口</span><br><span class="line">    public void login(String phone, String passwdMd5, final LoginHandler handler);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> （2）IUserLoginView  用户登录view 接口<br><br>    根据需求，VIEw 需要对Model的bean数据进行操作，当登录成功，返回登录人信息情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserLoginView</span> <span class="keyword">extends</span> <span class="title">IUserView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserLoginSuccess</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserLoginError</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> (3)IUserModel监听类</p>
<p>  Model联网成功后，根据返回情况进行监听，它也起到了传递数据的作用，它将Model的数据传递给<br>  Presenter ，从而Presenter 来讲数据传递给view</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface LoginHandler extends NetworkHandler &#123;</span><br><span class="line">    public void onLoginSuccess(User user);       &#x2F;&#x2F; 登录成功</span><br><span class="line"></span><br><span class="line">    public void onLoginError(String msg);         &#x2F;&#x2F; 登录失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> (4)UserPresenter</p>
<p> 连接model 层和 view层，处理model和view进行交互。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG=<span class="string">&quot;UserPresenter&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> IUserModel mUser;      </span><br><span class="line">    <span class="keyword">private</span> IUserView mView;       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建用户模型的主导器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view 如果不需要进行界面展示则View传入null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserPresenter</span><span class="params">(<span class="meta">@Nullable</span> IUserView view)</span> </span>&#123;</span><br><span class="line">        mUser = UserModel.getInstance();</span><br><span class="line">        mView = view;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String mobile,String password)</span></span>&#123;</span><br><span class="line">        mUser.login(mobile, password, <span class="keyword">new</span> LoginHandler() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onlinkError</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(mView!=<span class="keyword">null</span>&amp;&amp;mView <span class="keyword">instanceof</span> IUserLoginView)</span><br><span class="line">                 ( (IUserLoginView) mView).onUserLoginError(msg);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoginSuccess</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mView != <span class="keyword">null</span> &amp;&amp; mView <span class="keyword">instanceof</span> IUserLoginView)</span><br><span class="line">                    ((IUserLoginView) mView).onUserLoginSuccess(u);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoginError</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(mView!=<span class="keyword">null</span>&amp;&amp;mView <span class="keyword">instanceof</span> IUserLoginView)</span><br><span class="line">                   ((IUserLoginView)mView).onUserLoginError(msg);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）View 实现层<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends Activity implements IUserLoginView&#123;</span><br><span class="line">    </span><br><span class="line">    @ViewInject(id&#x3D;R.id.btn_login,click&#x3D;&quot;login&quot;) Button btn_login;</span><br><span class="line">    @ViewInject(id&#x3D;R.id.et_login_name)EditText et_login_name;</span><br><span class="line">    @ViewInject(id&#x3D;R.id.et_login_password) EditText et_login_password;</span><br><span class="line">    private Context mContext;</span><br><span class="line">    private UserPresenter userPresenter;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        FinalActivity.initInjectedView(this);</span><br><span class="line">        mContext&#x3D;this;</span><br><span class="line">        userPresenter&#x3D;new UserPresenter(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void login(View v)&#123;</span><br><span class="line">        String mobile&#x3D;et_login_name.getText().toString();</span><br><span class="line">        String password&#x3D;et_login_password.getText().toString();</span><br><span class="line">        String md5Pwd&#x3D;MD5(password);</span><br><span class="line">        userPresenter.login(mobile, md5Pwd);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onUserLoginSuccess(User user) &#123;</span><br><span class="line">        </span><br><span class="line">        Toast.makeText(mContext, &quot;&quot;+user.toString(), Toast.LENGTH_SHORT).show();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onUserLoginError(String msg) &#123;</span><br><span class="line">        Toast.makeText(mContext, msg, Toast.LENGTH_SHORT).show();</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public final static String MD5(String plain) &#123;  </span><br><span class="line">        try &#123;</span><br><span class="line">            MessageDigest md5 &#x3D; MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">            md5.update(plain.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            byte[] m &#x3D; md5.digest();</span><br><span class="line">            StringBuilder hex &#x3D; new StringBuilder(m.length * 2);</span><br><span class="line">            for (byte b : m) &#123;</span><br><span class="line">                if ((b &amp; 0xFF) &lt; 0x10) hex.append(&quot;0&quot;);</span><br><span class="line">                hex.append(Integer.toHexString(b &amp; 0xFF));</span><br><span class="line">            &#125;</span><br><span class="line">            return hex.toString();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写<br>更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9556104">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android图片圆角实现方式</title>
    <url>/2015/05/05/android-2015-05-05-android-round-pic/</url>
    <content><![CDATA[<p>android 圆角图片的实现形式，包括用第三方、也有系统的。比如makeramen:roundedimageview，系统的cardview ， glide .fresco 。</p>
<span id="more"></span>

<p><img src="http://img.blog.csdn.net/20160819134250608" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &#39;com.android.support:appcompat-v7:24.0.0&#39;</span><br><span class="line">   compile &#39;com.makeramen:roundedimageview:2.2.1&#39;</span><br><span class="line">   compile &#39;com.android.support:cardview-v7:24.0.0&#39;</span><br><span class="line">   compile &#39;com.github.bumptech.glide:glide:3.7.0&#39;</span><br><span class="line">   compile &#39;com.facebook.fresco:fresco:0.12.0&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;android.support.v7.widget.CardView</span><br><span class="line">    xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;id_cardview&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_gravity&#x3D;&quot;center_horizontal&quot;</span><br><span class="line">    app:cardBackgroundColor&#x3D;&quot;@color&#x2F;bg_light_gray&quot;</span><br><span class="line">    app:cardCornerRadius&#x3D;&quot;3dp&quot;</span><br><span class="line">    app:cardUseCompatPadding&#x3D;&quot;false&quot;</span><br><span class="line">    app:cardPreventCornerOverlap&#x3D;&quot;true&quot;</span><br><span class="line"></span><br><span class="line">    &gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;iv_subject&quot;</span><br><span class="line">        android:gravity&#x3D;&quot;center&quot;</span><br><span class="line">        android:scaleType&#x3D;&quot;centerCrop&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;200dp&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:paddingLeft&#x3D;&quot;5dp&quot;</span><br><span class="line">        android:paddingBottom&#x3D;&quot;5dp&quot;</span><br><span class="line">        android:background&#x3D;&quot;@drawable&#x2F;bg_biaoti&quot;</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;tv_subject&quot;</span><br><span class="line">        android:gravity&#x3D;&quot;center_vertical&quot;</span><br><span class="line">        android:text&#x3D;&quot;&quot;</span><br><span class="line">        android:ellipsize&#x3D;&quot;end&quot;</span><br><span class="line">        android:singleLine&#x3D;&quot;true&quot;</span><br><span class="line">        android:textSize&#x3D;&quot;13sp&quot;</span><br><span class="line">        android:textColor&#x3D;&quot;@color&#x2F;white&quot;</span><br><span class="line">        android:layout_gravity&#x3D;&quot;bottom&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;android.support.v7.widget.CardView&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">iv_round&#x3D;(RoundedImageView) findViewById(R.id.iv_round);</span><br><span class="line">Glide.with(this).load(url).into(iv_round);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iv_cardview&#x3D;(ImageView)findViewById(R.id.iv_cardview);</span><br><span class="line">  Glide.with(this).load(url).into(iv_cardview);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iv_fresco&#x3D;(SimpleDraweeView)findViewById(R.id.iv_fresco);</span><br><span class="line">     Glide.with(this).load(url).into(iv_round);</span><br><span class="line">     Glide.with(this).load(url).into(iv_cardview);</span><br><span class="line">     Uri uri &#x3D; Uri.parse(url);</span><br><span class="line">     iv_fresco.setImageURI(uri);</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package roundimageview.forezp.com.roundimageview;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.res.Resources;</span><br><span class="line">import android.graphics.Bitmap;</span><br><span class="line">import android.graphics.BitmapShader;</span><br><span class="line">import android.graphics.Canvas;</span><br><span class="line">import android.graphics.Paint;</span><br><span class="line">import android.graphics.RectF;</span><br><span class="line"></span><br><span class="line">import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;</span><br><span class="line">import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by Administrator on 2016&#x2F;8&#x2F;19 0019.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class  GlideRoundTransform extends BitmapTransformation &#123;</span><br><span class="line"></span><br><span class="line">    private static float radius &#x3D; 0f;</span><br><span class="line"></span><br><span class="line">    public GlideRoundTransform(Context context) &#123;</span><br><span class="line">        this(context, 4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GlideRoundTransform(Context context, int dp) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.radius &#x3D; Resources.getSystem().getDisplayMetrics().density * dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123;</span><br><span class="line">        return roundCrop(pool, toTransform);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123;</span><br><span class="line">        if (source &#x3D;&#x3D; null) return null;</span><br><span class="line"></span><br><span class="line">        Bitmap result &#x3D; pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">        if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">            result &#x3D; Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Canvas canvas &#x3D; new Canvas(result);</span><br><span class="line">        Paint paint &#x3D; new Paint();</span><br><span class="line">        paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));</span><br><span class="line">        paint.setAntiAlias(true);</span><br><span class="line">        RectF rectF &#x3D; new RectF(0f, 0f, source.getWidth(), source.getHeight());</span><br><span class="line">        canvas.drawRoundRect(rectF, radius, radius, paint);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String getId() &#123;</span><br><span class="line">        return getClass().getName() + Math.round(radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Glide.with(this).load(url).transform(new GlideRoundTransform(this,6)).into(iv_glide);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>省市区三级联动</title>
    <url>/2015/05/05/android-2015-05-05-android-ssq-sjliand/</url>
    <content><![CDATA[<p>最近项目，需要用到三级联动，在网上找了一些例子，进行了修改，实现，提炼出来了给大家分享<br>实现思路是在三个wheelview 进行联动。选择了省，马上就关联到市和区，选择了市 ，马上就可以关联到区。</p>
<span id="more"></span>

<p>效果图：</p>
<img src="http://img.blog.csdn.net/20160616165630865" width = "300"  alt="图片名称" align=center />
首先建了三个Model 用于存数据
存省 和市的list 和区的
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProvinceInfoModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;CityInfoModel&gt; cityList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProvinceInfoModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProvinceInfoModel</span><span class="params">(String name, List&lt;CityInfoModel&gt; cityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.cityList = cityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CityInfoModel&gt; <span class="title">getCityList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCityList</span><span class="params">(List&lt;CityInfoModel&gt; cityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cityList = cityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ProvinceInfoModel [name=&quot;</span> + name + <span class="string">&quot;, cityList=&quot;</span> + cityList + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
存市和其对应的区list
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityInfoModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DistrictInfoModel&gt; districtList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CityInfoModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CityInfoModel</span><span class="params">(String name, List&lt;DistrictInfoModel&gt; districtList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.districtList = districtList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DistrictInfoModel&gt; <span class="title">getDistrictList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> districtList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDistrictList</span><span class="params">(List&lt;DistrictInfoModel&gt; districtList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.districtList = districtList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CityInfoModel [name=&quot;</span> + name + <span class="string">&quot;, districtList=&quot;</span> + districtList</span><br><span class="line">                + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
区的modeL
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistrictInfoModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String zipcode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistrictInfoModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistrictInfoModel</span><span class="params">(String name, String zipcode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.zipcode = zipcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getZipcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zipcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZipcode</span><span class="params">(String zipcode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zipcode = zipcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DistrictInfoModel [name=&quot;</span> + name + <span class="string">&quot;, zipcode=&quot;</span> + zipcode + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
数据存储在xml中，在assets目录下，详情见源代码，代码太多了。

<p>用的sax解析xml并得到数据存储在内存中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddrXmlParser</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ProvinceInfoModel&gt; provinceList = <span class="keyword">new</span> ArrayList&lt;ProvinceInfoModel&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.<span class="function">List&lt;ProvinceInfoModel&gt; <span class="title">getDataList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> provinceList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProvinceInfoModel provinceModel = <span class="keyword">new</span> ProvinceInfoModel();</span><br><span class="line">    CityInfoModel cityModel = <span class="keyword">new</span> CityInfoModel();</span><br><span class="line">    DistrictInfoModel districtModel = <span class="keyword">new</span> DistrictInfoModel();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Attributes attributes)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qName.equals(<span class="string">&quot;province&quot;</span>)) &#123;</span><br><span class="line">            provinceModel = <span class="keyword">new</span> ProvinceInfoModel();</span><br><span class="line">            provinceModel.setName(attributes.getValue(<span class="number">0</span>));</span><br><span class="line">            provinceModel.setCityList(<span class="keyword">new</span> ArrayList&lt;CityInfoModel&gt;());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">&quot;city&quot;</span>)) &#123;</span><br><span class="line">            cityModel = <span class="keyword">new</span> CityInfoModel();</span><br><span class="line">            cityModel.setName(attributes.getValue(<span class="number">0</span>));</span><br><span class="line">            cityModel.setDistrictList(<span class="keyword">new</span> ArrayList&lt;DistrictInfoModel&gt;());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">&quot;district&quot;</span>)) &#123;</span><br><span class="line">            districtModel = <span class="keyword">new</span> DistrictInfoModel();</span><br><span class="line">            districtModel.setName(attributes.getValue(<span class="number">0</span>));</span><br><span class="line">            districtModel.setZipcode(attributes.getValue(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qName.equals(<span class="string">&quot;district&quot;</span>)) &#123;</span><br><span class="line">            cityModel.getDistrictList().add(districtModel);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">&quot;city&quot;</span>)) &#123;</span><br><span class="line">            provinceModel.getCityList().add(cityModel);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">&quot;province&quot;</span>)) &#123;</span><br><span class="line">            provinceList.add(provinceModel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要在activity 中开启线程读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">readAddrDatas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ProvinceInfoModel&gt; provinceList = <span class="keyword">null</span>;</span><br><span class="line">        AssetManager asset = getAssets();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream input = asset.open(<span class="string">&quot;province_data.xml&quot;</span>);</span><br><span class="line">            SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">            SAXParser parser = spf.newSAXParser();</span><br><span class="line">            AddrXmlParser handler = <span class="keyword">new</span> AddrXmlParser();</span><br><span class="line">            parser.parse(input, handler);</span><br><span class="line">            input.close();</span><br><span class="line">            provinceList = handler.getDataList();</span><br><span class="line">            <span class="keyword">if</span> (provinceList != <span class="keyword">null</span> &amp;&amp; !provinceList.isEmpty()) &#123;</span><br><span class="line">                mCurrentProviceName = provinceList.get(<span class="number">0</span>).getName();</span><br><span class="line">                List&lt;CityInfoModel&gt; cityList = provinceList.get(<span class="number">0</span>).getCityList();</span><br><span class="line">                <span class="keyword">if</span> (cityList != <span class="keyword">null</span> &amp;&amp; !cityList.isEmpty()) &#123;</span><br><span class="line">                    mCurrentCityName = cityList.get(<span class="number">0</span>).getName();</span><br><span class="line">                    List&lt;DistrictInfoModel&gt; districtList = cityList.get(<span class="number">0</span>).getDistrictList();</span><br><span class="line">                    mCurrentDistrictName = districtList.get(<span class="number">0</span>).getName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mProvinceDatas = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinceList.size(); i++) &#123;</span><br><span class="line">                mProvinceDatas.add(provinceList.get(i).getName());</span><br><span class="line">                List&lt;CityInfoModel&gt; cityList = provinceList.get(i).getCityList();</span><br><span class="line">                ArrayList&lt;String&gt; cityNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cityList.size(); j++) &#123;</span><br><span class="line">                    cityNames.add(cityList.get(j).getName());</span><br><span class="line">                    List&lt;DistrictInfoModel&gt; districtList = cityList.get(j).getDistrictList();</span><br><span class="line">                    ArrayList&lt;String&gt; distrinctNameArray = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                    DistrictInfoModel[] distrinctArray = <span class="keyword">new</span> DistrictInfoModel[districtList.size()];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; districtList.size(); k++) &#123;</span><br><span class="line">                        DistrictInfoModel districtModel = <span class="keyword">new</span> DistrictInfoModel(districtList.get(k).getName(), districtList.get(k).getZipcode());</span><br><span class="line">                        distrinctArray[k] = districtModel;</span><br><span class="line">                        distrinctNameArray.add(districtModel.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    mDistrictDatasMap.put(cityNames.get(j), distrinctNameArray);</span><br><span class="line">                &#125;</span><br><span class="line">                mCitisDatasMap.put(provinceList.get(i).getName(), cityNames);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读取完数据需要设置weelview 的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mProvincePicker.setOnSelectListener(<span class="keyword">new</span> WheelView.OnSelectListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endSelect</span><span class="params">(<span class="keyword">int</span> id, String text)</span> </span>&#123;</span><br><span class="line">               String provinceText = mProvinceDatas.get(id);</span><br><span class="line">               <span class="keyword">if</span> (!mCurrentProviceName.equals(provinceText)) &#123;</span><br><span class="line">                   mCurrentProviceName = provinceText;</span><br><span class="line">                   ArrayList&lt;String&gt; mCityData = mCitisDatasMap.get(mCurrentProviceName);</span><br><span class="line">                   mCityPicker.resetData(mCityData);</span><br><span class="line">                   mCityPicker.setDefault(<span class="number">0</span>);</span><br><span class="line">                   mCurrentCityName = mCityData.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                   ArrayList&lt;String&gt; mDistrictData = mDistrictDatasMap.get(mCurrentCityName);</span><br><span class="line">                   mCountyPicker.resetData(mDistrictData);</span><br><span class="line">                   mCountyPicker.setDefault(<span class="number">0</span>);</span><br><span class="line">                   mCurrentDistrictName = mDistrictData.get(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selecting</span><span class="params">(<span class="keyword">int</span> id, String text)</span> </span>&#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<p>代码不一一写成，详情见源码。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9551637">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android学习路线图</title>
    <url>/2015/05/05/android-2015-05-05-android-study-way/</url>
    <content><![CDATA[<p>jixiaohua发了一篇一个老鸟也发了一份他给公司内部小伙伴整理的路线图。另一份 Android 开发学习路线图。可惜不是MarkDown格式的，所以jixiaohua直接上传的截图，在jixiaohua的呼吁下，我花了些时间，把这篇大牛的推荐清单编辑成了Markdown格式，方便大家浏览，学习。</p>
<span id="more"></span>

<p>有一些链接可能还不是特别准确，因为我只能根据图片上的书或者资源的名字去Google可能的书籍，所以链接上有什么不对的，欢迎大家评论指出，我会及时更正。请参考原文：另一份 Android 开发学习路线图 帮助修改。谢谢。</p>
<p>基础工具部分： 中文手册，我猜测是Maven中文手册，可是我并没有找到这样的资源，欢迎知道的朋友告诉我；<br>Android部分有 『第三方库集合』，我没能找到资源地址；<br>书籍我大多是给的豆瓣链接，如果觉得不合适可以替换一下；<br>关于Markdown表格</p>
<p>本来我一开始整理了一份表格版本的, 用 Mou 写的，表格内的换行用<br/>标签处理的，但是在DiyCode上来发的时候，发现Markdown表格内部不支持<br/>标签换行，所以就只能整理成平铺的文档格式。Markdown对于表格的支持不是很强大。</p>
<p>程序设计</p>
<p>一、java</p>
<p>（a）基本语法(如继承、异常、引用、泛型等)</p>
<p>Java核心技术 卷I（适合入门）<br>进阶<br>Effective Java中文版（如何写好的Java代码）<br>Java解惑 （介绍烂Java代码是什么样的）<br>（b）多线程、并发</p>
<p>Java并发编程实战 （系统全面的介绍了Java的并发，如何设计支持并发的数据结构）<br>（c）Java 7</p>
<p>Java程序员修炼之道 （详细的介绍Java 7 的新特性）<br>（d）Java 8</p>
<p>写给大忙人看的Java SE 8<br>函数式编程思维<br>（e）Java虚拟机</p>
<p>深入理解Java虚拟机 （并不是那么难，Java程序员都该看看）<br>（f）性能优化</p>
<p>Java性能优化权威指南 （后面的章节好像用处不大，前面有些部分还是值得看）<br>二、算法与数据结构</p>
<p>算法时间复杂度、空间复杂度的基本认知<br>熟悉常用数据结构：链表、队列、散列表、树等；<br>递归、分支等基本思想；<br>常用算法应用：排序、查找、比较等<br>数据结构与算法分析 （涵盖面比较全、示例是Java语言）<br>算法设计与分析基础 （实用主义的典型、偏算法设计）<br>编程珠玑 （实践型算法数据）<br>三、操作系统</p>
<p>对Linux/OS的基本认知<br>Linux的常用命令<br>鸟哥的Linux私房菜<br>Linux内核设计与实现(原书第3版) （很精炼的语言描述清楚了内核算法）<br>四、网络</p>
<p>Http/Https<br>TCP/IP<br>图解HTTP<br>图解TCP/IP<br>进阶<br>TCP/IP详解<br>五、Android</p>
<p>四大组件（服务、广播、ContentProvider、页面容器）<br>基础UI组件（ListView、ViewPager）<br>异步任务机制（AsyncTask、Handler、线程池）<br>布局优化（层级、绘制、碎片化处理）<br>图片加载（Bitmap、缓冲区）<br>UniversalMusicePlayer (通过学习一个音乐播放器的代码能很快了解四大组件)<br>Android Training官方课程<br>Android一些重要知识点解析整理<br>Android UI/UX库（各类常用组件及扩展组件的集合）<br>Picasso 、 Glide （两个图片加载库）<br>The Google I/O 2015 Android App (Google大会官方的App，适合学习各类实现)<br>Android开发技术前线 （定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）<br>进阶<br>第三方库集合 （列举了常见的各方向第三方库）<br>软件工程</p>
<p>一、基础工具</p>
<p>IDE、Git、Maven<br>AndroidStudio<br>Git权威指南中文手册<br>二、软件质量</p>
<p>代码整洁<br>码质量<br>码重构<br>编写可读代码的艺术 （来自Google工程师，专注于代码可读性）<br>代码整洁之道（使用面向对象+敏捷开发原则编写清晰可维护的代码）<br>重构-改善既有代码的设计 （学习改善已有代码）<br>重构手册 （改善代码的实际操作）<br>三、设计模式</p>
<p>23种常见设计模式<br>大话设计模式<br>Head First设计模式(两本入门级的设计模式书籍)<br>进阶<br>设计模式-可复用面向对象软件的基础（设计模式在实际中的应用）<br>四、敏捷开发</p>
<p>解析极限编程<br>敏捷开发的艺术<br>进阶<br>敏捷软件开发-原则、模式与实践<br>五、专业开发</p>
<p>序员职业素养<br>更高效、更实效<br>程序员的是职业素养<br>程序员修炼之道-从小工到专家<br>六、思考人生</p>
<p>黑客与画家 (硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>瓣呀，一个非官方的豆瓣app</title>
    <url>/2015/05/05/android-2015-05-05-banya/</url>
    <content><![CDATA[<h1 id="瓣呀，一个非官方的豆瓣app"><a href="#瓣呀，一个非官方的豆瓣app" class="headerlink" title="瓣呀，一个非官方的豆瓣app"></a>瓣呀，一个非官方的豆瓣app</h1><p>源码下载： <a target="_blank" rel="noopener" href="https://github.com/forezp/banya">https://github.com/forezp/banya</a></p>
<span id="more"></span>

<ul>
<li><p>首页分为三大模块，包括：电影、看书、音乐。而电影模块又包括最近热门电影、TOP250；看书模块包括综合、文学、流行、文化、生活五个部分；音乐模块包括流行、经典、韩系、欧美四个模块。</p>
</li>
<li><p>首页界面风格采用Material Design设计规范，使用了CoordinatorLayout和viewpager配合，使用behavior属性对toolbar的显示和隐藏进行了控制，tablayout和viewpager配合，viewpager切换fragment，整体界面模仿了网易云音乐。</p>
</li>
<li><p>抽屉界面的实现是使用DrawerLayout和NavigationView配合，使用的icon来自<a target="_blank" rel="noopener" href="https://design.google.com/icons/index.html">material design icon</a>。</p>
</li>
<li><p>详情界面模仿了豆瓣app的详情界面，包括了电影详情、音乐详情、书籍详情，另外使用了webview 对详情页面和导演、演员、作者歌手的个人信息进行了展示。</p>
</li>
<li><p>项目整体采用mvp+rxjava+retrofit 框架，用butterknif注解，使用glide进行图片展示，另外使用了java8的拉姆达表达式，安卓原生并不支持，需要导插件。</p>
</li>
<li><p>对okhttpClient进行了缓存配置，然而豆瓣API对Cache-Control的设置为no-cache，所以目前没有缓存，需要自己实现，后面会花时间用Realm去实现本地缓存。</p>
</li>
<li><p>整体界面采用了沉浸式布局，另外使用了主题切换。在切换主题时，存在一个bug，切换时 statusBar的颜色并没有改变，这个问题已经提交给了<a target="_blank" rel="noopener" href="https://github.com/laobie/StatusBarUtil">StatusBarUtil</a> 的作者。</p>
</li>
</ul>
<h2 id="ScreenShot"><a href="#ScreenShot" class="headerlink" title="ScreenShot"></a>ScreenShot</h2><p><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-4b643a88dc389ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-4b643a88dc389ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-e1957c770e7ded13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-e1957c770e7ded13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a><br><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-db261ac4eda9332f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-db261ac4eda9332f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-ff6527c9926d5ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-ff6527c9926d5ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a><br><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-d491957f5d4937d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-d491957f5d4937d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-7db6a539cedd037f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-7db6a539cedd037f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a><br><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-90e41d49e9bab397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-90e41d49e9bab397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-31aec938d435e736.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-31aec938d435e736.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a><br><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-fbc8b7784a474dbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-fbc8b7784a474dbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-56edca81b54f0fcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-56edca81b54f0fcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a><br><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-51fcc42efce3a2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-51fcc42efce3a2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-4c6e98905233f15b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-4c6e98905233f15b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a></p>
<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p>app所以的api都来自<a target="_blank" rel="noopener" href="https://developers.douban.com/wiki/?title=api_v2">豆瓣Api V2（测试版）</a>;一切数据都归豆瓣所有。</p>
<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>该项目仅供交流学习使用，如果该项目有侵犯版权问题，或被告知需停止共享与使用，本人会及时删除此页面与整个项目。</p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxJava">RXJava</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/square/okhttp">okhttp</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/square/retrofit">retrofit</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/JakeWharton/butterknife">butterknif</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/bumptech/glide">glide</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/laobie/StatusBarUtil">StatusBarUtil</a></li>
</ul>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>一个在深圳的全栈开发者，对技术有着强烈的追求。</p>
<h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我:"></a>联系我:</h2><ul>
<li>Email:<a href="mailto:&#x31;&#x32;&#52;&#55;&#x34;&#54;&#52;&#48;&#x36;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;">&#x31;&#x32;&#52;&#55;&#x34;&#54;&#52;&#48;&#x36;&#64;&#x71;&#x71;&#x2e;&#x63;&#111;&#109;</a></li>
<li>jianshu: <a target="_blank" rel="noopener" href="http://www.jianshu.com/users/f2550db5eca3/latest_articles">jianshu</a></li>
<li>Blog : <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">csdn blog</a></li>
<li>GitHub: <a target="_blank" rel="noopener" href="https://github.com/forezp">Forezp</a></li>
</ul>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Copyright 2016 Forezp</p>
<p>Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a target="_blank" rel="noopener" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>改变shape里面的值</title>
    <url>/2015/05/05/android-2015-05-05-chaneg-shape-solid-color/</url>
    <content><![CDATA[<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;solid android:color&#x3D;&quot;#FF4081&quot;&#x2F;&gt;</span><br><span class="line">    &lt;corners android:radius&#x3D;&quot;15dp&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;shape&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:paddingBottom&#x3D;&quot;@dimen&#x2F;activity_vertical_margin&quot;</span><br><span class="line">    android:paddingLeft&#x3D;&quot;@dimen&#x2F;activity_horizontal_margin&quot;</span><br><span class="line">    android:paddingRight&#x3D;&quot;@dimen&#x2F;activity_horizontal_margin&quot;</span><br><span class="line">    android:paddingTop&#x3D;&quot;@dimen&#x2F;activity_vertical_margin&quot;</span><br><span class="line">    tools:context&#x3D;&quot;forezp.com.changesolidcolorfromshape.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;tv&quot;</span><br><span class="line">        android:background&#x3D;&quot;@drawable&#x2F;button&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:textSize&#x3D;&quot;14sp&quot;</span><br><span class="line">        android:padding&#x3D;&quot;10dp&quot;</span><br><span class="line">        android:textColor&#x3D;&quot;#ffffff&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;Hello World!&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;RelativeLayout&gt;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    &#x2F;&#x2F;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;16775891&#x2F;how-to-change-solid-color-from-the-code</span><br><span class="line">    private TextView tv;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tv&#x3D;(TextView)findViewById(R.id.tv);</span><br><span class="line">        GradientDrawable myGrad &#x3D; (GradientDrawable)tv.getBackground();</span><br><span class="line">        myGrad.setColor(Color.BLACK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>拆掉思维的墙</title>
    <url>/2015/05/05/android-2015-05-05-cdswdq/</url>
    <content><![CDATA[<p>你是不是在追求安全感？</p>
<span id="more"></span>

<p>思维有时候给我们太多的禁锢，安全感就是其一。为了生活安全感，有人放弃了梦想；为了职业安全感，有人放弃了多样的可能；为了爱的安全感，有人放弃了真正的人生。<br>安全感的需要源自我们内在的恐惧。恐惧有三层：<br>第一层是恐惧做不成某件事；<br>第二层是恐惧做不成时别人对我们的开法或批评；<br>第三层是恐惧我们无法应对这样的看法或批评。<br>其实，恐惧就像一个懦夫，当你撸起袖子准备跟它大干一场的时候，它却逃的无影踪。<br>排除恐惧要问自己两个触底反弹的问题：如果我失败了，新来替代我的那个家伙，他会怎么办？既然这样，为什么我们不这样去做？</p>
<p>逃出安全感，让有趣的生命扑面而来</p>
<p>逃出安全感的掌控，让有趣的生命扑面而来，生活不是单调的百分之百。可是，生活和工作中我们总会遇到不感兴趣的人和感兴趣的人。前者日复一日重复的活着，就像复读机，数十年如一日。后者总是活力四射，充满好奇，不断尝试并乐于分享其中带来的喜悦。<br>做一个有趣之人，生活也会对你有趣，而无趣之人往往是因为缺乏胆识，不敢冒险，也不能体验探索的乐趣。有趣之人，冒险——投入，成功了是一种收获，不成功也会有快乐甚至智慧。无趣之人，冒险——投入，成功了会担心失败，不成功也会有恐惧。<br>生命不是追求一个结果，而是一个追求快乐的过程。投入到当下之中，只有在投入中体验的快乐才是无条件的快乐。</p>
<p>心智模决定命运</p>
<p>你的思维决定你的疆域。你的见识决定你看到的世界。正如小时候我只知道电灯电话楼上楼下，没有想过网络世界的神奇，更没有想过移动互联网带给生活的便捷。永远不要给可能性设置障碍，要知道凡是所想皆有存在，我们只是需要发现和等待。 </p>
<p>成功学不能学</p>
<p>成功永远都是小概率事件，过的非常惨也一样是小概率事件。这是社会学正态分布告诉我们的。可是，为什么还有所谓的成功学大师？他们在一次次推销自己的成功理论，让你心潮澎湃。但是你要知道，历史和经历是无法模仿的，唯有在自己的梦想之路越走越近。<br>success源自中古英语succeden，前面是拉丁文前缀suc，代表“靠近、接近”。后面是“走”的词根cess。所以，success本意是：越走越近。如果你有一个梦想，就去捍卫它；如果你有一个目标就去争取它。走起来，不羡慕走在高处的人，不轻视走在你后面的人，成功就是越走越近。 </p>
<p>如何找到热衷一生的事业？</p>
<p>如果你还在等待一个热衷一生的事业，打算找到后再全力以赴，那么你是不可能找到的。这就是小说和现实的区别。你只有在该尝试的年纪不停的尝试，在该专注的年纪专注投入，才能找到热衷一生的事业。<br>选择职业与恋爱一样，如果你只和结婚对象谈恋爱，那么很难找到结婚的人。选择职业也要“一见钟情很多，两情相悦一些，白头偕老一个”。<br>职业是你的天赋和现实世界的结合，不要奢望能有30年，50年的规划。在你视野所及的范围内精细计划，在你听说的范围内需要大方向的规划，而那些你连听都没听说过的地方，你需要的是相信。 </p>
<p>原来我还可以这样活</p>
<p>投入当下，体验越来越近的成功感也许是最好的活法。但是，有两种心智模式决定着你的幸福感：受害者模式和掌控者模式。受害者习惯于把自己的痛苦和快乐放在别人手上，面带怨气。掌控者乐观积极，把每件事情都看成生命的一件礼物，自我掌控，总能做好当下。你是哪一种？ </p>
<p>幸福是一种转换力</p>
<p>每个人内在都存在一个男人和一个女人。男人代表社会系统，是通过对外获取资源得以生存；女人代表自我系统，将资源转换为内心的幸福感得以让生存变得更好。小时候，社会系统和自我系统均衡发展，但随着成长我们越来越会看社会的要求，家长亲友的态度，同龄人的攀比。在竞争中社会系统变得越来越强大，而自我系统相对越来越渺小，以至于有些人丧生了自我系统，无论获取再多的资源也无法更好的生活，没有幸福感而言。很多人会掉入父母的剧本里去扮演一个自己，也有很多人落入世俗里随波逐流，从未思考过我是谁，从未想过活出自己。 </p>
<p>上天不需要你成功，只需要你尝试</p>
<p>活出自己需要不断的尝试，在当下立即行动。不要在抱怨中浪费生命，陷入“等死模式”。与其在等待中枯萎不如在等待中绽放。但是，你也许有这样的经验，雄心壮志制定一个长远的计划，然后浅尝辄止，没有了下文。我们要警惕自己变成一个“开始爱好者”，仅仅在开始时热情高涨，却无法坚持下来。但无论如何不要去等待一个万事具备的开始，我们虽然常说好的开始是成功的一半，可是坏的开始也是成功的三分之一。</p>
<p>成长为自己的样子</p>
<p>测评无法预测你的未来，只有内心才知道自己的样子。时常问问自己：我到底希望自己成为什么样子的人？或许给自己设定几个关键词，定下计划，去做你希望成为那样的人。但是要记住，我们的生命就是一个三脚架：自我、家庭、职业。三者的平衡才是最稳固的人生。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android 定时任务</title>
    <url>/2015/05/05/android-2015-05-05-java-timer/</url>
    <content><![CDATA[<h4 id="1-android-自带闹钟定时任务"><a href="#1-android-自带闹钟定时任务" class="headerlink" title="1.android 自带闹钟定时任务"></a>1.android 自带闹钟定时任务</h4><p>安卓闹钟可以配合广播来实现（不推荐），系统资源浪费，安卓系统在5.0以后的定时<br>任务貌似触发时间不准了，因为了为了省电。</p>
<span id="more"></span>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取系统闹钟</span><br><span class="line">AlarmManager alarmManager &#x3D; (AlarmManager) getSystemService(ALARM_SERVICE);</span><br><span class="line">Intent intent &#x3D; new Intent(ReportDetailsActivity.this, ReportDetailsActivity.MyReceiver.class);</span><br><span class="line">pendingIntent &#x3D; PendingIntent.getBroadcast(getApplicationContext(), 0, intent, 0);</span><br><span class="line">&#x2F;&#x2F;开启定时任务</span><br><span class="line">alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 1000, 5 * 1000, pendingIntent);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>记得在manifeast 文件配置该广播</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class MyReceiver extends BroadcastReceiver &#123;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">            if (bo &gt; 0) &#123;</span><br><span class="line">                if (bo &gt; 240) &#123;&#x2F;&#x2F;刷票</span><br><span class="line">                    handler.sendEmptyMessage(3);&#x2F;&#x2F;弹窗警告 刷票</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    handler.sendEmptyMessage(2);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在OnDestroy()中取消闹钟</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> @Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    alarmManager.cancel(pendingIntent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-开启Thread"><a href="#2-开启Thread" class="headerlink" title="2.开启Thread"></a>2.开启Thread</h4><p>睡5s中去定时操作任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyRunnable  implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (isLoop)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                    if (bo &gt; 0) &#123;</span><br><span class="line">                        if (bo &gt; 240) &#123;&#x2F;&#x2F;刷票</span><br><span class="line">                            handler.sendEmptyMessage(3);&#x2F;&#x2F;弹窗警告 刷票</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            handler.sendEmptyMessage(2);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在onCreate()方法中开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loopThread&#x3D;new Thread(new MyRunnable());</span><br><span class="line">loopThread.start();</span><br></pre></td></tr></table></figure>
<p>在页面销毁时终止掉该Thread</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isLoop&#x3D;false;</span><br><span class="line">loopThread.interrupt();</span><br></pre></td></tr></table></figure>
<h4 id="3-使用timer类。"><a href="#3-使用timer类。" class="headerlink" title="3. 使用timer类。"></a>3. 使用timer类。</h4><p>开启timer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Timer timer&#x3D;new Timer();</span><br><span class="line">       timer.schedule(new TimerTask() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">           &#x2F;&#x2F;TODO ...</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,new Date(),5000);</span><br></pre></td></tr></table></figure>

<p>终止timer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timer.cancel();</span><br></pre></td></tr></table></figure>
<p>以上三种定时任务除了第一种不要随便使用外，推荐使用第三种和第二种。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjava +retrofit+mvp</title>
    <url>/2015/05/05/android-2015-05-05-rxjava-retrofit-mvp/</url>
    <content><![CDATA[<p>最近在看Rxjava，写了一个简单的 demo整合了Rxjava +retrofit+mvp，写完了迫不及待的分享出来了，打算以后的开发都用这个，太强大了，另外OKhTTP用了网络缓存，非常的方便，以后写缓存都不需要写本地数据库了。</p>
<span id="more"></span>

<p>这个项目使用到了拉姆达表达式：<br>在安卓中使用Java 8 lambda表达式，很遗憾安卓原生不支持，需要用插件。<br> 在工程中build.GRADLE导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">      classpath &#39;com.android.tools.build:gradle:2.1.0&#39;</span><br><span class="line">      classpath &#39;me.tatarka:gradle-retrolambda:3.2.5&#39;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 在项目的build.gradle导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;me.tatarka.retrolambda&#39;</span><br></pre></td></tr></table></figure>
<p> 需要使用到Java8在android根下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  android &#123;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 这样就可以在android下使用拉姆达表达式。</p>
<p> 引入RXjAVA、RxAndroid、retrofit  jar包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &#39;io.reactivex:rxandroid:1.2.1&#39;</span><br><span class="line">  compile &#39;com.squareup.retrofit2:retrofit:2.1.0&#39;</span><br><span class="line">  compile &#39;com.squareup.retrofit2:converter-gson:2.1.0&#39;</span><br><span class="line">  compile &#39;com.squareup.retrofit2:adapter-rxjava:2.1.0&#39;</span><br></pre></td></tr></table></figure>
<p> 关于retrofit的用法，<a target="_blank" rel="noopener" href="http://square.github.io/retrofit/">点击见官网</a>。</p>
<p> 关于Rxjava的用法， <a target="_blank" rel="noopener" href="https://github.com/mcxiaoke/RxDocs">翻译的Rxjava中文文档</a></p>
<p> 本文是一个整理好的RxJava+retrofit+Mvp的例子。</p>
<p> 本文的的网络请求来源知乎API.</p>
<p> 1.首先创建retrofit 接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public interface ZhihuApi &#123;</span><br><span class="line">    @GET(&quot;news&#x2F;latest&quot;)</span><br><span class="line">    Observable&lt;NewsTimeLine&gt; getLatestNews();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 2.创建retrofit  service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">File httpCacheDirectory &#x3D; new File(MyApp.mContext.getCacheDir(), &quot;responses&quot;);</span><br><span class="line">      int cacheSize &#x3D; 10 * 1024 * 1024; &#x2F;&#x2F; 10 MiB</span><br><span class="line">      Cache cache &#x3D; new Cache(httpCacheDirectory, cacheSize);</span><br><span class="line">      OkHttpClient client &#x3D; new OkHttpClient.Builder()</span><br><span class="line">              .addInterceptor(REWRITE_CACHE_CONTROL_INTERCEPTOR)</span><br><span class="line">              .cache(cache).build();</span><br><span class="line">      Retrofit retrofit_zhihu &#x3D; new Retrofit.Builder()</span><br><span class="line">              .baseUrl(ZHIHU_BASE_URL)</span><br><span class="line">              .client(client)</span><br><span class="line">              .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">              .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">              .build();</span><br><span class="line">      ZhihuApiService &#x3D; retrofit_zhihu.create(ZhihuApi.class);</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置json解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.addConverterFactory(GsonConverterFactory.create())</span><br></pre></td></tr></table></figure>

<p>配置Rxjava  适配器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br></pre></td></tr></table></figure>
<p>  其中配置了网络缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR &#x3D; chain -&gt; &#123;</span><br><span class="line">        CacheControl.Builder cacheBuilder &#x3D; new CacheControl.Builder();</span><br><span class="line">        cacheBuilder.maxAge(0, TimeUnit.SECONDS);</span><br><span class="line">        cacheBuilder.maxStale(365, TimeUnit.DAYS);</span><br><span class="line">        CacheControl cacheControl &#x3D; cacheBuilder.build();</span><br><span class="line">        Request request &#x3D; chain.request();</span><br><span class="line">        if (!NetUtils.isNetworkAvailable(MyApp.mContext)) &#123;</span><br><span class="line">            request &#x3D; request.newBuilder()</span><br><span class="line">                    .cacheControl(cacheControl)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        Response originalResponse &#x3D; chain.proceed(request);</span><br><span class="line">        if (NetUtils.isNetworkAvailable(MyApp.mContext)) &#123;</span><br><span class="line">            int maxAge &#x3D; 0; &#x2F;&#x2F; read from cache</span><br><span class="line">            return originalResponse.newBuilder()</span><br><span class="line">                    .removeHeader(&quot;Pragma&quot;)</span><br><span class="line">                    .header(&quot;Cache-Control&quot;, &quot;public ,max-age&#x3D;&quot; + maxAge)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int maxStale &#x3D; 60 * 60 * 24 * 28; &#x2F;&#x2F; tolerate 4-weeks stale</span><br><span class="line">            return originalResponse.newBuilder()</span><br><span class="line">                    .removeHeader(&quot;Pragma&quot;)</span><br><span class="line">                    .header(&quot;Cache-Control&quot;, &quot;public, only-if-cached, max-stale&#x3D;&quot; + maxStale)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  在MVP的P层进行网络请求，传统的应该是Model  层，写在P层少一次接口回调。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>   public void getNews(IGetZhihuNewsView iGetZhihuNewsView){<br>        zhihuApi.getLatestNews( )<br>                .subscribeOn(Schedulers.io())<br>                .observeOn(AndroidSchedulers.mainThread())<br>                .subscribe(newsTimeLine -&gt; {<br>                    disPlayZhihuList(iGetZhihuNewsView,newsTimeLine, context);<br>                },this::loadError);<br>    }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">其中view接口</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public interface IGetZhihuNewsView {<br>    void  getSuccess(NewsTimeLine newsTimeLine);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在Activity中</span><br></pre></td></tr></table></figure>
<p>  public class MainActivity extends AppCompatActivity implements IGetZhihuNewsView {<br>    private TextView tv;<br>    @Override<br>    protected void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        tv= (TextView) findViewById(R.id.tv) ;<br>        ZhihuPresenter zhihuPresenter=new ZhihuPresenter(this);<br>        zhihuPresenter.getNews(this);<br>    }</p>
<p>   @Override<br>    public void getSuccess(NewsTimeLine newsTimeLine) {<br>        tv.setText(newsTimeLine.toString());<br>    }<br>}</p>
<pre><code>
  代码比较简单，~~~
  
  [源码下载](https://github.com/forezp/RxJavaRetrofit)
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>viewpager</title>
    <url>/2015/05/05/android-2015-05-05-viewpager-jrtt/</url>
    <content><![CDATA[<p>利用简单的Textview 和Viewpager实现滑动、点击换页的效果，效果图如下：</p>
<span id="more"></span>

<p><img src="http://img.blog.csdn.net/20160625113922931" width = "200"  alt="行走的那些事" align=center />　　　<img src="http://img.blog.csdn.net/20160625113940119" width = "200"  alt="行走的那些事" align=center /></p>
<p>先上布局文件代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:background&#x3D;&quot;@color&#x2F;white&quot;</span><br><span class="line">    android:orientation&#x3D;&quot;vertical&quot; &gt;</span><br><span class="line"></span><br><span class="line">   &lt;LinearLayout</span><br><span class="line">       android:background&#x3D;&quot;@color&#x2F;red_base&quot;</span><br><span class="line">       android:orientation&#x3D;&quot;horizontal&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;50dp&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;LinearLayout&gt;</span><br><span class="line">    &lt;!-- 选项卡 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;40dp&quot;</span><br><span class="line">        android:background&#x3D;&quot;@color&#x2F;white&quot;</span><br><span class="line">        android:orientation&#x3D;&quot;horizontal&quot;</span><br><span class="line">        android:weightSum&#x3D;&quot;5&quot; &gt;</span><br><span class="line"></span><br><span class="line">        &lt;FrameLayout</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_tab1_fl&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">            android:clickable&#x3D;&quot;true&quot;</span><br><span class="line">            android:gravity&#x3D;&quot;center&quot; &gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id&#x3D;&quot;@+id&#x2F;rim_tab1_tv&quot;</span><br><span class="line">                android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class="line">                android:text&#x3D;&quot;全部&quot;</span><br><span class="line">                android:textColor&#x3D;&quot;@color&#x2F;red_base&quot;</span><br><span class="line">                android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;FrameLayout&gt;</span><br><span class="line"></span><br><span class="line">        &lt;View</span><br><span class="line">            android:layout_width&#x3D;&quot;0.5dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_marginBottom&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:background&#x3D;&quot;@color&#x2F;divider_gray_line&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;FrameLayout</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_tab2_fl&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">            android:clickable&#x3D;&quot;true&quot;</span><br><span class="line">            android:gravity&#x3D;&quot;center&quot; &gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id&#x3D;&quot;@+id&#x2F;rim_tab2_tv&quot;</span><br><span class="line">                android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class="line">                android:text&#x3D;&quot;周边&quot;</span><br><span class="line">                android:textColor&#x3D;&quot;@color&#x2F;text_gray_4&quot;</span><br><span class="line">                android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;FrameLayout&gt;</span><br><span class="line"></span><br><span class="line">        &lt;View</span><br><span class="line">            android:layout_width&#x3D;&quot;0.5dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_marginBottom&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:background&#x3D;&quot;@color&#x2F;divider_gray_line&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;FrameLayout</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_tab3_fl&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">            android:clickable&#x3D;&quot;true&quot;</span><br><span class="line">            android:gravity&#x3D;&quot;center&quot; &gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id&#x3D;&quot;@+id&#x2F;rim_tab3_tv&quot;</span><br><span class="line">                android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class="line">                android:text&#x3D;&quot;应援&quot;</span><br><span class="line">                android:textColor&#x3D;&quot;@color&#x2F;text_gray_4&quot;</span><br><span class="line">                android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;FrameLayout&gt;</span><br><span class="line"></span><br><span class="line">        &lt;View</span><br><span class="line">            android:layout_width&#x3D;&quot;0.5dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_marginBottom&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:background&#x3D;&quot;@color&#x2F;divider_gray_line&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;FrameLayout</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_tab4_fl&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">            android:clickable&#x3D;&quot;true&quot;</span><br><span class="line">            android:gravity&#x3D;&quot;center&quot; &gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id&#x3D;&quot;@+id&#x2F;rim_tab4_tv&quot;</span><br><span class="line">                android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class="line">                android:text&#x3D;&quot;话题&quot;</span><br><span class="line">                android:textColor&#x3D;&quot;@color&#x2F;text_gray_4&quot;</span><br><span class="line">                android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;FrameLayout&gt;</span><br><span class="line"></span><br><span class="line">        &lt;View</span><br><span class="line">            android:layout_width&#x3D;&quot;0.5dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_marginBottom&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:background&#x3D;&quot;@color&#x2F;divider_gray_line&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;FrameLayout</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_tab5_fl&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">            android:clickable&#x3D;&quot;true&quot;</span><br><span class="line">            android:gravity&#x3D;&quot;center&quot; &gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id&#x3D;&quot;@+id&#x2F;rim_tab5_tv&quot;</span><br><span class="line">                android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class="line">                android:text&#x3D;&quot;明星&quot;</span><br><span class="line">                android:textColor&#x3D;&quot;@color&#x2F;text_gray_4&quot;</span><br><span class="line">                android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;FrameLayout&gt;</span><br><span class="line">    &lt;&#x2F;LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;3dp&quot;</span><br><span class="line">        android:background&#x3D;&quot;@color&#x2F;white&quot; &gt;</span><br><span class="line"></span><br><span class="line">        &lt;ImageView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_cursor&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;80dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;3dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;0dip&quot;</span><br><span class="line">            android:background&#x3D;&quot;@color&#x2F;title_bar_blue&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;View</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;0.1dp&quot;</span><br><span class="line">        android:background&#x3D;&quot;@color&#x2F;btn_bg_gray&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 选项卡内容显示区域 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;View</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;10dp&quot;</span><br><span class="line">        android:background&#x3D;&quot;@color&#x2F;bg_light_gray&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v4.view.ViewPager</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;rim_third_vp&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;match_parent&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>上面红色指示器的view的初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int screenWidth;&#x2F;&#x2F;指示器</span><br><span class="line">private ImageView cursorImg;</span><br><span class="line">private LinearLayout.LayoutParams lp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private void initViews()&#123;</span><br><span class="line"></span><br><span class="line">        WindowManager wm &#x3D; (WindowManager)</span><br><span class="line">                getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line"></span><br><span class="line">        int width &#x3D; wm.getDefaultDisplay().getWidth();</span><br><span class="line">        screenWidth&#x3D;width&#x2F;5;</span><br><span class="line">        cursorImg &#x3D; (ImageView) findViewById(R.id.rim_cursor);</span><br><span class="line">        lp &#x3D; (LinearLayout.LayoutParams) cursorImg.getLayoutParams();</span><br><span class="line">        lp.width &#x3D; screenWidth;</span><br><span class="line">        cursorImg.setLayoutParams(lp);</span><br><span class="line">        leftMargin &#x3D; lp.leftMargin;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>初始化indicater</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void initViewPager() &#123;</span><br><span class="line">        viewPager &#x3D; (ViewPager) findViewById(R.id.rim_third_vp);</span><br><span class="line">        fragmentsList &#x3D; new ArrayList&lt;Fragment&gt;();</span><br><span class="line">        fragment1 &#x3D; new RimFragment();     </span><br><span class="line">        fragmentsList.add(fragment1);</span><br><span class="line">        fragmentsList.add(fragment2);</span><br><span class="line">        fragmentsList.add(fragment3);</span><br><span class="line">        fragmentsList.add(fragment4);</span><br><span class="line">        fragmentsList.add(fragment5);</span><br><span class="line"></span><br><span class="line">        viewPager.setAdapter(new FragmentAdapter(getSupportFragmentManager(),</span><br><span class="line">                fragmentsList));</span><br><span class="line">        viewPager.setCurrentItem(0);</span><br><span class="line">        viewPager.setOnPageChangeListener(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>设置上面选项卡的点击事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void onClick(View v) &#123;</span><br><span class="line">       switch (v.getId())&#123;</span><br><span class="line">           case R.id.rim_tab1_fl:</span><br><span class="line">               viewPager.setCurrentItem(0);</span><br><span class="line">               num_tab1_tv.setTextColor(getResources().getColor(R.color.red_base));</span><br><span class="line">               num_tab2_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab3_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab4_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab5_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               fragment1.setMsgName(&quot;1&quot;,&quot;周边&quot;);&#x2F;&#x2F;周边的官方和会员的接口参数,官方</span><br><span class="line">               break;</span><br></pre></td></tr></table></figure>

<p>设置viewpager 滑动事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;</span><br><span class="line"></span><br><span class="line">       offset &#x3D; (screenWidth - cursorImg.getLayoutParams().width) &#x2F; 5;</span><br><span class="line">       </span><br><span class="line">       hidePoint(position, positionOffsetPixels);&#x2F;&#x2F;设置红色指示器的位置</span><br><span class="line">       cursorImg.setLayoutParams(lp);</span><br><span class="line">       currentIndex &#x3D; position;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void onPageSelected(int position) &#123;</span><br><span class="line"></span><br><span class="line">       switch (position)&#123;&#x2F;&#x2F;设置点击事件</span><br><span class="line">           case  0:</span><br><span class="line">               fragment1.setMsgName(&quot;1&quot;,&quot;周边&quot;);</span><br><span class="line">               num_tab1_tv.setTextColor(getResources().getColor(R.color.red_base));</span><br><span class="line">               num_tab2_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab3_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab4_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab5_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               break;</span><br><span class="line">         </span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (position&#x3D;&#x3D;0)</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;else &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void onPageScrollStateChanged(int state) &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置指示器的位置</span><br><span class="line">   private void hidePoint(int position, int positionOffsetPixels) &#123;</span><br><span class="line">       if (position &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; 0&lt;-&gt;1</span><br><span class="line">           lp.leftMargin &#x3D; (int) (positionOffsetPixels &#x2F; 5) + offset;</span><br><span class="line"></span><br><span class="line">       &#125; else if (position &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F; 1&lt;-&gt;2</span><br><span class="line">           lp.leftMargin &#x3D; (int) (positionOffsetPixels &#x2F; 5) + screenWidth</span><br><span class="line">                   + offset;</span><br><span class="line"></span><br><span class="line">       &#125;else  if(position&#x3D;&#x3D;2)&#123;</span><br><span class="line">           lp.leftMargin &#x3D; (int) (positionOffsetPixels &#x2F; 5) + screenWidth*2</span><br><span class="line">                   + offset;</span><br><span class="line">       &#125;</span><br><span class="line">       else  if(position&#x3D;&#x3D;3)&#123;</span><br><span class="line">           lp.leftMargin &#x3D; (int) (positionOffsetPixels &#x2F; 5) + screenWidth*3</span><br><span class="line">                   + offset;</span><br><span class="line">       &#125;</span><br><span class="line">       else  if(position&#x3D;&#x3D;4)&#123;</span><br><span class="line">           lp.leftMargin &#x3D; (int) (positionOffsetPixels &#x2F; 5) + screenWidth*4</span><br><span class="line">                   + offset;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9559206">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android eventbus</title>
    <url>/2015/05/05/android-2015-05-05-eventbus/</url>
    <content><![CDATA[<p>最近在研究RxJava ，突然想起了事件分发另一个强大的框架Eventbus ,并且项目经常用到，特意整理了下。<br>what is Eventbus?<br>官方的解释为：<br>EventBus is a publish/subscribe event bus optimized for Android.<br>它是专门为优化安卓一个 发布者/订阅者的事件总线。</p>
<p><img src="http://img.blog.csdn.net/20160622183052058" alt="事件分发流程"></p>
<span id="more"></span>

<p>发布者，发布事件。通过事件总线（其实就是在一个单例内部维持着一个map对象存储了一堆的方法），分发给订阅者。</p>
<p>它的优点：<br>轻量、简单、降低耦合。</p>
<p>用法：<br>1.声明Event事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MessageEvent &#123; &#x2F;* Additional fields if needed *&#x2F; &#125;</span><br></pre></td></tr></table></figure>
<p>2.注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eventBus.register(this);</span><br></pre></td></tr></table></figure>
<p>声明方法，有四种方法，最主要的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Subscribe</span><br><span class="line">   public void onEventMainThread(CommonEvent event) &#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>3.发布事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eventBus.post(event);</span><br></pre></td></tr></table></figure>

<p>例子：<br>在oncrete（） 方法中注册，无论是Activity 还是Fragment ,不在这里注册会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line">       EventBus.getDefault().register(this);</span><br><span class="line">       btn&#x3D;(Button)findViewById(R.id.btn);</span><br><span class="line">       tv&#x3D;(TextView)findViewById(R.id.tv);</span><br><span class="line">       btn.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line">               Intent intent&#x3D;new Intent(MainActivity.this,SecondActivity.class);</span><br><span class="line">               startActivity(intent);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在OnDestroy中反注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDestroy() &#123;</span><br><span class="line">      super.onDestroy();</span><br><span class="line">      EventBus.getDefault().unregister(this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>声明订阅者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Subscribe</span><br><span class="line">   public void onEventMainThread(CommonEvent event) &#123;</span><br><span class="line"></span><br><span class="line">      if(event.getType().equals(CommonEvent.TYPE_99))&#123;</span><br><span class="line">          tv.setText(&quot;从第二个页面来的：eventtype&#x3D;&quot;+event.getType());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在需要触发事件的位置提交事件：例如我在第二个界面提交事件，在第一个页面接受：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().post(new CommonEvent(CommonEvent.TYPE_99));</span><br></pre></td></tr></table></figure>

<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9556776">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Ribbon源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-Ribbon-resources/</url>
    <content><![CDATA[<h2 id="什么是Ribbon"><a href="#什么是Ribbon" class="headerlink" title="什么是Ribbon"></a>什么是Ribbon</h2><p>Ribbon是Netflix公司开源的一个负载均衡的项目，它属于上述的第二种，是一个客户端负载均衡器，运行在客户端上。它是一个经过了云端测试的IPC库，可以很好地控制HTTP和TCP客户端的一些行为。 Feign已经默认使用了Ribbon。</p>
<ul>
<li>负载均衡</li>
<li>容错</li>
<li>多协议（HTTP，TCP，UDP）支持异步和反应模型</li>
<li>缓存和批处理 </li>
</ul>
<span id="more"></span>

<h2 id="RestTemplate和Ribbon相结合"><a href="#RestTemplate和Ribbon相结合" class="headerlink" title="RestTemplate和Ribbon相结合"></a>RestTemplate和Ribbon相结合</h2><p>Ribbon在Netflix组件是非常重要的一个组件，在Zuul中使用Ribbon做负载均衡，以及Feign组件的结合等。在Spring Cloud 中，作为开发中，做的最多的可能是将RestTemplate和Ribbon相结合，你可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RibbonConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    RestTemplate restTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消费另外一个的服务的接口，差不多是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RibbonService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line">    public String hi(String name) &#123;</span><br><span class="line">        return restTemplate.getForObject(&quot;http:&#x2F;&#x2F;eureka-client&#x2F;hi?name&#x3D;&quot;+name,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="深入理解Ribbon"><a href="#深入理解Ribbon" class="headerlink" title="深入理解Ribbon"></a>深入理解Ribbon</h2><h3 id="LoadBalancerClient"><a href="#LoadBalancerClient" class="headerlink" title="LoadBalancerClient"></a>LoadBalancerClient</h3><p>在Riibon中一个非常重要的组件为LoadBalancerClient，它作为负载均衡的一个客户端。它在spring-cloud-commons包下：<br>的LoadBalancerClient是一个接口，它继承ServiceInstanceChooser，它的实现类是RibbonLoadBalancerClient，这三者之间的关系如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-961a4933f2f92c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>其中LoadBalancerClient接口，有如下三个方法，其中excute()为执行请求，reconstructURI()用来重构url：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface LoadBalancerClient extends ServiceInstanceChooser &#123;</span><br><span class="line">  &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException;</span><br><span class="line">  &lt;T&gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request) throws IOException;</span><br><span class="line">  URI reconstructURI(ServiceInstance instance, URI original);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ServiceInstanceChooser接口，主要有一个方法，用来根据serviceId来获取ServiceInstance，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ServiceInstanceChooser &#123;</span><br><span class="line"></span><br><span class="line">    ServiceInstance choose(String serviceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LoadBalancerClient的实现类为RibbonLoadBalancerClient，这个类是非常重要的一个类，最终的负载均衡的请求处理，由它来执行。它的部分源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RibbonLoadBalancerClient implements LoadBalancerClient &#123;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">	public ServiceInstance choose(String serviceId) &#123;</span><br><span class="line">		Server server &#x3D; getServer(serviceId);</span><br><span class="line">		if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return new RibbonServer(serviceId, server, isSecure(server, serviceId),</span><br><span class="line">				serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected Server getServer(String serviceId) &#123;</span><br><span class="line">		return getServer(getLoadBalancer(serviceId));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected Server getServer(ILoadBalancer loadBalancer) &#123;</span><br><span class="line">		if (loadBalancer &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return loadBalancer.chooseServer(&quot;default&quot;); &#x2F;&#x2F; TODO: better handling of key</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected ILoadBalancer getLoadBalancer(String serviceId) &#123;</span><br><span class="line">		return this.clientFactory.getLoadBalancer(serviceId);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在RibbonLoadBalancerClient的源码中，其中choose()方法是选择具体服务实例的一个方法。该方法通过getServer()方法去获取实例，经过源码跟踪，最终交给了ILoadBalancer类去选择服务实例。</p>
<p>ILoadBalancer在ribbon-loadbalancer的jar包下,它是定义了实现软件负载均衡的一个接口，它需要一组可供选择的服务注册列表信息，以及根据特定方法去选择服务，它的源码如下 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ILoadBalancer &#123;</span><br><span class="line"></span><br><span class="line">    public void addServers(List&lt;Server&gt; newServers);</span><br><span class="line">    public Server chooseServer(Object key);</span><br><span class="line">    public void markServerDown(Server server);</span><br><span class="line">    public List&lt;Server&gt; getReachableServers();</span><br><span class="line">    public List&lt;Server&gt; getAllServers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，addServers()方法是添加一个Server集合；chooseServer()方法是根据key去获取Server；markServerDown()方法用来标记某个服务下线；getReachableServers()获取可用的Server集合；getAllServers()获取所有的Server集合。</p>
<h2 id="DynamicServerListLoadBalancer"><a href="#DynamicServerListLoadBalancer" class="headerlink" title="DynamicServerListLoadBalancer"></a>DynamicServerListLoadBalancer</h2><p>它的继承类为BaseLoadBalancer，它的实现类为DynamicServerListLoadBalancer，这三者之间的关系如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-09ad9b1ece18a1a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>查看上述三个类的源码，可用发现，配置以下信息，IClientConfig、IRule、IPing、ServerList、ServerListFilter和ILoadBalancer，查看BaseLoadBalancer类，它默认的情况下，实现了以下配置：</p>
<ul>
<li>IClientConfig ribbonClientConfig:  DefaultClientConfigImpl配置</li>
<li>IRule ribbonRule: RoundRobinRule 路由策略</li>
<li>IPing ribbonPing: DummyPing </li>
<li>ServerList ribbonServerList: ConfigurationBasedServerList</li>
<li>ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter</li>
<li>ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</li>
</ul>
<p>IClientConfig 用于对客户端或者负载均衡的配置，它的默认实现类为DefaultClientConfigImpl。</p>
<p>IRule用于复杂均衡的策略，它有三个方法，其中choose()是根据key 来获取server,setLoadBalancer()和getLoadBalancer()是用来设置和获取ILoadBalancer的，它的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IRule&#123;</span><br><span class="line"></span><br><span class="line">    public Server choose(Object key);</span><br><span class="line">    </span><br><span class="line">    public void setLoadBalancer(ILoadBalancer lb);</span><br><span class="line">    </span><br><span class="line">    public ILoadBalancer getLoadBalancer();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>IRule有很多默认的实现类，这些实现类根据不同的算法和逻辑来处理负载均衡。Ribbon实现的IRule有一下。在大多数情况下，这些默认的实现类是可以满足需求的，如果有特性的需求，可以自己实现。</p>
<ul>
<li><p>BestAvailableRule 选择最小请求数</p>
</li>
<li><p>ClientConfigEnabledRoundRobinRule 轮询</p>
</li>
<li><p>RandomRule 随机选择一个server</p>
</li>
<li><p>RoundRobinRule 轮询选择server</p>
</li>
<li><p>RetryRule 根据轮询的方式重试</p>
</li>
<li><p>WeightedResponseTimeRule 根据响应时间去分配一个weight ，weight越低，被选择的可能性就越低</p>
</li>
<li><p>ZoneAvoidanceRule 根据server的zone区域和可用性来轮询选择</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-ce636f8c473f6e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>IPing是用来想server发生”ping”，来判断该server是否有响应，从而判断该server是否可用。它有一个isAlive()方法，它的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IPing &#123;</span><br><span class="line">    public boolean isAlive(Server server);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IPing的实现类有PingUrl、PingConstant、NoOpPing、DummyPing和NIWSDiscoveryPing。它门之间的关系如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-a2871eb4f4e82714.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>PingUrl 真实的去ping 某个url，判断其是否alive</li>
<li>PingConstant 固定返回某服务是否可用，默认返回true，即可用</li>
<li>NoOpPing 不去ping,直接返回true,即可用。</li>
<li>DummyPing 直接返回true，并实现了initWithNiwsConfig方法。</li>
<li>NIWSDiscoveryPing，根据DiscoveryEnabledServer的InstanceInfo的InstanceStatus去判断，如果为InstanceStatus.UP，则为可用，否则不可用。</li>
</ul>
<p>ServerList是定义获取所有的server的注册列表信息的接口，它的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ServerList&lt;T extends Server&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;T&gt; getInitialListOfServers();</span><br><span class="line">    public List&lt;T&gt; getUpdatedListOfServers();   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ServerListFilter接口，定于了可根据配置去过滤或者根据特性动态获取符合条件的server列表的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ServerListFilter&lt;T extends Server&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;T&gt; getFilteredListOfServers(List&lt;T&gt; servers);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>阅读DynamicServerListLoadBalancer的源码，DynamicServerListLoadBalancer的构造函数中有个initWithNiwsConfig()方法。在改方法中，经过一系列的初始化配置，最终执行了restOfInit()方法。其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public DynamicServerListLoadBalancer(IClientConfig clientConfig) &#123;</span><br><span class="line">       initWithNiwsConfig(clientConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   public void initWithNiwsConfig(IClientConfig clientConfig) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           super.initWithNiwsConfig(clientConfig);</span><br><span class="line">           String niwsServerListClassName &#x3D; clientConfig.getPropertyAsString(</span><br><span class="line">                   CommonClientConfigKey.NIWSServerListClassName,</span><br><span class="line">                   DefaultClientConfigImpl.DEFAULT_SEVER_LIST_CLASS);</span><br><span class="line"></span><br><span class="line">           ServerList&lt;T&gt; niwsServerListImpl &#x3D; (ServerList&lt;T&gt;) ClientFactory</span><br><span class="line">                   .instantiateInstanceWithClientConfig(niwsServerListClassName, clientConfig);</span><br><span class="line">           this.serverListImpl &#x3D; niwsServerListImpl;</span><br><span class="line"></span><br><span class="line">           if (niwsServerListImpl instanceof AbstractServerList) &#123;</span><br><span class="line">               AbstractServerListFilter&lt;T&gt; niwsFilter &#x3D; ((AbstractServerList) niwsServerListImpl)</span><br><span class="line">                       .getFilterImpl(clientConfig);</span><br><span class="line">               niwsFilter.setLoadBalancerStats(getLoadBalancerStats());</span><br><span class="line">               this.filter &#x3D; niwsFilter;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           String serverListUpdaterClassName &#x3D; clientConfig.getPropertyAsString(</span><br><span class="line">                   CommonClientConfigKey.ServerListUpdaterClassName,</span><br><span class="line">                   DefaultClientConfigImpl.DEFAULT_SERVER_LIST_UPDATER_CLASS</span><br><span class="line">           );</span><br><span class="line"></span><br><span class="line">           this.serverListUpdater &#x3D; (ServerListUpdater) ClientFactory</span><br><span class="line">                   .instantiateInstanceWithClientConfig(serverListUpdaterClassName, clientConfig);</span><br><span class="line"></span><br><span class="line">           restOfInit(clientConfig);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">                   &quot;Exception while initializing NIWSDiscoveryLoadBalancer:&quot;</span><br><span class="line">                           + clientConfig.getClientName()</span><br><span class="line">                           + &quot;, niwsClientConfig:&quot; + clientConfig, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在restOfInit()方法上，有一个 updateListOfServers()的方法，该方法是用来获取所有的ServerList的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void restOfInit(IClientConfig clientConfig) &#123;</span><br><span class="line">       boolean primeConnection &#x3D; this.isEnablePrimingConnections();</span><br><span class="line">       &#x2F;&#x2F; turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span><br><span class="line">       this.setEnablePrimingConnections(false);</span><br><span class="line">       enableAndInitLearnNewServersFeature();</span><br><span class="line"></span><br><span class="line">       updateListOfServers();</span><br><span class="line">       if (primeConnection &amp;&amp; this.getPrimeConnections() !&#x3D; null) &#123;</span><br><span class="line">           this.getPrimeConnections()</span><br><span class="line">                   .primeConnections(getReachableServers());</span><br><span class="line">       &#125;</span><br><span class="line">       this.setEnablePrimingConnections(primeConnection);</span><br><span class="line">       LOGGER.info(&quot;DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;&quot;, clientConfig.getClientName(), this.toString());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进一步跟踪updateListOfServers()方法的源码，最终由serverListImpl.getUpdatedListOfServers()获取所有的服务列表的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@VisibleForTesting</span><br><span class="line"> public void updateListOfServers() &#123;</span><br><span class="line">     List&lt;T&gt; servers &#x3D; new ArrayList&lt;T&gt;();</span><br><span class="line">     if (serverListImpl !&#x3D; null) &#123;</span><br><span class="line">         servers &#x3D; serverListImpl.getUpdatedListOfServers();</span><br><span class="line">         LOGGER.debug(&quot;List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;,</span><br><span class="line">                 getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">         if (filter !&#x3D; null) &#123;</span><br><span class="line">             servers &#x3D; filter.getFilteredListOfServers(servers);</span><br><span class="line">             LOGGER.debug(&quot;Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;,</span><br><span class="line">                     getIdentifier(), servers);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     updateAllServerList(servers);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而serverListImpl是ServerList接口的具体实现类。跟踪代码，ServerList的实现类为DiscoveryEnabledNIWSServerList，在ribbon-eureka.jar的com.netflix.niws.loadbalancer下。其中DiscoveryEnabledNIWSServerList有 getInitialListOfServers()和getUpdatedListOfServers()方法，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public List&lt;DiscoveryEnabledServer&gt; getInitialListOfServers()&#123;</span><br><span class="line">        return obtainServersViaDiscovery();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;DiscoveryEnabledServer&gt; getUpdatedListOfServers()&#123;</span><br><span class="line">        return obtainServersViaDiscovery();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>继续跟踪源码，obtainServersViaDiscovery（），是根据eurekaClientProvider.get()来回去EurekaClient，再根据EurekaClient来获取注册列表信息，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private List&lt;DiscoveryEnabledServer&gt; obtainServersViaDiscovery() &#123;</span><br><span class="line">       List&lt;DiscoveryEnabledServer&gt; serverList &#x3D; new ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line"></span><br><span class="line">       if (eurekaClientProvider &#x3D;&#x3D; null || eurekaClientProvider.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">           logger.warn(&quot;EurekaClient has not been initialized yet, returning an empty list&quot;);</span><br><span class="line">           return new ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       EurekaClient eurekaClient &#x3D; eurekaClientProvider.get();</span><br><span class="line">       if (vipAddresses!&#x3D;null)&#123;</span><br><span class="line">           for (String vipAddress : vipAddresses.split(&quot;,&quot;)) &#123;</span><br><span class="line">               &#x2F;&#x2F; if targetRegion is null, it will be interpreted as the same region of client</span><br><span class="line">               List&lt;InstanceInfo&gt; listOfInstanceInfo &#x3D; eurekaClient.getInstancesByVipAddress(vipAddress, isSecure, targetRegion);</span><br><span class="line">               for (InstanceInfo ii : listOfInstanceInfo) &#123;</span><br><span class="line">                   if (ii.getStatus().equals(InstanceStatus.UP)) &#123;</span><br><span class="line"></span><br><span class="line">                       if(shouldUseOverridePort)&#123;</span><br><span class="line">                           if(logger.isDebugEnabled())&#123;</span><br><span class="line">                               logger.debug(&quot;Overriding port on client name: &quot; + clientName + &quot; to &quot; + overridePort);</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           &#x2F;&#x2F; copy is necessary since the InstanceInfo builder just uses the original reference,</span><br><span class="line">                           &#x2F;&#x2F; and we don&#39;t want to corrupt the global eureka copy of the object which may be</span><br><span class="line">                           &#x2F;&#x2F; used by other clients in our system</span><br><span class="line">                           InstanceInfo copy &#x3D; new InstanceInfo(ii);</span><br><span class="line"></span><br><span class="line">                           if(isSecure)&#123;</span><br><span class="line">                               ii &#x3D; new InstanceInfo.Builder(copy).setSecurePort(overridePort).build();</span><br><span class="line">                           &#125;else&#123;</span><br><span class="line">                               ii &#x3D; new InstanceInfo.Builder(copy).setPort(overridePort).build();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       DiscoveryEnabledServer des &#x3D; new DiscoveryEnabledServer(ii, isSecure, shouldUseIpAddr);</span><br><span class="line">                       des.setZone(DiscoveryClient.getZone(ii));</span><br><span class="line">                       serverList.add(des);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (serverList.size()&gt;0 &amp;&amp; prioritizeVipAddressBasedServers)&#123;</span><br><span class="line">                   break; &#x2F;&#x2F; if the current vipAddress has servers, we dont use subsequent vipAddress based servers</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return serverList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中eurekaClientProvider的实现类是LegacyEurekaClientProvider，它是一个获取eurekaClient类，通过静态的方法去获取eurekaClient，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LegacyEurekaClientProvider implements Provider&lt;EurekaClient&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private volatile EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized EurekaClient get() &#123;</span><br><span class="line">        if (eurekaClient &#x3D;&#x3D; null) &#123;</span><br><span class="line">            eurekaClient &#x3D; DiscoveryManager.getInstance().getDiscoveryClient();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return eurekaClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>EurekaClient的实现类为DiscoveryClient，在之前已经分析了它具有服务注册、获取服务注册列表等的全部功能。</p>
<p>由此可见，负载均衡器是从EurekaClient获取服务信息，并根据IRule去路由，并且根据IPing去判断服务的可用性。</p>
<p>那么现在还有个问题，负载均衡器多久一次去获取一次从Eureka Client获取注册信息呢。</p>
<p>在BaseLoadBalancer类下，BaseLoadBalancer的构造函数，该构造函数开启了一个PingTask任务，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public BaseLoadBalancer(String name, IRule rule, LoadBalancerStats stats,</span><br><span class="line">         IPing ping, IPingStrategy pingStrategy) &#123;</span><br><span class="line">  ...&#x2F;&#x2F;代码省略</span><br><span class="line">     setupPingTask();</span><br><span class="line">      ...&#x2F;&#x2F;代码省略</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>setupPingTask()的具体代码逻辑，它开启了ShutdownEnabledTimer执行PingTask任务，在默认情况下pingIntervalSeconds为10，即每10秒钟，想EurekaClient发送一次”ping”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void setupPingTask() &#123;</span><br><span class="line">    if (canSkipPing()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (lbTimer !&#x3D; null) &#123;</span><br><span class="line">        lbTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    lbTimer &#x3D; new ShutdownEnabledTimer(&quot;NFLoadBalancer-PingTimer-&quot; + name,</span><br><span class="line">            true);</span><br><span class="line">    lbTimer.schedule(new PingTask(), 0, pingIntervalSeconds * 1000);</span><br><span class="line">    forceQuickPing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PingTask源码，即new一个Pinger对象，并执行runPinger()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PingTask extends TimerTask &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            	new Pinger(pingStrategy).runPinger();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(&quot;LoadBalancer [&#123;&#125;]: Error pinging&quot;, name, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看Pinger的runPinger()方法，最终根据  pingerStrategy.pingServers(ping, allServers)来获取服务的可用性，如果该返回结果，如之前相同，则不去向EurekaClient获取注册列表，如果不同则通知ServerStatusChangeListener或者changeListeners发生了改变，进行更新或者重新拉取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void runPinger() throws Exception &#123;</span><br><span class="line">          if (!pingInProgress.compareAndSet(false, true)) &#123; </span><br><span class="line">              return; &#x2F;&#x2F; Ping in progress - nothing to do</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F; we are &quot;in&quot; - we get to Ping</span><br><span class="line"></span><br><span class="line">          Server[] allServers &#x3D; null;</span><br><span class="line">          boolean[] results &#x3D; null;</span><br><span class="line"></span><br><span class="line">          Lock allLock &#x3D; null;</span><br><span class="line">          Lock upLock &#x3D; null;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              &#x2F;*</span><br><span class="line">               * The readLock should be free unless an addServer operation is</span><br><span class="line">               * going on...</span><br><span class="line">               *&#x2F;</span><br><span class="line">              allLock &#x3D; allServerLock.readLock();</span><br><span class="line">              allLock.lock();</span><br><span class="line">              allServers &#x3D; allServerList.toArray(new Server[allServerList.size()]);</span><br><span class="line">              allLock.unlock();</span><br><span class="line"></span><br><span class="line">              int numCandidates &#x3D; allServers.length;</span><br><span class="line">              results &#x3D; pingerStrategy.pingServers(ping, allServers);</span><br><span class="line"></span><br><span class="line">              final List&lt;Server&gt; newUpList &#x3D; new ArrayList&lt;Server&gt;();</span><br><span class="line">              final List&lt;Server&gt; changedServers &#x3D; new ArrayList&lt;Server&gt;();</span><br><span class="line"></span><br><span class="line">              for (int i &#x3D; 0; i &lt; numCandidates; i++) &#123;</span><br><span class="line">                  boolean isAlive &#x3D; results[i];</span><br><span class="line">                  Server svr &#x3D; allServers[i];</span><br><span class="line">                  boolean oldIsAlive &#x3D; svr.isAlive();</span><br><span class="line"></span><br><span class="line">                  svr.setAlive(isAlive);</span><br><span class="line"></span><br><span class="line">                  if (oldIsAlive !&#x3D; isAlive) &#123;</span><br><span class="line">                      changedServers.add(svr);</span><br><span class="line">                      logger.debug(&quot;LoadBalancer [&#123;&#125;]:  Server [&#123;&#125;] status changed to &#123;&#125;&quot;, </span><br><span class="line">                  		name, svr.getId(), (isAlive ? &quot;ALIVE&quot; : &quot;DEAD&quot;));</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  if (isAlive) &#123;</span><br><span class="line">                      newUpList.add(svr);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              upLock &#x3D; upServerLock.writeLock();</span><br><span class="line">              upLock.lock();</span><br><span class="line">              upServerList &#x3D; newUpList;</span><br><span class="line">              upLock.unlock();</span><br><span class="line"></span><br><span class="line">              notifyServerStatusChangeListener(changedServers);</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              pingInProgress.set(false);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由此可见，LoadBalancerClient是在初始化的时候，会向Eureka回去服务注册列表，并且向通过10s一次向EurekaClient发送“ping”，来判断服务的可用性，如果服务的可用性发生了改变或者服务数量和之前的不一致，则更新或者重新拉取。LoadBalancerClient有了这些服务注册列表，就可以根据具体的IRule来进行负载均衡。</p>
<h2 id="RestTemplate是如何和Ribbon结合的"><a href="#RestTemplate是如何和Ribbon结合的" class="headerlink" title="RestTemplate是如何和Ribbon结合的"></a>RestTemplate是如何和Ribbon结合的</h2><p>最后，回答问题的本质，为什么在RestTemplate加一个@LoadBalance注解就可可以开启负载均衡呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">   RestTemplate restTemplate() &#123;</span><br><span class="line">       return new RestTemplate();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>全局搜索ctr+shift+f  @LoadBalanced有哪些类用到了LoadBalanced有哪些类用到了， 发现LoadBalancerAutoConfiguration类，即LoadBalancer自动配置类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(RestTemplate.class)</span><br><span class="line">@ConditionalOnBean(LoadBalancerClient.class)</span><br><span class="line">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span><br><span class="line">public class LoadBalancerAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@LoadBalanced</span><br><span class="line">	@Autowired(required &#x3D; false)</span><br><span class="line">	private List&lt;RestTemplate&gt; restTemplates &#x3D; Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line">	@Bean</span><br><span class="line">	public SmartInitializingSingleton loadBalancedRestTemplateInitializer(</span><br><span class="line">			final List&lt;RestTemplateCustomizer&gt; customizers) &#123;</span><br><span class="line">		return new SmartInitializingSingleton() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void afterSingletonsInstantiated() &#123;</span><br><span class="line">				for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) &#123;</span><br><span class="line">					for (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">						customizer.customize(restTemplate);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	@Configuration</span><br><span class="line">	@ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;)</span><br><span class="line">	static class LoadBalancerInterceptorConfig &#123;</span><br><span class="line">		@Bean</span><br><span class="line">		public LoadBalancerInterceptor ribbonInterceptor(</span><br><span class="line">				LoadBalancerClient loadBalancerClient,</span><br><span class="line">				LoadBalancerRequestFactory requestFactory) &#123;</span><br><span class="line">			return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Bean</span><br><span class="line">		@ConditionalOnMissingBean</span><br><span class="line">		public RestTemplateCustomizer restTemplateCustomizer(</span><br><span class="line">				final LoadBalancerInterceptor loadBalancerInterceptor) &#123;</span><br><span class="line">			return new RestTemplateCustomizer() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void customize(RestTemplate restTemplate) &#123;</span><br><span class="line">					List&lt;ClientHttpRequestInterceptor&gt; list &#x3D; new ArrayList&lt;&gt;(</span><br><span class="line">							restTemplate.getInterceptors());</span><br><span class="line">					list.add(loadBalancerInterceptor);</span><br><span class="line">					restTemplate.setInterceptors(list);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该类中，首先维护了一个被@LoadBalanced修饰的RestTemplate对象的List，在初始化的过程中，通过调用customizer.customize(restTemplate)方法来给RestTemplate增加拦截器LoadBalancerInterceptor。</p>
<p>而LoadBalancerInterceptor，用于实时拦截，在LoadBalancerInterceptor这里实现来负载均衡。LoadBalancerInterceptor的拦截方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,</span><br><span class="line">			final ClientHttpRequestExecution execution) throws IOException &#123;</span><br><span class="line">		final URI originalUri &#x3D; request.getURI();</span><br><span class="line">		String serviceName &#x3D; originalUri.getHost();</span><br><span class="line">		Assert.state(serviceName !&#x3D; null, &quot;Request URI does not contain a valid hostname: &quot; + originalUri);</span><br><span class="line">		return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，Ribbon的负载均衡，主要通过LoadBalancerClient来实现的，而LoadBalancerClient具体交给了ILoadBalancer来处理，ILoadBalancer通过配置IRule、IPing等信息，并向EurekaClient获取注册列表的信息，并默认10秒一次向EurekaClient发送“ping”,进而检查是否更新服务列表，最后，得到注册列表后，ILoadBalancer根据IRule的策略进行负载均衡。</p>
<p>而RestTemplate 被@LoadBalance注解后，能过用负载均衡，主要是维护了一个被@LoadBalance注解的RestTemplate列表，并给列表中的RestTemplate添加拦截器，进而交给负载均衡器去处理。</p>
<h2 id="关注我的公众号"><a href="#关注我的公众号" class="headerlink" title="关注我的公众号"></a>关注我的公众号</h2><p>精彩内容不能错过！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0805748d92bba033.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="forezp.jpg"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>NestedScrollView和RecyclerView使用</title>
    <url>/2015/05/05/android-2015-05-05-nestedscrollview-recyclerview/</url>
    <content><![CDATA[<p>NestedScrollView和RecyclerView使用，并设置间距:</p>
<span id="more"></span>

<p>效果图如下：<br><img src="http://oaurstf0m.bkt.clouddn.com/DEREEE360.gif" alt="这里写图片描述"><br>1.NestedScrollView 和RecyclerView嵌套问题（类似ScrollView 和listView）<br>需重写 RecyclerView  的  GridLayoutManager(还有另外2种，随便搜下就有)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FullyGridLayoutManager extends GridLayoutManager &#123;</span><br><span class="line">    public FullyGridLayoutManager(Context context, int spanCount) &#123;</span><br><span class="line">        super(context, spanCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public FullyGridLayoutManager(Context context, int spanCount, int orientation, boolean reverseLayout) &#123;</span><br><span class="line">        super(context, spanCount, orientation, reverseLayout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int[] mMeasuredDimension &#x3D; new int[2];</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMeasure(RecyclerView.Recycler recycler, RecyclerView.State state, int widthSpec, int heightSpec) &#123;</span><br><span class="line">        final int widthMode &#x3D; View.MeasureSpec.getMode(widthSpec);</span><br><span class="line">        final int heightMode &#x3D; View.MeasureSpec.getMode(heightSpec);</span><br><span class="line">        final int widthSize &#x3D; View.MeasureSpec.getSize(widthSpec);</span><br><span class="line">        final int heightSize &#x3D; View.MeasureSpec.getSize(heightSpec);</span><br><span class="line"></span><br><span class="line">        int width &#x3D; 0;</span><br><span class="line">        int height &#x3D; 0;</span><br><span class="line">        int count &#x3D; getItemCount();</span><br><span class="line">        int span &#x3D; getSpanCount();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            measureScrapChild(recycler, i,</span><br><span class="line">                    View.MeasureSpec.makeMeasureSpec(i, View.MeasureSpec.UNSPECIFIED),</span><br><span class="line">                    View.MeasureSpec.makeMeasureSpec(i, View.MeasureSpec.UNSPECIFIED),</span><br><span class="line">                    mMeasuredDimension);</span><br><span class="line"></span><br><span class="line">            if (getOrientation() &#x3D;&#x3D; HORIZONTAL) &#123;</span><br><span class="line">                if (i % span &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    width &#x3D; width + mMeasuredDimension[0];</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    height &#x3D; mMeasuredDimension[1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (i % span &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    height &#x3D; height + mMeasuredDimension[1];</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    width &#x3D; mMeasuredDimension[0];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (widthMode) &#123;</span><br><span class="line">            case View.MeasureSpec.EXACTLY:</span><br><span class="line">                width &#x3D; widthSize;</span><br><span class="line">            case View.MeasureSpec.AT_MOST:</span><br><span class="line">            case View.MeasureSpec.UNSPECIFIED:</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (heightMode) &#123;</span><br><span class="line">            case View.MeasureSpec.EXACTLY:</span><br><span class="line">                height &#x3D; heightSize;</span><br><span class="line">            case View.MeasureSpec.AT_MOST:</span><br><span class="line">            case View.MeasureSpec.UNSPECIFIED:</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void measureScrapChild(RecyclerView.Recycler recycler, int position, int widthSpec,</span><br><span class="line">                                   int heightSpec, int[] measuredDimension) &#123;</span><br><span class="line">        if (position &lt; getItemCount()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                View view &#x3D; recycler.getViewForPosition(0);&#x2F;&#x2F;fix 动态添加时报IndexOutOfBoundsException</span><br><span class="line">                if (view !&#x3D; null) &#123;</span><br><span class="line">                    RecyclerView.LayoutParams p &#x3D; (RecyclerView.LayoutParams) view.getLayoutParams();</span><br><span class="line">                    int childWidthSpec &#x3D; ViewGroup.getChildMeasureSpec(widthSpec,</span><br><span class="line">                            getPaddingLeft() + getPaddingRight(), p.width);</span><br><span class="line">                    int childHeightSpec &#x3D; ViewGroup.getChildMeasureSpec(heightSpec,</span><br><span class="line">                            getPaddingTop() + getPaddingBottom(), p.height);</span><br><span class="line">                    view.measure(childWidthSpec, childHeightSpec);</span><br><span class="line">                    measuredDimension[0] &#x3D; view.getMeasuredWidth() + p.leftMargin + p.rightMargin;</span><br><span class="line">                    measuredDimension[1] &#x3D; view.getMeasuredHeight() + p.bottomMargin + p.topMargin;</span><br><span class="line">                    recycler.recycleView(view);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写NestedScrollView,实际上是NestedScrollView禁止滑动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyNestedScrollView extends NestedScrollView &#123;</span><br><span class="line">    private int downX;</span><br><span class="line">    private int downY;</span><br><span class="line">    private int mTouchSlop;</span><br><span class="line"></span><br><span class="line">    public MyNestedScrollView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        mTouchSlop &#x3D; ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyNestedScrollView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        mTouchSlop &#x3D; ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyNestedScrollView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        mTouchSlop &#x3D; ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent e) &#123;</span><br><span class="line">        int action &#x3D; e.getAction();</span><br><span class="line">        switch (action) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                downX &#x3D; (int) e.getRawX();</span><br><span class="line">                downY &#x3D; (int) e.getRawY();</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                int moveY &#x3D; (int) e.getRawY();</span><br><span class="line">                if (Math.abs(moveY - downY) &gt; mTouchSlop) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onInterceptTouchEvent(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让recyclerView滑动</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">recyclerView.setNestedScrollingEnabled(<span class="keyword">false</span>);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> 给recyclerView创建Adapter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class DemoAdapter extends RecyclerView.Adapter&lt;DemoViewHolder&gt; &#123;</span><br><span class="line">    private ArrayList&lt;String&gt; list;</span><br><span class="line">    public Context mContext;</span><br><span class="line"></span><br><span class="line">    public DemoAdapter(Context mContext) &#123;</span><br><span class="line">        this.mContext&#x3D;mContext;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public DemoViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">        View mView &#x3D; LayoutInflater.from(mContext).inflate(R.layout.item_viewholder, parent, false);</span><br><span class="line">        DemoViewHolder mViewHolder &#x3D; new DemoViewHolder(mView);</span><br><span class="line">        return mViewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onBindViewHolder(DemoViewHolder holder, int position) &#123;</span><br><span class="line">        Glide.with(mContext).load(&quot;http:&#x2F;&#x2F;img.nongshanghang.cn&#x2F;allimg&#x2F;160906&#x2F;22435210b_1.jpg&quot;).into(  holder.imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getItemCount() &#123;</span><br><span class="line">        return 9;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> Viewholder 部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class DemoViewHolder extends RecyclerView.ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">    public DemoViewHolder(View itemView) &#123;</span><br><span class="line">        super(itemView);</span><br><span class="line">        imageView&#x3D;(ImageView)itemView.findViewById(R.id.imageview);</span><br><span class="line">    &#125;</span><br><span class="line">    public ImageView imageView;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> 设置RecyclerView 的item间距</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class SpacesItemDecoration extends RecyclerView.ItemDecoration  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int left;</span><br><span class="line">    private int right;</span><br><span class="line">    private int top;</span><br><span class="line">    private int bottom;</span><br><span class="line">    public SpacesItemDecoration(int space) &#123;</span><br><span class="line">        this.left&#x3D;space;</span><br><span class="line">        this.right&#x3D;space;</span><br><span class="line">        this.top&#x3D;space;</span><br><span class="line">        this.bottom&#x3D;space;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SpacesItemDecoration(int left,int right,int top,int bottom) &#123;</span><br><span class="line">        this.left&#x3D;left;</span><br><span class="line">        this.right&#x3D;right;</span><br><span class="line">        this.top&#x3D;top;</span><br><span class="line">        this.bottom&#x3D;bottom;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">        outRect.left&#x3D;left;</span><br><span class="line">        outRect.right&#x3D;right;</span><br><span class="line">        outRect.bottom&#x3D;bottom;</span><br><span class="line">        outRect.top&#x3D;top;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> 最后设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">recyclerView&#x3D;(RecyclerView)findViewById(R.id.recyclerview);</span><br><span class="line">     recyclerView.setNestedScrollingEnabled(false);</span><br><span class="line">     layoutManager&#x3D;new FullyGridLayoutManager(this,3,GridLayoutManager.VERTICAL,false);</span><br><span class="line">     adpater&#x3D;new DemoAdapter(this);</span><br><span class="line">     recyclerView.setAdapter(adpater);</span><br><span class="line">     recyclerView.setLayoutManager(layoutManager);</span><br><span class="line">     SpacesItemDecoration decoration;</span><br><span class="line">     &#x2F;&#x2F;  if (Integer.parseInt(android.os.Build.VERSION.SDK) &gt;&#x3D; 19) &#123;</span><br><span class="line">     &#x2F;&#x2F;     decoration &#x3D; new SpacesItemDecoration(ScreenUtils.dipToPx(getActivity(), 4), ScreenUtils.dipToPx(getActivity(), 4), ScreenUtils.dipToPx(getActivity(), 0), ScreenUtils.dipToPx(getActivity(), 8));</span><br><span class="line">     &#x2F;&#x2F;   &#125;else&#123;</span><br><span class="line">     decoration &#x3D; new SpacesItemDecoration(4, 4, 4,4);</span><br><span class="line">     &#x2F;&#x2F;  &#125;</span><br><span class="line">     recyclerView.addItemDecoration(decoration);</span><br><span class="line">     adpater.notifyDataSetChanged();</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>  代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9624181">源码下载</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">csdn博客</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-eureka-resources/</url>
    <content><![CDATA[<p>本篇文章以源码的角度来深入理解Eureka.</p>
<span id="more"></span>

<h2 id="Eureka的一些概念"><a href="#Eureka的一些概念" class="headerlink" title="Eureka的一些概念"></a>Eureka的一些概念</h2><ul>
<li><p>Register：服务注册<br>当Eureka客户端向Eureka Server注册时，它提供自身的元数据，比如IP地址、端口，运行状况指示符URL，主页等。</p>
</li>
<li><p>Renew：服务续约<br>Eureka客户会每隔30秒发送一次心跳来续约。 通过续约来告知Eureka Server该Eureka客户仍然存在，没有出现问题。 正常情况下，如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。 建议不要更改续约间隔.</p>
</li>
<li><p>Fetch Registries：获取注册列表信息<br>Eureka客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与Eureka客户端的缓存信息不同， Eureka客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka客户端则会重新获取整个注册表信息。 Eureka服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。Eureka客户端和Eureka 服务器可以使用JSON / XML格式进行通讯。在默认的情况下Eureka客户端使用压缩JSON格式来获取注册列表的信息。</p>
</li>
<li><p>Cancel：服务下线<br>Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：<br>DiscoveryManager.getInstance().shutdownComponent()；</p>
</li>
<li><p>Eviction 服务剔除<br>在默认的情况下，当Eureka客户端连续90秒没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除，即服务剔除。</p>
</li>
</ul>
<h2 id="Eureka的高可用架构"><a href="#Eureka的高可用架构" class="headerlink" title="Eureka的高可用架构"></a>Eureka的高可用架构</h2><p>如图为Eureka的高级架构图，该图片来自于Eureka开源代码的文档，地址为<a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a> 。</p>
<p><img src="https://github.com/Netflix/eureka/raw/master/images/eureka_architecture.png" alt="Eureka的高级架构图"></p>
<p> 从图可以看出在这个体系中，有2个角色，即Eureka Server和Eureka Client。而Eureka Client又分为Applicaton Service和Application Client，即服务提供者何服务消费者。 每个区域有一个Eureka集群，并且每个区域至少有一个eureka服务器可以处理区域故障，以防服务器瘫痪。</p>
<p>Eureka Client向Eureka Serve注册，并将自己的一些客户端信息发送Eureka Serve。然后，Eureka Client通过向Eureka Serve发送心跳（每30秒）来续约服务的。 如果客户端持续不能续约，那么，它将在大约90秒内从服务器注册表中删除。 注册信息和续订被复制到集群中的Eureka Serve所有节点。 来自任何区域的Eureka Client都可以查找注册表信息（每30秒发生一次）。根据这些注册表信息，Application Client可以远程调用Applicaton Service来消费服务。</p>
<h2 id="Register服务注册"><a href="#Register服务注册" class="headerlink" title="Register服务注册"></a>Register服务注册</h2><p>服务注册，即Eureka Client向Eureka Server提交自己的服务信息，包括IP地址、端口、service ID等信息。如果Eureka Client没有写service ID，则默认为 ${spring.application.name}。</p>
<p>服务注册其实很简单，在Eureka Client启动的时候，将自身的服务的信息发送到Eureka Server。现在来简单的阅读下源码。在Maven的依赖包下，找到eureka-client-1.6.2.jar包。在com.netflix.discovery包下有个DiscoveryClient类，该类包含了Eureka Client向Eureka Server的相关方法。其中DiscoveryClient实现了EurekaClient接口，并且它是一个单例模式，而EurekaClient继承了LookupService接口。它们之间的关系如图所示。</p>
<p><img src="http://img.blog.csdn.net/20170611110916402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在DiscoveryClient类有一个服务注册的方法register()，该方法是通过Http请求向Eureka Client注册。其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean register() throws Throwable &#123;</span><br><span class="line">        logger.info(PREFIX + appPathIdentifier + &quot;: registering service...&quot;);</span><br><span class="line">        EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">        try &#123;</span><br><span class="line">            httpResponse &#x3D; eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.warn(&quot;&#123;&#125; - registration failed &#123;&#125;&quot;, PREFIX + appPathIdentifier, e.getMessage(), e);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(&quot;&#123;&#125; - registration status: &#123;&#125;&quot;, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">        &#125;</span><br><span class="line">        return httpResponse.getStatusCode() &#x3D;&#x3D; 204;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在DiscoveryClient类继续追踪register()方法，它被InstanceInfoReplicator 类的run()方法调用，其中InstanceInfoReplicator实现了Runnable接口，run()方法代码如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           discoveryClient.refreshInstanceInfo();</span><br><span class="line"></span><br><span class="line">           Long dirtyTimestamp &#x3D; instanceInfo.isDirtyWithTime();</span><br><span class="line">           if (dirtyTimestamp !&#x3D; null) &#123;</span><br><span class="line">               discoveryClient.register();</span><br><span class="line">               instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Throwable t) &#123;</span><br><span class="line">           logger.warn(&quot;There was a problem with the instance info replicator&quot;, t);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Future next &#x3D; scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">           scheduledPeriodicRef.set(next);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而InstanceInfoReplicator类是在DiscoveryClient初始化过程中使用的，其中有一个initScheduledTasks()方法。该方法主要开启了获取服务注册列表的信息，如果需要向Eureka Server注册，则开启注册，同时开启了定时向Eureka Server服务续约的定时任务，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void initScheduledTasks() &#123;</span><br><span class="line">       ...&#x2F;&#x2F;省略了任务调度获取注册列表的代码</span><br><span class="line">        if (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line">         ... </span><br><span class="line">            &#x2F;&#x2F; Heartbeat timer</span><br><span class="line">            scheduler.schedule(</span><br><span class="line">                    new TimedSupervisorTask(</span><br><span class="line">                            &quot;heartbeat&quot;,</span><br><span class="line">                            scheduler,</span><br><span class="line">                            heartbeatExecutor,</span><br><span class="line">                            renewalIntervalInSecs,</span><br><span class="line">                            TimeUnit.SECONDS,</span><br><span class="line">                            expBackOffBound,</span><br><span class="line">                            new HeartbeatThread()</span><br><span class="line">                    ),</span><br><span class="line">                    renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; InstanceInfo replicator</span><br><span class="line">            instanceInfoReplicator &#x3D; new InstanceInfoReplicator(</span><br><span class="line">                    this,</span><br><span class="line">                    instanceInfo,</span><br><span class="line">                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),</span><br><span class="line">                    2); &#x2F;&#x2F; burstSize</span><br><span class="line"></span><br><span class="line">            statusChangeListener &#x3D; new ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getId() &#123;</span><br><span class="line">                    return &quot;statusChangeListener&quot;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void notify(StatusChangeEvent statusChangeEvent) &#123;</span><br><span class="line">                 </span><br><span class="line">                    instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在来看Eureka server端的代码，在Maven的eureka-core:1.6.2的jar包下。打开com.netflix.eureka包，很轻松的就发现了又一个EurekaBootStrap的类，BootStrapContext具有最先初始化的权限，所以先看这个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void initEurekaServerContext() throws Exception &#123;</span><br><span class="line"> </span><br><span class="line"> ...&#x2F;&#x2F;省略代码</span><br><span class="line">   PeerAwareInstanceRegistry registry;</span><br><span class="line">        if (isAws(applicationInfoManager.getInfo())) &#123;</span><br><span class="line">           ...&#x2F;&#x2F;省略代码，如果是AWS的代码</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            registry &#x3D; new PeerAwareInstanceRegistryImpl(</span><br><span class="line">                    eurekaServerConfig,</span><br><span class="line">                    eurekaClient.getEurekaClientConfig(),</span><br><span class="line">                    serverCodecs,</span><br><span class="line">                    eurekaClient</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PeerEurekaNodes peerEurekaNodes &#x3D; getPeerEurekaNodes(</span><br><span class="line">                registry,</span><br><span class="line">                eurekaServerConfig,</span><br><span class="line">                eurekaClient.getEurekaClientConfig(),</span><br><span class="line">                serverCodecs,</span><br><span class="line">                applicationInfoManager</span><br><span class="line">        );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其中PeerAwareInstanceRegistryImpl和PeerEurekaNodes两个类看其命名，应该和服务注册以及Eureka Server高可用有关。先追踪PeerAwareInstanceRegistryImpl类，在该类有个register()方法，该方法提供了注册，并且将注册后信息同步到其他的Eureka Server服务。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void register(final InstanceInfo info, final boolean isReplication) &#123;</span><br><span class="line">        int leaseDuration &#x3D; Lease.DEFAULT_DURATION_IN_SECS;</span><br><span class="line">        if (info.getLeaseInfo() !&#x3D; null &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; 0) &#123;</span><br><span class="line">            leaseDuration &#x3D; info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">        &#125;</span><br><span class="line">        super.register(info, leaseDuration, isReplication);</span><br><span class="line">        replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中 super.register(info, leaseDuration, isReplication)方法，点击进去到子类AbstractInstanceRegistry可以发现更多细节，其中注册列表的信息被保存在一个Map中。replicateToPeers()方法，即同步到其他Eureka Server的其他Peers节点，追踪代码，发现它会遍历循环向所有的Peers节点注册，最终执行类PeerEurekaNodes的register()方法，该方法通过执行一个任务向其他节点同步该注册信息，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void register(final InstanceInfo info) throws Exception &#123;</span><br><span class="line">      long expiryTime &#x3D; System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">      batchingDispatcher.process(</span><br><span class="line">              taskId(&quot;register&quot;, info),</span><br><span class="line">              new InstanceReplicationTask(targetHost, Action.Register, info, null, true) &#123;</span><br><span class="line">                  public EurekaHttpResponse&lt;Void&gt; execute() &#123;</span><br><span class="line">                      return replicationClient.register(info);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              expiryTime</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过一系列的源码追踪，可以发现PeerAwareInstanceRegistryImpl的register()方法实现了服务的注册，并且向其他Eureka Server的Peer节点同步了该注册信息，那么register()方法被谁调用了呢？之前在Eureka Client的分析可以知道，Eureka Client是通过 http来向Eureka Server注册的，那么Eureka Server肯定会提供一个注册的接口给Eureka Client调用，那么PeerAwareInstanceRegistryImpl的register()方法肯定最终会被暴露的Http接口所调用。在Idea开发工具，按住alt+鼠标左键，可以很快定位到ApplicationResource类的addInstance ()方法，即服务注册的接口，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@POST</span><br><span class="line">    @Consumes(&#123;&quot;application&#x2F;json&quot;, &quot;application&#x2F;xml&quot;&#125;)</span><br><span class="line">    public Response addInstance(InstanceInfo info,</span><br><span class="line">                                @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) &#123;</span><br><span class="line">       </span><br><span class="line">    ...&#x2F;&#x2F;省略代码                 </span><br><span class="line">               registry.register(info, &quot;true&quot;.equals(isReplication));</span><br><span class="line">        return Response.status(204).build();  &#x2F;&#x2F; 204 to be backwards compatible</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Renew服务续约"><a href="#Renew服务续约" class="headerlink" title="Renew服务续约"></a>Renew服务续约</h2><p>服务续约和服务注册非常类似，通过之前的分析可以知道，服务注册在Eureka Client程序启动之后开启，并同时开启服务续约的定时任务。在eureka-client-1.6.2.jar的DiscoveryClient的类下有renew()方法，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * Renew with the eureka service by making the appropriate REST call</span><br><span class="line">   *&#x2F;</span><br><span class="line">  boolean renew() &#123;</span><br><span class="line">      EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">      try &#123;</span><br><span class="line">          httpResponse &#x3D; eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);</span><br><span class="line">          logger.debug(&quot;&#123;&#125; - Heartbeat status: &#123;&#125;&quot;, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">          if (httpResponse.getStatusCode() &#x3D;&#x3D; 404) &#123;</span><br><span class="line">              REREGISTER_COUNTER.increment();</span><br><span class="line">              logger.info(&quot;&#123;&#125; - Re-registering apps&#x2F;&#123;&#125;&quot;, PREFIX + appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">              return register();</span><br><span class="line">          &#125;</span><br><span class="line">          return httpResponse.getStatusCode() &#x3D;&#x3D; 200;</span><br><span class="line">      &#125; catch (Throwable e) &#123;</span><br><span class="line">          logger.error(&quot;&#123;&#125; - was unable to send heartbeat!&quot;, PREFIX + appPathIdentifier, e);</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外服务端的续约接口在eureka-core:1.6.2.jar的 com.netflix.eureka包下的InstanceResource类下，接口方法为renewLease()，它是REST接口。为了减少类篇幅，省略了大部分代码的展示。其中有个registry.renew()方法，即服务续约，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PUT</span><br><span class="line">public Response renewLease(...参数省略）&#123;</span><br><span class="line">     ...  代码省略</span><br><span class="line">    boolean isSuccess&#x3D;registry.renew(app.getName(),id, isFromReplicaNode);</span><br><span class="line">       ...  代码省略</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读者可以跟踪registry.renew的代码一直深入研究。在这里就不再多讲述。另外服务续约有2个参数是可以配置，即Eureka Client发送续约心跳的时间参数和Eureka Server在多长时间内没有收到心跳将实例剔除的时间参数，在默认的情况下这两个参数分别为30秒和90秒，官方给的建议是不要修改，如果有特殊要求还是可以调整的，只需要分别在Eureka Client和Eureka Server修改以下参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka.instance.leaseRenewalIntervalInSeconds</span><br><span class="line">eureka.instance.leaseExpirationDurationInSeconds</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，服务注册列表的获取、服务下线和服务剔除就不在这里进行源码跟踪解读，因为和服务注册和续约类似，有兴趣的朋友可以自己看下源码，深入理解。总的来说，通过读源码，可以发现，整体架构与前面小节的eureka 的高可用架构图完全一致。</p>
<h2 id="Eureka-Client注册一个实例为什么这么慢"><a href="#Eureka-Client注册一个实例为什么这么慢" class="headerlink" title="Eureka Client注册一个实例为什么这么慢"></a>Eureka Client注册一个实例为什么这么慢</h2><ul>
<li>   Eureka Client一启动（不是启动完成），不是立即向Eureka Server注册，它有一个延迟向服务端注册的时间，通过跟踪源码，可以发现默认的延迟时间为40秒，源码在eureka-client-1.6.2.jar的DefaultEurekaClientConfig类下，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int getInitialInstanceInfoReplicationIntervalSeconds() &#123;</span><br><span class="line">    return configInstance.getIntProperty(</span><br><span class="line">        namespace + INITIAL_REGISTRATION_REPLICATION_DELAY_KEY, 40).get();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>   Eureka Server的响应缓存<br>Eureka Server维护每30秒更新的响应缓存,可通过更改配置eureka.server.responseCacheUpdateIntervalMs来修改。 所以即使实例刚刚注册，它也不会出现在调用/ eureka / apps REST端点的结果中。 </p>
</li>
<li><p> Eureka Server刷新缓存<br>  Eureka客户端保留注册表信息的缓存。 该缓存每30秒更新一次（如前所述）。 因 此，客户端决定刷新其本地缓存并发现其他新注册的实例可能需要30秒。</p>
</li>
<li><p>   LoadBalancer Refresh<br>Ribbon的负载平衡器从本地的Eureka Client获取服务注册列表信息。Ribbon本身还维护本地缓存，以避免为每个请求调用本地客户端。 此缓存每30秒刷新一次（可由ribbon.ServerListRefreshInterval配置）。 所以，可能需要30多秒才能使用新注册的实例。</p>
</li>
</ul>
<p>综上几个因素，一个新注册的实例，特别是启动较快的实例（默认延迟40秒注册），不能马上被Eureka Server发现。另外，刚注册的Eureka Client也不能立即被其他服务调用，因为调用方因为各种缓存没有及时的获取到新的注册列表。</p>
<h2 id="Eureka-的自我保护模式"><a href="#Eureka-的自我保护模式" class="headerlink" title="Eureka 的自我保护模式"></a>Eureka 的自我保护模式</h2><p>当一个新的Eureka Server出现时，它尝试从相邻节点获取所有实例注册表信息。如果从Peer节点获取信息时出现问题，Eureka Serve会尝试其他的Peer节点。如果服务器能够成功获取所有实例，则根据该信息设置应该接收的更新阈值。如果有任何时间，Eureka Serve接收到的续约低于为该值配置的百分比（默认为15分钟内低于85％），则服务器开启自我保护模式，即不再剔除注册列表的信息。</p>
<p>这样做的好处就是，如果是Eureka Server自身的网络问题，导致Eureka Client的续约不上，Eureka Client的注册列表信息不再被删除，也就是Eureka Client还可以被其他服务消费。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://cloud.spring.io/spring-cloud-static/Dalston.RELEASE/#netflix-eureka-client-starter">http://cloud.spring.io/spring-cloud-static/Dalston.RELEASE/#netflix-eureka-client-starter</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki">https://github.com/Netflix/eureka/wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication">https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication</a></p>
<p><a target="_blank" rel="noopener" href="http://xujin.org/sc/sc-eureka-register/">http://xujin.org/sc/sc-eureka-register/</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.abhijitsarkar.org/technical/netflix-eureka/">http://blog.abhijitsarkar.org/technical/netflix-eureka/</a></p>
<p><a target="_blank" rel="noopener" href="http://nobodyiam.com/2016/06/25/dive-into-eureka/">http://nobodyiam.com/2016/06/25/dive-into-eureka/</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-springcloud-feign-resources/</url>
    <content><![CDATA[<h2 id="什么是Feign"><a href="#什么是Feign" class="headerlink" title="什么是Feign"></a>什么是Feign</h2><p>Feign是由Retrofit，JAXRS-2.0和WebSocket启发的一个java到http客户端绑定。 Feign的主要目标是将Java Http Clients变得简单。Feign的源码地址：<a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<span id="more"></span>

<h2 id="写一个Feign"><a href="#写一个Feign" class="headerlink" title="写一个Feign"></a>写一个Feign</h2><p>在我之前的博文有写到如何用Feign去消费服务，文章地址：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69808079">http://blog.csdn.net/forezp/article/details/69808079</a>  。</p>
<p>简单的实现一个Feign客户端，首先通过@FeignClient，客户端，其中value为调用其他服务的名称，FeignConfig.class为FeignClient的配置文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@FeignClient(value &#x3D; &quot;service-hi&quot;,configuration &#x3D; FeignConfig.class)</span><br><span class="line">public interface SchedualServiceHi &#123;</span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;hi&quot;)</span><br><span class="line">    String sayHiFromClientOne(@RequestParam(value &#x3D; &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Retryer feignRetryer() &#123;</span><br><span class="line">        return new Retryer.Default(100, SECONDS.toMillis(1), 5);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看FeignClient的源码，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface FeignClient &#123;</span><br><span class="line"></span><br><span class="line">@AliasFor(&quot;name&quot;)</span><br><span class="line">String value() default &quot;&quot;;</span><br><span class="line">	</span><br><span class="line">@AliasFor(&quot;value&quot;)</span><br><span class="line">String name() default &quot;&quot;;</span><br><span class="line">	</span><br><span class="line">@AliasFor(&quot;value&quot;)</span><br><span class="line">String name() default &quot;&quot;;</span><br><span class="line">String url() default &quot;&quot;;</span><br><span class="line">boolean decode404() default false;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] configuration() default &#123;&#125;;</span><br><span class="line">Class&lt;?&gt; fallback() default void.class;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; fallbackFactory() default void.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String path() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">boolean primary() default true;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>feign 用于声明具有该接口的REST客户端的接口的注释应该是创建（例如用于自动连接到另一个组件。 如果功能区可用，那将是<br>用于负载平衡后端请求，并且可以配置负载平衡器<br>使用与伪装客户端相同名称（即值）@RibbonClient 。</p>
<p>其中value()和name()一样，是被调用的 service的名称。<br>url(),直接填写硬编码的url,decode404()即404是否被解码，还是抛异常；configuration()，标明FeignClient的配置类，默认的配置类为FeignClientsConfiguration类，可以覆盖Decoder、Encoder和Contract等信息，进行自定义配置。fallback(),填写熔断器的信息类。</p>
<h2 id="FeignClient的配置"><a href="#FeignClient的配置" class="headerlink" title="FeignClient的配置"></a>FeignClient的配置</h2><p>默认的配置类为FeignClientsConfiguration，这个类在spring-cloud-netflix-core的jar包下，打开这个类，可以发现它是一个配置类，注入了很多的相关配置的bean，包括feignRetryer、FeignLoggerFactory、FormattingConversionService等,其中还包括了Decoder、Encoder、Contract，如果这三个bean在没有注入的情况下，会自动注入默认的配置。</p>
<ul>
<li>Decoder feignDecoder: ResponseEntityDecoder(这是对SpringDecoder的封装)</li>
<li>Encoder feignEncoder: SpringEncoder</li>
<li>Logger feignLogger: Slf4jLogger</li>
<li>Contract feignContract: SpringMvcContract</li>
<li>Feign.Builder feignBuilder: HystrixFeign.Builder</li>
</ul>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignClientsConfiguration &#123;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Decoder feignDecoder() &#123;</span><br><span class="line">		return new ResponseEntityDecoder(new SpringDecoder(this.messageConverters));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Encoder feignEncoder() &#123;</span><br><span class="line">		return new SpringEncoder(this.messageConverters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Contract feignContract(ConversionService feignConversionService) &#123;</span><br><span class="line">		return new SpringMvcContract(this.parameterProcessors, feignConversionService);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重写配置：</p>
<p>你可以重写FeignClientsConfiguration中的bean，从而达到自定义配置的目的，比如FeignClientsConfiguration的默认重试次数为Retryer.NEVER_RETRY，即不重试，那么希望做到重写，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Retryer feignRetryer() &#123;</span><br><span class="line">        return new Retryer.Default(100, SECONDS.toMillis(1), 5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述代码更改了该FeignClient的重试次数，重试间隔为100ms，最大重试时间为1s,重试次数为5次。</p>
<h2 id="Feign的工作原理"><a href="#Feign的工作原理" class="headerlink" title="Feign的工作原理"></a>Feign的工作原理</h2><p>feign是一个伪客户端，即它不做任何的请求处理。Feign通过处理注解生成request，从而实现简化HTTP API开发的目的，即开发人员可以使用注解的方式定制request api模板，在发送http request请求之前，feign通过处理注解的方式替换掉request模板中的参数，这种实现方式显得更为直接、可理解。</p>
<p>通过包扫描注入FeignClient的bean，该源码在FeignClientsRegistrar类：<br>首先在启动配置上检查是否有@EnableFeignClients注解，如果有该注解，则开启包扫描，扫描被@FeignClient注解接口。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void registerDefaultConfiguration(AnnotationMetadata metadata,</span><br><span class="line">			BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; defaultAttrs &#x3D; metadata</span><br><span class="line">				.getAnnotationAttributes(EnableFeignClients.class.getName(), true);</span><br><span class="line"></span><br><span class="line">		if (defaultAttrs !&#x3D; null &amp;&amp; defaultAttrs.containsKey(&quot;defaultConfiguration&quot;)) &#123;</span><br><span class="line">			String name;</span><br><span class="line">			if (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">				name &#x3D; &quot;default.&quot; + metadata.getEnclosingClassName();</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				name &#x3D; &quot;default.&quot; + metadata.getClassName();</span><br><span class="line">			&#125;</span><br><span class="line">			registerClientConfiguration(registry, name,</span><br><span class="line">					defaultAttrs.get(&quot;defaultConfiguration&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>扫描到FeignClient后，将信息取出，以bean的形式注入到ioc容器中，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void registerFeignClients(AnnotationMetadata metadata,</span><br><span class="line">			BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		ClassPathScanningCandidateComponentProvider scanner &#x3D; getScanner();</span><br><span class="line">		scanner.setResourceLoader(this.resourceLoader);</span><br><span class="line"></span><br><span class="line">		Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; attrs &#x3D; metadata</span><br><span class="line">				.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">		AnnotationTypeFilter annotationTypeFilter &#x3D; new AnnotationTypeFilter(</span><br><span class="line">				FeignClient.class);</span><br><span class="line">		final Class&lt;?&gt;[] clients &#x3D; attrs &#x3D;&#x3D; null ? null</span><br><span class="line">				: (Class&lt;?&gt;[]) attrs.get(&quot;clients&quot;);</span><br><span class="line">		if (clients &#x3D;&#x3D; null || clients.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">			basePackages &#x3D; getBasePackages(metadata);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			final Set&lt;String&gt; clientClasses &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">			basePackages &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">			for (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">				basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">				clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">			&#125;</span><br><span class="line">			AbstractClassTestingTypeFilter filter &#x3D; new AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				protected boolean match(ClassMetadata metadata) &#123;</span><br><span class="line">					String cleaned &#x3D; metadata.getClassName().replaceAll(&quot;\\$&quot;, &quot;.&quot;);</span><br><span class="line">					return clientClasses.contains(cleaned);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			scanner.addIncludeFilter(</span><br><span class="line">					new AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (String basePackage : basePackages) &#123;</span><br><span class="line">			Set&lt;BeanDefinition&gt; candidateComponents &#x3D; scanner</span><br><span class="line">					.findCandidateComponents(basePackage);</span><br><span class="line">			for (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">				if (candidateComponent instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">					&#x2F;&#x2F; verify annotated class is an interface</span><br><span class="line">					AnnotatedBeanDefinition beanDefinition &#x3D; (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">					AnnotationMetadata annotationMetadata &#x3D; beanDefinition.getMetadata();</span><br><span class="line">					Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">							&quot;@FeignClient can only be specified on an interface&quot;);</span><br><span class="line"></span><br><span class="line">					Map&lt;String, Object&gt; attributes &#x3D; annotationMetadata</span><br><span class="line">							.getAnnotationAttributes(</span><br><span class="line">									FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">					String name &#x3D; getClientName(attributes);</span><br><span class="line">					registerClientConfiguration(registry, name,</span><br><span class="line">							attributes.get(&quot;configuration&quot;));</span><br><span class="line"></span><br><span class="line">					registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void registerFeignClient(BeanDefinitionRegistry registry,</span><br><span class="line">			AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) &#123;</span><br><span class="line">		String className &#x3D; annotationMetadata.getClassName();</span><br><span class="line">		BeanDefinitionBuilder definition &#x3D; BeanDefinitionBuilder</span><br><span class="line">				.genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">		validate(attributes);</span><br><span class="line">		definition.addPropertyValue(&quot;url&quot;, getUrl(attributes));</span><br><span class="line">		definition.addPropertyValue(&quot;path&quot;, getPath(attributes));</span><br><span class="line">		String name &#x3D; getName(attributes);</span><br><span class="line">		definition.addPropertyValue(&quot;name&quot;, name);</span><br><span class="line">		definition.addPropertyValue(&quot;type&quot;, className);</span><br><span class="line">		definition.addPropertyValue(&quot;decode404&quot;, attributes.get(&quot;decode404&quot;));</span><br><span class="line">		definition.addPropertyValue(&quot;fallback&quot;, attributes.get(&quot;fallback&quot;));</span><br><span class="line">		definition.addPropertyValue(&quot;fallbackFactory&quot;, attributes.get(&quot;fallbackFactory&quot;));</span><br><span class="line">		definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">		String alias &#x3D; name + &quot;FeignClient&quot;;</span><br><span class="line">		AbstractBeanDefinition beanDefinition &#x3D; definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">		boolean primary &#x3D; (Boolean)attributes.get(&quot;primary&quot;); &#x2F;&#x2F; has a default, won&#39;t be null</span><br><span class="line"></span><br><span class="line">		beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">		String qualifier &#x3D; getQualifier(attributes);</span><br><span class="line">		if (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">			alias &#x3D; qualifier;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BeanDefinitionHolder holder &#x3D; new BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">				new String[] &#123; alias &#125;);</span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注入bean之后，通过jdk的代理，当请求Feign Client的方法时会被拦截，代码在ReflectiveFeign类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T newInstance(Target&lt;T&gt; target) &#123;</span><br><span class="line">   Map&lt;String, MethodHandler&gt; nameToHandler &#x3D; targetToHandlersByName.apply(target);</span><br><span class="line">   Map&lt;Method, MethodHandler&gt; methodToHandler &#x3D; new LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">   List&lt;DefaultMethodHandler&gt; defaultMethodHandlers &#x3D; new LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line"></span><br><span class="line">   for (Method method : target.type().getMethods()) &#123;</span><br><span class="line">     if (method.getDeclaringClass() &#x3D;&#x3D; Object.class) &#123;</span><br><span class="line">       continue;</span><br><span class="line">     &#125; else if(Util.isDefault(method)) &#123;</span><br><span class="line">       DefaultMethodHandler handler &#x3D; new DefaultMethodHandler(method);</span><br><span class="line">       defaultMethodHandlers.add(handler);</span><br><span class="line">       methodToHandler.put(method, handler);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   InvocationHandler handler &#x3D; factory.create(target, methodToHandler);</span><br><span class="line">   T proxy &#x3D; (T) Proxy.newProxyInstance(target.type().getClassLoader(), new Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">   for(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">     defaultMethodHandler.bindTo(proxy);</span><br><span class="line">   &#125;</span><br><span class="line">   return proxy;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在SynchronousMethodHandler类进行拦截处理，当被拦截会根据参数生成RequestTemplate对象，该对象就是http请求的模板，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public Object invoke(Object[] argv) throws Throwable &#123;</span><br><span class="line">   RequestTemplate template &#x3D; buildTemplateFromArgs.create(argv);</span><br><span class="line">   Retryer retryer &#x3D; this.retryer.clone();</span><br><span class="line">   while (true) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       return executeAndDecode(template);</span><br><span class="line">     &#125; catch (RetryableException e) &#123;</span><br><span class="line">       retryer.continueOrPropagate(e);</span><br><span class="line">       if (logLevel !&#x3D; Logger.Level.NONE) &#123;</span><br><span class="line">         logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">       &#125;</span><br><span class="line">       continue;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中有个executeAndDecode()方法，该方法是通RequestTemplate生成Request请求对象，然后根据用client获取response。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Object executeAndDecode(RequestTemplate template) throws Throwable &#123;</span><br><span class="line">    Request request &#x3D; targetRequest(template);</span><br><span class="line">    ...&#x2F;&#x2F;省略代码</span><br><span class="line">    response &#x3D; client.execute(request, options);</span><br><span class="line">    ...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Client组件"><a href="#Client组件" class="headerlink" title="Client组件"></a>Client组件</h2><p>其中Client组件是一个非常重要的组件，Feign最终发送request请求以及接收response响应，都是由Client组件完成的，其中Client的实现类，只要有Client.Default，该类由HttpURLConnnection实现网络请求，另外还支持HttpClient、Okhttp.</p>
<p>首先来看以下在FeignRibbonClient的自动配置类，FeignRibbonClientAutoConfiguration ，主要在工程启动的时候注入一些bean,其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConditionalOnClass(&#123; ILoadBalancer.class, Feign.class &#125;)</span><br><span class="line">@Configuration</span><br><span class="line">@AutoConfigureBefore(FeignAutoConfiguration.class)</span><br><span class="line">public class FeignRibbonClientAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,</span><br><span class="line">			SpringClientFactory clientFactory) &#123;</span><br><span class="line">		return new LoadBalancerFeignClient(new Client.Default(null, null),</span><br><span class="line">				cachingFactory, clientFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在缺失配置feignClient的情况下，会自动注入new Client.Default(),跟踪Client.Default()源码，它使用的网络请求框架为HttpURLConnection，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public Response execute(Request request, Options options) throws IOException &#123;</span><br><span class="line">    HttpURLConnection connection &#x3D; convertAndSend(request, options);</span><br><span class="line">    return convertResponse(connection).toBuilder().request(request).build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>怎么在feign中使用HttpClient，查看FeignRibbonClientAutoConfiguration的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConditionalOnClass(&#123; ILoadBalancer.class, Feign.class &#125;)</span><br><span class="line">@Configuration</span><br><span class="line">@AutoConfigureBefore(FeignAutoConfiguration.class)</span><br><span class="line">public class FeignRibbonClientAutoConfiguration &#123;</span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">	@ConditionalOnClass(ApacheHttpClient.class)</span><br><span class="line">	@ConditionalOnProperty(value &#x3D; &quot;feign.httpclient.enabled&quot;, matchIfMissing &#x3D; true)</span><br><span class="line">	protected static class HttpClientFeignLoadBalancedConfiguration &#123;</span><br><span class="line"></span><br><span class="line">		@Autowired(required &#x3D; false)</span><br><span class="line">		private HttpClient httpClient;</span><br><span class="line"></span><br><span class="line">		@Bean</span><br><span class="line">		@ConditionalOnMissingBean(Client.class)</span><br><span class="line">		public Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,</span><br><span class="line">				SpringClientFactory clientFactory) &#123;</span><br><span class="line">			ApacheHttpClient delegate;</span><br><span class="line">			if (this.httpClient !&#x3D; null) &#123;</span><br><span class="line">				delegate &#x3D; new ApacheHttpClient(this.httpClient);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				delegate &#x3D; new ApacheHttpClient();</span><br><span class="line">			&#125;</span><br><span class="line">			return new LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从代码@ConditionalOnClass(ApacheHttpClient.class)注解可知道，只需要在pom文件加上HttpClient的classpath就行了，另外需要在配置文件上加上feign.httpclient.enabled为true，从    @ConditionalOnProperty注解可知，这个可以不写，在默认的情况下就为true.</p>
<p>在pom文件加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-httpclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同理，如果想要feign使用Okhttp，则只需要在pom文件上加上feign-okhttp的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-okhttp&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="feign的负载均衡是怎么样实现的呢？"><a href="#feign的负载均衡是怎么样实现的呢？" class="headerlink" title="feign的负载均衡是怎么样实现的呢？"></a>feign的负载均衡是怎么样实现的呢？</h2><p>通过上述的FeignRibbonClientAutoConfiguration类配置Client的类型(httpurlconnection，okhttp和httpclient)时候，可知最终向容器注入的是LoadBalancerFeignClient，即负载均衡客户端。现在来看下LoadBalancerFeignClient的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Response execute(Request request, Request.Options options) throws IOException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		URI asUri &#x3D; URI.create(request.url());</span><br><span class="line">		String clientName &#x3D; asUri.getHost();</span><br><span class="line">		URI uriWithoutHost &#x3D; cleanUrl(request.url(), clientName);</span><br><span class="line">		FeignLoadBalancer.RibbonRequest ribbonRequest &#x3D; new FeignLoadBalancer.RibbonRequest(</span><br><span class="line">				this.delegate, request, uriWithoutHost);</span><br><span class="line"></span><br><span class="line">		IClientConfig requestConfig &#x3D; getClientConfig(options, clientName);</span><br><span class="line">		return lbClient(clientName).executeWithLoadBalancer(ribbonRequest,</span><br><span class="line">				requestConfig).toResponse();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ClientException e) &#123;</span><br><span class="line">		IOException io &#x3D; findIOException(e);</span><br><span class="line">		if (io !&#x3D; null) &#123;</span><br><span class="line">			throw io;</span><br><span class="line">		&#125;</span><br><span class="line">		throw new RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有个executeWithLoadBalancer()方法，即通过负载均衡的方式请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T executeWithLoadBalancer(final S request, final IClientConfig requestConfig) throws ClientException &#123;</span><br><span class="line">      RequestSpecificRetryHandler handler &#x3D; getRequestSpecificRetryHandler(request, requestConfig);</span><br><span class="line">      LoadBalancerCommand&lt;T&gt; command &#x3D; LoadBalancerCommand.&lt;T&gt;builder()</span><br><span class="line">              .withLoadBalancerContext(this)</span><br><span class="line">              .withRetryHandler(handler)</span><br><span class="line">              .withLoadBalancerURI(request.getUri())</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">          return command.submit(</span><br><span class="line">              new ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public Observable&lt;T&gt; call(Server server) &#123;</span><br><span class="line">                      URI finalUri &#x3D; reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                      S requestForServer &#x3D; (S) request.replaceUri(finalUri);</span><br><span class="line">                      try &#123;</span><br><span class="line">                          return Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig));</span><br><span class="line">                      &#125; </span><br><span class="line">                      catch (Exception e) &#123;</span><br><span class="line">                          return Observable.error(e);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .toBlocking()</span><br><span class="line">              .single();</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          Throwable t &#x3D; e.getCause();</span><br><span class="line">          if (t instanceof ClientException) &#123;</span><br><span class="line">              throw (ClientException) t;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              throw new ClientException(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中服务在submit()方法上，点击submit进入具体的方法,这个方法是LoadBalancerCommand的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable&lt;T&gt; o &#x3D; </span><br><span class="line">           (server &#x3D;&#x3D; null ? selectServer() : Observable.just(server))</span><br><span class="line">           .concatMap(new Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               &#x2F;&#x2F; Called for each server being selected</span><br><span class="line">               public Observable&lt;T&gt; call(Server server) &#123;</span><br><span class="line">                   context.setServer(server);</span><br><span class="line">    </span><br><span class="line">   &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中有个selectServe()，该方法是选择服务的进行负载均衡的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Observable&lt;Server&gt; selectServer() &#123;</span><br><span class="line">    return Observable.create(new OnSubscribe&lt;Server&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Subscriber&lt;? super Server&gt; next) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Server server &#x3D; loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   </span><br><span class="line">                next.onNext(server);</span><br><span class="line">                next.onCompleted();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                next.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终负载均衡交给loadBalancerContext来处理，即之前讲述的Ribbon，在这里不再重复。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总到来说，Feign的源码实现的过程如下：</p>
<ul>
<li>首先通过@EnableFeignCleints注解开启FeignCleint</li>
<li>根据Feign的规则实现接口，并加@FeignCleint注解</li>
<li>程序启动后，会进行包扫描，扫描所有的@ FeignCleint的注解的类，并将这些信息注入到ioc容器中。</li>
<li>当接口的方法被调用，通过jdk的代理，来生成具体的RequesTemplate</li>
<li>RequesTemplate在生成Request</li>
<li>Request交给Client去处理，其中Client可以是HttpUrlConnection、HttpClient也可以是Okhttp</li>
<li>最后Client被封装到LoadBalanceClient类，这个类结合类Ribbon做到了负载均衡。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.de-swaef.eu/the-netflix-stack-using-spring-boot-part-3-feign/">https://blog.de-swaef.eu/the-netflix-stack-using-spring-boot-part-3-feign/</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul上传文件，中文文件名乱码解决办法</title>
    <url>/2017/08/11/dive-into-sc-2017-08-14-springcloud-upload-file-problem/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在项目中又一个上传文件的oss服务，直接调用服务的上传文件成功，如果经过网关zuul服务，上传中文名字的文件，文件名会出现乱码，最终导致上传失败，如果上传英文名字的文件，没有任何问题。怀疑网关zuul对中文做编码处理。</p>
 <span id="more"></span>

<h2 id="解决问题的过程"><a href="#解决问题的过程" class="headerlink" title="解决问题的过程"></a>解决问题的过程</h2><p>这个问题出现之后，我个人的解决办法如下：</p>
<ul>
<li><p>第一反应是看文档，文档地址：<a target="_blank" rel="noopener" href="http://cloud.spring.io/spring-cloud-static/Dalston.SR1/#_uploading_files_through_zuul">http://cloud.spring.io/spring-cloud-static/Dalston.SR1/#_uploading_files_through_zuul</a></p>
</li>
<li><p>粗略地看了下文档，以为没有给出解决方案（其实已经给出，只是没有理解好文档）。狂撸源码，依然没有找到解决办法。</p>
</li>
<li><p>Google搜，搜到了这条Issue，<a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1385">https://github.com/spring-cloud/spring-cloud-netflix/issues/1385</a></p>
</li>
</ul>
<p>这位大神给出的解决办法，使用zuul servlet去上传文件，而不是默认的spring mvc。使用 zuul servlet之需要在请求uri，前面加上”/zuul”即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-e1eeda790fa3fe15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先列出我的zuul服务的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port: 5000</span><br><span class="line">zuul:</span><br><span class="line">   routes:</span><br><span class="line">      oss-api:</span><br><span class="line">      path: &#x2F;oss&#x2F;**</span><br><span class="line">      serviceId: oss-service</span><br></pre></td></tr></table></figure>
<p>oss服务上传文件的接口，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;file&quot;)</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line">    @PostMapping(&quot;&#x2F;upload&quot;)  </span><br><span class="line">    public RespDTO handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file) &#123;</span><br><span class="line">        &#x2F;&#x2F;上传代码省略</span><br><span class="line">        return RespDTO.onSuc(upLoadResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么，经过网关，调用上传文件的url地址如下：</p>
<blockquote>
<p>localhost:5000/oss/file/upload</p>
</blockquote>
<p>这时如果出现中文文件名，上传文件的文件名会出现失败。按照上述大神的办法，直接在这个uri，前面加上”/zuul”，那么请求地址如下：</p>
<blockquote>
<p>localhost:5000/zuul/oss/file/upload</p>
</blockquote>
<p>测试一下，果然通过，上传中文名的文件乱码问题解决。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-springcloud-zuul-resources/</url>
    <content><![CDATA[<h2 id="Zuul-架构图"><a href="#Zuul-架构图" class="headerlink" title="Zuul 架构图"></a>Zuul 架构图</h2><p>在zuul中， 整个请求的过程是这样的，首先将请求给zuulservlet处理，zuulservlet中有一个zuulRunner对象，该对象中初始化了RequestContext：作为存储整个请求的一些数据，并被所有的zuulfilter共享。zuulRunner中还有 FilterProcessor，FilterProcessor作为执行所有的zuulfilter的管理器。FilterProcessor从filterloader 中获取zuulfilter，而zuulfilter是被filterFileManager所加载，并支持groovy热加载，采用了轮询的方式热加载。</p>
<span id="more"></span>


<p>有了这些filter之后，zuulservelet首先执行的Pre类型的过滤器，再执行route类型的过滤器，最后执行的是post 类型的过滤器，如果在执行这些过滤器有错误的时候则会执行error类型的过滤器。执行完这些过滤器，最终将请求的结果返回给客户端。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/2279594-2e6134e4743b0483.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zuul.png"></p>
<h2 id="zuul工作原理源码分析"><a href="#zuul工作原理源码分析" class="headerlink" title="zuul工作原理源码分析"></a>zuul工作原理源码分析</h2><p>在之前已经讲过，如何使用zuul，其中不可缺少的一个步骤就是在程序的启动类加上＠EnableZuulProxy，该EnableZuulProxy类代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableCircuitBreaker</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Import(ZuulProxyConfiguration.class)</span><br><span class="line">public @interface EnableZuulProxy &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 其中，引用了ZuulProxyConfiguration，跟踪ZuulProxyConfiguration，该类注入了DiscoveryClient、RibbonCommandFactoryConfiguration用作负载均衡相关的。注入了一些列的filters，比如PreDecorationFilter、RibbonRoutingFilter、SimpleHostRoutingFilter，代码如如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public PreDecorationFilter preDecorationFilter(RouteLocator routeLocator, ProxyRequestHelper proxyRequestHelper) &#123;</span><br><span class="line">	return new PreDecorationFilter(routeLocator, this.server.getServletPrefix(), this.zuulProperties,</span><br><span class="line">			proxyRequestHelper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; route filters</span><br><span class="line">@Bean</span><br><span class="line">public RibbonRoutingFilter ribbonRoutingFilter(ProxyRequestHelper helper,</span><br><span class="line">		RibbonCommandFactory&lt;?&gt; ribbonCommandFactory) &#123;</span><br><span class="line">	RibbonRoutingFilter filter &#x3D; new RibbonRoutingFilter(helper, ribbonCommandFactory, this.requestCustomizers);</span><br><span class="line">	return filter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleHostRoutingFilter simpleHostRoutingFilter(ProxyRequestHelper helper, ZuulProperties zuulProperties) &#123;</span><br><span class="line">	return new SimpleHostRoutingFilter(helper, zuulProperties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 它的父类ZuulConfiguration ，引用了一些相关的配置。在缺失zuulServlet  bean的情况下注入了ZuulServlet，该类是zuul的核心类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	@Bean</span><br><span class="line">@ConditionalOnMissingBean(name &#x3D; &quot;zuulServlet&quot;)</span><br><span class="line">public ServletRegistrationBean zuulServlet() &#123;</span><br><span class="line">	ServletRegistrationBean servlet &#x3D; new ServletRegistrationBean(new ZuulServlet(),</span><br><span class="line">			this.zuulProperties.getServletPattern());</span><br><span class="line">	&#x2F;&#x2F; The whole point of exposing this servlet is to provide a route that doesn&#39;t</span><br><span class="line">	&#x2F;&#x2F; buffer requests.</span><br><span class="line">	servlet.addInitParameter(&quot;buffer-requests&quot;, &quot;false&quot;);</span><br><span class="line">	return servlet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时也注入了其他的过滤器，比如ServletDetectionFilter、DebugFilter、Servlet30WrapperFilter，这些过滤器都是pre类型的。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ServletDetectionFilter servletDetectionFilter() &#123;</span><br><span class="line">	return new ServletDetectionFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public FormBodyWrapperFilter formBodyWrapperFilter() &#123;</span><br><span class="line">	return new FormBodyWrapperFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public DebugFilter debugFilter() &#123;</span><br><span class="line">	return new DebugFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Servlet30WrapperFilter servlet30WrapperFilter() &#123;</span><br><span class="line">	return new Servlet30WrapperFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 它也注入了post类型的，比如 SendResponseFilter，error类型，比如 SendErrorFilter，route类型比如SendForwardFilter，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SendResponseFilter sendResponseFilter() &#123;</span><br><span class="line">	return new SendResponseFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SendErrorFilter sendErrorFilter() &#123;</span><br><span class="line">	return new SendErrorFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SendForwardFilter sendForwardFilter() &#123;</span><br><span class="line">	return new SendForwardFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化ZuulFilterInitializer类，将所有的filter 向FilterRegistry注册。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	@Configuration</span><br><span class="line">protected static class ZuulFilterConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private Map&lt;String, ZuulFilter&gt; filters;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public ZuulFilterInitializer zuulFilterInitializer(</span><br><span class="line">			CounterFactory counterFactory, TracerFactory tracerFactory) &#123;</span><br><span class="line">		FilterLoader filterLoader &#x3D; FilterLoader.getInstance();</span><br><span class="line">		FilterRegistry filterRegistry &#x3D; FilterRegistry.instance();</span><br><span class="line">		return new ZuulFilterInitializer(this.filters, counterFactory, tracerFactory, filterLoader, filterRegistry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 而FilterRegistry管理了一个ConcurrentHashMap，用作存储过滤器的，并有一些基本的CURD过滤器的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class FilterRegistry &#123;</span><br><span class="line"></span><br><span class="line">    private static final FilterRegistry INSTANCE &#x3D; new FilterRegistry();</span><br><span class="line"></span><br><span class="line">    public static final FilterRegistry instance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final ConcurrentHashMap&lt;String, ZuulFilter&gt; filters &#x3D; new ConcurrentHashMap&lt;String, ZuulFilter&gt;();</span><br><span class="line"></span><br><span class="line">    private FilterRegistry() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ZuulFilter remove(String key) &#123;</span><br><span class="line">        return this.filters.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ZuulFilter get(String key) &#123;</span><br><span class="line">        return this.filters.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(String key, ZuulFilter filter) &#123;</span><br><span class="line">        this.filters.putIfAbsent(key, filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return this.filters.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Collection&lt;ZuulFilter&gt; getAllFilters() &#123;</span><br><span class="line">        return this.filters.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> FilterLoader类持有FilterRegistry，FilterFileManager类持有FilterLoader，所以最终是由FilterFileManager注入 filterFilterRegistry的ConcurrentHashMap的。FilterFileManager到开启了轮询机制，定时的去加载过滤器，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void startPoller() &#123;</span><br><span class="line">      poller &#x3D; new Thread(&quot;GroovyFilterFileManagerPoller&quot;) &#123;</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              while (bRunning) &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      sleep(pollingIntervalSeconds * 1000);</span><br><span class="line">                      manageFiles();</span><br><span class="line">                  &#125; catch (Exception e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      poller.setDaemon(true);</span><br><span class="line">      poller.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> Zuulservlet作为类似于Spring MVC中的DispatchServlet,起到了前端控制器的作用，所有的请求都由它接管。它的核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">@Override</span><br><span class="line"> public void service(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Marks this request as having passed through the &quot;Zuul engine&quot;, as opposed to servlets</span><br><span class="line">         &#x2F;&#x2F; explicitly bound in web.xml, for which requests will not have the same data attached</span><br><span class="line">         RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">         context.setZuulEngineRan();</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">             preRoute();</span><br><span class="line">         &#125; catch (ZuulException e) &#123;</span><br><span class="line">             error(e);</span><br><span class="line">             postRoute();</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         try &#123;</span><br><span class="line">             route();</span><br><span class="line">         &#125; catch (ZuulException e) &#123;</span><br><span class="line">             error(e);</span><br><span class="line">             postRoute();</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         try &#123;</span><br><span class="line">             postRoute();</span><br><span class="line">         &#125; catch (ZuulException e) &#123;</span><br><span class="line">             error(e);</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125; catch (Throwable e) &#123;</span><br><span class="line">         error(new ZuulException(e, 500, &quot;UNHANDLED_EXCEPTION_&quot; + e.getClass().getName()));</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         RequestContext.getCurrentContext().unset();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>跟踪init（），可以发现这个方法为每个请求生成了RequestContext,RequestContext继承了ConcurrentHashMap&lt;String, Object&gt;，在请求结束时销毁掉该RequestContext，RequestContext的生命周期为请求到zuulServlet开始处理，直到请求结束返回结果。<br>RequestContext类在存储了很多重要的信息，包括HttpServletRequest、HttpServletRespons、ResponseDataStream、ResponseStatusCode等。 RequestContext对象在处理请求的过程中，一直存在，所以这个对象为所有Filter共享。</p>
<p>从ZuulServlet的service（）方法可知，它是先处理pre()类型的处理器，然后在处理route()类型的处理器，最后再处理post类型的处理器。</p>
<p>首先来看一看pre()的处理过程，它会进入到ZuulRunner,该类的作用是将请求的HttpServletRequest、HttpServletRespons放在RequestContext类中，并包装了一个FilterProcessor，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) &#123;</span><br><span class="line"></span><br><span class="line">        RequestContext ctx &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">        if (bufferRequests) &#123;</span><br><span class="line">            ctx.setRequest(new HttpServletRequestWrapper(servletRequest));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ctx.setRequest(servletRequest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.setResponse(new HttpServletResponseWrapper(servletResponse));</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> public void preRoute() throws ZuulException &#123;</span><br><span class="line">    FilterProcessor.getInstance().preRoute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而FilterProcessor类为调用filters的类，比如调用pre类型所有的过滤器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void preRoute() throws ZuulException &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          runFilters(&quot;pre&quot;);</span><br><span class="line">      &#125; catch (ZuulException e) &#123;</span><br><span class="line">          throw e;</span><br><span class="line">      &#125; catch (Throwable e) &#123;</span><br><span class="line">          throw new ZuulException(e, 500, &quot;UNCAUGHT_EXCEPTION_IN_PRE_FILTER_&quot; + e.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>跟踪runFilters（）方法，可以发现，它最终调用了FilterLoader的getFiltersByType(sType)方法来获取同一类的过滤器，然后用for循环遍历所有的ZuulFilter，执行了 processZuulFilter（）方法，跟踪该方法可以发现最终是执行了ZuulFilter的方法，最终返回了该方法返回的Object对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object runFilters(String sType) throws Throwable &#123;</span><br><span class="line">       if (RequestContext.getCurrentContext().debugRouting()) &#123;</span><br><span class="line">           Debug.addRoutingDebug(&quot;Invoking &#123;&quot; + sType + &quot;&#125; type filters&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       boolean bResult &#x3D; false;</span><br><span class="line">       List&lt;ZuulFilter&gt; list &#x3D; FilterLoader.getInstance().getFiltersByType(sType);</span><br><span class="line">       if (list !&#x3D; null) &#123;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">               ZuulFilter zuulFilter &#x3D; list.get(i);</span><br><span class="line">               Object result &#x3D; processZuulFilter(zuulFilter);</span><br><span class="line">               if (result !&#x3D; null &amp;&amp; result instanceof Boolean) &#123;</span><br><span class="line">                   bResult |&#x3D; ((Boolean) result);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return bResult;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>route、post类型的过滤器的执行过程和pre执行过程类似。</p>
<h2 id="Zuul默认过滤器"><a href="#Zuul默认过滤器" class="headerlink" title="Zuul默认过滤器"></a>Zuul默认过滤器</h2><h4 id="默认的核心过滤器一览表"><a href="#默认的核心过滤器一览表" class="headerlink" title="默认的核心过滤器一览表"></a>默认的核心过滤器一览表</h4><p>Zuul默认注入的过滤器，它们的执行顺序在FilterConstants类，我们可以先定位在这个类，然后再看这个类的过滤器的执行顺序以及相关的注释，可以很轻松定位到相关的过滤器，也可以直接打开<br>spring-cloud-netflix-core.jar的 zuul.filters包，可以看到一些列的filter，现在我以表格的形式，列出默认注入的filter.</p>
<table>
<thead>
<tr>
<th>过滤器</th>
<th align="right">order</th>
<th align="center">描述</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td>ServletDetectionFilter</td>
<td align="right">-3</td>
<td align="center">检测请求是用 DispatcherServlet还是 ZuulServlet</td>
<td align="center">pre</td>
</tr>
<tr>
<td>Servlet30WrapperFilter</td>
<td align="right">-2</td>
<td align="center">在Servlet 3.0 下，包装 requests</td>
<td align="center">pre</td>
</tr>
<tr>
<td>FormBodyWrapperFilter</td>
<td align="right">-1</td>
<td align="center">解析表单数据</td>
<td align="center">pre</td>
</tr>
<tr>
<td>SendErrorFilter</td>
<td align="right">0</td>
<td align="center">如果中途出现错误</td>
<td align="center">error</td>
</tr>
<tr>
<td>DebugFilter</td>
<td align="right">1</td>
<td align="center">设置请求过程是否开启debug</td>
<td align="center">pre</td>
</tr>
<tr>
<td>PreDecorationFilter</td>
<td align="right">5</td>
<td align="center">根据uri决定调用哪一个route过滤器</td>
<td align="center">pre</td>
</tr>
<tr>
<td>RibbonRoutingFilter</td>
<td align="right">10</td>
<td align="center">如果写配置的时候用ServiceId则用这个route过滤器，该过滤器可以用Ribbon 做负载均衡，用hystrix做熔断</td>
<td align="center">route</td>
</tr>
<tr>
<td>SimpleHostRoutingFilter</td>
<td align="right">100</td>
<td align="center">如果写配置的时候用url则用这个route过滤</td>
<td align="center">route</td>
</tr>
<tr>
<td>SendForwardFilter</td>
<td align="right">500</td>
<td align="center">用RequestDispatcher请求转发</td>
<td align="center">route</td>
</tr>
<tr>
<td>SendResponseFilter</td>
<td align="right">1000</td>
<td align="center">用RequestDispatcher请求转发</td>
<td align="center">post</td>
</tr>
</tbody></table>
<p>过滤器的order值越小，就越先执行，并且在执行过滤器的过程中，它们共享了一个RequestContext对象，该对象的生命周期贯穿于请求，可以看出优先执行了pre类型的过滤器，并将执行后的结果放在RequestContext中，供后续的filter使用，比如在执行PreDecorationFilter的时候，决定使用哪一个route，它的结果的是放在RequestContext对象中，后续会执行所有的route的过滤器，如果不满足条件就不执行该过滤器的run方法。最终达到了就执行一个route过滤器的run()方法。</p>
<p>而error类型的过滤器，是在程序发生异常的时候执行的。</p>
<p>post类型的过滤，在默认的情况下，只注入了SendResponseFilter，该类型的过滤器是将最终的请求结果以流的形式输出给客户单。</p>
<h4 id="现在来看SimpleHostRoutingFilter是如何工作"><a href="#现在来看SimpleHostRoutingFilter是如何工作" class="headerlink" title="现在来看SimpleHostRoutingFilter是如何工作?"></a>现在来看SimpleHostRoutingFilter是如何工作?</h4><p>进入到SimpleHostRoutingFilter类的方法的run()方法，核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object run() &#123;</span><br><span class="line">	RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">    &#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">	String uri &#x3D; this.helper.buildZuulRequestURI(request);</span><br><span class="line">	this.helper.addIgnoredHeaders();</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		CloseableHttpResponse response &#x3D; forward(this.httpClient, verb, uri, request,</span><br><span class="line">				headers, params, requestEntity);</span><br><span class="line">		setResponse(response);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;</span><br><span class="line">		throw new ZuulRuntimeException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查阅这个类的全部代码可知，该类创建了一个HttpClient作为请求类，并重构了url,请求到了具体的服务，得到的一个CloseableHttpResponse对象，并将CloseableHttpResponse对象的保存到RequestContext对象中。并调用了ProxyRequestHelper的setResponse方法，将请求状态码，流等信息保存在RequestContext对象中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void setResponse(HttpResponse response) throws IOException &#123;</span><br><span class="line">		RequestContext.getCurrentContext().set(&quot;zuulResponse&quot;, response);</span><br><span class="line">		this.helper.setResponse(response.getStatusLine().getStatusCode(),</span><br><span class="line">				response.getEntity() &#x3D;&#x3D; null ? null : response.getEntity().getContent(),</span><br><span class="line">				revertHeaders(response.getAllHeaders()));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="现在来看SendResponseFilter是如何工作"><a href="#现在来看SendResponseFilter是如何工作" class="headerlink" title="现在来看SendResponseFilter是如何工作?"></a>现在来看SendResponseFilter是如何工作?</h4><p>这个过滤器的order为1000,在默认且正常的情况下，是最后一个执行的过滤器，该过滤器是最终将得到的数据返回给客户端的请求。</p>
<p>在它的run()方法里，有两个方法：addResponseHeaders()和writeResponse()，即添加响应头和写入响应数据流。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public Object run() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		addResponseHeaders();</span><br><span class="line">		writeResponse();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;</span><br><span class="line">		ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中writeResponse（）方法是通过从RequestContext中获取ResponseBody获或者ResponseDataStream来写入到HttpServletResponse中的，但是在默认的情况下ResponseBody为null，而ResponseDataStream在route类型过滤器中已经设置进去了。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void writeResponse() throws Exception &#123;</span><br><span class="line">		RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">	</span><br><span class="line">		HttpServletResponse servletResponse &#x3D; context.getResponse();</span><br><span class="line">			&#x2F;&#x2F;代码省略</span><br><span class="line">		OutputStream outStream &#x3D; servletResponse.getOutputStream();</span><br><span class="line">		InputStream is &#x3D; null;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (RequestContext.getCurrentContext().getResponseBody() !&#x3D; null) &#123;</span><br><span class="line">				String body &#x3D; RequestContext.getCurrentContext().getResponseBody();</span><br><span class="line">				writeResponse(</span><br><span class="line">						new ByteArrayInputStream(</span><br><span class="line">								body.getBytes(servletResponse.getCharacterEncoding())),</span><br><span class="line">						outStream);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;代码省略</span><br><span class="line">			is &#x3D; context.getResponseDataStream();</span><br><span class="line">			InputStream inputStream &#x3D; is;</span><br><span class="line">				&#x2F;&#x2F;代码省略</span><br><span class="line">		</span><br><span class="line">			writeResponse(inputStream, outStream);</span><br><span class="line">				&#x2F;&#x2F;代码省略</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    ..&#x2F;&#x2F;代码省略</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="如何在zuul上做日志处理"><a href="#如何在zuul上做日志处理" class="headerlink" title="如何在zuul上做日志处理"></a>如何在zuul上做日志处理</h2><p>由于zuul作为api网关，所有的请求都经过这里，所以在网关上，可以做请求相关的日志处理。<br>我的需求是这样的，需要记录请求的 url,ip地址，参数，请求发生的时间，整个请求的耗时，请求的响应状态，甚至请求响应的结果等。<br>很显然，需要实现这样的一个功能，需要写一个ZuulFliter，它应该是在请求发送给客户端之前做处理，并且在route过滤器路由之后，在默认的情况下，这个过滤器的order应该为500-1000之间。那么如何获取这些我需要的日志信息呢？找RequestContext,在请求的生命周期里这个对象里，存储了整个请求的所有信息。</p>
<p>现在编码，在代码的注释中，做了详细的说明，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class LoggerFilter extends ZuulFilter &#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return FilterConstants.POST_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() &#123;</span><br><span class="line">        RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request &#x3D; context.getRequest();</span><br><span class="line">        String method &#x3D; request.getMethod();&#x2F;&#x2F;氢气的类型，post get ..</span><br><span class="line">        Map&lt;String, String&gt; params &#x3D; HttpUtils.getParams(request);</span><br><span class="line">        String paramsStr &#x3D; params.toString();&#x2F;&#x2F;请求的参数</span><br><span class="line">        long statrtTime &#x3D; (long) context.get(&quot;startTime&quot;);&#x2F;&#x2F;请求的开始时间</span><br><span class="line">        Throwable throwable &#x3D; context.getThrowable();&#x2F;&#x2F;请求的异常，如果有的话</span><br><span class="line">        request.getRequestURI()；&#x2F;&#x2F;请求的uri</span><br><span class="line">        HttpUtils.getIpAddress(request);&#x2F;&#x2F;请求的iP地址</span><br><span class="line">        context.getResponseStatusCode();&#x2F;&#x2F;请求的状态</span><br><span class="line">        long duration&#x3D;System.currentTimeMillis() - statrtTime);&#x2F;&#x2F;请求耗时</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在读者也许有疑问，如何得到的statrtTime，即请求开始的时间，其实这需要另外一个过滤器，在网络请求route之前(大部分耗时都在route这一步)，在过滤器中，在RequestContext存储一个时间即可，另写一个过滤器，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AccessFilter extends ZuulFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return &quot;pre&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() &#123;</span><br><span class="line">        RequestContext ctx &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">        ctx.set(&quot;startTime&quot;,System.currentTimeMillis());</span><br><span class="line">       </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可能还有这样的需求，我需要将响应结果，也要存储在log中，在之前已经分析了，在route结束后，将从具体服务获取的响应流存储在RequestContext中，在SendResponseFilter过滤器写入在HttpServletResponse中，最终返回给客户端。那么我只需要在SendResponseFilter写入响应流之前把响应流写入到 log日志中即可，那么会引发另外一个问题，因为响应流写入到 log后，RequestContext就没有响应流了，在SendResponseFilter就没有流输入到HttpServletResponse中，导致客户端没有任何的返回数据，那么解决的办法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream inputStream &#x3D;RequestContext.getCurrentContext().getResponseDataStream();</span><br><span class="line">InputStream newInputStream&#x3D; copy(inputStream);</span><br><span class="line">transerferTolog(inputStream);</span><br><span class="line">RequestContext.getCurrentContext().setResponseDataStream(newInputStream);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从RequestContext获取到流之后，首先将流 copy一份，将流转化下字符串，存在日志中，再set到RequestContext中，<br>这样SendResponseFilter就可以将响应返回给客户端。这样的做法有点影响性能，如果不是字符流，可能需要做更多的处理工作。</p>
<h2 id="关注我的公众号"><a href="#关注我的公众号" class="headerlink" title="关注我的公众号"></a>关注我的公众号</h2><p>精彩内容不能错过！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0805748d92bba033.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="forezp.jpg"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2020/10/30/designPattern-2020-10-30-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。</p>
<p>在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。</p>
<span id="more"></span>

<h3 id="代理模式的定义与特点"><a href="#代理模式的定义与特点" class="headerlink" title="代理模式的定义与特点"></a>代理模式的定义与特点</h3><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<h3 id="代理模式的主要优点有："><a href="#代理模式的主要优点有：" class="headerlink" title="代理模式的主要优点有："></a>代理模式的主要优点有：</h3><ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li>
</ul>
<h3 id="其主要缺点是："><a href="#其主要缺点是：" class="headerlink" title="其主要缺点是："></a>其主要缺点是：</h3><ul>
<li>代理模式会造成系统设计中类的数量增加</li>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
<li>那么如何解决以上提到的缺点呢？答案是可以使用动态代理方式</li>
</ul>
<h3 id="代理模式的结构与实现"><a href="#代理模式的结构与实现" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h3><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p>
<h4 id="1-模式的结构"><a href="#1-模式的结构" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h4><p>代理模式的主要角色如下。</p>
<ul>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<p>其结构图如图 1 所示<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk7fvl8ky9g30i209mmxh.gif"></p>
<p>在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。</p>
<p>根据代理的创建时期，代理模式分为静态代理和动态代理。</p>
<ul>
<li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li>
<li>动态：在程序运行时，运用反射机制动态创建而成</li>
</ul>
<h4 id="2-模式的实现"><a href="#2-模式的实现" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.三个抽象主题</span><br><span class="line">&#x2F;**</span><br><span class="line"> * process check gamer ticket</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface CheckProcess &#123;</span><br><span class="line">    void check();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface DietProcess &#123;</span><br><span class="line">    void diet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * process game</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface GameProcess &#123;</span><br><span class="line">    void play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 三个真实主题</span><br><span class="line">public class BigGamePayer extends GamePayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void play() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; big player start play ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BigChecker implements CheckProcess &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void check() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; start check ticket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dieter implements DietProcess &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void diet() &#123;</span><br><span class="line">      log.info(&quot;&#x3D;&#x3D; start make diet : ice &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3. 代理类</span><br><span class="line">public class ProxyProcess implements GameProcess, CheckProcess, DietProcess &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理检票</span><br><span class="line">    private CheckProcess checkProcess;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理游戏</span><br><span class="line">    private GameProcess  gameProcess;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理饮食</span><br><span class="line">    private DietProcess  dietProcess;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; ProxyProcess(T t) &#123;</span><br><span class="line">        if (t instanceof GameProcess) &#123;</span><br><span class="line">            this.gameProcess &#x3D; (GameProcess) t;</span><br><span class="line">        &#125; else if (t instanceof CheckProcess) &#123;</span><br><span class="line">            this.checkProcess &#x3D; (CheckProcess) t;</span><br><span class="line">        &#125; else if (t instanceof DietProcess) &#123;</span><br><span class="line">            this.dietProcess &#x3D; (DietProcess) t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void play() &#123;</span><br><span class="line">        before();</span><br><span class="line">        this.gameProcess.play();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void check() &#123;</span><br><span class="line">        this.checkProcess.check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void diet() &#123;</span><br><span class="line">        this.dietProcess.diet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void before() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; proxy: start before play game&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void after() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; proxy:  start after play game&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>游戏屋:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GameHome &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        proxyCheck();</span><br><span class="line">        proxyPlay();</span><br><span class="line">        proxyDiete();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void proxyPlay() &#123;</span><br><span class="line">        &#x2F;&#x2F; 代理玩游戏</span><br><span class="line">        BigGamePayer bigGamePayer &#x3D; new BigGamePayer();</span><br><span class="line">        ProxyProcess proxyPayer &#x3D; new ProxyProcess(bigGamePayer);</span><br><span class="line">        proxyPayer.play();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void proxyCheck() &#123;</span><br><span class="line">        &#x2F;&#x2F; 代理检票</span><br><span class="line">        BigChecker bigChecker &#x3D; new BigChecker();</span><br><span class="line">        ProxyProcess proxyProcess &#x3D; new ProxyProcess(bigChecker);</span><br><span class="line">        proxyProcess.check();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void proxyDiete() &#123;</span><br><span class="line">        &#x2F;&#x2F; 代理美食</span><br><span class="line">        Dieter dieter &#x3D; new Dieter();</span><br><span class="line">        ProxyProcess proxyProcess &#x3D; new ProxyProcess(dieter);</span><br><span class="line">        proxyProcess.diet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16:29:18.572 [main] INFO com.ckj.base.designPatternes.proxy.extend.BigChecker - &#x3D;&#x3D;&#x3D; start check ticket</span><br><span class="line">16:29:18.575 [main] INFO com.ckj.base.designPatternes.proxy.proxy.ProxyProcess - &#x3D;&#x3D;&#x3D; proxy: start before play game</span><br><span class="line">16:29:18.575 [main] INFO com.ckj.base.designPatternes.proxy.extend.BigGamePayer - &#x3D;&#x3D;&#x3D; big player start play ...</span><br><span class="line">16:29:18.575 [main] INFO com.ckj.base.designPatternes.proxy.proxy.ProxyProcess - &#x3D;&#x3D;&#x3D; proxy:  start after play game</span><br><span class="line">16:29:18.576 [main] INFO com.ckj.base.designPatternes.proxy.extend.Dieter - &#x3D;&#x3D; start make diet : ice </span><br></pre></td></tr></table></figure>

<h4 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h4><p>在前面介绍的代理模式中，代理类中包含了对真实主题的引用，这种方式存在两个缺点。</p>
<ul>
<li>真实主题与代理主题一一对应，增加真实主题也要增加代理。</li>
<li>设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 SpringAOP，其结构图如图 4 所示。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk7jnux1oeg30hi0g6js3.gif"></p>
<p>改造如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dynamic proxy</span><br><span class="line">    GameProcess proxy &#x3D; (GameProcess) Proxy.newProxyInstance(GameProcess.class.getClassLoader(), new Class[]&#123;GameProcess.class&#125;,</span><br><span class="line">            new InvocationHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            log.info(&quot;start dynamic process...&quot;);</span><br><span class="line">            return method.invoke(new BigGamePayer(), args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.play();</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18:17:11.681 [main] INFO com.ckj.base.designPatternes.proxy.GameHome - start dynamic process...</span><br><span class="line">18:17:11.681 [main] INFO com.ckj.base.designPatternes.proxy.extend.BigGamePayer - &#x3D;&#x3D;&#x3D; big player start play ...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基本概念</title>
    <url>/2020/11/12/internet-2020-11-12-%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>本篇文章简单梳理网络通信的基础概念</p>
<p>在学习Java网络编程之前，我们先来了解什么是计算机网络。</p>
<p>计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p>
<p>那什么是互联网呢？互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p>
<p>对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用<strong>TCP/IP协议</strong>。</p>
<p>TCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。</p>
<span id="more"></span>

<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。</p>
<p>IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似101.202.99.12，而IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。</p>
<p>IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：</p>
<ul>
<li>192.168.x.x</li>
<li>10.x.x.x</li>
</ul>
<p>有一个特殊的IP地址，称之为本机地址，它总是<strong>127.0.0.1</strong>。</p>
<p>IPv4地址实际上是一个32位整数。例如：</p>
<p>106717964 = 0x65ca630c<br>          = 65  ca  63 0c<br>          = 101.202.99.12<br>如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址<strong>127.0.0.1</strong>，还有一个IP地址，例如<strong>101.202.99.12</strong>，可以通过这个IP地址接入网络。</p>
<p>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</p>
<p>如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：</p>
<p>某台计算机的IP是<strong>101.202.99.2</strong>，子网掩码是<strong>255.255.255.0</strong>，那么计算该计算机的网络号是：</p>
<ul>
<li>IP = 101.202.99.2</li>
<li>Mask = 255.255.255.0</li>
<li>Network = IP &amp; Mask = 101.202.99.0</li>
</ul>
<p>每台计算机都需要正确配置IP地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为<strong>网关</strong>。</p>
<p>网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫<strong>路由</strong>。</p>
<p>所以，一台计算机的一个网卡会有3个关键配置：</p>
<p>network</p>
<ul>
<li>IP地址，例如：10.0.2.15</li>
<li>子网掩码，例如：255.255.255.0</li>
<li>网关的IP地址，例如：10.0.2.2<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3>因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。</li>
</ul>
<p>用nslookup可以查看域名对应的IP地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nslookup  https:&#x2F;&#x2F;smalltechnologyjun.com</span><br><span class="line">Server:  xxx.xxx.xxx.xxx</span><br><span class="line">Address: xxx.xxx.xxx.xxx#53</span><br></pre></td></tr></table></figure>

<p>有一个特殊的本机域名<strong>localhost</strong>，它对应的IP地址总是本机地址<strong>127.0.0.1</strong>。</p>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用<strong>分层模型</strong>，每一层负责处理自己的操作。<strong>OSI（Open System Interconnect）网络模型</strong>是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：</p>
<ul>
<li>应用层，提供应用程序之间的通信；</li>
<li>表示层：处理数据格式，加解密等等；</li>
<li>会话层：负责建立和维护会话；</li>
<li>传输层：负责提供端到端的可靠传输；</li>
<li>网络层：负责根据目标地址选择路由来传输数据；</li>
<li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li>
</ul>
<h4 id="互联网实际使用的TCP-IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型："><a href="#互联网实际使用的TCP-IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：" class="headerlink" title="互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型："></a>互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：</h4><pre><code>OSI         TCP/IP 
应用层      应用层 
表示层
会话层
传输层      传输层
网络层      IP层
链路层      网络接口层
物理层
</code></pre>
<h3 id="常用协议"><a href="#常用协议" class="headerlink" title="常用协议"></a>常用协议</h3><p>IP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。</p>
<ul>
<li><p>TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。</p>
</li>
<li><p>UDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。</p>
</li>
</ul>
<p>选择UDP协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择UDP协议。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>计算机网络的基本概念主要有：</p>
<ul>
<li>计算机网络：由两台或更多计算机组成的网络；</li>
<li>互联网：连接网络的网络；</li>
<li>IP地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；</li>
<li>网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；</li>
<li>网络协议：互联网使用TCP/IP协议，它泛指互联网协议簇；</li>
<li>IP协议：一种分组交换传输协议；</li>
<li>TCP协议：一种面向连接，可靠传输的协议；</li>
<li>UDP协议：一种无连接，不可靠传输的协议。</li>
</ul>
]]></content>
      <categories>
        <category>internet</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>5分钟入门入redis</title>
    <url>/2016/11/12/j2ee-2016-05-05-5minute-redis/</url>
    <content><![CDATA[<h3 id="1-redis概述"><a href="#1-redis概述" class="headerlink" title="1.redis概述"></a>1.redis概述</h3><p> redis是一个开源的，先进的 key-value 存储可用于构建高性能的存储解决方案。它支持数据结构有字符串，哈希，列表，集合，带有范围查询的排序集，位图，超文本和具有半径查询的地理空间索引。 NoSQL，Not Only [SQL]，泛指非关系型的数据库。所以redis是一种nosql。<em>敲黑板画重点：redis是一种nosql.</em></p>
 <span id="more"></span>
<p>redis的优点：</p>
<ul>
<li>异常快速</li>
<li>支持丰富的数据类型 </li>
<li>操作都是原子的</li>
</ul>
<h3 id="2-下载安装"><a href="#2-下载安装" class="headerlink" title="2.下载安装"></a>2.下载安装</h3><p>linux 系统下安装：</p>
<pre><code>$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz
$ tar xzf redis-3.2.6.tar.gz
$ cd redis-3.2.6
$ make

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">启动服务器：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    $ src/redis-server
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">启动客户端</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 $ src/redis-cli
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">mac下安装:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
brew install redis
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis-server
redis-cli 

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> windows下安装:</span><br><span class="line"></span><br><span class="line">由于官方并没有提供windows 版本，不过微软为了能够应用redis 到 windows服务器，由微软维护了windows版的redis，下载地址：[点击进入](https:&#x2F;&#x2F;github.com&#x2F;MSOpenTech&#x2F;redis&#x2F;releases).建议下载msi 版本，直接安装即可。</span><br><span class="line"></span><br><span class="line">![sss](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;2279594-ddad8a98ff77bace.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">启动成功：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

[35142] 01 May 14:36:28.939 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf
[35142] 01 May 14:36:28.940 * Max number of open files set to 10032
                _._
              _.-``__ &#39;&#39;-._
        _.-``    `.  `_.  &#39;&#39;-._           Redis 2.6.12 (00000000/0) 64 bit
    .-`` .-```.  ```\/    _.,_ &#39;&#39;-._
  (    &#39;      ,       .-`  | `,    )     Running in stand alone mode
  |`-._`-...-` __...-.``-._|&#39;` _.-&#39;|     Port: 6379
  |    `-._   `._    /     _.-&#39;    |     PID: 35142
    `-._    `-._  `-./  _.-&#39;    _.-&#39;
  |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|
  |    `-._`-._        _.-&#39;_.-&#39;    |           http://redis.io
    `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;
  |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|
  |    `-._`-._        _.-&#39;_.-&#39;    |
    `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;
        `-._    `-.__.-&#39;    _.-&#39;
            `-._        _.-&#39;
                `-.__.-&#39;

[35142] 01 May 14:36:28.941 # Server started, Redis version 2.6.12
[35142] 01 May 14:36:28.941 * The server is now ready to accept connections on port 6379

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">### 3.redis 支持的数据类型</span><br><span class="line"> </span><br><span class="line">#### 3.1字符串</span><br><span class="line">启动客户端 ,存储字符串到redis.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis&gt; SET name forezp
OK
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">取字符串:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 redis&gt; get name 
&quot;forezp&quot;
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 3.2Hashes - 哈希值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

redis &gt; HMSET king username forezp password xxdxx age 22
redis &gt; HGETALL king
1) &quot;username&quot;
2) &quot;forezp &quot;
3) &quot;password &quot;
4) &quot;xxdxx &quot;
5) &quot;age &quot;
6) &quot;22&quot;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 3.3 Lists - 列表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis&gt; lpush pricess jack
(integer) 1
redis 127.0.0.1:6379&gt; lpush pricess jolin
(integer) 2
redis 127.0.0.1:6379&gt; lpush pricess mayun
(integer) 3
redis 127.0.0.1:6379&gt; lrange pricess 0 10
1) &quot;jack&quot;
2) &quot;jolin&quot;
3) &quot;mayun&quot;

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.4 Redis有序集合</span><br><span class="line">Redis有序集合类似Redis集合存储在设定值唯一性。不同的是，一个有序集合的每个成员带有分数，用于以便采取有序set命令，从最小的到最大的分数有关。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis &gt; ZADD kindom 1 redis
(integer) 1
redis&gt; ZADD kindom 2 mongodb
(integer) 1
redis &gt; ZADD kindom 3 mysql
(integer) 1
redis &gt; ZADD kindom 3 mysql
(integer) 0
redis &gt; ZADD kindom 4 mysql
(integer) 0
redis &gt; ZRANGE kindom 0 10 WITHSCORES
1) &quot;redis&quot;
2) &quot;1&quot;
3) &quot;mongodb&quot;
4) &quot;2&quot;
5) &quot;mysql&quot;
6) &quot;4&quot;

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 3.5 Redis发布订阅</span><br><span class="line"></span><br><span class="line">开启客户端作为接受者</span><br></pre></td></tr></table></figure>

redis&gt; SUBSCRIBE myking messages...
 (press Ctrl-C to quit
)1) &quot;subscribe&quot;
2) &quot;myking &quot;
3) (integer) 1

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">开启另一个客户端作为发送者：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis &gt; PUBLISH myking &quot;Redis is a great caching technique&quot;
(integer) 1

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这样接受者就可以收到:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&quot;Redis is a great caching technique&quot;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.6 其他的一些操作</span><br><span class="line"></span><br><span class="line">1.获取所以的key</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis&gt; KEYS *

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2,判断key是否存在</span><br><span class="line"></span><br></pre></td></tr></table></figure>
EXISTS key
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3.删除key </span><br><span class="line"></span><br></pre></td></tr></table></figure>
DEL key [key …]
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4.获取数据类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

TYPE key
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5.向尾部添加</span><br><span class="line"></span><br></pre></td></tr></table></figure>
APPEND key value

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6.获取字符串长度</span><br><span class="line"></span><br></pre></td></tr></table></figure>
strlen key
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">当然这里只是介绍简单的一些操作，复杂的参考官方文档。</span><br><span class="line"></span><br><span class="line">###  4. 在java应用中使用redis---jedis</span><br><span class="line"></span><br><span class="line">前提是redis 已经安装，并且已经开启服务。</span><br><span class="line"></span><br><span class="line"> jedis 下载地址 [https:&#x2F;&#x2F;github.com&#x2F;xetorthio&#x2F;jedis](https:&#x2F;&#x2F;github.com&#x2F;xetorthio&#x2F;jedis)</span><br><span class="line"></span><br><span class="line">&gt;Jedis is a blazingly small and sane [Redis](http:&#x2F;&#x2F;github.com&#x2F;antirez&#x2F;redis) java client.</span><br><span class="line">Jedis was conceived to be EASY to use.</span><br><span class="line"></span><br><span class="line">&gt;翻译： jedis是一个非常小的java客户端，被认为是容易使用。</span><br><span class="line"></span><br><span class="line">*怎么使用？*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

    public static void main(String[] args)&#123;

        Jedis jedis = new Jedis(&quot;localhost&quot;);
        System.out.println(&quot;Connection to server sucessfully&quot;);
        //check whether server is running or not
        System.out.println(&quot;Server is running: &quot;+jedis.ping());
        jedis.lpush(&quot;forezp-list&quot;, &quot;Redis&quot;);
        jedis.lpush(&quot;forezp-list&quot;, &quot;Mongodb&quot;);
        jedis.lpush(&quot;forezp-list&quot;, &quot;Mysql&quot;);
        // Get the stored data and print it
        List&lt;String&gt; list = jedis.lrange(&quot;forezp-list&quot;, 0 ,5);
        for(int i=0; i&lt;list.size(); i++) &#123;
            System.out.println(&quot;Stored string in redis:: &quot;+list.get(i));
        &#125;

    &#125;

```

运行：

&gt; Connection to server sucessfully
Server is running: PONG
Stored string in redis:: Mysql
Stored string in redis:: Mongodb
Stored string in redis:: Redis
Stored string in redis:: Mysql
Stored string in redis:: Mongodb
Stored string in redis:: Redis

 redis 入门介绍就到这里了。另外，*敲黑板，划重点：* 遇到问题首先不要去百度搜，要去官网搜。聪明的你，是不是自己安装下 ，实践下。

### 优秀文章推荐：
* [史上最简单的 SpringCloud 教程 | 终章](http://blog.csdn.net/forezp/article/details/70148833)
* [史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）](http://blog.csdn.net/forezp/article/details/69696915)
* [史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)](http://blog.csdn.net/forezp/article/details/70037513)
</code></pre>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee redis</tag>
      </tags>
  </entry>
  <entry>
    <title>filter</title>
    <url>/2016/11/12/j2ee-2016-05-05-filter-aop/</url>
    <content><![CDATA[<h3 id="一、filter简介"><a href="#一、filter简介" class="headerlink" title="一、filter简介"></a>一、filter简介</h3><p>filter是Servlet规范里的一个高级特性，只用于对request、response的进行修改。</p>
<span id="more"></span>

<p>filter提出了FilterChain的概念，客户端请求request在抵达servlet之前都会经过filterChain里的所有fiter，如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-166a5c28d392f743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="filterchain工作原理，（用processOn画的） "></p>
<h3 id="二、filter的生命周期"><a href="#二、filter的生命周期" class="headerlink" title="二、filter的生命周期"></a>二、filter的生命周期</h3><p>在web.xml中配置filter，当启动服务器时会实例化，并且会初始化，当有网络请求时会进行过滤操作，当 服务器关闭时，会进行销毁，全过程如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0bfdef229be804e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="filter生命周期"></p>
<h3 id="三、编写第一个filter"><a href="#三、编写第一个filter" class="headerlink" title="三、编写第一个filter"></a>三、编写第一个filter</h3><p>filter类需实现fiter接口，需复写里面的三个方法，其中init(),在初始化时调用；doFiler()方法每次都会调用，在这个方法中一定要执行chain.doFilter(),否则request不会交给后面的filter或者servler;ondestroy()在关闭服务器时调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class FirstFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		System.out.println(&quot;destroy---FirstFilter&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">		System.out.println(&quot;start----doFilter--FirstFilter&quot;);		</span><br><span class="line">		chain.doFilter(request, response);</span><br><span class="line">		System.out.println(&quot;end------doFilter--FirstFilter&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">		System.out.println(&quot;init----FirstFilter&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置filter:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">       &lt;filter-name&gt;FirstFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">       &lt;filter-class&gt;com.forezp.filter.FirstFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">       </span><br><span class="line">   &lt;&#x2F;filter&gt;</span><br><span class="line">   &lt;filter-mapping&gt;</span><br><span class="line">       &lt;filter-name&gt;FirstFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;&#x2F;index.jsp&lt;&#x2F;url-pattern&gt; </span><br><span class="line">        &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt; </span><br><span class="line">        &lt;dispatcher&gt;REQUEST&lt;&#x2F;dispatcher&gt; </span><br><span class="line">   &lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，url_pattern可以配置多个，也可以用通配符，当访问满足路径匹配，并且符合dispatcher时，request会被filter拦截进行处理，处理完后的response再次被filter拦截，可以进行处理。</p>
<p>其中dispatcher 默认REQUEST，四种不同的dispatcher：</p>
<ul>
<li>REQUEST:请求时有效</li>
<li>FORWARD:当某servlet通过forward到该servlet才有效</li>
<li>INCLUDE: jsp通过&lt; jsp: incluser/&gt; 请求servlet有效</li>
<li>ERROR: &lt; %@page errorPage=”” % &gt;有效</li>
</ul>
<h3 id="四、防盗链"><a href="#四、防盗链" class="headerlink" title="四、防盗链"></a>四、防盗链</h3><p>filter的特性使它可以处理特殊的工作，例如防盗链，字符编码的处理，日志记录，数据加密，过滤一些黑词等等。</p>
<p>例如： 防盗链图片，当其他网站请求本网站图片资源时显示错误的图片，只有本应用先生的图片才显示正确的图片，代码如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImageFilter implements Filter&#123;</span><br><span class="line">	public void init(FilterConfig config) throws Exception()&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain)throws Exception&#123;</span><br><span class="line">	HttpServletRequest request&#x3D;(HttpServletRequest )req;</span><br><span class="line">	HttpServletResponse  response&#x3D;(HttpServletResponse)res;</span><br><span class="line">	String referer&#x3D;request.getHeader(&quot;referer&quot;);</span><br><span class="line">		if(referer&#x3D;&#x3D;null||!referer.contains(request.getServerName()))&#123;</span><br><span class="line">		request.getRequestDispatcher(&quot;&#x2F;error.png&quot;).forwar(request,response);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		chain.doFilter(request,response);</span><br><span class="line">		  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public void destroy()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 在web.xml中配置：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">		&lt;filter-name&gt;imageFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">		&lt;filter-class&gt;com.forezp.ImageFilter &lt;&#x2F;filter-class&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;imageFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt; &#x2F;images&#x2F;* &lt;&#x2F;url-pattern&gt;</span><br><span class="line"> &lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 当访问images下的所有图片会经过该filter,根据访问头信息，如果说本站点的访问则显示正确图片，否则先生错误图片。</p>
<h3 id="五、字符编码"><a href="#五、字符编码" class="headerlink" title="五、字符编码"></a>五、字符编码</h3><p> 直接上代码：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CharsetFilter implements Filter&#123;</span><br><span class="line">	private String characterEncoding;</span><br><span class="line">	private String enabled;</span><br><span class="line">	public void init(FilterConfig config) throws Exception()&#123;</span><br><span class="line">	characterEncoding&#x3D;config.getInitParameter(&quot;characterEncoding&quot;);</span><br><span class="line">	enabled&#x3D;config.getInitParameter(&quot;enabled&quot;).equals(&quot;true&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain)throws Exception&#123;</span><br><span class="line">		if(enabled|| characterEncoding!&#x3D;null)&#123;</span><br><span class="line">			req.setCharacterEncoding(characterEncoding);</span><br><span class="line">			res.setCharacterEncoding(characterEncoding);</span><br><span class="line">		&#125;</span><br><span class="line">		chain.doFilter(req,res);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void destroy()&#123;</span><br><span class="line">	  characterEncoding&#x3D;null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  在web.xml中配置：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">	&lt;filter-name&gt;CharsetFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">	&lt;filter-class&gt;com.forezp.CharsetFilter &lt;&#x2F;filter-class&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;characterEncoding&lt;&#x2F;param-name&gt;</span><br><span class="line">		&lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">	&lt;&#x2F;init-param&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;enabled&lt;&#x2F;param-name&gt;</span><br><span class="line">		&lt;param-value&gt;true&lt;&#x2F;param-value&gt;</span><br><span class="line">	&lt;&#x2F;init-param&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">	&lt;filter-name&gt;CharsetFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中页面编码方式也必须一致，希望全部用utf-8，另外需要配置Tomcat的／config/server.xml编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; protocal&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">	connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">	redirectPort&#x3D;&quot;8443&quot; URIEncoding&#x3D;&quot;UTF-8&quot;&#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，还有比较常见的日志记录filter、异常捕捉filter、权限校验、内容替换filter等等。</p>
<p>filter有很大的弹性机制，功能强大，而且跟servlet、jsp没耦合.filter是现在面向切面编程aop的一种思想体现，它能够胜任很多工作。</p>
<p>2.5的fiter需要在web.xml中配置，执行顺序按照配置顺序，另外3.0可以用注解的方式配置filter，此时没有配置的顺序。</p>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射</title>
    <url>/2016/11/12/j2ee-2016-05-05-java-refelation/</url>
    <content><![CDATA[<p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。【翻译于 官方文档】</p>
<span id="more"></span>

<p>本篇将从以下几个方面讲述反射的知识：</p>
<ul>
<li>calss的使用</li>
<li>方法的反射</li>
<li>构造函数的反射</li>
<li>成员变量的反射</li>
</ul>
<h3 id="一、什么是class类"><a href="#一、什么是class类" class="headerlink" title="一、什么是class类"></a>一、什么是class类</h3><p>在面向对象的世界里，万物皆对象。类是对象，类是java.lang.Class类的实例对象。另外class类只有java虚拟机才能new出来。任何一个类都是Class 类的实例对象。这实例对象有三种表达方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassTest&#123;</span><br><span class="line">User u&#x3D;new User();</span><br><span class="line"> &#x2F;&#x2F;方式1:</span><br><span class="line"> Class c1&#x3D;User.class;</span><br><span class="line">&#x2F;&#x2F;方式2:</span><br><span class="line">Class c2&#x3D;u.getClass();</span><br><span class="line">&#x2F;&#x2F;方式3:</span><br><span class="line">Class c3&#x3D;Class.forName(&quot;com.forezp.User&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以通过类的类型创建该类的实例对象</span><br><span class="line">User user&#x3D;(User)c1.newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、class类的动态加载"><a href="#二、class类的动态加载" class="headerlink" title="二、class类的动态加载"></a>二、class类的动态加载</h3><p>Class.forName(类的全称);该方法不仅表示了类的类型，还代表了动态加载类。编译时刻加载类是静态加载、运行时刻加载类是动态加载类。</p>
<h3 id="三、获取方法信息"><a href="#三、获取方法信息" class="headerlink" title="三、获取方法信息"></a>三、获取方法信息</h3><p>基本的数据类型，void关键字都Class 类的实例;可以通过get<br>ame();getSimpleName()获取类的名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c1&#x3D;String.class;</span><br><span class="line">Class c2&#x3D;int.class;</span><br><span class="line">Class c3&#x3D;void.class;</span><br><span class="line">System.out.println(c1.getName());</span><br><span class="line">System.out.println(c2.getSimpleName());</span><br></pre></td></tr></table></figure>
<p>获取类的所有方法，并打印出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void printClassInfo(Object object)&#123;</span><br><span class="line">        Class c&#x3D;object.getClass();</span><br><span class="line">        System.out.println(&quot;类的名称：&quot;+c.getName());</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 一个成员方法就是一个method对象</span><br><span class="line">         * getMethod()所有的 public方法，包括父类继承的 public</span><br><span class="line">         * getDeclaredMethods()获取该类所有的方法，包括private ,但不包括继承的方法。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Method[] methods&#x3D;c.getMethods();&#x2F;&#x2F;获取方法</span><br><span class="line">        &#x2F;&#x2F;获取所以的方法，包括private ,c.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;methods.length;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;得到方法的返回类型</span><br><span class="line">            Class returnType&#x3D;methods[i].getReturnType();</span><br><span class="line">            System.out.print(returnType.getName());</span><br><span class="line">            &#x2F;&#x2F;得到方法名：</span><br><span class="line">            System.out.print(methods[i].getName()+&quot;(&quot;);</span><br><span class="line"></span><br><span class="line">            Class[] parameterTypes&#x3D;methods[i].getParameterTypes();</span><br><span class="line">            for(Class class1:parameterTypes)&#123;</span><br><span class="line">                System.out.print(class1.getName()+&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReflectTest &#123;</span><br><span class="line"></span><br><span class="line">        public static void main(String[] args)&#123;</span><br><span class="line">                String s&#x3D;&quot;ss&quot;;</span><br><span class="line">                ClassUtil.printClassInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<blockquote>
<p>类的名称：java.lang.String</p>
<p>booleanequals(java.lang.Object,)</p>
</blockquote>
<blockquote>
<p>java.lang.StringtoString()</p>
</blockquote>
<blockquote>
<p>inthashCode()</p>
<p>…</p>
</blockquote>
<h3 id="四、获取成员变量的信息"><a href="#四、获取成员变量的信息" class="headerlink" title="四、获取成员变量的信息"></a>四、获取成员变量的信息</h3><p>也可以获取类的成员变量信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static void printFiledInfo(Object o)&#123;</span><br><span class="line"></span><br><span class="line">       Class c&#x3D;o.getClass();</span><br><span class="line">       &#x2F;**</span><br><span class="line">        * getFileds()获取public</span><br><span class="line">        * getDeclaredFields()获取所有</span><br><span class="line">        *&#x2F;</span><br><span class="line">       Field[] fileds&#x3D;c.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">       for(Field f:fileds)&#123;</span><br><span class="line">           &#x2F;&#x2F;获取成员变量的类型</span><br><span class="line">           Class filedType&#x3D;f.getType();</span><br><span class="line">           System.out.println(filedType.getName()+&quot; &quot;+f.getName());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">               String s&#x3D;&quot;ss&quot;;</span><br><span class="line">               &#x2F;&#x2F;ClassUtil.printClassInfo(s);</span><br><span class="line">               ClassUtil.printFiledInfo(s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<blockquote>
<p>[C value<br>int hash<br>long serialVersionUID<br>[Ljava.io.ObjectStreamField; serialPersistentFields<br>java.util.Comparator CASE_INSENSITIVE_ORDER<br>int HASHING_SEED<br>int hash32</p>
</blockquote>
<h3 id="五、获取构造函数的信息"><a href="#五、获取构造函数的信息" class="headerlink" title="五、获取构造函数的信息"></a>五、获取构造函数的信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void printConstructInfo(Object o)&#123;</span><br><span class="line">        Class c&#x3D;o.getClass();</span><br><span class="line"></span><br><span class="line">        Constructor[] constructors&#x3D;c.getDeclaredConstructors();</span><br><span class="line">        for (Constructor con:constructors)&#123;</span><br><span class="line">            System.out.print(con.getName()+&quot;(&quot;);</span><br><span class="line"></span><br><span class="line">            Class[] typeParas&#x3D;con.getParameterTypes();</span><br><span class="line">            for (Class class1:typeParas)&#123;</span><br><span class="line">                System.out.print(class1.getName()+&quot; ,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">               String s&#x3D;&quot;ss&quot;;</span><br><span class="line">               &#x2F;&#x2F;ClassUtil.printClassInfo(s);</span><br><span class="line">               &#x2F;&#x2F;ClassUtil.printFiledInfo(s);</span><br><span class="line">               ClassUtil.printConstructInfo(s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行：</p>
<blockquote>
<p>java.lang.String([B ,)<br>java.lang.String([B ,int ,int ,)<br>java.lang.String([B ,java.nio.charset.Charset ,)<br>java.lang.String([B ,java.lang.String ,)<br>java.lang.String([B ,int ,int ,java.nio.charset.Charset ,)<br>java.lang.String(int ,int ,[C ,)<br>java.lang.String([C ,boolean ,)<br>java.lang.String(java.lang.StringBuilder ,)<br>java.lang.String(java.lang.StringBuffer ,)</p>
</blockquote>
<blockquote>
<p>…</p>
</blockquote>
<h3 id="六、方法反射的操作"><a href="#六、方法反射的操作" class="headerlink" title="六、方法反射的操作"></a>六、方法反射的操作</h3><p>获取一个方法：需要获取方法的名称和方法的参数才能决定一个方法。</p>
<p>方法的反射操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method.invoke(对象，参数列表);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">    public void add(int a,int b)&#123;</span><br><span class="line">        System.out.print(a+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void toUpper(String a)&#123;</span><br><span class="line">        System.out.print(a.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       A a&#x3D;new A();</span><br><span class="line">       Class c&#x3D;a.getClass();</span><br><span class="line">       try &#123;</span><br><span class="line">           Method method&#x3D;c.getMethod(&quot;add&quot;,new Class[]&#123;int.class,int.class&#125;);</span><br><span class="line">           &#x2F;&#x2F;也可以 Method method&#x3D;c.getMethod(&quot;add&quot;,int.class,int.class);</span><br><span class="line">           &#x2F;&#x2F;方法的反射操作</span><br><span class="line">           method.invoke(a,10,10);</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行：</p>
<blockquote>
<p>20</p>
</blockquote>
<p>本篇文章已经讲解了java反射的基本用法， 它可以在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。</p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>jsp详解</title>
    <url>/2016/11/12/j2ee-2016-05-05-jsp-detail/</url>
    <content><![CDATA[<p>###一、什么是Jsp<br>jsp是一种基于文本的程序，全名java server page,其特点是html和java程序共存。执行时jsp会被运行容器编译，编译后的jsp跟servlet一样，因此jsp是另一种形式的servlet。</p>
<span id="more"></span>

<h3 id="二、jsp页面组成"><a href="#二、jsp页面组成" class="headerlink" title="二、jsp页面组成"></a>二、jsp页面组成</h3><p>jsp 页面包括以下内容：</p>
<ul>
<li>静态内容 </li>
<li>指令</li>
<li>表达式</li>
<li>小脚本</li>
<li>声明</li>
<li>注释</li>
</ul>
<p><em>1.指令：</em></p>
<ul>
<li>page指令：  通常位于jsp页面的顶端，同一个页面可以有多个page指令。</li>
<li>include指令：将一个外部文件嵌入到jsp文件中。</li>
<li>taglib指令 ：使用标签定义新的自定义标签。</li>
</ul>
<p><em>1.1其中page指令语法：</em></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page 属性&#x3D;“属性值”&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>属性</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>language</td>
<td>java</td>
</tr>
<tr>
<td>import</td>
<td>“”</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><em>1.2</em> include 指令</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ include file&#x3D;&quot;url&quot; %&gt;</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">*1.3 动作*</span><br><span class="line"></span><br><span class="line">* include动作</span><br><span class="line"></span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>&lt;jsp:include page=”url” flush=”true”/&gt;</td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">  *include 动作和include指令区别*</span><br><span class="line">  </span><br><span class="line"> 描述  | include指令  |  include 动作</span><br><span class="line">--- | --- | ---    </span><br><span class="line">  语法 | &lt; % @ include file&#x3D;&quot;&quot;&#x2F;&gt; | &lt; jsp:include page&#x3D;&quot;url&quot; flush&#x3D;&quot;true&quot;&#x2F;&gt;    </span><br><span class="line">  发生时间 | 页面转换期间 | 请求期间</span><br><span class="line">  包含内容 | 文件实际内容 |  页面的输出</span><br><span class="line">  转化servlet | 一个servlet |  2个servlet</span><br><span class="line">  编译时间 | 较慢 | 较快</span><br><span class="line">  执行时间 | 稍快 |较慢--每次资源必须被编译</span><br><span class="line">  </span><br><span class="line">  *forward动作*</span><br><span class="line">  </span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>&lt;jsp:forward page=”url”/&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>==</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td>request.getRequestDispatcher(“/url”).forward(res,resp);</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*param动作*</span><br><span class="line"></span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>&lt;jsp:param name=”参数名” value=”参数值”/&gt;</td>
<td></td>
</tr>
<tr>
<td>常常与<a href="jsp:forward">jsp:forward</a>一起使用</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br></pre></td></tr></table></figure></td>
<td></td>
</tr>
<tr>
<td>&lt;jsp:forward page=”user.jsp”&gt;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<pre><code>  &lt;jsp:param name=&quot;email&quot;  value=&quot;1233@154.com&quot;/&gt;
</code></pre>
<p>   </jsp:forward></p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*2.jsp注释* </span><br><span class="line"></span><br><span class="line">* html注释</span><br><span class="line"></span><br></pre></td></tr></table></figure>
  <!-- html注释 -->//客户端可见
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* jsp 注释 </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  &lt;%– jsp注释 –%&gt;//客户端不可见<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* jsp 脚本注释  &#x2F;&#x2F;客户端不可见</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>  //单行注射<br>  ／** 多行注释*／<br>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*3.jsp脚本* </span><br><span class="line"></span><br><span class="line">在jsp页面中执行的java代码，语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure><br>&lt;%   java 代码 %&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*4.jsp声明* </span><br><span class="line">在jsp页面定义变量或者方法，语法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;%! java 代码  %&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">举例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;%!<br> String s=”adele”;<br> int add(int x,int y){<br>    return x+y;<br> }<br>%&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*5.jsp表达式* </span><br><span class="line">在jsp页面执行的表达式，语法：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;% =表达式 %&gt;// 表达式不以分号结尾</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">举例：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;%!<br> String s=”adele”;</p>
<p>%&gt;</p>
<h2>  hello,<%=s %> </h2>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 三、jsp生命周期</span><br><span class="line"></span><br><span class="line">![CC36B22A-503E-4C29-98BB-3B58038C140E.png](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;2279594-70294c4b278ed9b9.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br><span class="line">jspService()是用来处理客户端请求的，对于每一个请求，服务器会创建一个新的线程来处理该请求。以多线程方式执行大大降低对系统的资源需求，提高系统的并发量和缩短了响应时间，servlet是常驻在服务器内存中。</span><br><span class="line"></span><br><span class="line">它同servlet 一样，jsp 实例初始化和销毁也会调用sevlet的init() 和destroy();</span><br><span class="line">另外jsp还有自己的初始化方法_jspInit();_jspDestroy();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;%@ page language=”java” contentType=”text/html”;charset=”utf-8”&gt;</p>
<p>&lt;%!<br>public void _jspInit(){<br>}<br>public void _jspDestroy(){<br>}<br>%&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 四、javaben的使用</span><br><span class="line"></span><br><span class="line">*动作元素：*</span><br><span class="line">动作元素为请求处理阶段提供信息。</span><br><span class="line"></span><br><span class="line">![Paste_Image.png](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;2279594-cd9657ce138ebed4.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在jsp页面使用javaben</span><br><span class="line"></span><br><span class="line">* 像普通的java类一样，创建javabean;</span><br><span class="line">*  在jsp使用动作标签来使用 javaben</span><br><span class="line"></span><br><span class="line">相关标签如下：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&lt;jsp:useBwan id=”” class=”” scope=”” /&gt;</p>
<p>&lt;jsp:setProperty name=”javabean 是例”  property=”*”/&gt;(跟表单关联)</p>
<p>&lt;jsp:setProperty name=”javabean 是例”  property=”javaben 属性名”/&gt;(跟表单关联)</p>
<p>&lt;jsp:setProperty name=”javabean 是例”  property=”javaben 属性名”  value=””/&gt;(手动设置)</p>
<p>&lt;jsp:setProperty name=”javabean 是例”  property=”javaben 属性名”  param=”request对象参数”/&gt;(跟request参数关联)</p>
<p>&lt;jsp:getProperty name=”” property=””/&gt;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">举个例子：</span><br><span class="line">首先用户 在login.jsp提交表单，然后用户在dologin.jsp 根据动作标签获取参数。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">login.jsp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

 <form name="loginForm" action="dologin.jsp?mypass=999999" method="post">
      <table>
        <tr>
          <td>用户名：</td>
          <td><input type="text" name="username" value=""/></td>
        </tr>
        <tr>
          <td>密码：</td>
          <td><input type="password" name="password" value=""/></td>
        </tr>
        <tr>
          <td colspan="2" align="center"><input type="submit" value="登录"/></td>
          
        </tr>
      </table>
    </form>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">dologin.jsp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<body>
    <jsp:useBean id="myUsers" class="com.po.Users" scope="page"/>
    <h1>setProperty动作元素</h1>
    <hr>
   <!--根据表单自动匹配所有的属性 -->
   <%-- 
   <jsp:setProperty name="myUsers" property="*"/>  
   --%>
   <!--根据表单匹配所有部分的属性 -->
   <%-- 
   <jsp:setProperty name="myUsers" property="username"/>  
   --%>
   <!--根表单无关，通过手工赋值给属性 -->
   <%-- 
   <jsp:setProperty name="myUsers" property="username" value="lisi"/>
   <jsp:setProperty name="myUsers" property="password" value="888888"/>
   --%>
   <!--通过URL传参数给属性赋值 -->
   <jsp:setProperty name="myUsers" property="username"/>
   <jsp:setProperty name="myUsers" property="password" param="mypass"/>
   <!-- 使用传统的表达式方式来获取用户名和密码 -->
   <%--     
       用户名：<%=myUsers.getUsername() %><br>
       密码：<%=myUsers.getPassword() %><br> 
   --%>
   <!-- 使用getProperty方式来获取用户名和密码 -->
      用户名：<jsp:getProperty name="myUsers" property="username"/> <br>
      密码：<jsp:getProperty name="myUsers" property="password"/><br>
   <br>
   <br>
      <a href="testScope.jsp">测试javabean的四个作用域范围</a>
      <% 
         request.getRequestDispatcher("testScope.jsp").forward(request, response);
      %>
  </body>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*javaben 四大作用域*</span><br><span class="line"></span><br><span class="line">* page ，仅当前页面有效</span><br><span class="line">* request  ,通过httpRequest.getAttribute()获取jvabean对象</span><br><span class="line">* session ,通过httpSession.getAttribute() 获取javabean对象</span><br><span class="line">* application，通过application.getAttribute方法获取javabean 对象。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 五、cookie</span><br><span class="line"></span><br><span class="line">*1.概述：*</span><br><span class="line"></span><br><span class="line">由于http协议的无状态，无法保存用户的状态，所以需要用session和cookie.</span><br><span class="line"></span><br><span class="line">cookie 是web服务器保存在客户端的一系列文本信息。它的作用时记录一些用户的行为，简化登陆，但是容易泄露用户信息。</span><br><span class="line"></span><br><span class="line">*2.jsp创建和使用cookie*</span><br><span class="line"></span><br><span class="line">* 创建cookie</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Cookie cookie=new Cookie(String ,Object);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 写入cookie</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>response.addCookie(cookie);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">* 读取 cookie</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Cookie[] cookies=request.getCookies();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*3.cookie的常用方法*</span><br><span class="line"></span><br><span class="line">* setMaxAge();</span><br><span class="line">* setValue();</span><br><span class="line">* getName();</span><br><span class="line">* getValue();</span><br><span class="line">* getMaxAge();</span><br><span class="line"></span><br><span class="line">举个列子： 使用cookie记住用户登陆的账号密码；</span><br><span class="line"></span><br><span class="line">登陆界面：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<body>
    <h1>用户登录</h1>
    <hr>
    <% 
      request.setCharacterEncoding("utf-8");
      String username="";
      String password = "";
      Cookie[] cookies = request.getCookies();
      if(cookies!=null&&cookies.length>0)
      {
           for(Cookie c:cookies)
           {
              if(c.getName().equals("username"))
              {
                   username =  URLDecoder.decode(c.getValue(),"utf-8");
              }
              if(c.getName().equals("password"))
              {
                   password =  URLDecoder.decode(c.getValue(),"utf-8");
              }
           }
      }
    %>
    <form name="loginForm" action="dologin.jsp" method="post">
       <table>
         <tr>
           <td>用户名：</td>
           <td><input type="text" name="username" value="<%=username %>"/></td>
         </tr>
         <tr>
           <td>密码：</td>
           <td><input type="password" name="password" value="<%=password %>" /></td>
         </tr>
         <tr>
           <td colspan="2"><input type="checkbox" name="isUseCookie" checked="checked"/>十天内记住我的登录状态</td>
         </tr>
         <tr>
           <td colspan="2" align="center"><input type="submit" value="登录"/><input type="reset" value="取消"/></td>
         </tr>
       </table>
    </form>
  </body>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">处理登陆逻辑的jsp</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <body>
    <h1>登录成功</h1>
    <hr>
    <br>
    <br>
    <br>
    <% 
       request.setCharacterEncoding("utf-8");
       //首先判断用户是否选择了记住登录状态
       String[] isUseCookies = request.getParameterValues("isUseCookie");
       if(isUseCookies!=null&&isUseCookies.length>0)
       {
          //把用户名和密码保存在Cookie对象里面
          String username = URLEncoder.encode(request.getParameter("username"),"utf-8");
          //使用URLEncoder解决无法在Cookie当中保存中文字符串问题
          String password = URLEncoder.encode(request.getParameter("password"),"utf-8");
          
          Cookie usernameCookie = new Cookie("username",username);
          Cookie passwordCookie = new Cookie("password",password);
          usernameCookie.setMaxAge(864000);
          passwordCookie.setMaxAge(864000);//设置最大生存期限为10天
          response.addCookie(usernameCookie);
          response.addCookie(passwordCookie);
       }
       else
       {
          Cookie[] cookies = request.getCookies();
          if(cookies!=null&&cookies.length>0)
          {
             for(Cookie c:cookies)
             {
                if(c.getName().equals("username")||c.getName().equals("password"))
                {
                    c.setMaxAge(0); //设置Cookie失效
                    response.addCookie(c); //重新保存。
                }
             }
          }
       }
    %>
    <a href="users.jsp" target="_blank">查看用户信息</a>
    
  </body>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">使用cookie获取用户信息：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 <body>
    <h1>用户信息</h1>
    <hr>
    <% 
      request.setCharacterEncoding("utf-8");
      String username="";
      String password = "";
      Cookie[] cookies = request.getCookies();
      if(cookies!=null&&cookies.length>0)
      {
           for(Cookie c:cookies)
           {
              if(c.getName().equals("username"))
              {
                   username = URLDecoder.decode(c.getValue(),"utf-8");
              }
              if(c.getName().equals("password"))
              {
                   password = URLDecoder.decode(c.getValue(),"utf-8");
              }
           }
      }
    %>
    <BR>
    <BR>
    <BR>
         用户名：<%=username %><br>
         密码：<%=password %><br>
  </body>

<pre><code>
*3.cookie和 session的区别*

session |cookie 
--- | ---
在服务端保存信息 | 在客户端保存信息
保存的 object类型 | 保存的是 string 类型
随会话结束，销毁数据 | 可以长期保存在客户端中
重要信息 | 不重要信息
</code></pre>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet</title>
    <url>/2016/11/12/j2ee-2016-05-05-java-servlet/</url>
    <content><![CDATA[<p>###一、什么是servlet</p>
<p>servlet是在服务器上运行的小程序。一个servlet就是一个 java类，并且通过“请求-响应”编程模型来访问的这个驻留在服务器内存里的程序。</p>
<span id="more"></span>

<p>继承关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">servlet(interface)-&gt;init(),service(),destroy();</span><br><span class="line">^</span><br><span class="line">genericServlet(abstract class)-&gt;与协议无关</span><br><span class="line">^</span><br><span class="line">httpServlet(abstract class)-&gt;实现了http协议</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>servlet 是一个接口，genericServlet是它的一个抽象实现类，但它没有实现任何的协议，httpServlet是genericServlet的子类，实现了http协议，一般我们写servlet需要继承httpServlet。</p>
</blockquote>
<p>###二、手工书写第一个servlet程序<br>1.创建一个web工程，新建一个 servlet包，创建一个HelloServlet类。需要复写doGet()和doPost()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void doGet(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		System.out.println(&quot;get method invoke&quot;);</span><br><span class="line">		PrintWriter out&#x3D;resp.getWriter();</span><br><span class="line">		out.print(&quot;hello get method&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void doPost(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		System.out.println(&quot;post method invoke&quot;);</span><br><span class="line">		PrintWriter out&#x3D;resp.getWriter();</span><br><span class="line">		out.print(&quot;hi post method&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在index.jsp上写两个访问servelet的路径方法。其中，&lt; a &gt;标签，是get请求，form表单指明post请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; import&#x3D;&quot;java.util.*&quot; pageEncoding&#x3D;&quot;utf-8&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String path &#x3D; request.getContextPath();</span><br><span class="line">String basePath &#x3D; request.getScheme()+&quot;:&#x2F;&#x2F;&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;&#x2F;&quot;;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href&#x3D;&quot;&lt;%&#x3D;basePath%&gt;&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;title&gt;servelet first&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;pragma&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;cache-control&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;0&quot;&gt;    </span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;keywords&quot; content&#x3D;&quot;keyword1,keyword2,keyword3&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;description&quot; content&#x3D;&quot;This is my page&quot;&gt;</span><br><span class="line">	&lt;!--</span><br><span class="line">	&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;styles.css&quot;&gt;</span><br><span class="line">	--&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;first servlet&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;servlet&#x2F;HelloServlet&quot;&gt;Get方式请求servlet&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;servlet&#x2F;HelloServlet&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Post方式请求servlet&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>配置web.xml，需配置servlet的名字和具体的类名，以及访问路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app version&#x3D;&quot;2.5&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee </span><br><span class="line">	http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_2_5.xsd&quot;&gt;</span><br><span class="line">	&lt;display-name&gt;&lt;&#x2F;display-name&gt;</span><br><span class="line">	&lt;welcome-file-list&gt;</span><br><span class="line">		&lt;welcome-file&gt;index.jsp&lt;&#x2F;welcome-file&gt;</span><br><span class="line">	&lt;&#x2F;welcome-file-list&gt;</span><br><span class="line"></span><br><span class="line">	&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;&lt;!-- servlet的名字 --&gt;</span><br><span class="line">		&lt;servlet-class&gt;servlet.HelloServlet&lt;&#x2F;servlet-class&gt;&lt;!-- servlet的具体类型，需要带包名 --&gt;</span><br><span class="line">	&lt;&#x2F;servlet&gt;</span><br><span class="line">	&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;&lt;!-- servlet 名字 --&gt;</span><br><span class="line">	&lt;url-pattern&gt;&#x2F;servlet&#x2F;HelloServlet&lt;&#x2F;url-pattern&gt; &lt;!-- servlet访问路径 --&gt;</span><br><span class="line">	&lt;&#x2F;servlet-mapping&gt;</span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>
<p>部署该工程，运行，访问index.jsp界面，分别点击超链接和form表单，控制台输出类容：</p>
<blockquote>
<p>get method invoke</p>
<p>post method invoke</p>
</blockquote>
<p>这说明，通过页面的访问，点击超链接和form表单提交按钮，分别访问了servelet里的doGet()和doPost().</p>
<p>这里以get请求来说一下 servlet的执行顺序，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-c1784d7afba86584.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="get请求执行流程"></p>
<h3 id="三、servlet的生命周期"><a href="#三、servlet的生命周期" class="headerlink" title="三、servlet的生命周期"></a>三、servlet的生命周期</h3><ul>
<li>初始化阶段，可以是在服务器启动初始化，也可以在第一次调用初始化，生成实例。</li>
<li>调用init();</li>
<li>调用servicr();判断是哪一种请求，get请求会调用doGet(),post请求调用doPost();</li>
<li>在服务器停止的时候，调用destroy();</li>
</ul>
<p>几个知识点：</p>
<ul>
<li>Servlet 启动时自动装载servlet，需要在 web.xml配置，在<servlet></servlet>之间添加如下代码：&lt; loadon-starup &gt;1&lt; /loadon-starup&gt;,数字越小，优先级越高。如果不配置，则第一次访问servlet时装载。</li>
<li>servlet被加载的时候，会调用init()方法，在整个生命周期中init（） 只会调用一次，装载后，实例贮存在服务器的内存中。</li>
</ul>
<h3 id="四、Servlet获取表单数据"><a href="#四、Servlet获取表单数据" class="headerlink" title="四、Servlet获取表单数据"></a>四、Servlet获取表单数据</h3><p>post提交表单，form的method属性设为post, 浏览器即以post方式提交表单内容，与get方式一样，servlet可以通过httpServletRequest对象的getParameter(String para)方式获取param对应的参数值。</p>
<p>如下是jsp提交表单的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;用户注册&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;form name&#x3D;&quot;regForm&quot; action&#x3D;&quot;servlet&#x2F;RegServlet&quot; method&#x3D;&quot;post&quot; &gt;</span><br><span class="line">			  &lt;table border&#x3D;&quot;0&quot; width&#x3D;&quot;800&quot; cellspacing&#x3D;&quot;0&quot; cellpadding&#x3D;&quot;0&quot;&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;lalel&quot;&gt;用户名：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;密码：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;mypassword&quot; &gt;&lt;&#x2F;td&gt;</span><br><span class="line">			    	</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;确认密码：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;confirmpass&quot; &gt;&lt;&#x2F;td&gt;</span><br><span class="line">			    	</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;电子邮箱：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot; &gt;&lt;&#x2F;td&gt;</span><br><span class="line">			    	</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;性别：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; checked&#x3D;&quot;checked&quot; value&#x3D;&quot;Male&quot;&gt;男&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;Female&quot;&gt;女&lt;&#x2F;td&gt;</span><br><span class="line">			    	</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			   </span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;出生日期：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;</span><br><span class="line">			    	  &lt;input name&#x3D;&quot;birthday&quot; type&#x3D;&quot;text&quot; id&#x3D;&quot;control_date&quot; size&#x3D;&quot;10&quot;</span><br><span class="line">                      maxlength&#x3D;&quot;10&quot; onclick&#x3D;&quot;new Calendar().show(this);&quot; readonly&#x3D;&quot;readonly&quot; &#x2F;&gt;</span><br><span class="line">			    	&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;爱好：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;</span><br><span class="line">			    	&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;nba&quot;&gt; NBA  </span><br><span class="line">			    	  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;music&quot;&gt; 音乐  </span><br><span class="line">			    	  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;movie&quot;&gt; 电影  </span><br><span class="line">			    	  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;internet&quot;&gt; 上网  </span><br><span class="line">			    	&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;自我介绍：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;</span><br><span class="line">			    		&lt;textarea name&#x3D;&quot;introduce&quot; rows&#x3D;&quot;10&quot; cols&#x3D;&quot;40&quot;&gt;&lt;&#x2F;textarea&gt;</span><br><span class="line">			    	&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;接受协议：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;</span><br><span class="line">			    		&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;isAccept&quot; value&#x3D;&quot;true&quot;&gt;是否接受霸王条款</span><br><span class="line">			    	&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">			    		&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&#x2F;&gt;  </span><br><span class="line">			    	    &lt;input type&#x3D;&quot;reset&quot; value&#x3D;&quot;取消&quot;&#x2F;&gt;  </span><br><span class="line">			    	&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			  &lt;&#x2F;table&gt;</span><br><span class="line">			&lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>其中兴趣爱好为多个，即字符串数组，需要使用 httpServletRequest的getParameters(String param)获取.</p>
<p>下面是servlet接受信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line"></span><br><span class="line">			username &#x3D; request.getParameter(&quot;username&quot;);</span><br><span class="line">			mypassword &#x3D; request.getParameter(&quot;mypassword&quot;);</span><br><span class="line">			gender &#x3D; request.getParameter(&quot;gender&quot;);</span><br><span class="line">			email &#x3D; request.getParameter(&quot;email&quot;);</span><br><span class="line">			introduce &#x3D; request.getParameter(&quot;introduce&quot;);</span><br><span class="line">			birthday &#x3D; sdf.parse(request.getParameter(&quot;birthday&quot;));</span><br><span class="line">			if(request.getParameterValues(&quot;isAccpet&quot;)!&#x3D;null)</span><br><span class="line">			&#123;</span><br><span class="line">			  isAccept &#x3D; request.getParameter(&quot;isAccept&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">			  isAccept &#x3D; &quot;false&quot;;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;用来获取多个复选按钮的值</span><br><span class="line">			favorites &#x3D; request.getParameterValues(&quot;favorite&quot;);</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h3 id="五、Servlet之间的跳转"><a href="#五、Servlet之间的跳转" class="headerlink" title="五、Servlet之间的跳转"></a>五、Servlet之间的跳转</h3><p><em>1.转向（forward)</em></p>
<p>转向是通过requestDispatcher对象的forward(httpServletRequest req,HttpServletResponse res)方法来实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;&#x2F;servlet&#x2F;LifeCycleServlet&quot;).forward(request,response);</span><br></pre></td></tr></table></figure>
<p>其中getRequestDispatcher方法的参数，必须以“／”开头，表示web的根目录，比如要<br>跳转：　“<a target="_blank" rel="noopener" href="http://locahost:8080/servlet/servet/LifeCycleServlet&quot;">http://locahost:8080/servlet/servet/LifeCycleServlet&quot;</a>, 则参数为”/servlet/LifeCycleServlet”.</p>
<p><em>2.重定向（redirect)</em><br>通过httpServlet的sendDirect(String location)方法。</p>
<h3 id="六、获取初始化参数"><a href="#六、获取初始化参数" class="headerlink" title="六、获取初始化参数"></a>六、获取初始化参数</h3><p>1.在 web.xml中配置servlet时，可以配置一些初始化参数，在servlet可以通过servletConfig接口提供的接口获取这些参数。</p>
<p>在web.xml中配置init-param 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;&lt;!-- servlet的名字 --&gt;</span><br><span class="line">		&lt;servlet-class&gt;servlet.HelloServlet&lt;&#x2F;servlet-class&gt;&lt;!-- servlet的具体类型，需要带包名 --&gt;</span><br><span class="line">		&lt;init-param&gt;</span><br><span class="line">			&lt;param-name&gt;username&lt;&#x2F;param-name&gt;</span><br><span class="line">			&lt;param-value&gt;forezp&lt;&#x2F;param-value&gt;</span><br><span class="line">		&lt;&#x2F;init-param&gt;</span><br><span class="line">	&lt;&#x2F;servlet&gt;</span><br></pre></td></tr></table></figure>
<p>在servlet中获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void init() throws ServletException &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		super.init();</span><br><span class="line">		String name&#x3D;this.getInitParameter(&quot;username&quot;);</span><br><span class="line">		System.out.println(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署项目，访问helloServlet就可以看见在控制台打印了forezp</p>
<p>2.也可以配置一些全局的参数:context-param.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;web-app version&#x3D;&quot;2.5&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee </span><br><span class="line">	http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_2_5.xsd&quot;&gt;</span><br><span class="line">	&lt;display-name&gt;&lt;&#x2F;display-name&gt;</span><br><span class="line">	&lt;welcome-file-list&gt;</span><br><span class="line">		&lt;welcome-file&gt;index.jsp&lt;&#x2F;welcome-file&gt;</span><br><span class="line">	&lt;&#x2F;welcome-file-list&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;context-param&gt;</span><br><span class="line">		&lt;param-name&gt;haha&lt;&#x2F;param-name&gt;</span><br><span class="line">		&lt;param-value&gt;xixi&lt;&#x2F;param-value&gt;</span><br><span class="line">	&lt;&#x2F;context-param&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;&#x2F;web-app&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取方式：</p>
<p>servlet中通过getServletContext()获取servletContext对象，使用ServletContext的getInitParameter()方法获取制定参数名来获取参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServletContext servletContext&#x3D;getServletConfig().getServletContext();</span><br><span class="line">		String str&#x3D;servletContext.getInitParameter(&quot;haha&quot;);</span><br><span class="line">		System.out.println(str);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="七、servlet九大内置对象"><a href="#七、servlet九大内置对象" class="headerlink" title="七、servlet九大内置对象"></a>七、servlet九大内置对象</h3><p><img src="http://upload-images.jianshu.io/upload_images/2279594-721dfc4ed65824ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>本篇文章是我在学习 servlet的一个总结，参考资料包括《javaweb整合王者归来》，慕课网上的sevlet基础视频。下一篇文章讲讲述jsp的相关内容，尽情期待，感谢大家。</p>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>jsp九大内置对象</title>
    <url>/2016/11/12/j2ee-2016-05-05-jsp-9-object/</url>
    <content><![CDATA[<p>jsp内置对象对象是web容器创建的一组对象，不使用new关键词久可以使用的内置对象。<br>九大内置对象包括以下：</p>
<ul>
<li>out  –JspWriter</li>
<li>request –ServletRequest</li>
<li>reponse –ServletResponse</li>
<li>config –ServletConfig</li>
<li>session –HttpSession</li>
<li>application –ServlerContext</li>
<li>page –HttpJspPage</li>
<li>pageContext –PageContext</li>
<li>exception –Exception</li>
</ul>
<span id="more"></span>

<h3 id="1、out对象"><a href="#1、out对象" class="headerlink" title="1、out对象"></a>1、out对象</h3><p>JspWriter类实例，是向客户端负责输出内容的。<br>常用方法如下：</p>
<ul>
<li>println();</li>
<li>clear (),如果在flush()之后调用会抛出异常。</li>
<li>clearBuffer();</li>
<li>flush();</li>
<li>isAutoFlush();</li>
</ul>
<p>举例子：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;h1&gt;out内置对象&lt;&#x2F;h1&gt;</span><br><span class="line">   &lt;% </span><br><span class="line">      out.println(&quot;&lt;h2&gt;静夜思&lt;&#x2F;h2&gt;&quot;);</span><br><span class="line">      out.println(&quot;床前明月光&lt;br&gt;&quot;);</span><br><span class="line">      out.println(&quot;疑是地上霜&lt;br&gt;&quot;);</span><br><span class="line">      out.flush();</span><br><span class="line">      &#x2F;&#x2F;out.clear();&#x2F;&#x2F;这里会抛出异常。</span><br><span class="line">      out.clearBuffer();&#x2F;&#x2F;这里不会抛出异常。</span><br><span class="line">      out.println(&quot;举头望明月&lt;br&gt;&quot;);</span><br><span class="line">      out.println(&quot;低头思故乡&lt;br&gt;&quot;);</span><br><span class="line">   </span><br><span class="line">   %&gt;</span><br><span class="line">       缓冲区大小：&lt;%&#x3D;out.getBufferSize() %&gt;byte&lt;br&gt;</span><br><span class="line">       缓冲区剩余大小：&lt;%&#x3D;out.getRemaining() %&gt;byte&lt;br&gt;</span><br><span class="line">      是否自动清空缓冲区：&lt;%&#x3D;out.isAutoFlush() %&gt;&lt;BR&gt;    </span><br><span class="line"> &lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2、request对象"><a href="#2、request对象" class="headerlink" title="2、request对象"></a>2、request对象</h3><p> 客户端的请求被封装在request对象中，通过它可以了解客户端的请求，然后作出响应，request请求具有request请求域。<br> 常用方法：</p>
<ul>
<li>getParameter(String name)</li>
<li>getParamterValues(String name)</li>
<li>setAttribute(String name,Onject o)</li>
<li>getAttribute(string name)</li>
<li>getContetType();</li>
<li>getProtocol()</li>
<li>getServerName();</li>
</ul>
<p> 举个例子：用户注册提交数据给request.jsp，在request.jsp页面根据request对象可以获取提交过来的数据。</p>
<p> reg.jsp 注册jsp</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;h1&gt;用户注册&lt;&#x2F;h1&gt;</span><br><span class="line">   &lt;hr&gt;</span><br><span class="line">   &lt;% </span><br><span class="line">      int number&#x3D;-1;</span><br><span class="line">      &#x2F;&#x2F;说明用户第一次访问页面，计数器对象还未创建</span><br><span class="line">      if(application.getAttribute(&quot;counter&quot;)&#x3D;&#x3D;null)</span><br><span class="line">      &#123;</span><br><span class="line">          application.setAttribute(&quot;counter&quot;, 0);</span><br><span class="line">      &#125;</span><br><span class="line">      number &#x3D; Integer.parseInt(application.getAttribute(&quot;counter&quot;).toString());</span><br><span class="line">      number++;</span><br><span class="line">      application.setAttribute(&quot;counter&quot;, number);</span><br><span class="line">   %&gt;</span><br><span class="line">   &lt;!-- &lt;form name&#x3D;&quot;regForm&quot; action&#x3D;&quot;request.jsp&quot; method&#x3D;&quot;post&quot;&gt; --&gt;</span><br><span class="line">   &lt;form name&#x3D;&quot;regForm&quot; action&#x3D;&quot;response.jsp&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">   &lt;table&gt;</span><br><span class="line">     &lt;tr&gt;</span><br><span class="line">       &lt;td&gt;用户名：&lt;&#x2F;td&gt;</span><br><span class="line">       &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">     &lt;&#x2F;tr&gt;</span><br><span class="line">     &lt;tr&gt;</span><br><span class="line">       &lt;td&gt;爱好：&lt;&#x2F;td&gt;</span><br><span class="line">       &lt;td&gt;</span><br><span class="line">          &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;read&quot;&gt;读书</span><br><span class="line">          &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;music&quot;&gt;音乐</span><br><span class="line">          &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;movie&quot;&gt;电影</span><br><span class="line">          &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;internet&quot;&gt;上网</span><br><span class="line">       &lt;&#x2F;td&gt;</span><br><span class="line">     &lt;&#x2F;tr&gt;</span><br><span class="line">     &lt;tr&gt;</span><br><span class="line">        &lt;td colspan&#x3D;&quot;2&quot;&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">     &lt;&#x2F;tr&gt;</span><br><span class="line">   &lt;&#x2F;table&gt;</span><br><span class="line">   &lt;&#x2F;form&gt;</span><br><span class="line">   &lt;br&gt;</span><br><span class="line">   &lt;br&gt;</span><br><span class="line">   &lt;a href&#x3D;&quot;request.jsp?username&#x3D;李四&quot;&gt;测试URL传参数&lt;&#x2F;a&gt;</span><br><span class="line">   </span><br><span class="line">   &lt;br&gt;</span><br><span class="line">   &lt;br&gt;</span><br><span class="line">   &lt;center&gt;</span><br><span class="line">            您是第&lt;%&#x3D;number %&gt;位访问本页面的用户。</span><br><span class="line">   &lt;&#x2F;center&gt;</span><br><span class="line"> &lt;&#x2F;body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  request.jsp</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;body&gt;</span><br><span class="line">  &lt;h1&gt;request内置对象&lt;&#x2F;h1&gt;</span><br><span class="line">  &lt;% </span><br><span class="line">     request.setCharacterEncoding(&quot;utf-8&quot;); &#x2F;&#x2F;解决中文乱码问题，无法解决URL传递中文出现的乱码问题。</span><br><span class="line">     request.setAttribute(&quot;password&quot;, &quot;123456&quot;);</span><br><span class="line">  </span><br><span class="line">  %&gt;</span><br><span class="line">      用户名：&lt;%&#x3D;request.getParameter(&quot;username&quot;) %&gt;&lt;br&gt;   </span><br><span class="line">      爱好 ：&lt;% </span><br><span class="line">         if(request.getParameterValues(&quot;favorite&quot;)!&#x3D;null)</span><br><span class="line">         &#123;</span><br><span class="line">          String[] favorites &#x3D; request.getParameterValues(&quot;favorite&quot;);</span><br><span class="line">          for(int i&#x3D;0;i&lt;favorites.length;i++)</span><br><span class="line">          &#123;</span><br><span class="line">             out.println(favorites[i]+&quot;  &quot;);</span><br><span class="line">          &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      %&gt; &lt;br&gt;</span><br><span class="line">       密码：&lt;%&#x3D;request.getAttribute(&quot;password&quot;) %&gt;&lt;br&gt; </span><br><span class="line">       请求体的MIME类型:&lt;%&#x3D;request.getContentType() %&gt;&lt;br&gt;</span><br><span class="line">       协议类型及版本号:  &lt;%&#x3D;request.getProtocol() %&gt;&lt;br&gt;</span><br><span class="line">       服务器主机名 :&lt;%&#x3D;request.getServerName() %&gt;&lt;br&gt;</span><br><span class="line">       服务器端口号：&lt;%&#x3D;request.getServerPort() %&gt;&lt;BR&gt;</span><br><span class="line">       请求文件的长度 ：&lt;%&#x3D;request.getContentLength() %&gt;&lt;BR&gt;</span><br><span class="line">       请求客户端的IP地址：&lt;%&#x3D;request.getRemoteAddr() %&gt;&lt;BR&gt;</span><br><span class="line">       请求的真实路径：&lt;%&#x3D;request.getRealPath(&quot;request.jsp&quot;) %&gt;&lt;br&gt;</span><br><span class="line">       请求的上下文路径：&lt;%&#x3D;request.getContextPath() %&gt;&lt;BR&gt;         </span><br><span class="line">               </span><br><span class="line">       </span><br><span class="line">                 </span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<h3 id="3、response对象"><a href="#3、response对象" class="headerlink" title="3、response对象"></a>3、response对象</h3><p>  response对象包含了响应客户端请求的有关信息，它具有页面作用域，该页面的作用域只对该页面有效。常用方法：</p>
<ul>
<li>getCharacterEncoding()</li>
<li>setContentType();</li>
<li>getWriter();该方法打应输出流总是前于 out.println();</li>
<li>sendRedirect(String location)</li>
</ul>
<p><em>请求重定向和请求转发：</em></p>
<ul>
<li>请求重定向：客户端行为:response.sendDirect();两次请求，前一次请求的请求对象不会保存，地址栏的url地址会发生改变</li>
<li>请求转发：服务器行为，request.getResuestDispatcher().forward();一次请求，转发后请求对象会保存，地址栏url地址不会变。</li>
</ul>
<h3 id="4、session对象"><a href="#4、session对象" class="headerlink" title="4、session对象"></a>4、session对象</h3><p>一些基本概念：</p>
<ul>
<li>session表示客户端与服务器的一次会话</li>
<li>web中session指的是用户在浏览某个网站，是进入网站到关闭浏览器这段时间</li>
<li>它是保存在服务器的内存中，不同用户有不同的session</li>
<li>它在第一个jsp页面被装载时自动创建，完成会话期管理。</li>
</ul>
<p>它的的一些常用方法：</p>
<ul>
<li>getCreationTime();</li>
<li>String getId();</li>
<li>setAttribute(String name,Object o);</li>
<li>getAttribute(String name);</li>
<li>String[] getValueNames();</li>
<li>int getMaxInactivieInterval();单位 秒</li>
<li>setMaxInactiveInterval();</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;session内置对象&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">      SimpleDateFormat sdf &#x3D; new SimpleDateFormat(&quot;yyyy年MM月dd日 HH:mm:ss&quot;);</span><br><span class="line">      Date d &#x3D; new Date(session.getCreationTime());</span><br><span class="line">      session.setAttribute(&quot;username&quot;, &quot;admin&quot;); </span><br><span class="line">      session.setAttribute(&quot;password&quot;, &quot;123456&quot;);</span><br><span class="line">      session.setAttribute(&quot;age&quot;, 20);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F;设置当前session最大生成期限单位是秒</span><br><span class="line">      &#x2F;&#x2F;session.setMaxInactiveInterval(10);&#x2F;&#x2F;10秒钟</span><br><span class="line">      </span><br><span class="line">    %&gt;</span><br><span class="line">    Session创建时间：&lt;%&#x3D;sdf.format(d)%&gt;&lt;br&gt;    </span><br><span class="line">    Session的ID编号：&lt;%&#x3D;session.getId()%&gt;&lt;BR&gt;</span><br><span class="line">         从Session中获取用户名：&lt;%&#x3D;session.getAttribute(&quot;username&quot;) %&gt;&lt;br&gt;</span><br><span class="line">         </span><br><span class="line">    &lt;a href&#x3D;&quot;session_page2.jsp&quot; target&#x3D;&quot;_blank&quot;&gt;跳转到Session_page2.jsp&lt;&#x2F;a&gt;     </span><br><span class="line">        </span><br><span class="line">  &lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p><em>session的生命周期：</em></p>
<ul>
<li>创建： 当客户端第一次访问某个页面jsp或者servlet，服务器会创建一个 sessionId,每次客户端向服务器发送请求时，都会将sessionId携带过去，服务器会对sessionId进行校验。</li>
<li>活动： 当客户端通过超链接打开新页面属于同一次会话；当浏览页面全部关闭，重新打开属于一次新的会话。</li>
<li>销毁：调用sesson.invalidate();session过期，默认是30分钟；服务器重启；</li>
</ul>
<h3 id="5、application对象"><a href="#5、application对象" class="headerlink" title="5、application对象"></a>5、application对象</h3><ul>
<li>application实现了用户数据共享，可存放全局变量。</li>
<li>application 开始于服务器的重启，终止于服务器的关闭</li>
<li>application 是ServletContext实例。</li>
</ul>
<p>常用方法：</p>
<ul>
<li>setAttribute(String ,Object);</li>
<li>getAttribute(String);</li>
<li>Enumeration getAttributeNames();</li>
<li>getServerInfo();返回Jsp 引擎名和版本号</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;application内置对象&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;% </span><br><span class="line">       application.setAttribute(&quot;city&quot;, &quot;北京&quot;);</span><br><span class="line">       application.setAttribute(&quot;postcode&quot;, &quot;10000&quot;);</span><br><span class="line">       application.setAttribute(&quot;email&quot;, &quot;lisi@126.com&quot;);</span><br><span class="line">       </span><br><span class="line">    %&gt;</span><br><span class="line">         所在城市是：&lt;%&#x3D;application.getAttribute(&quot;city&quot;) %&gt;&lt;br&gt;</span><br><span class="line">    application中的属性有：&lt;% </span><br><span class="line">         Enumeration attributes &#x3D; application.getAttributeNames();</span><br><span class="line">         while(attributes.hasMoreElements())</span><br><span class="line">         &#123;</span><br><span class="line">            out.println(attributes.nextElement()+&quot;  &quot;);</span><br><span class="line">         &#125;</span><br><span class="line">    %&gt;&lt;br&gt;</span><br><span class="line">    JSP(SERVLET)引擎名及版本号:&lt;%&#x3D;application.getServerInfo() %&gt;&lt;br&gt;              </span><br><span class="line">                   </span><br><span class="line">  &lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>
<h3 id="6、page对象"><a href="#6、page对象" class="headerlink" title="6、page对象"></a>6、page对象</h3><p>page对象就是指当前jsp页面本身，有点像this指针，它是java.lang.Object类的实例。常用的方法就是Object 类的方法。</p>
<ul>
<li>getClass()</li>
<li>hashCode();</li>
<li>equals();</li>
<li>copy();</li>
<li>clone()</li>
<li>toString();</li>
<li>notify();</li>
<li>notifyAll();</li>
<li>wait();</li>
</ul>
<h3 id="7、pageContext对象"><a href="#7、pageContext对象" class="headerlink" title="7、pageContext对象"></a>7、pageContext对象</h3><ul>
<li>pageContext 提供了对jsp页面所有的对象及名字空间的访问</li>
<li>它可以取application 某一属性，也可以取session;</li>
<li>相当于页面所有功能的集大成者。 </li>
</ul>
<p>方法：</p>
<ul>
<li>getOut()</li>
<li>geSession();</li>
<li>getPage();</li>
<li>getReuest();</li>
<li>getResponse();</li>
<li>setAttribute();</li>
<li>getAttibute();</li>
<li>getAttributeScope();</li>
<li>forward();</li>
<li>include();</li>
</ul>
<h3 id="8、config对象"><a href="#8、config对象" class="headerlink" title="8、config对象"></a>8、config对象</h3><p>它是在一个servlet初始化时，jsp页面用它传递信息，比如servlet初始化参数；以及服务器的有关信息。</p>
<ul>
<li>ServletContext getServletContext();</li>
<li>getInitParameter(String);</li>
<li>Enumeration getInitParameterNames();</li>
</ul>
<h3 id="9、exception对象"><a href="#9、exception对象" class="headerlink" title="9、exception对象"></a>9、exception对象</h3><p>即异常对象。如果一个jsp想要用此对象，就必须把isErrorPage 设为true.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; import&#x3D;&quot;java.util.*&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;utf-8&quot; isErrorPage&#x3D;&quot;true&quot; %&gt;</span><br><span class="line">&lt;%</span><br></pre></td></tr></table></figure>

<p>九大内置对象，讲解完毕，感谢大家，后一篇文章会讲述除了jsp的九大内置对象其他内容。</p>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee redis</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis</title>
    <url>/2016/11/12/j2ee-2016-05-05-mybatis-details/</url>
    <content><![CDATA[<h3 id="一-mybatis-基本配置"><a href="#一-mybatis-基本配置" class="headerlink" title="一.mybatis 基本配置"></a>一.mybatis 基本配置</h3><p>最近几天一直在学习mybatis，看了一些源码，本文讲述mybatis的一些基本配置和基本的用法和注意到一些细节。个人时间和精力有限，本文属于流水账类型，不成体系，算是自己的个人笔记吧。</p>
<span id="more"></span>

<p>1.本案例所使用的数据库为mysql，数据库的脚本代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;message&#96; (</span><br><span class="line">  &#96;ID&#96; int(11) NOT NULL AUTO_INCREMENT COMMENT &#39;主键&#39;,</span><br><span class="line">  &#96;COMMAND&#96; varchar(16) DEFAULT NULL COMMENT &#39;指令名称&#39;,</span><br><span class="line">  &#96;DESCRIPTION&#96; varchar(32) DEFAULT NULL COMMENT &#39;描述&#39;,</span><br><span class="line">  &#96;CONTENT&#96; varchar(2048) DEFAULT NULL COMMENT &#39;内容&#39;,</span><br><span class="line">  PRIMARY KEY (&#96;ID&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;9 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">INSERT INTO &#96;message&#96; VALUES (1, &#39;查看&#39;, &#39;精彩内容&#39;, &#39;精彩内容&#39;);</span><br><span class="line">INSERT INTO &#96;message&#96; VALUES (2, &#39;段子&#39;, &#39;精彩段子&#39;, &#39;如果你的月薪是3000块钱，请记得分成五份，一份用来买书，一份给家人，一份给女朋友买化妆品和衣服，一份请朋友们吃饭，一份作为同事的各种婚丧嫁娶的份子钱。剩下的2999块钱藏起来，不要告诉任何人&#39;);</span><br><span class="line">INSERT INTO &#96;message&#96; VALUES (3, &#39;新闻&#39;, &#39;今日头条&#39;, &#39;7月17日，马来西亚一架载有298人的777客机在乌克兰靠近俄罗斯边界坠毁。另据国际文传电讯社消息，坠毁机型为一架波音777客机，机载约280名乘客和15个机组人员。\r\n乌克兰空管部门随后证实马航MH17航班坠毁。乌克兰内政部幕僚表示，这一航班在顿涅茨克地区上空被击落。马来西亚航空公司确认，该公司从阿姆斯特丹飞往吉隆坡的MH17航班失联，并称最后与该客机取得联系的地点在乌克兰上空。图为马航客机坠毁现场。&#39;);</span><br><span class="line">INSERT INTO &#96;message&#96; VALUES (4, &#39;娱乐&#39;, &#39;娱乐新闻&#39;, &#39;昨日，邓超在微博分享了自己和孙俪的书法。夫妻同样写幸福，但差距很大。邓超自己都忍不住感慨字丑：左边媳妇写的。右边是我写的。看完我再也不幸福了。&#39;);</span><br><span class="line">INSERT INTO &#96;message&#96; VALUES (5, &#39;电影&#39;, &#39;近日上映大片&#39;, &#39;《忍者神龟》[2]真人电影由美国派拉蒙影业发行，《洛杉矶之战》导演乔纳森·里贝斯曼执导。 \r\n片中四只神龟和老鼠老师都基于漫画和卡通重新绘制，由动作捕捉技术实现。\r\n其中皮特·普劳泽克饰演达芬奇(武器：武士刀)，诺尔·费舍饰演米开朗基罗(武器：双节棍)，阿伦·瑞奇森饰演拉斐尔(武器：铁叉)，杰瑞米·霍华德饰演多拉泰罗(武器：武士棍)。\r\n该片计划于2014年8月8日在北美上映。&#39;);</span><br><span class="line">INSERT INTO &#96;message&#96; VALUES (6, &#39;彩票&#39;, &#39;中奖号码&#39;, &#39;查啥呀查，你不会中奖的！&#39;);</span><br></pre></td></tr></table></figure>
<p>2.创建实体类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Message &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 主键</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private String id;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 指令名称</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private String command;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 描述</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private String description;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 内容</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private String content;</span><br><span class="line">	public String getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(String id) &#123;</span><br><span class="line">		this.id &#x3D; id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getCommand() &#123;</span><br><span class="line">		return command;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setCommand(String command) &#123;</span><br><span class="line">		this.command &#x3D; command;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getDescription() &#123;</span><br><span class="line">		return description;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setDescription(String description) &#123;</span><br><span class="line">		this.description &#x3D; description;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getContent() &#123;</span><br><span class="line">		return content;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setContent(String content) &#123;</span><br><span class="line">		this.content &#x3D; content;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 3.去<a target="_blank" rel="noopener" href="http://blog.mybatis.org/">官网</a>下载mybatis ，导入相应的jar包。</p>
<p> 创建配置文件configuration.xml</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line"> &lt;!DOCTYPE configuration</span><br><span class="line">    PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">    &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">&lt;!-- </span><br><span class="line">  &lt;settings&gt;</span><br><span class="line">    &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span><br><span class="line">    &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;settings&gt;</span><br><span class="line"></span><br><span class="line">  &lt;typeAliases&gt;</span><br><span class="line">    &lt;typeAlias alias&#x3D;&quot;UserAlias&quot; type&#x3D;&quot;org.apache.ibatis.submitted.complex_property.User&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;typeAliases&gt; --&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line">    &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line">      &lt;transactionManager type&#x3D;&quot;JDBC&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;&quot; value&#x3D;&quot;&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;transactionManager&gt;</span><br><span class="line">      &lt;dataSource type&#x3D;&quot;UNPOOLED&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;micro_message&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123&quot;&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;dataSource&gt;</span><br><span class="line">    &lt;&#x2F;environment&gt;</span><br><span class="line">  &lt;&#x2F;environments&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;mappers&gt;</span><br><span class="line">    &lt;mapper resource&#x3D;&quot;com&#x2F;imooc&#x2F;config&#x2F;sqlxml&#x2F;Message.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;mapper resource&#x3D;&quot;com&#x2F;imooc&#x2F;config&#x2F;sqlxml&#x2F;Command.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;mapper resource&#x3D;&quot;com&#x2F;imooc&#x2F;config&#x2F;sqlxml&#x2F;CommandContent.xml&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p> 这个配置文件，需要一个对象跟数据库交互,这个对象是sqlsession,下面讲述sqlsession.</p>
<h3 id="二-Sqlsession对象"><a href="#二-Sqlsession对象" class="headerlink" title="二.Sqlsession对象"></a>二.Sqlsession对象</h3><p>Sqlsession的作用：</p>
<ul>
<li><ol>
<li>向sql 语句传入参数</li>
</ol>
</li>
<li><ol start="2">
<li>执行 sql语句</li>
</ol>
</li>
<li><ol start="3">
<li>获取执行sql语句的结果</li>
</ol>
</li>
<li><ol start="4">
<li>事物的控制</li>
</ol>
</li>
</ul>
<p>如何获取Sqlsession：</p>
<ul>
<li><ol>
<li>通过获取配置文件获取数据库连接相关信息</li>
</ol>
</li>
<li><ol start="2">
<li>通过配置信息构建 sqlSessionFactory 的对象</li>
</ol>
</li>
<li><ol start="3">
<li>通过sqlsessionFactory大家数据库会话。</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public SqlSession getSqlSession() throws IOException &#123;</span><br><span class="line">		&#x2F;&#x2F; 通过配置文件获取数据库连接信息</span><br><span class="line">		Reader reader &#x3D; Resources.getResourceAsReader(&quot;com&#x2F;forzp&#x2F;config&#x2F;Configuration.xml&quot;);</span><br><span class="line">		&#x2F;&#x2F; 通过配置信息构建一个SqlSessionFactory</span><br><span class="line">		SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">		&#x2F;&#x2F; 通过sqlSessionFactory打开一个数据库会话</span><br><span class="line">		SqlSession sqlSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line">		return sqlSession;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.SQL基本配置、执行</p>
<p>Message.xml文件配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;Message&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;resultMap type&#x3D;&quot;com.imooc.bean.Message&quot; id&#x3D;&quot;MessageResult&quot;&gt;</span><br><span class="line">    &lt;id column&#x3D;&quot;ID&quot; jdbcType&#x3D;&quot;INTEGER&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;COMMAND&quot; jdbcType&#x3D;&quot;VARCHAR&quot; property&#x3D;&quot;command&quot;&#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;DESCRIPTION&quot; jdbcType&#x3D;&quot;VARCHAR&quot; property&#x3D;&quot;description&quot;&#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;CONTENT&quot; jdbcType&#x3D;&quot;VARCHAR&quot; property&#x3D;&quot;content&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br><span class="line"></span><br><span class="line">&lt;select id&#x3D;&quot;queryMessageList&quot; parameterType&#x3D;&quot;com.imooc.bean.Message&quot; resultMap&#x3D;&quot;MessageResult&quot;&gt;</span><br><span class="line">    select &lt;include refid&#x3D;&quot;columns&quot;&#x2F;&gt; from MESSAGE</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">    	&lt;if test&#x3D;&quot;command !&#x3D; null and !&quot;&quot;.equals(command.trim())&quot;&gt;</span><br><span class="line">	    	and COMMAND&#x3D;#&#123;command&#125;</span><br><span class="line">	    &lt;&#x2F;if&gt;</span><br><span class="line">	    &lt;if test&#x3D;&quot;description !&#x3D; null and !&quot;&quot;.equals(description.trim())&quot;&gt;</span><br><span class="line">	    	and DESCRIPTION like &#39;%&#39; #&#123;description&#125; &#39;%&#39;</span><br><span class="line">	    &lt;&#x2F;if&gt;</span><br><span class="line">    &lt;&#x2F;where&gt;</span><br><span class="line">  &lt;&#x2F;select&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中使用到了ONGL表达式:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-e0f33461de4654fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20161225-220301@2x.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-469157fcf09f72e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20161225-220208@2x.png"></p>
<p>在configuration.xml中配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mappers&gt;</span><br><span class="line">   &lt;mapper resource&#x3D;&quot;com&#x2F;imooc&#x2F;config&#x2F;sqlxml&#x2F;Message.xml&quot;&#x2F;&gt;</span><br><span class="line"> </span><br><span class="line"> &lt;&#x2F;mappers&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">	 * 根据查询条件查询消息列表</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	public List&lt;Message&gt; queryMessageList(String command,String description) &#123;</span><br><span class="line">		DBAccess dbAccess &#x3D; new DBAccess();</span><br><span class="line">		List&lt;Message&gt; messageList &#x3D; new ArrayList&lt;Message&gt;();</span><br><span class="line">		SqlSession sqlSession &#x3D; null;</span><br><span class="line">		try &#123;</span><br><span class="line">			sqlSession &#x3D; dbAccess.getSqlSession();</span><br><span class="line">			Message message &#x3D; new Message();</span><br><span class="line">			message.setCommand(command);</span><br><span class="line">			message.setDescription(description);</span><br><span class="line">			&#x2F;&#x2F; 通过sqlSession执行SQL语句</span><br><span class="line">			messageList &#x3D; sqlSession.selectList(&quot;Message.queryMessageList&quot;,message);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			&#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; finally &#123;</span><br><span class="line">			if(sqlSession !&#x3D; null) &#123;</span><br><span class="line">				sqlSession.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return messageList;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三、log4j动态调试SQL"><a href="#三、log4j动态调试SQL" class="headerlink" title="三、log4j动态调试SQL"></a>三、log4j动态调试SQL</h3><p>由于mybatis的sql语句写在了xml中，导致调试比较困难，不能打断点。这时需要日志去调。</p>
<p>下载log4j jar包,并配置log4j.propertites</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">log4j.rootLogger&#x3D;DEBUG,Console</span><br><span class="line">log4j.appender.Console&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.Console.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.Console.layout.ConversionPattern&#x3D;%d [%t] %-5p [%c] - %m%n</span><br><span class="line">log4j.logger.org.apache&#x3D;INFO</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>log的级别：</p>
<blockquote>
<p>log.debug</p>
<p>log.info</p>
</blockquote>
<blockquote>
<p>log.warm</p>
</blockquote>
<blockquote>
<p>log.error</p>
</blockquote>
<p>级别从小到大，也就是og4j.rootLogger=DEBUG；可以输出所有的日志类型；og4j.rootLogger=info ，只能够输出　info,warm ,error</p>
<p>要想mybtis  显示日志，必须log4j.rootLogger=DEBUG；<br>项目中配置了log4j，mybatis 会自动应用log4j</p>
<h3 id="四、一些其他的知识点"><a href="#四、一些其他的知识点" class="headerlink" title="四、一些其他的知识点"></a>四、一些其他的知识点</h3><p> mybatis sql配置文件常用的标签如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-96c5b9f6f1dc1bb6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20161226-213750@2x.png"></p>
<p>mapper文件下的标签含义：</p>
<p>nameSpace  标签区分可以用来区分sql文件</p>
<p>parameterType    将会传入这条语句的参数类的完全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过 TypeHandler 推断出具体传入语句的参数，默认值为 unset。</p>
<p>resultMap    外部 resultMap 的命名引用。结果集的映射是 MyBatis 最强大的特性，对其有一个很好的理解的话，许多复杂映射的情形都能迎刃而解。使用 resultMap 或 resultType，但不能同时使用。</p>
<h3 id="五、一对多sql-xml的配置"><a href="#五、一对多sql-xml的配置" class="headerlink" title="五、一对多sql xml的配置"></a>五、一对多sql xml的配置</h3><p>java实体内Command包含了一个List<CommandContent> contentList集合。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Command &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 主键</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private String id;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 指令名称</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private String name;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 描述</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private String description;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * 一条指令对应的自动回复内容列表</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	private List&lt;CommandContent&gt; contentList;</span><br><span class="line">	</span><br><span class="line">	public String getId() &#123;</span><br><span class="line">		return id;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setId(String id) &#123;</span><br><span class="line">		this.id &#x3D; id;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line">	public String getDescription() &#123;</span><br><span class="line">		return description;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setDescription(String description) &#123;</span><br><span class="line">		this.description &#x3D; description;</span><br><span class="line">	&#125;</span><br><span class="line">	public List&lt;CommandContent&gt; getContentList() &#123;</span><br><span class="line">		return contentList;</span><br><span class="line">	&#125;</span><br><span class="line">	public void setContentList(List&lt;CommandContent&gt; contentList) &#123;</span><br><span class="line">		this.contentList &#x3D; contentList;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在mapper中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;Command&quot;&gt;</span><br><span class="line">  &lt;resultMap type&#x3D;&quot;com.imooc.bean.Command&quot; id&#x3D;&quot;Command&quot;&gt;</span><br><span class="line">    &lt;id column&#x3D;&quot;C_ID&quot; jdbcType&#x3D;&quot;INTEGER&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;NAME&quot; jdbcType&#x3D;&quot;VARCHAR&quot; property&#x3D;&quot;name&quot;&#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;DESCRIPTION&quot; jdbcType&#x3D;&quot;VARCHAR&quot; property&#x3D;&quot;description&quot;&#x2F;&gt;</span><br><span class="line">    &lt;collection property&#x3D;&quot;contentList&quot;  resultMap&#x3D;&quot;CommandContent.Content&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;resultMap&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;select id&#x3D;&quot;queryCommandList&quot; parameterType&#x3D;&quot;com.imooc.bean.Command&quot; resultMap&#x3D;&quot;Command&quot;&gt;</span><br><span class="line">    select a.ID C_ID,a.NAME,a.DESCRIPTION,b.ID,b.CONTENT,b.COMMAND_ID</span><br><span class="line">    from COMMAND a left join COMMAND_CONTENT b</span><br><span class="line">    on a.ID&#x3D;b.COMMAND_ID</span><br><span class="line">    &lt;where&gt;</span><br><span class="line">    	&lt;if test&#x3D;&quot;name !&#x3D; null and !&quot;&quot;.equals(name.trim())&quot;&gt;</span><br><span class="line">	    	and a.NAME&#x3D;#&#123;name&#125;</span><br><span class="line">	    &lt;&#x2F;if&gt;</span><br><span class="line">	    &lt;if test&#x3D;&quot;description !&#x3D; null and !&quot;&quot;.equals(description.trim())&quot;&gt;</span><br><span class="line">	    	and a.DESCRIPTION like &#39;%&#39; #&#123;description&#125; &#39;%&#39;</span><br><span class="line">	    &lt;&#x2F;if&gt;</span><br><span class="line">    &lt;&#x2F;where&gt;</span><br><span class="line">  &lt;&#x2F;select&gt;</span><br><span class="line">  </span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>CommandContent.xml配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;CommandContent&quot;&gt;</span><br><span class="line">  &lt;resultMap type&#x3D;&quot;com.imooc.bean.CommandContent&quot; id&#x3D;&quot;Content&quot;&gt;</span><br><span class="line">    &lt;id column&#x3D;&quot;ID&quot; jdbcType&#x3D;&quot;INTEGER&quot; property&#x3D;&quot;id&quot;&#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;CONTENT&quot; jdbcType&#x3D;&quot;VARCHAR&quot; property&#x3D;&quot;content&quot;&#x2F;&gt;</span><br><span class="line">    &lt;result column&#x3D;&quot;COMMAND_ID&quot; jdbcType&#x3D;&quot;VARCHAR&quot; property&#x3D;&quot;commandId&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;resultMap&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过这样的配置，在DAO层执行，就可以取出command中的属性。</p>
<p>六.取自增长 key</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;insert id&#x3D;&quot;insert&quot; parameterType&#x3D;&quot;com.imooc.bean.Command&quot; useGeneratedKeys&#x3D;&quot;true&quot; keyProperty&#x3D;&quot;id&quot;&gt;</span><br><span class="line">  insert into Command (name,description) values(#&#123;name&#125;,#&#123;description&#125;);</span><br><span class="line"> &lt;&#x2F;insert&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>七、一点细节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#123;&#125; 和$&#123;&#125;区别：</span><br><span class="line">#&#123;&#125;相当于preparedStatment;</span><br><span class="line">$&#123;&#125;相当于statment,它主要用于排序oderby </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>另外：</p>
<p>敲黑板划重点，mybatis的所有知识都可以在官网上都有，建议看十遍，……^_^，地址：<a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html">http://www.mybatis.org/mybatis-3/zh/configuration.html</a></p>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>AOP</title>
    <url>/2016/11/12/j2ee-2016-05-05-spring-aop/</url>
    <content><![CDATA[<h3 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h3><p>Aop(aspect oriented programming面向切面编程），是spring框架的另一个特征。AOP包括切面、连接点、通知（advice）、切入点（pointCut) 。</p>
<span id="more"></span>

<p>1.aop几个概念：</p>
<ul>
<li>横切关注点： 对哪些方面进行拦截，拦截后怎么处理。</li>
<li>切面(aspect):切面是横切关注点的抽象。</li>
<li>连接点(joinpoint)：被拦截的方法</li>
<li>切入点(pointcut):对连接点进行拦截的定义。</li>
<li>通知(advice)：拦截到连接点之后要执行的代码</li>
<li>目标对象：代理的目标对象</li>
<li>织入</li>
<li>引入</li>
</ul>
<p>2.主要功能：</p>
<ul>
<li> 日志记录</li>
<li> 性能统计</li>
<li> 安全控制</li>
<li> 事物处理</li>
<li> 异常处理</li>
</ul>
<p>3.advice类型：</p>
<ul>
<li>前置通知(before advice)</li>
<li>返回后通知(after  returning advice)</li>
<li>抛出异常后通知(after throwing advice)</li>
<li>后通知(after advice)</li>
<li> 环绕通知(around advice)</li>
</ul>
<p>4.Spring对AOP的支持</p>
<p>Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。 </p>
<p>二、基于xml配置的aop</p>
<p> 在spring基于schemel中，aop需要声明一个切面aspect,一个pointcut,一个advisor.<br> 举个例子：</p>
<p> 切面：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MoocAspect &#123;</span><br><span class="line"></span><br><span class="line">public void before() &#123;</span><br><span class="line">	System.out.println(&quot;MoocAspect before.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 切点：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class AspectBiz &#123;</span><br><span class="line">	</span><br><span class="line">	public void biz() &#123;</span><br><span class="line">		System.out.println(&quot;AspectBiz biz.&quot;);</span><br><span class="line">&#x2F;&#x2F;		throw new RuntimeException();</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> 配置文件：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line"> &lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:aop&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans </span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd  </span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop </span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;aop&#x2F;spring-aop-4.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id&#x3D;&quot;moocAspect&quot; class&#x3D;&quot;com.imooc.aop.schema.advice.MoocAspect&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;bean id&#x3D;&quot;aspectBiz&quot; class&#x3D;&quot;com.imooc.aop.schema.advice.biz.AspectBiz&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;aop:config&gt;</span><br><span class="line">		&lt;aop:aspect id&#x3D;&quot;moocAspectAOP&quot; ref&#x3D;&quot;moocAspect&quot;&gt;</span><br><span class="line">			&lt;aop:pointcut expression&#x3D;&quot;execution(* com.imooc.aop.schema.advice.biz.*Biz.*(..))&quot; id&#x3D;&quot;moocPiontcut&quot;&#x2F;&gt;</span><br><span class="line">			&lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;moocPiontcut&quot;&#x2F;&gt;</span><br><span class="line">				&lt;&#x2F;aop:aspect&gt;</span><br><span class="line">	&lt;&#x2F;aop:config&gt;</span><br><span class="line"></span><br><span class="line"> &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> 单元测试：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> @RunWith(BlockJUnit4ClassRunner.class)</span><br><span class="line">public class TestAOPSchemaAdvice extends UnitTestBase &#123;</span><br><span class="line">	</span><br><span class="line">	public TestAOPSchemaAdvice() &#123;</span><br><span class="line">		super(&quot;classpath:spring-aop-schema-advice.xml&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void testBiz() &#123;</span><br><span class="line">		AspectBiz biz &#x3D; super.getBean(&quot;aspectBiz&quot;);</span><br><span class="line">		biz.biz();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> 运行：</p>
<blockquote>
<p>MoocAspect before.</p>
</blockquote>
<blockquote>
<p>AspectBiz biz.</p>
</blockquote>
<p>这是 机遇 schemel配置使用aop，其实在spring 1.2版本是有api的，基于api配置aop很麻烦，但是也也应该了解下</p>
<h3 id="三、基于spring-api方式配置aop"><a href="#三、基于spring-api方式配置aop" class="headerlink" title="三、基于spring api方式配置aop"></a>三、基于spring api方式配置aop</h3><p>直接上代码：</p>
<p>接口中有两个方法，一个基于aop,会被拦截 ，另外一个不会被拦截。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAopService &#123;</span><br><span class="line"></span><br><span class="line">	public void withAop() throws Exception;</span><br><span class="line"></span><br><span class="line">	public void withoutAop() throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AopServiceImpl implements IAopService &#123;</span><br><span class="line"></span><br><span class="line">	private String name&#x3D;&quot;forezp&quot;;</span><br><span class="line"></span><br><span class="line">	public void withAop() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;with aop run: &quot; + name);</span><br><span class="line"></span><br><span class="line">		if (name.trim().length() &#x3D;&#x3D; 0)</span><br><span class="line">			throw new AccountException(&quot;name cannot be null&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void withoutAop() throws Exception &#123;</span><br><span class="line">		System.out.println(&quot;without aop&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getName() &#123;</span><br><span class="line">		return name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setName(String name) &#123;</span><br><span class="line">		this.name &#x3D; name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>方法前拦截器，实现MethodBeforeAdvice,在制定方法前会被调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class MethodBeforeInterceptor implements MethodBeforeAdvice &#123;</span><br><span class="line"></span><br><span class="line">	public void before(Method method, Object[] args, Object instance)</span><br><span class="line">			throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;method invoke:&quot; + method.getName());</span><br><span class="line"></span><br><span class="line">		if (instance instanceof AopServiceImpl) &#123;</span><br><span class="line"></span><br><span class="line">			String name &#x3D; ((AopServiceImpl) instance).getName();</span><br><span class="line"></span><br><span class="line">			if (name &#x3D;&#x3D; null)</span><br><span class="line">				throw new NullPointerException(&quot;name cannot be null&quot;);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回后拦截器，执行指定方法后会被调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MethodAfterInterceptor implements AfterReturningAdvice &#123;</span><br><span class="line"></span><br><span class="line">	public void afterReturning(Object value, Method method, Object[] args,</span><br><span class="line">			Object instance) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;method  &quot; + method.getName() + &quot;had finished and return value-&quot; + value);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>异常拦截器，当出现异常时拦截：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class ThrowsInterceptor implements ThrowsAdvice &#123;</span><br><span class="line"></span><br><span class="line">	public void afterThrowing(Method method, Object[] args, Object instance,</span><br><span class="line">			AccountException ex) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;method&quot; + method.getName() + &quot; throws exception:&quot; + ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void afterThrowing(NullPointerException ex) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;the exception:&quot; + ex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>三个拦截器和Servce实现类需要配置到spring中。实际上，spring无法组装，需要借助代理类，把拦截器安装到NameMatchMethodPointcutAdvisor中，把自定义的bean安装到ProxyFactoryBean中，然后组装在一起：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans-2.0.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 拦截器 在 withAop() 方法前运行 --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;aopMethodBeforeInterceptor&quot;</span><br><span class="line">		class&#x3D;&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;advice&quot;&gt;</span><br><span class="line">			&lt;bean</span><br><span class="line">				class&#x3D;&quot;com.imooc.aop.example2.MethodBeforeInterceptor&quot; &#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;mappedName&quot; value&#x3D;&quot;withAop&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 拦截器 在 withAop() 返回后运行 --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;aopMethodAfterInterceptor&quot;</span><br><span class="line">		class&#x3D;&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;advice&quot;&gt;</span><br><span class="line">			&lt;bean</span><br><span class="line">				class&#x3D;&quot;com.imooc.aop.example2.MethodAfterInterceptor&quot; &#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;mappedName&quot; value&#x3D;&quot;withAop&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;!-- 拦截器 在异常抛出后运行 --&gt;</span><br><span class="line">	&lt;bean id&#x3D;&quot;aopThrowsInterceptor&quot;</span><br><span class="line">		class&#x3D;&quot;org.springframework.aop.support.NameMatchMethodPointcutAdvisor&quot;&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;advice&quot;&gt;</span><br><span class="line">			&lt;bean</span><br><span class="line">				class&#x3D;&quot;com.imooc.aop.example2.ThrowsInterceptor&quot; &#x2F;&gt;</span><br><span class="line">		&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;mappedName&quot; value&#x3D;&quot;withAop&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">	&lt;bean id&#x3D;&quot;aopService&quot;</span><br><span class="line">		class&#x3D;&quot;org.springframework.aop.framework.ProxyFactoryBean&quot;&gt;</span><br><span class="line">		&lt;!-- 拦截器 --&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;interceptorNames&quot;&gt;</span><br><span class="line">			&lt;list&gt;</span><br><span class="line">				&lt;value&gt;aopMethodBeforeInterceptor&lt;&#x2F;value&gt;</span><br><span class="line">				&lt;value&gt;aopMethodAfterInterceptor&lt;&#x2F;value&gt;</span><br><span class="line">				&lt;value&gt;aopThrowsInterceptor&lt;&#x2F;value&gt;</span><br><span class="line">			&lt;&#x2F;list&gt;</span><br><span class="line">		&lt;&#x2F;property&gt;</span><br><span class="line">		&lt;!-- 被拦截的对象 --&gt;</span><br><span class="line">		&lt;property name&#x3D;&quot;target&quot;&gt;</span><br><span class="line">			&lt;bean</span><br><span class="line">				class&#x3D;&quot;com.imooc.aop.example2.AopServiceImpl&quot;&gt;</span><br><span class="line">	</span><br><span class="line">					&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;forezp&quot;&gt;&lt;&#x2F;property&gt;</span><br><span class="line">			</span><br><span class="line">			&lt;&#x2F;bean&gt;</span><br><span class="line">		&lt;&#x2F;property&gt;</span><br><span class="line">	&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单元测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>method invoke:withAop</p>
<p>with aop run: forezp</p>
<p>method  withAophad finished and return value-forezp</p>
<p>without aop</p>
</blockquote>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络思维导图</title>
    <url>/2020/11/12/internet-2020-11-26-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<p>分享计算机网络思维导图，持续更新ing</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/ChengKeJ/ChengKeJ.github.io/master/img/internet.png"></p>
]]></content>
      <categories>
        <category>internet</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>IOC</title>
    <url>/2016/11/12/j2ee-2016-05-05-spring-ioc/</url>
    <content><![CDATA[<p>###一.Spring概况</p>
<ul>
<li>spring是一个开源框架</li>
<li>是一个轻量的控制反转和面向切面的容器框架</li>
<li>大小和开销都是轻量的。</li>
<li>通过控制反转技术可以达到松耦合的目的</li>
<li>切面编程，允许通过分离应用的业务逻辑。</li>
<li>包含并管理应用对象的配置和生命周期，是一个容器，并且能够组装。</li>
</ul>
<span id="more"></span>

<h3 id="二、IoC"><a href="#二、IoC" class="headerlink" title="二、IoC"></a>二、IoC</h3><p>ioc控制反转：控制权转移，应用程序本身不负责依赖对象的创建和维护，而是由外部容器负责和维护。ioc的目的是创建对象并且组装对象之间的关系。</p>
<p>####1.bean容器初始化</p>
<ul>
<li><p> –org.springframework.beans</p>
</li>
<li><p>–org.springframework.context</p>
</li>
<li><p> beanfactory 提供配置结构和基本功能，加载并初始化bean</p>
</li>
<li><p> applicationContext 保存bean对象并在应用中被应用</p>
</li>
</ul>
<h4 id="2-spring注入："><a href="#2-spring注入：" class="headerlink" title="2.spring注入："></a>2.spring注入：</h4><ul>
<li>spring 注入是指在启动 spring容器加载bean配置的时候，完成对变量的赋值行为。</li>
<li>常见的注入方式:设值注入、构建注入</li>
</ul>
<p>举个例子，构建注入</p>
<p>dao层</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface InjectionDAO &#123;</span><br><span class="line">	</span><br><span class="line">	public void save(String arg);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class InjectionDAOImpl implements InjectionDAO &#123;</span><br><span class="line">	</span><br><span class="line">	public void save(String arg) &#123;</span><br><span class="line">		&#x2F;&#x2F;模拟数据库保存操作</span><br><span class="line">		System.out.println(&quot;保存数据：&quot; + arg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>service 层接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface InjectionService &#123;</span><br><span class="line">	</span><br><span class="line">	public void save(String arg);</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>service 层实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class InjectionServiceImpl implements InjectionService &#123;</span><br><span class="line">	</span><br><span class="line">	private InjectionDAO injectionDAO;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;构造器注入</span><br><span class="line">	public InjectionServiceImpl(InjectionDAO injectionDAO1) &#123;</span><br><span class="line">		this.injectionDAO &#x3D; injectionDAO1;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F;设值注入</span><br><span class="line">	public void setInjectionDAO(InjectionDAO injectionDAO) &#123;</span><br><span class="line">		this.injectionDAO &#x3D; injectionDAO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void save(String arg) &#123;</span><br><span class="line">		&#x2F;&#x2F;模拟业务操作</span><br><span class="line">		System.out.println(&quot;Service接收参数：&quot; + arg);</span><br><span class="line">		arg &#x3D; arg + &quot;:&quot; + this.hashCode();</span><br><span class="line">		injectionDAO.save(arg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在spring xml中的配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot; &gt;</span><br><span class="line">        </span><br><span class="line">		&lt;bean id&#x3D;&quot;injectionService&quot; class&#x3D;&quot;com.forezp.ioc.injection.service.InjectionServiceImpl&quot;&gt;</span><br><span class="line">        	&lt;constructor-arg name&#x3D;&quot;injectionDAO1&quot; ref&#x3D;&quot;injectionDAO&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">        &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">        &lt;bean id&#x3D;&quot;injectionDAO&quot; class&#x3D;&quot;com.forezp.ioc.injection.dao.InjectionDAOImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"> &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单元测试</p>
<p>本系列文章单元测试基类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class UnitTestBase &#123;</span><br><span class="line">	</span><br><span class="line">	private ClassPathXmlApplicationContext context;</span><br><span class="line">	</span><br><span class="line">	private String springXmlpath;</span><br><span class="line">	</span><br><span class="line">	public UnitTestBase() &#123;&#125;</span><br><span class="line">	</span><br><span class="line">	public UnitTestBase(String springXmlpath) &#123;</span><br><span class="line">		this.springXmlpath &#x3D; springXmlpath;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Before</span><br><span class="line">	public void before() &#123;</span><br><span class="line">		if (StringUtils.isEmpty(springXmlpath)) &#123;</span><br><span class="line">			springXmlpath &#x3D; &quot;classpath*:spring-*.xml&quot;;</span><br><span class="line">		&#125;</span><br><span class="line">		try &#123;</span><br><span class="line">			context &#x3D; new ClassPathXmlApplicationContext(springXmlpath.split(&quot;[,\\s]+&quot;));</span><br><span class="line">			context.start();</span><br><span class="line">		&#125; catch (BeansException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@After</span><br><span class="line">	public void after() &#123;</span><br><span class="line">		context.destroy();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">	protected &lt;T extends Object&gt; T getBean(String beanId) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return (T)context.getBean(beanId);</span><br><span class="line">		&#125; catch (BeansException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	protected &lt;T extends Object&gt; T getBean(Class&lt;T&gt; clazz) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return context.getBean(clazz);</span><br><span class="line">		&#125; catch (BeansException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单元测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@RunWith(BlockJUnit4ClassRunner.class)</span><br><span class="line">public class TestInjection extends UnitTestBase &#123;</span><br><span class="line">	</span><br><span class="line">	public TestInjection() &#123;</span><br><span class="line">		super(&quot;classpath:spring-injection.xml&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void testSetter() &#123;</span><br><span class="line">		InjectionService service &#x3D; super.getBean(&quot;injectionService&quot;);</span><br><span class="line">		service.save(&quot;这是要保存的数据&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void testCons() &#123;</span><br><span class="line">		InjectionService service &#x3D; super.getBean(&quot;injectionService&quot;);</span><br><span class="line">		service.save(&quot;这是要保存的数据&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行打印：</p>
<blockquote>
<p>Service接收参数：这是要保存的数据</p>
</blockquote>
<blockquote>
<p>保存数据：这是要保存的数据:1247298779</p>
</blockquote>
<p>这个例子说明，我们可以通过ClassPathXmlApplicationContext.getBean()获取到了service，这个service 是通过xml配置注入到容器中，并且注入的时候通过构造函数的设置了成员变量dao。</p>
<h3 id="三-bean的配置项"><a href="#三-bean的配置项" class="headerlink" title="三.bean的配置项"></a>三.bean的配置项</h3><p>####3.1 bean常见的配置项，如下：</p>
<ul>
<li>Id</li>
<li>Class</li>
<li>Scope </li>
<li>Constructor arguments</li>
<li>Properties</li>
<li>Autowiring mode</li>
<li>lazy-initialization mode</li>
<li>Initialization/destruction method</li>
</ul>
<h4 id="3-2-bean的作用域"><a href="#3-2-bean的作用域" class="headerlink" title="3.2 bean的作用域"></a>3.2 bean的作用域</h4><ul>
<li>singleton: 单列</li>
<li> prototype每次使用都会创建新实例</li>
<li> request :每次http请求创建一个实例，仅在当前　request有效</li>
<li> session ： 当前session有效</li>
</ul>
<p>举个例子：<br>测试sinleton和prototype</p>
<p>创建bean实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BeanScope &#123;</span><br><span class="line">	</span><br><span class="line">	public void say() &#123;</span><br><span class="line">		System.out.println(&quot;BeanScope say : &quot; + this.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在xml中配置,作用域为singleton</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot; &gt;</span><br><span class="line">        </span><br><span class="line">        &lt;bean id&#x3D;&quot;beanScope&quot; class&#x3D;&quot;com.imooc.bean.BeanScope&quot; scope&#x3D;&quot;singleton&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">        </span><br><span class="line"> &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单元测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(BlockJUnit4ClassRunner.class)</span><br><span class="line">public class TestBeanScope extends UnitTestBase &#123;</span><br><span class="line">	</span><br><span class="line">	public TestBeanScope() &#123;</span><br><span class="line">		super(&quot;classpath*:spring-beanscope.xml&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void testSay() &#123;</span><br><span class="line">		BeanScope beanScope &#x3D; super.getBean(&quot;beanScope&quot;);</span><br><span class="line">		beanScope.say();</span><br><span class="line">		</span><br><span class="line">		BeanScope beanScope2 &#x3D; super.getBean(&quot;beanScope&quot;);</span><br><span class="line">		beanScope2.say();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行单元测试：</p>
<blockquote>
<p>BeanScope say : 1113008012</p>
</blockquote>
<p>BeanScope say : 1113008012</p>
<p>在xml中配置,作用域为prototype</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot; &gt;</span><br><span class="line">        </span><br><span class="line">        &lt;bean id&#x3D;&quot;beanScope&quot; class&#x3D;&quot;com.imooc.bean.BeanScope&quot; scope&#x3D;&quot;prototype&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">        </span><br><span class="line"> &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行单元测试</p>
<blockquote>
<p>BeanScope say : 144724468</p>
</blockquote>
<p>BeanScope say : 1432645272</p>
<p>由此可发现sington在bean容器是一个实例，而prototype创建了二个实例。</p>
<h3 id="四-bean的生命周期"><a href="#四-bean的生命周期" class="headerlink" title="四.bean的生命周期"></a>四.bean的生命周期</h3><p>包括以下几个方面：</p>
<ul>
<li>定义，在xml中配置</li>
<li>初始化</li>
<li>使用</li>
<li>销毁</li>
</ul>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>有两种方式</p>
<ul>
<li>实现 InitializingBeean接口，覆盖afterPropertiesSet()</li>
<li>配置init-method方法</li>
</ul>
<h4 id="销毁"><a href="#销毁" class="headerlink" title="销毁"></a>销毁</h4><p>也有两种方式：</p>
<ul>
<li>实现DisposableBean接口，覆盖destroy();</li>
<li>配置 destroy-method</li>
</ul>
<p>举个例子:</p>
<p>创建bean实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BeanLifeCycle implements InitializingBean, DisposableBean &#123;</span><br><span class="line">	</span><br><span class="line">	public void defautInit() &#123;</span><br><span class="line">		System.out.println(&quot;Bean defautInit.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void defaultDestroy() &#123;</span><br><span class="line">		System.out.println(&quot;Bean defaultDestroy.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void destroy() throws Exception &#123;</span><br><span class="line">		System.out.println(&quot;Bean destroy.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void afterPropertiesSet() throws Exception &#123;</span><br><span class="line">		System.out.println(&quot;Bean afterPropertiesSet.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void start() &#123;</span><br><span class="line">		System.out.println(&quot;Bean start .&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void stop() &#123;</span><br><span class="line">		System.out.println(&quot;Bean stop.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>bean的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot; </span><br><span class="line">        default-init-method&#x3D;&quot;defautInit&quot; default-destroy-method&#x3D;&quot;defaultDestroy&quot;&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;bean id&#x3D;&quot;beanLifeCycle&quot; class&#x3D;&quot;com.imooc.lifecycle.BeanLifeCycle&quot;  init-method&#x3D;&quot;start&quot; destroy-method&#x3D;&quot;stop&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">	</span><br><span class="line"> &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单元测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(BlockJUnit4ClassRunner.class)</span><br><span class="line">public class TestBeanLifecycle extends UnitTestBase &#123;</span><br><span class="line">	</span><br><span class="line">	public TestBeanLifecycle() &#123;</span><br><span class="line">		super(&quot;classpath:spring-lifecycle.xml&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void test1() &#123;</span><br><span class="line">		super.getBean(&quot;beanLifeCycle&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<blockquote>
<p>Bean afterPropertiesSet.</p>
<p>Bean start .</p>
</blockquote>
<p>Bean destroy.</p>
<blockquote>
<p>Bean stop.</p>
</blockquote>
<p>同时实现两种方式的初始化方法的执行顺序： 接口实现优先于xml中的配置。</p>
<h3 id="五-bean的自动装配（Autowiring）"><a href="#五-bean的自动装配（Autowiring）" class="headerlink" title="五.bean的自动装配（Autowiring）"></a>五.bean的自动装配（Autowiring）</h3><ul>
<li>No: 不做任何操作</li>
<li>byname:根据属性名自动装配</li>
<li>byType:如果容器存在一个与指定类型相同的bean，则自动装配，如果存在多个，则抛出异常。</li>
<li>constructor:与 byType类似，不同之处它在于构造器的参数。</li>
</ul>
<p>举例子：<br>1.byName方式：</p>
<p>创建一个dao:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AutoWiringDAO &#123;</span><br><span class="line">	</span><br><span class="line">	public void say(String word) &#123;</span><br><span class="line">		System.out.println(&quot;AutoWiringDAO : &quot; + word);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AutoWiringService &#123;</span><br><span class="line">	</span><br><span class="line">	private AutoWiringDAO autoWiringDAO;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) &#123;</span><br><span class="line">		System.out.println(&quot;setAutoWiringDAO&quot;);</span><br><span class="line">		this.autoWiringDAO &#x3D; autoWiringDAO;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void say(String word) &#123;</span><br><span class="line">		this.autoWiringDAO.say(word);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在xml中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot; </span><br><span class="line">        default-autowire&#x3D;&quot;byName&quot;&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;bean id&#x3D;&quot;autoWiringService&quot; class&#x3D;&quot;com.imooc.autowiring.AutoWiringService&quot; &gt;&lt;&#x2F;bean&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;bean id&#x3D;&quot;autoWiringDAO&quot; class&#x3D;&quot;com.imooc.autowiring.AutoWiringDAO&quot; &gt;&lt;&#x2F;bean&gt;</span><br><span class="line">	</span><br><span class="line"> &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单元测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(BlockJUnit4ClassRunner.class)</span><br><span class="line">public class TestAutoWiring extends UnitTestBase &#123;</span><br><span class="line">	</span><br><span class="line">	public TestAutoWiring() &#123;</span><br><span class="line">		super(&quot;classpath:spring-autowiring.xml&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void testSay() &#123;</span><br><span class="line">		AutoWiringService service &#x3D; super.getBean(&quot;autoWiringService&quot;);</span><br><span class="line">		service.say(&quot; this is a test&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<blockquote>
<p>setAutoWiringDAO</p>
</blockquote>
<p>AutoWiringDAO :  this is a test</p>
<p>通过default-autowire=”byName”;<br>AutoWiringService 自动获取了autoWiringDAO的实例。</p>
<p>2.byTYpe</p>
<p>将在xml中配置改为byType ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot; </span><br><span class="line">        default-autowire&#x3D;&quot;byName&quot;&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;bean id&#x3D;&quot;autoWiringService&quot; class&#x3D;&quot;com.imooc.autowiring.AutoWiringService&quot; &gt;&lt;&#x2F;bean&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;bean id&#x3D;&quot;autoWiringDAO&quot; class&#x3D;&quot;com.imooc.autowiring.AutoWiringDAO&quot; &gt;&lt;&#x2F;bean&gt;</span><br><span class="line">	</span><br><span class="line"> &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其他不变，运行和byName 一样。</p>
<p>3.constructor</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot; </span><br><span class="line">        default-autowire&#x3D;&quot;constructor&quot;&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;bean id&#x3D;&quot;autoWiringService&quot; class&#x3D;&quot;com.imooc.autowiring.AutoWiringService&quot; &gt;&lt;&#x2F;bean&gt;</span><br><span class="line">        </span><br><span class="line">        &lt;bean id&#x3D;&quot;autoWiringDAO&quot; class&#x3D;&quot;com.imooc.autowiring.AutoWiringDAO&quot; &gt;&lt;&#x2F;bean&gt;</span><br><span class="line">	</span><br><span class="line"> &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>AutoWiringService 中增加构造器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class AutoWiringService &#123;</span><br><span class="line">	</span><br><span class="line">	private AutoWiringDAO autoWiringDAO;</span><br><span class="line">	</span><br><span class="line">	public AutoWiringService(AutoWiringDAO autoWiringDAO) &#123;</span><br><span class="line">		System.out.println(&quot;AutoWiringService&quot;);</span><br><span class="line">		this.autoWiringDAO &#x3D; autoWiringDAO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setAutoWiringDAO(AutoWiringDAO autoWiringDAO) &#123;</span><br><span class="line">		System.out.println(&quot;setAutoWiringDAO&quot;);</span><br><span class="line">		this.autoWiringDAO &#x3D; autoWiringDAO;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void say(String word) &#123;</span><br><span class="line">		this.autoWiringDAO.say(word);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>允行：</p>
<blockquote>
<p>AutoWiringDAO :  this is a test</p>
</blockquote>
<h3 id="六-classPath扫描与组件管理"><a href="#六-classPath扫描与组件管理" class="headerlink" title="六.classPath扫描与组件管理"></a>六.classPath扫描与组件管理</h3><p>从spring 3.0开始，spring javaConfig 项目提供了许多特性，包括使用java而不是xml</p>
<p>1.比如注解</p>
<blockquote>
<p>@Configuration<br>@Bean<br>@Import<br>@DependsOn</p>
<p>@Component 是一个通用注解，应用于任何bean</p>
<p>@Reposity注解DAO</p>
<p>@Service注解service</p>
<p>@Controller注解controller</p>
</blockquote>
<p>2.spring可以自动检测类并注册bean到applicationContext中。比如<br>@Service  @Reposity等</p>
<p>3.&lt; context:annoation-config /&gt;会查找applicationContext中bean的注解。</p>
<p>扫描 ：&lt; context:component-scan&gt;  包含&lt; context:annoation-config/&gt;，通常只需要使用前者。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;context:component-scan base-package&#x3D;&quot;com.forezp&quot; &gt; </span><br></pre></td></tr></table></figure>



<p>举个例子：<br>通过扫描获取bean,在xml中的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot; &gt;</span><br><span class="line">        </span><br><span class="line">        &lt;context:component-scan base-package&#x3D;&quot;com.forezp.beanannotation&quot;&gt;&lt;&#x2F;context:component-scan&gt;</span><br><span class="line">        </span><br><span class="line"> &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>定义一个bean类：<br>其中scope 注解表示bean的作用域，默认singleton。Component默认类名并将第一个字母小写。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Scope</span><br><span class="line">@Component</span><br><span class="line">public class BeanAnnotation &#123;</span><br><span class="line">	</span><br><span class="line">	public void say(String arg) &#123;</span><br><span class="line">		System.out.println(&quot;BeanAnnotation : &quot; + arg);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void myHashCode() &#123;</span><br><span class="line">		System.out.println(&quot;BeanAnnotation : &quot; + this.hashCode());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>单元测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(BlockJUnit4ClassRunner.class)</span><br><span class="line">public class TestBeanAnnotation extends UnitTestBase &#123;</span><br><span class="line">	</span><br><span class="line">	public TestBeanAnnotation() &#123;</span><br><span class="line">		super(&quot;classpath*:spring-beanannotation.xml&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void testSay() &#123;</span><br><span class="line">		BeanAnnotation bean &#x3D; super.getBean(&quot;beanAnnotation&quot;);</span><br><span class="line">		bean.say(&quot;This is test.&quot;);</span><br><span class="line">		</span><br><span class="line">		&#x2F;&#x2F;bean &#x3D; super.getBean(&quot;bean&quot;);</span><br><span class="line">		&#x2F;&#x2F;bean.say(&quot;This is test.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行：</p>
<blockquote>
<p>BeanAnnotation : This is test.</p>
</blockquote>
<h3 id="七、Autowired"><a href="#七、Autowired" class="headerlink" title="七、Autowired"></a>七、Autowired</h3><ul>
<li>@Autowired可以用于setter方法上</li>
<li>可以用于成员变量</li>
<li>可以用于构造器</li>
</ul>
<p>举个例子：</p>
<p>采用包扫描：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">    xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">    xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot; &gt;</span><br><span class="line">        </span><br><span class="line">        &lt;context:component-scan base-package&#x3D;&quot;com.forezp.beanannotation&quot;&gt;&lt;&#x2F;context:component-scan&gt;</span><br><span class="line">        </span><br><span class="line"> &lt;&#x2F;beans&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>采用注解：DAO层</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class InjectionDAOImpl implements InjectionDAO &#123;</span><br><span class="line">	</span><br><span class="line">	public void save(String arg) &#123;</span><br><span class="line">		&#x2F;&#x2F;模拟数据库保存操作</span><br><span class="line">		System.out.println(&quot;保存数据：&quot; + arg);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>service层：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class InjectionServiceImpl implements InjectionService &#123;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;	@Autowired</span><br><span class="line">	private InjectionDAO injectionDAO;</span><br><span class="line">	</span><br><span class="line">	@Autowired</span><br><span class="line">	public InjectionServiceImpl(InjectionDAO injectionDAO) &#123;</span><br><span class="line">		this.injectionDAO &#x3D; injectionDAO;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;	@Autowired</span><br><span class="line">	public void setInjectionDAO(InjectionDAO injectionDAO) &#123;</span><br><span class="line">		this.injectionDAO &#x3D; injectionDAO;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public void save(String arg) &#123;</span><br><span class="line">		&#x2F;&#x2F;模拟业务操作</span><br><span class="line">		System.out.println(&quot;Service接收参数：&quot; + arg);</span><br><span class="line">		arg &#x3D; arg + &quot;:&quot; + this.hashCode();</span><br><span class="line">		injectionDAO.save(arg);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> 单元测试：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> @RunWith(BlockJUnit4ClassRunner.class)</span><br><span class="line">public class TestInjection extends UnitTestBase &#123;</span><br><span class="line">	</span><br><span class="line">	public TestInjection() &#123;</span><br><span class="line">		super(&quot;classpath:spring-beanannotation.xml&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void testAutowired() &#123;</span><br><span class="line">		InjectionService service &#x3D; super.getBean(&quot;injectionServiceImpl&quot;);</span><br><span class="line">		service.save(&quot;This is autowired.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> 运行：</p>
<blockquote>
<p>Service接收参数：This is autowired.</p>
</blockquote>
<blockquote>
<p>保存数据：This is autowired.:1641742937</p>
</blockquote>
<h3 id="八、基于java的容器注解-Bean"><a href="#八、基于java的容器注解-Bean" class="headerlink" title="八、基于java的容器注解@Bean"></a>八、基于java的容器注解@Bean</h3><ul>
<li>@Bean 标识一个用于配置和初始化一个由springIoC容器管理的新对象的方法，类似于　xml配置文件的&lt;/ bean&gt;</li>
</ul>
<p>举个例子：<br>用注解去代替xml文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line"></span><br><span class="line">public class StoreConfig &#123;</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">@Bean(name &#x3D; &quot;stringStore&quot;, initMethod&#x3D;&quot;init&quot;, destroyMethod&#x3D;&quot;destroy&quot;)</span><br><span class="line">	public Store stringStore() &#123;</span><br><span class="line">		return new StringStore();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>javabean StringStore类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class StringStore implements Store&lt;String&gt; &#123;</span><br><span class="line">	</span><br><span class="line">	public void init() &#123;</span><br><span class="line">		System.out.println(&quot;This is init.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		System.out.println(&quot;This is destroy.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>单元测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(BlockJUnit4ClassRunner.class)</span><br><span class="line">public class TestJavabased extends UnitTestBase &#123;</span><br><span class="line">	</span><br><span class="line">	public TestJavabased() &#123;</span><br><span class="line">		super(&quot;classpath*:spring-beanannotation.xml&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@Test</span><br><span class="line">	public void test() &#123;</span><br><span class="line">		Store store &#x3D; super.getBean(&quot;stringStore&quot;);</span><br><span class="line">		System.out.println(store.getClass().getName());</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外可以用ImportResource注解类获取资源文件信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ImportResource(&quot;classpath:config.xml&quot;)</span><br><span class="line">public class StoreConfig &#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	@Value(&quot;$&#123;url&#125;&quot;)</span><br><span class="line">	private String url;</span><br><span class="line">	</span><br><span class="line">	@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span><br><span class="line">	private String username;</span><br><span class="line">	</span><br><span class="line">	@Value(&quot;$&#123;password&#125;&quot;)</span><br><span class="line">	private String password;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="九、JSR-250"><a href="#九、JSR-250" class="headerlink" title="九、JSR-250"></a>九、JSR-250</h3><ul>
<li>spring支持jsr-250 </li>
<li>@Resource注解变量或者setter 方法</li>
<li>Resource注解有一个name属性，默认该值作为被注入bean的名称。</li>
</ul>
<p>举个例子：</p>
<p>Dao层：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class JsrDAO &#123;</span><br><span class="line">	</span><br><span class="line">	public void save() &#123;</span><br><span class="line">		System.out.println(&quot;JsrDAO invoked.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>service层：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class JsrServie &#123;</span><br><span class="line">	</span><br><span class="line">	@Resource</span><br><span class="line">	private JsrDAO jsrDAO;</span><br><span class="line">	</span><br><span class="line">&#x2F;&#x2F;	@Resource</span><br><span class="line">&#x2F;&#x2F;	public void setJsrDAO(@Named(&quot;jsrDAO&quot;) JsrDAO jsrDAO) &#123;</span><br><span class="line">	&#x2F;&#x2F;	this.jsrDAO &#x3D; jsrDAO;</span><br><span class="line">	&#x2F;&#x2F;&#125;</span><br><span class="line">	</span><br><span class="line">	@PostConstruct</span><br><span class="line">	public void init() &#123;</span><br><span class="line">		System.out.println(&quot;JsrServie init.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	@PreDestroy</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		System.out.println(&quot;JsrServie destroy.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void save() &#123;</span><br><span class="line">		jsrDAO.save();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合2</title>
    <url>/2016/11/12/j2ee-2016-05-05-ssm1/</url>
    <content><![CDATA[<p>上一篇讲述了DAO 层，mybatis实现数据库的连接，DAO层接口设计，以及mybtis和spring的整合。DAO层采用接口设计方式实现，接口和SQL实现的分离，方便维护。DAO层所负责的仅仅是接口的设计和实现，而负责的逻辑即一个或多个DAO层接口的拼接是在Sevice层中完成。这篇文章接上篇文章，主要讲述Service层的实现、和Spring的整合以及声明如何声明事物。</p>
<span id="more"></span>

<p>###一、Service层接口设计<br>业务接口设计应当站在“使用者”角度设计接口，应遵循三个规范：合理的命令，明确的参数，返回结果（正常接口／异常结果）。本例子采用的Java高并发的秒杀API系列课程的例子，创建设计的业务逻辑接口如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface SeckillService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询所有秒杀记录</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    List&lt;Seckill&gt; getSerkillList();</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询单个秒杀记录</span><br><span class="line">     * @param seckillId</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Seckill getById(long seckillId);</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 秒杀开启时输出秒杀接口地址，</span><br><span class="line">     * 否则输出系统时间和秒杀时间</span><br><span class="line">     * @param seckillId</span><br><span class="line">     *&#x2F;</span><br><span class="line">    Exposer exportSeckillUrl(long seckillId);</span><br><span class="line">   </span><br><span class="line">	</span><br><span class="line">	／**</span><br><span class="line">	  *执行秒杀接口</span><br><span class="line">	  *&#x2F;</span><br><span class="line">   SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException,RepeatKillException,SeckillCloseException;</span><br><span class="line">  </span><br><span class="line">     </span><br></pre></td></tr></table></figure>

<h3 id="二、Service接口的实现"><a href="#二、Service接口的实现" class="headerlink" title="二、Service接口的实现"></a>二、Service接口的实现</h3><p>直接上代码了，在这里讲下秒杀业务的逻辑：首先是获取秒杀列表，点击列表进入秒杀详情页，这时获取系统时间，如果秒杀开始，获取秒杀地址，点击秒杀，执行秒杀。所以业务逻辑也只设计了这相关的4个业务逻辑。其中使用了dto层去传递响应数据，以及自定义异常，所有的异常都继承运行异常，这是为了方便spring自动回滚，这两个知识点，自行看源码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package org.forezp.service.impl;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class SeckillServiceImpl implements SeckillService&#123;</span><br><span class="line">    private Logger logger&#x3D; LoggerFactory.getLogger(this.getClass());</span><br><span class="line">    &#x2F;&#x2F;注入service依赖</span><br><span class="line">    @Autowired</span><br><span class="line">    private SeckillDao seckillDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SuccessKilledDao successKilledDao;</span><br><span class="line">    &#x2F;&#x2F;MD5盐值字符串，用户混淆MD5</span><br><span class="line">    private final String slat&#x3D;&quot;sfsa&#x3D;32q4r23234215ERWERT^**%^SDF&quot;;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    public List&lt;Seckill&gt; getSerkillList() &#123;</span><br><span class="line">        return seckillDao.queryAll(0,4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Seckill getById(long seckillId) &#123;</span><br><span class="line">        return seckillDao.queryById(seckillId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public Exposer exportSeckillUrl(long seckillId) &#123;</span><br><span class="line">        Seckill seckill &#x3D;seckillDao.queryById(seckillId);</span><br><span class="line">        if(seckill&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return new Exposer(false,seckillId);</span><br><span class="line">        &#125;</span><br><span class="line">        Date startTime&#x3D;seckill.getStartTime();</span><br><span class="line">        Date endTime&#x3D;seckill.getEndTime();</span><br><span class="line">        &#x2F;&#x2F;系统当前时间</span><br><span class="line">        Date nowTime&#x3D;new Date();</span><br><span class="line">        if(nowTime.getTime()&lt;startTime.getTime()||nowTime.getTime()&gt;endTime.getTime())&#123;</span><br><span class="line">            return new Exposer(false,seckillId,nowTime.getTime(),startTime.getTime(),endTime.getTime());</span><br><span class="line">        &#125;</span><br><span class="line">        String md5&#x3D;getMD5(seckillId);</span><br><span class="line">        return new Exposer(true,md5,seckillId);</span><br><span class="line">    &#125;</span><br><span class="line">    private String getMD5(long seckillId)&#123;</span><br><span class="line">        String base&#x3D;seckillId+&quot;&#x2F;&quot;+slat;</span><br><span class="line">        String md5&#x3D; DigestUtils.md5DigestAsHex(base.getBytes());</span><br><span class="line">        return md5;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    @Transactional</span><br><span class="line">    &#x2F;**</span><br><span class="line">     *使用注解控制事务方法的优点</span><br><span class="line">     * 1：开发团队达成一致约定，明确标注事务方法的编程风格</span><br><span class="line">     * 2：保证事务方法的执行时间尽可能短，不要穿插其他网络请求，RPC&#x2F;HTTP请求或者剥离到事务方法外</span><br><span class="line">     * 3：不是所有的方法都需要事务，如只有一条修改操作，只读操作不需要事务控制</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException &#123;</span><br><span class="line">        if(md5&#x3D;&#x3D;null ||!md5.equals(getMD5(seckillId)))&#123;</span><br><span class="line">            throw new SeckillException(&quot;seckill data rewrite&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;执行秒杀逻辑：减库存+记录购买行为</span><br><span class="line">        Date nowTime&#x3D;new Date();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;记录购买行为</span><br><span class="line">            int insertCount&#x3D;successKilledDao.insertSuccessKilled(seckillId,userPhone);</span><br><span class="line">            &#x2F;&#x2F;唯一：seckillId，userphone</span><br><span class="line">            if(insertCount&lt;&#x3D;0)&#123;</span><br><span class="line">                &#x2F;&#x2F;重复秒杀</span><br><span class="line">                throw new RepeatKillException(&quot;seckill repeated&quot;);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                &#x2F;&#x2F;减库存，热点商品竞争</span><br><span class="line">                int updateCount&#x3D;seckillDao.reduceNumber(seckillId,nowTime);</span><br><span class="line">                if(updateCount&lt;&#x3D;0)&#123;</span><br><span class="line">                    &#x2F;&#x2F;没有更新到记录,秒杀结束 rollback</span><br><span class="line">                    throw new SeckillCloseException(&quot;seckill is closed&quot;);</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    &#x2F;&#x2F;秒杀成功 commit</span><br><span class="line">                    SuccessKilled successKilled&#x3D;successKilledDao.queryByIdWithSeckill(seckillId,userPhone);</span><br><span class="line">                    return new SeckillExecution(seckillId, SeckillStatEnum.SUCCESS,successKilled);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;catch(SeckillCloseException e1)&#123;</span><br><span class="line">            throw e1;</span><br><span class="line">        &#125; catch (RepeatKillException e2)&#123;</span><br><span class="line">            throw e2;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">            &#x2F;&#x2F;所有的编译期异常，转化为运行期异常(运行时异常，spring可以做rollback操作)</span><br><span class="line">            throw new SeckillException(&quot;seckill inner error:&quot;+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;抛出异常是为了告诉spring是否rollback，此处使用存储过程的话，就不需要抛异常了</span><br><span class="line">    public SeckillExecution executeSeckillProcedure(long seckillId, long userPhone, String md5) &#123;</span><br><span class="line">        if(md5 &#x3D;&#x3D;null || !md5.equals(getMD5(seckillId)))&#123;</span><br><span class="line">            return new SeckillExecution(seckillId,SeckillStatEnum.DATA_REWRITE);</span><br><span class="line">        &#125;</span><br><span class="line">        Date killTime&#x3D;new Date();</span><br><span class="line">        Map&lt;String,Object&gt; map&#x3D;new HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(&quot;seckillId&quot;,seckillId);</span><br><span class="line">        map.put(&quot;phone&quot;,userPhone);</span><br><span class="line">        map.put(&quot;killTime&quot;,killTime);</span><br><span class="line">        map.put(&quot;result&quot;,null);</span><br><span class="line">        &#x2F;&#x2F;执行存储过程，result被赋值</span><br><span class="line">        try &#123;</span><br><span class="line">            seckillDao.killByProcedure(map);</span><br><span class="line">            int result&#x3D;(Integer) map.get(&quot;result&quot;);</span><br><span class="line">            if(result&#x3D;&#x3D;1)&#123;</span><br><span class="line">                SuccessKilled successKilled&#x3D;successKilledDao.queryByIdWithSeckill(seckillId,userPhone);</span><br><span class="line">                return new SeckillExecution(seckillId, SeckillStatEnum.SUCCESS,successKilled);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return new SeckillExecution(seckillId,SeckillStatEnum.stateof(result));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.error(e.getMessage(),e);</span><br><span class="line">            return new SeckillExecution(seckillId,SeckillStatEnum.INNER_ERROE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="三、Sping托管-service的实现类"><a href="#三、Sping托管-service的实现类" class="headerlink" title="三、Sping托管 service的实现类"></a>三、Sping托管 service的实现类</h3><p>和上一篇文章使用spring托管dao接口一样，这里也需要用 spring 托管service. spring ioc 使用对象工程模式，对所有的注入的依赖进行了管理，暴露出了一致性的访问接口，当我们需要某个对象时，直接从spring ioc中取就行了，不需要new，也不需要对它们的生命周期进行管理。更为重要的是spring 自动组装依赖，比如最终的接口controller依赖service,而service依赖dao,dao依赖sessionfactory,而sessionfactory依赖datasource,这些层层依赖是通过spring管理并层层组装，只要我们简单配置和注解就可以方便的使用，代码的分层和编程的艺术在spring框架中展现得淋漓尽至。</p>
<blockquote>
<p>本项目采用spring ioc :</p>
<p>1.xml配置</p>
<p>2.包扫描</p>
<p>3.annotation注解。</p>
</blockquote>
<p>创建sping-service.xml</p>
<p>采用包扫描+注解方式，首先在xml中声明包扫描：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xmlns:tx&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;tx&#x2F;spring-tx.xsd&quot;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;!--扫描service包下所有使用注解的类型--&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;org.forezp.service&quot;&#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在org,forezp.service包下的类采用注解。比如@Service 注解声明是一个service， @Autowired注入service 所需依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service&#x2F;&#x2F;声明是一个service</span><br><span class="line">public class SeckillServiceImpl implements SeckillService&#123;</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;注入service依赖</span><br><span class="line">    @Autowired</span><br><span class="line">    private SeckillDao seckillDao;</span><br><span class="line">    @Autowired</span><br><span class="line">    private SuccessKilledDao successKilledDao;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只需要一个包扫描和几个简单的注解就可以将service注解到spring  ioc容器中。</p>
<h3 id="四、spring声明式事物"><a href="#四、spring声明式事物" class="headerlink" title="四、spring声明式事物"></a>四、spring声明式事物</h3><p>在秒杀案例中，我们需要采用事物来防止数据的正确性，防止重复秒杀，防止库存不足、库存剩余等情况。一般使用事物需要开启事物／经常一些列的操作，提交或者回滚。spring声明式事物，就是将事物的开启、提交等托管给spring管理，我们只需要注重如何修改数据。</p>
<p>配置spring 声明式事物<br>在spring-service.xml中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--配置事务管理器--&gt;</span><br><span class="line">   &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">       &lt;!--注入数据库连接池--&gt;</span><br><span class="line">       &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">   &lt;!--配置基于注解的声明式事务</span><br><span class="line">       默认使用注解来管理事务行为</span><br><span class="line">   --&gt;</span><br><span class="line">   &lt;tx:annotation-driven transaction-manager&#x3D;&quot;transactionManager&quot;&#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在需要事物的业务逻辑下加 @Transactional注解。<br>比如在开启秒杀方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public SeckillExecution executeSeckill(long seckillId, long userPhone, String md5) throws SeckillException, RepeatKillException, SeckillCloseException &#123;</span><br><span class="line">        if(md5&#x3D;&#x3D;null ||!md5.equals(getMD5(seckillId)))&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><em>注意：</em></p>
<blockquote>
<p>1开发团队达成一致约定，明确标注事务方法的编程风格</p>
<p>2：保证事务方法的执行时间尽可能短，不要穿插其他网络请求，RPC/HTTP请求或者剥离到事务方法外</p>
<p>3：不是所有的方法都需要事务，如只有一条修改操作，只读操作不需要事务控制</p>
</blockquote>
<h3 id="五、单元测试"><a href="#五、单元测试" class="headerlink" title="五、单元测试"></a>五、单元测试</h3><p>需要配置:</p>
<blockquote>
<p>@ContextConfiguration({<br>        “classpath:spring/spring-dao.xml”,<br>        “classpath:spring/spring-service.xml”<br>})<br>直接上代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(&#123;</span><br><span class="line">        &quot;classpath:spring&#x2F;spring-dao.xml&quot;,</span><br><span class="line">        &quot;classpath:spring&#x2F;spring-service.xml&quot;</span><br><span class="line">&#125;)</span><br><span class="line">public class SeckillServiceTest &#123;</span><br><span class="line">    private final Logger logger&#x3D;LoggerFactory.getLogger(this.getClass());</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SeckillService seckillService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getSerkillList() throws Exception &#123;</span><br><span class="line">        List&lt;Seckill&gt; list&#x3D;seckillService.getSerkillList();</span><br><span class="line">       System.out.println(list);</span><br><span class="line">       &#x2F;&#x2F;执行结果[Seckill&#123;seckillId&#x3D;1000, name&#x3D;&#39;1000元秒杀iphone6&#39;..... 省略。。。]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getById() throws Exception &#123;</span><br><span class="line">        long id&#x3D;1000;</span><br><span class="line">        Seckill seckill&#x3D;seckillService.getById(id);</span><br><span class="line">        System.out.println(seckill);</span><br><span class="line">        &#x2F;&#x2F;执行结果：Seckill&#123;seckillId&#x3D;1000, name&#x3D;&#39;1000元秒杀iphone6&#39;, number&#x3D;100, startTime&#x3D;Sun Nov 01 00:00:00 CST 2015,。。。。&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void exportSeckillUrl() throws Exception &#123;</span><br><span class="line">        long id&#x3D;1000;</span><br><span class="line">        Exposer exposer&#x3D;seckillService.exportSeckillUrl(id);</span><br><span class="line">        System.out.println(exposer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void executeSeckill() throws Exception &#123;</span><br><span class="line">        long id&#x3D;1000;</span><br><span class="line">        long phone&#x3D;13502171122L;</span><br><span class="line">        String md5&#x3D;&quot;e83eef2cc6b033ca0848878afc20e80d&quot;;</span><br><span class="line">        SeckillExecution execution&#x3D;seckillService.executeSeckill(id,phone,md5);</span><br><span class="line">        System.out.println(execution);</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这篇文章主要讲了service业务接口的编写和实现，以及采用xml和注解方式讲service 注入到spring ioc，以及声明式事物，不得不感叹spring 的强大。下一篇文章讲讲述 web层的开发，spring mvc的相关配置。感谢大家，再接再厉，晚安。^_^。</p>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合3</title>
    <url>/2016/11/12/j2ee-2016-05-05-ssm2/</url>
    <content><![CDATA[<p>###一.SpringMVC理论</p>
<blockquote>
<p>它始终是围绕 handler、<br>数据模型 model、<br>页面view进行开发的。</p>
</blockquote>
<p>运行流程图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0db2fd62077e21cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="33A5816F-66F9-43A3-B616-8E2D409B4CA3.png"></p>
<span id="more"></span>

<p>通过mvc配置文件，配置“中央处理器”dispatchservlet，当用户请求一个url，dispatchservlet通过handlerMapping（通过注解的形式）将url给对应的handleradapter,handleradapter的具体业务逻辑是controller即我们需要实现的部分，实现具体的业务逻辑之后，需要返回modelandview给dispatchservlet，dispatchservlet再返回具体的数据或者jsp给用户。</p>
<h3 id="二-http请求地址映射"><a href="#二-http请求地址映射" class="headerlink" title="二.http请求地址映射"></a>二.http请求地址映射</h3><blockquote>
<p>http请求 -&gt; sringmvc handler mapping注解 -&gt; handler处理</p>
</blockquote>
<p>1.注解映射：<br>@RequestMapping</p>
<ul>
<li>支持标准url</li>
<li>ant风格url (? * 字符形式)</li>
<li>{xxx}占位符  restful 形式</li>
</ul>
<p>2.请求方法细节</p>
<ul>
<li>请求参数绑定</li>
<li>请求方式限制</li>
<li>请求转发和重定向</li>
<li>数据模型赋值</li>
<li>返回joson数据</li>
</ul>
<p>举个列子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@RequestMapping(value&#x3D;&quot;&#x2F;&#123;seckillId&#125;&#x2F;detail&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public String detail(@PathVariable(&quot;seckillId&quot;) Long seckillId, Model model)&#123;</span><br><span class="line">        if(seckillId&#x3D;&#x3D;null)&#123;</span><br><span class="line">            return &quot;redirect:&#x2F;seckill&#x2F;list&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        Seckill seckill&#x3D;seckillService.getById(seckillId);</span><br><span class="line">        if(seckill&#x3D;&#x3D;null)&#123;</span><br><span class="line">             return &quot;redirect:&#x2F;seckill&#x2F;list&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        model.addAttribute(&quot;seckill&quot;,seckill);</span><br><span class="line">      return &quot;detail&quot;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@PathVariable(“seckillId”)  请求参数绑定</p>
<p>method = RequestMethod.GET) 请求方式限制</p>
<p> return “redirect:/seckill/list”;<br>  return “redirect:/seckill/list”;请求转发和重定向</p>
<p>model.addAttribute(“seckill”,seckill);数据模型赋值</p>
</blockquote>
<blockquote>
<p>返回json通过produces = {“application/json;charset=UTF-8”}／ @ResponseBody注解</p>
</blockquote>
<p>###三.整合springMVC框架<br>在webapp 的web-inf下的web.xml配置。<br>配置DisatchServlet：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">    &lt;servlet-name&gt;seckill-dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span><br><span class="line">      &lt;init-param&gt;</span><br><span class="line">          &lt;param-name&gt;contextConfigLocation&lt;&#x2F;param-name&gt;</span><br><span class="line">          &lt;param-value&gt;classpath:spring&#x2F;spring-*.xml&lt;&#x2F;param-value&gt;</span><br><span class="line">      &lt;&#x2F;init-param&gt;</span><br><span class="line">  &lt;&#x2F;servlet&gt;</span><br><span class="line">  </span><br><span class="line">   &lt;servlet-mapping&gt;</span><br><span class="line">        &lt;servlet-name&gt;seckill-dispatcher&lt;&#x2F;servlet-name&gt;</span><br><span class="line">        &lt;!--默认匹配所有的请求--&gt;</span><br><span class="line">        &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span><br><span class="line">    &lt;&#x2F;servlet-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建spring-web.xml配置SpringMvc,在代码中有详细的注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:mvc&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;mvc&#x2F;spring-mvc.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;</span><br><span class="line">&gt;</span><br><span class="line">    &lt;!--配置springMVC--&gt;</span><br><span class="line">    &lt;!--1:开启springMVC注解模式--&gt;</span><br><span class="line">    &lt;!--简化配置</span><br><span class="line">    （1）自动注册DefautAnnotationHandlerMapping,AnnotationMethodHandlerAdapter</span><br><span class="line">     (2) 提供一系列：数据绑定，数字和日期的format @NumberFormat，@DataTimeFormat,</span><br><span class="line">         xml,json默认读写支持</span><br><span class="line">    --&gt;</span><br><span class="line">   &lt;mvc:annotation-driven&#x2F;&gt;</span><br><span class="line">    &lt;!--2:静态资源默认servlet配置</span><br><span class="line">    1：加入对静态资源的处理：js，gif,png</span><br><span class="line">    2:允许使用&quot;&#x2F;&quot;做整体映射</span><br><span class="line">    --&gt;</span><br><span class="line">   &lt;mvc:default-servlet-handler&#x2F;&gt;</span><br><span class="line">    &lt;!--3:配置jsp 显示viewResolver--&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;viewClass&quot; value&#x3D;&quot;org.springframework.web.servlet.view.JstlView&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;prefix&quot; value&#x3D;&quot;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;suffix&quot; value&#x3D;&quot;.jsp&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">    &lt;!--4:扫描web相关的bean--&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;org.forezp.web&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>

<h3 id="四-controller的实现"><a href="#四-controller的实现" class="headerlink" title="四.controller的实现"></a>四.controller的实现</h3><blockquote>
<p>通过@Controller 注解将controller注入到spring ioc中</p>
<p>@RequestMapping url映射</p>
<p>model用来存放数据的。</p>
</blockquote>
<p>例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">@RequestMapping(&quot;&#x2F;seckill&quot;) &#x2F;&#x2F;url:&#x2F;模块&#x2F;资源&#x2F;&#123;id&#125;&#x2F;细分  &#x2F;seckill&#x2F;list</span><br><span class="line">public class SeckillController &#123;</span><br><span class="line">    private final Logger logger&#x3D; LoggerFactory.getLogger(this.getClass());</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private SeckillService seckillService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&#x2F;list&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public String list(Model model)&#123;</span><br><span class="line">        &#x2F;&#x2F;获取列表页</span><br><span class="line">       List&lt;Seckill&gt; list&#x3D;seckillService.getSerkillList();</span><br><span class="line">        model.addAttribute(&quot;list&quot;,list);</span><br><span class="line">        &#x2F;&#x2F;list.jsp+model&#x3D;ModelAndView</span><br><span class="line">        return &quot;list&quot;;&#x2F;&#x2F;&#x2F;WEB-INF&#x2F;jsp&#x2F;&quot;list&quot;.jsp</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>###五.view的实现</p>
<p>直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ taglib prefix&#x3D;&quot;c&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;core&quot; %&gt;</span><br><span class="line">&lt;%@ taglib prefix&#x3D;&quot;fmt&quot; uri&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;jsp&#x2F;jstl&#x2F;fmt&quot; %&gt;</span><br><span class="line">&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;秒杀列表页&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;%@include file&#x3D;&quot;common&#x2F;head.jsp&quot; %&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;!--页面显示部分--&gt;</span><br><span class="line">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;panel panel-default&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;panel-heading text-center&quot;&gt;</span><br><span class="line">            &lt;h2&gt;秒杀列表&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;panel-body&quot;&gt;</span><br><span class="line">            &lt;table class&#x3D;&quot;table table-hover&quot;&gt;</span><br><span class="line">                &lt;thead&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;th&gt;名称&lt;&#x2F;th&gt;</span><br><span class="line">                    &lt;th&gt;库存&lt;&#x2F;th&gt;</span><br><span class="line">                    &lt;th&gt;开始时间&lt;&#x2F;th&gt;</span><br><span class="line">                    &lt;th&gt;结束时间&lt;&#x2F;th&gt;</span><br><span class="line">                    &lt;th&gt;创建时间&lt;&#x2F;th&gt;</span><br><span class="line">                    &lt;th&gt;详情页&lt;&#x2F;th&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;&#x2F;thead&gt;</span><br><span class="line">                &lt;tbody&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;c:forEach var&#x3D;&quot;sk&quot; items&#x3D;&quot;$&#123;list&#125;&quot;&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;$&#123;sk.name&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td&gt;$&#123;sk.number&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &lt;fmt:formatDate value&#x3D;&quot;$&#123;sk.startTime&#125;&quot; pattern&#x3D;&quot;yyyy-MM-dd HH:mm:ss&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &lt;fmt:formatDate value&#x3D;&quot;$&#123;sk.endTime&#125;&quot; pattern&#x3D;&quot;yyyy-MM-dd HH:mm:ss&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &lt;fmt:formatDate value&#x3D;&quot;$&#123;sk.createTime&#125;&quot; pattern&#x3D;&quot;yyyy-MM-dd HH:mm:ss&quot;&#x2F;&gt;</span><br><span class="line">                    &lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td&gt;</span><br><span class="line">                        &lt;a class&#x3D;&quot;btn btn-info&quot; href&#x3D;&quot;&#x2F;minnkill&#x2F;seckill&#x2F;$&#123;sk.seckillId&#125;&#x2F;detail&quot; target&#x3D;&quot;_blank&quot;&gt;link&lt;&#x2F;a&gt;</span><br><span class="line">                    &lt;&#x2F;td&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;&#x2F;c:forEach&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;&#x2F;tbody&gt;</span><br><span class="line">            &lt;&#x2F;table&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;!-- jQuery文件。务必在bootstrap.min.js 之前引入 --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;apps.bdimg.com&#x2F;libs&#x2F;jquery&#x2F;2.0.0&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 最新的 Bootstrap 核心 JavaScript 文件 --&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;apps.bdimg.com&#x2F;libs&#x2F;bootstrap&#x2F;3.3.0&#x2F;js&#x2F;bootstrap.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>运行tomacat，<a target="_blank" rel="noopener" href="http://localhost:8080/minnkill/seckill/list%E9%A1%B5%E9%9D%A2%E5%86%85%E5%AE%B9%E7%9A%84%E5%B1%95%E7%A4%BA">http://localhost:8080/minnkill/seckill/list页面内容的展示</a>:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-7c9faaa1b52d6dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<blockquote>
<p>通过url:<a target="_blank" rel="noopener" href="http://localhost:8080/minnkill/seckill/list;%E6%9C%8D%E5%8A%A1%E7%AB%AF%E9%80%9A%E8%BF%87springmvc-mybatis%E6%A1%86%E6%9E%B6%E4%BB%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8B%BF%E5%88%B0%E4%BA%86%E6%95%B0%E6%8D%AE%E5%B9%B6%E5%B1%95%E7%A4%BA%E5%9C%A8%E9%A1%B5%E9%9D%A2%E4%B8%8A%E3%80%82">http://localhost:8080/minnkill/seckill/list;服务端通过springmvc-mybatis框架从数据库拿到了数据并展示在页面上。</a></p>
</blockquote>
<p>本系列文章到此结束，它属于我学习完秒杀api的课程的一个总结，由于个人水平和精力的有限，并不能做到面面俱到，也没有深入的的讲解SSM这个框架，再未来的三到四个月里，我会不断的学习，j2ee框架，servelet\jsp\mysql,以及html\css\js的知识，也算是一次小的冲刺，大家一起加油，一起进步。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9697343">源码下载</a></p>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM整合1</title>
    <url>/2016/11/12/j2ee-2016-05-05-ssm3/</url>
    <content><![CDATA[<p>最近实在太忙，之前写的《rxjava系列文章》告一段落，还有两篇会在一月中旬补上，感谢大家。这篇文章讲述mybatis搭建DAO层，另外这系列文章是我看完《java高并发秒杀系列》的课程整理的，所以文章采用的例子也来源于这系列课程。</p>
<span id="more"></span>

<h3 id="一-环境／工具"><a href="#一-环境／工具" class="headerlink" title="一.环境／工具"></a>一.环境／工具</h3><p>1.开发工具idea</p>
<p>2.数据库mysql</p>
<p>3.javaweb容器 tomcat</p>
<p>4.构建项目工具maven</p>
<p>关于这几个工具下载安装，环境的搭建就不介绍，自行百度。</p>
<h3 id="二-采用maven-构建项目"><a href="#二-采用maven-构建项目" class="headerlink" title="二.采用maven 构建项目"></a>二.采用maven 构建项目</h3><p>采用命令构架，当然也可以采用ide 直接构建。</p>
<p><em>构建命令：</em></p>
<blockquote>
<p>mvn archetype:generate -DgroupId=org.forezp -DartifactId=minnkill -DarchetypeArtifactId=maven-archetype-webapp</p>
</blockquote>
<p>低版本maven需要将generate 改为create.</p>
<h3 id="三-补全SSM框架相关依赖"><a href="#三-补全SSM框架相关依赖" class="headerlink" title="三.补全SSM框架相关依赖"></a>三.补全SSM框架相关依赖</h3><p>下面是SSM框架所需的所有框架</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;maven-v4_0_0.xsd&quot;&gt;</span><br><span class="line">  &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line">  &lt;groupId&gt;org.seckill&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;seckill&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;packaging&gt;war&lt;&#x2F;packaging&gt;</span><br><span class="line">  &lt;version&gt;1.0.0&lt;&#x2F;version&gt;</span><br><span class="line">  &lt;name&gt;seckill Maven Webapp&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;url&gt;http:&#x2F;&#x2F;maven.apache.org&lt;&#x2F;url&gt;</span><br><span class="line">  &lt;dependencies&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;!--使用junit4，4以上使用注解--&gt;</span><br><span class="line">      &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.11&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--补全项目依赖--&gt;</span><br><span class="line">    &lt;!--1:日志，java日志：slf4j,log4j,logback,common-logging</span><br><span class="line">     使用：slf4j+logBack</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.slf4j&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;slf4j-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.5.6&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;logback-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.1.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;logback-classic&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.1.1&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--2:数据库相关依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.35&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;c3p0&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;c3p0&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;0.9.1.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;commons-dbcp&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;commons-dbcp&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.4&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--DAO框架：MyBatis依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.3.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--myBatis自身实现的spring整合依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;mybatis-spring&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.2.3&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--3:Servlet web相关依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;taglibs&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;standard&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.1.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;jstl&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;1.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;2.5.4&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.1.0&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--4:spring依赖--&gt;</span><br><span class="line">    &lt;!--spring核心依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.1.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-beans&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.1.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--spring dao层依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.1.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.1.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--spring web相关依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.1.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-webmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.1.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line">    &lt;!--spring test相关依赖--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;spring-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;4.1.7.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--引入一些工具类--&gt;</span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;commons-collections&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;commons-collections&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;3.2&lt;&#x2F;version&gt;</span><br><span class="line">    &lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br><span class="line">  &lt;build&gt;</span><br><span class="line">    &lt;finalName&gt;seckill&lt;&#x2F;finalName&gt;</span><br><span class="line">  &lt;&#x2F;build&gt;</span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="四-建数据库"><a href="#四-建数据库" class="headerlink" title="四.建数据库"></a>四.建数据库</h3><p>仿java高并发秒杀系列》的视频，建了两张表，一张上库存表，一张上秒杀表，我直接贴sql语句了，比较简单。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--创建数据库</span><br><span class="line">CREATE DATABASE seckill;</span><br><span class="line">--使用数据库</span><br><span class="line">use seckill;</span><br><span class="line"></span><br><span class="line">--库存表</span><br><span class="line">CREATE TABLE seckill(</span><br><span class="line">&#96;seckill_id&#96; bigint NOT NULL AUTO_INCREMENT COMMENT &#39;商品库存id&#39;,</span><br><span class="line">&#96;name&#96; VARCHAR(120) NOT NULL COMMENT &#39;商品名称&#39;,</span><br><span class="line">&#96;number&#96; int  NOT NULL COMMENT &#39;库存数量&#39;,</span><br><span class="line">&#96;start_time&#96; timestamp NOT NULL  DEFAULT &quot;2016-05-07 13:28:00&quot;,</span><br><span class="line">&#96;end_time&#96; timestamp NOT NULL  DEFAULT &quot;2016-05-07 13:28:00&quot;,</span><br><span class="line">&#96;create_time&#96; timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP  COMMENT &#39;创建时间&#39;,</span><br><span class="line"> PRIMARY KEY (seckill_id),</span><br><span class="line"> key idx_start_time(start_time),</span><br><span class="line">key idx_end_time(end_time),</span><br><span class="line"> key idx_create_time(create_time)</span><br><span class="line">)EnGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1000 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;秒杀库存表&#39;;</span><br><span class="line"></span><br><span class="line">---初始化数据</span><br><span class="line">insert into seckill(name,number,start_time,end_time)</span><br><span class="line">VALUES</span><br><span class="line"> (&#39;1000元秒杀iphone6&#39;,100,&#39;2015-11-01 00:00:00&#39;,&#39;2015-11-02 00:00:00&#39;),</span><br><span class="line"> (&#39;500元秒杀ipad2&#39;,200,&#39;2015-11-01 00:00:00&#39;,&#39;2015-11-02 00:00:00&#39;),</span><br><span class="line"> (&#39;300元秒杀小米4&#39;,300,&#39;2015-11-01 00:00:00&#39;,&#39;2015-11-02 00:00:00&#39;),</span><br><span class="line"> (&#39;200元秒杀红米note&#39;,400,&#39;2015-11-01 00:00:00&#39;,&#39;2015-11-02 00:00:00&#39;);</span><br><span class="line"></span><br><span class="line"> --秒杀成功明细表</span><br><span class="line"> --用户登录认证相关的信息</span><br><span class="line"> create table success_killed(</span><br><span class="line"> &#96;seckill_id&#96; bigint NOT NULL COMMENT &#39;秒杀商品id&#39;,</span><br><span class="line"> &#96;user_phone&#96; bigint NOT NULL COMMENT &#39;用户手机号&#39;,</span><br><span class="line">&#96;state&#96; tinyint NOT NULL DEFAULT 0 COMMENT &#39;状态标示:-1:无效 0:成功 1:已付款&#39;,</span><br><span class="line">&#96;create_time&#96; TIMESTAMP NOT NULL COMMENT &#39;创建时间&#39;,</span><br><span class="line">PRIMARY  KEY (seckill_id,user_phone),&#x2F;*联合主键*&#x2F;</span><br><span class="line">KEY idx_create_time(create_time)</span><br><span class="line"> )EnGINE&#x3D;InnoDB  DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&#39;秒杀明细表&#39;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="五-DAO层实体编写和接口编写"><a href="#五-DAO层实体编写和接口编写" class="headerlink" title="五.DAO层实体编写和接口编写"></a>五.DAO层实体编写和接口编写</h3><p>1.创建org.forezp.entity包，根据数据库字段，编写实体。<br>下面是Seckill库存实体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Seckill &#123;</span><br><span class="line">    private long seckillId;</span><br><span class="line">    private String name;</span><br><span class="line">    private int number;</span><br><span class="line">    private Date startTime;</span><br><span class="line">    private Date endTime;</span><br><span class="line">    private Date createTime;</span><br><span class="line">    &#x2F;&#x2F;这里省去了写getter setter方法，在实际项目补上	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建org.forezp.dao包<br>编写Seckill接口</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface SeckillDao &#123;</span><br><span class="line">    &#x2F;&#x2F;减库存</span><br><span class="line">    int reduceNumber(@Param(&quot;seckillId&quot;)long seckillId,@Param(&quot;killTime&quot;)Date killTime);</span><br><span class="line">    &#x2F;&#x2F;根据Id查询秒杀对象</span><br><span class="line">    Seckill queryById(long seckillId);</span><br><span class="line">    &#x2F;&#x2F;根据偏移量查询秒杀列表</span><br><span class="line">    List&lt;Seckill&gt; queryAll(@Param(&quot;offset&quot;)int offset,@Param(&quot;limit&quot;)int limit);</span><br><span class="line">   </span><br></pre></td></tr></table></figure>

<p>采用mapper实现接口</p>
<p>在resources目录下创建maaper文件夹，所有的接口实现类放在这里 ，另外项目采用xml的方式实现接口。采用这种方式的好处有很多，比如可以采用包扫描，更少的配置，所有的sql语句都放在这里，有利于统一规范，代码的可维护性和可读性也大大提高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;mapper namespace&#x3D;&quot;org.forezp.dao.SeckillDao&quot;&gt;</span><br><span class="line"></span><br><span class="line">	&lt;update id&#x3D;&quot;reduceNumber&quot;&gt;</span><br><span class="line">		update</span><br><span class="line">		seckill</span><br><span class="line">		set</span><br><span class="line">		number &#x3D; number-1</span><br><span class="line">		where seckill_id &#x3D; #&#123;seckillId&#125;</span><br><span class="line">		and</span><br><span class="line">		start_time &lt;![CDATA[ &lt;&#x3D; ]]&gt;</span><br><span class="line">		#&#123;killTime&#125;</span><br><span class="line">		and end_time &gt;&#x3D; #&#123;killTime&#125;</span><br><span class="line">		and number &gt; 0;</span><br><span class="line">	&lt;&#x2F;update&gt;</span><br><span class="line">	</span><br><span class="line">	 &lt;select id&#x3D;&quot;queryById&quot; resultType&#x3D;&quot;Seckill&quot; parameterType&#x3D;&quot;long&quot;&gt;</span><br><span class="line">        select seckill_id,name,number,start_time,end_time,create_time from seckill</span><br><span class="line">        where seckill_id &#x3D; #&#123;seckillId&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">   &lt;select id&#x3D;&quot;queryAll&quot; resultType&#x3D;&quot;Seckill&quot;&gt;</span><br><span class="line">        select seckill_id,name,number,start_time,end_time,create_time</span><br><span class="line">        from seckill</span><br><span class="line">        order by create_time desc</span><br><span class="line">        limit #&#123;offset&#125;,#&#123;limit&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>###六. mybatis的配置</p>
<p>创建mybatis-config.xml 全局配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">  PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">  &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"> &lt;!-- 配置全局属性 --&gt;	</span><br><span class="line"> </span><br><span class="line">&lt;settings&gt;</span><br><span class="line">        &lt;!--使用jdbc的getGeneratedKeys 获取数据库的自增主键值--&gt;</span><br><span class="line">        &lt;setting name&#x3D;&quot;useGeneratedKeys&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--使用别名替换列名 默认true</span><br><span class="line">        select name as title from table</span><br><span class="line">        --&gt;</span><br><span class="line">        &lt;setting name&#x3D;&quot;useColumnLabel&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--开启驼峰命名转换--&gt;</span><br><span class="line">        &lt;setting name&#x3D;&quot;mapUnderscoreToCamelCase&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;settings&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure>
<p>创建jdbc.properties文件<br>数据库配置文件和连接数据库驱动。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">driver&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;seckill?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8</span><br><span class="line">username&#x3D;root</span><br><span class="line">password&#x3D;123</span><br></pre></td></tr></table></figure>
<h3 id="七-mybatis和spring-整合"><a href="#七-mybatis和spring-整合" class="headerlink" title="七.mybatis和spring 整合"></a>七.mybatis和spring 整合</h3><p>直接贴配置文件，文件已经写好了注释。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;</span><br><span class="line">&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--配置整合mybatis过程--&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--１.配置数据库相关参数--&gt;</span><br><span class="line">    &lt;context:property-placeholder location&#x3D;&quot;classpath:jdbc.properties&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">      &lt;!--2.配置连接池属性--&gt;   </span><br><span class="line">    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;property name&#x3D;&quot;driverClassName&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;seckill&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;123&quot;&#x2F;&gt;</span><br><span class="line">       </span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;!--３.配置SqlSessionFactory对象--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;</span><br><span class="line">        &lt;!--注入数据库连接池--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--配置mybatis全局配置文件:mybatis-config.xml--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;configLocation&quot; value&#x3D;&quot;classpath:mybatis-config.xml&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--扫描entity包,使用别名,多个用;隔开--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;typeAliasesPackage&quot; value&#x3D;&quot;org.forezp.entity&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!--扫描sql配置文件:mapper需要的xml文件--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath:mapper&#x2F;*.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!--４:配置扫描Dao接口包,动态实现DAO接口,注入到spring容器--&gt;</span><br><span class="line">    &lt;bean class&#x3D;&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;</span><br><span class="line">        &lt;!--注入SqlSessionFactory--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;sqlSessionFactoryBeanName&quot; value&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;</span><br><span class="line">        &lt;!-- 给出需要扫描的Dao接口--&gt;</span><br><span class="line">        &lt;property name&#x3D;&quot;basePackage&quot; value&#x3D;&quot;org.forezp.dao&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure>
<p>就这样mybatis和spring就整合好了，spring 提供了的ioc容器，为我们管理bean，我们不需要管理bean的生命周期.</p>
<p>###八.单元测试</p>
<p>采用junit单元测试，spring 对junit做了很好的支持。只需要配置注解久可以了，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 配置spring和junit整合，junit启动时加载springIOC容器</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations &#x3D; &#123;&quot;classpath*:spring&#x2F;spring-dao.xml&quot;&#125;)</span><br><span class="line">public class SeckillDaoTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void reduceNumber() throws Exception &#123;</span><br><span class="line">        Date killTIme&#x3D;new Date();</span><br><span class="line">        int updateCount &#x3D;seckillDao.reduceNumber(1000L,killTIme);</span><br><span class="line">        System.out.println(updateCount);</span><br><span class="line">		&#x2F;&#x2F;结果第一次执行为1 后面为0 </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;注入Dao实现类依赖</span><br><span class="line">    @Resource</span><br><span class="line">    private SeckillDao seckillDao;</span><br><span class="line">    @Test</span><br><span class="line">    public void queryById() throws Exception &#123;</span><br><span class="line">        long id&#x3D;1001;</span><br><span class="line">        Seckill seckill&#x3D;seckillDao.queryById(id);</span><br><span class="line">        System.out.println(seckill.getName());</span><br><span class="line">        System.out.println(seckill);</span><br><span class="line">        &#x2F;&#x2F;运行结果</span><br><span class="line">        &#x2F;** 500元秒杀ipad2*／</span><br><span class="line">      ／**  Seckill&#123;seckillId&#x3D;1001, name&#x3D;&#39;500元秒杀ipad2&#39;,number&#x3D;200, startTime&#x3D;Sun Nov 01 00:00:00 CST 2015, endTime&#x3D;Mon Nov 02 00:00:00 CST 2015, createTime&#x3D;Sun Nov 27 10:44:30 CST 2016&#125;*&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void queryAll() throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F;java没有保存形参的记录，queryAll(int offeset,int limit)-&gt;queryAll(arg0,arg1),通过@param注解来解决</span><br><span class="line"></span><br><span class="line">        List&lt;Seckill&gt; seckills&#x3D;seckillDao.queryAll(0,100);</span><br><span class="line">        for(Seckill seckill:seckills)&#123;</span><br><span class="line">            System.out.println(seckill);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>到此为止，mybatis实现数据库的连接，和dao层代码的编写以及mybatis 和spring的整合 。我觉得学习路上虽然很孤单，但如果有一个分享的心态和持续学习的动力，生活也算是充实的，自己成长了，技术也提高了，回报也高了，生活品质也随之提高。所以无论做什么，自己快乐，并且能提高自己的快乐，且以此为目的就够了，祝自己好运。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9697343">源码下载</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-376be1da82d49908.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="拍摄于深圳大沙河公园"></p>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>web监听器</title>
    <url>/2016/11/12/j2ee-2016-05-05-web-listener/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>Listener是Servlet规范的另一个高级特性，它用于监听java web程序的事件，例如创建、修改、删除session,request,context等，并触发相应的处理事件，这个处理事件是由web容器回掉的。</p>
<p>学过安卓开发的同学一定很熟悉view.setonClickLister();这样的对安卓控件的监听。java web也是这样的 ，根据不同的listner 和不同的event，可以完成相应的处理事件。</p>
<span id="more"></span>

<h3 id="二、Listerner的分类"><a href="#二、Listerner的分类" class="headerlink" title="二、Listerner的分类"></a>二、Listerner的分类</h3><p>Listerner分为八种，前三种是用于监听对象的创建和销毁，中间三种用于监听对象属性的变化，后两种用于监听Session内对象。</p>
<ul>
<li><p>httpSessionListner: 监听session的创建与销毁，用于收集在线用户信息。</p>
</li>
<li><p>servletContextListener:监听context的创建与销毁，context代表当前web应用，该listener可用于启动时获取web.xml的初始化参数。</p>
</li>
<li><p>servletRequestListener:  监听request 的创建与销毁。</p>
</li>
<li><p>httpSessionAttributeListener 监听session的种属性变化</p>
</li>
<li><p>ServletContextAttributeListener</p>
</li>
<li><p>ServletRequestAttributeListener</p>
</li>
<li><p>HttpSessionBindingListener,监听对象存入或者移除 session</p>
</li>
<li><p>httpSessionActivationListener,钝化和重新加载 session的监听</p>
</li>
</ul>
<h3 id="三、监听session、request、servletContext"><a href="#三、监听session、request、servletContext" class="headerlink" title="三、监听session、request、servletContext"></a>三、监听session、request、servletContext</h3><p>直接上代码，下面监听了这三个对象创建销毁。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ListenerTest implements HttpSessionListener ,ServletContextListener,ServletRequestListener&#123;</span><br><span class="line"></span><br><span class="line">	Log log&#x3D;LogFactory.getLog(getClass());</span><br><span class="line">	public void requestDestroyed(ServletRequestEvent sre) &#123;</span><br><span class="line">		HttpServletRequest request&#x3D;(HttpServletRequest) sre.getServletRequest();</span><br><span class="line">		long time&#x3D;System.currentTimeMillis()-(Long)request.getAttribute(&quot;time&quot;);</span><br><span class="line">		log.info(&quot;请求处理时间&quot;+time);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void requestInitialized(ServletRequestEvent sre) &#123;</span><br><span class="line">		HttpServletRequest request&#x3D;(HttpServletRequest) sre.getServletRequest();</span><br><span class="line">		String uri&#x3D;request.getRequestURI();</span><br><span class="line">		uri&#x3D;request.getQueryString()&#x3D;&#x3D;null?uri:(uri+&quot;?&quot;+request.getQueryString());</span><br><span class="line">		log.info(&quot;ip&quot;+request.getRemoteAddr()+uri);</span><br><span class="line">		request.setAttribute(&quot;time&quot;, System.currentTimeMillis());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void contextDestroyed(ServletContextEvent sce) &#123;</span><br><span class="line">		ServletContext servletContext&#x3D;sce.getServletContext();</span><br><span class="line">		log.info(&quot;关闭：&quot;+servletContext.getContextPath());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void contextInitialized(ServletContextEvent sce) &#123;</span><br><span class="line">		ServletContext servletContext&#x3D;sce.getServletContext();</span><br><span class="line">		log.info(&quot;启动：&quot;+servletContext.getContextPath());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void sessionCreated(HttpSessionEvent se) &#123;</span><br><span class="line">		HttpSession session&#x3D;se.getSession();</span><br><span class="line">		log.info(&quot;创建：session:&quot;+session.getId());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void sessionDestroyed(HttpSessionEvent se) &#123;</span><br><span class="line">		HttpSession session&#x3D;se.getSession();</span><br><span class="line">		log.info(&quot;销毁建：session:&quot;+session.getId());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要在web.xml中配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">   &lt;listener-class&gt;com.forezp.listener.ListenerTest&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四、监听对象属性的变化"><a href="#四、监听对象属性的变化" class="headerlink" title="四、监听对象属性的变化"></a>四、监听对象属性的变化</h3><ul>
<li>httpSessionAttributeListener 监听session的种属性变化</li>
<li>ServletContextAttributeListener</li>
<li>ServletRequestAttributeListener</li>
</ul>
<p>以上三种方法用于监听session ,context,request的属性发生变化，例如添加、更新、移除。<br>下面以session的属性变化为例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SessionAttributeListener  implements HttpSessionAttributeListener&#123;</span><br><span class="line"></span><br><span class="line">	Log log&#x3D;LogFactory.getLog(getClass());</span><br><span class="line">	public void attributeAdded(HttpSessionBindingEvent se) &#123;</span><br><span class="line">		HttpSession httpSession&#x3D;se.getSession();</span><br><span class="line">		log.info(&quot;新建属性：&quot;+se.getName()+&quot;值：&quot;+se.getValue());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void attributeRemoved(HttpSessionBindingEvent se) &#123;</span><br><span class="line">		HttpSession httpSession&#x3D;se.getSession();</span><br><span class="line">		log.info(&quot; 删除属性：&quot;+se.getName()+&quot;值：&quot;+se.getValue());</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void attributeReplaced(HttpSessionBindingEvent se) &#123;</span><br><span class="line">		HttpSession httpSession&#x3D;se.getSession();</span><br><span class="line">		log.info(&quot; 修改属性：&quot;+se.getName()+&quot;原来的值：&quot;+se.getValue()+&quot;新值：&quot;+httpSession.getAttribute(se.getName()));</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>web.xml配置，此处省略。</p>
<h3 id="五、监听session内的对象"><a href="#五、监听session内的对象" class="headerlink" title="五、监听session内的对象"></a>五、监听session内的对象</h3><ul>
<li>HttpSessionBindingListener,当对象被放到session里执行valueBond();当对象被移除，执行valueUnbond();</li>
<li>httpSessionActivationListener,服务器关闭,会将session的内容保存在硬盘里，这个过程叫钝化；服务器重启，会将session的内容从硬盘中重新加载。钝化时执行sesionWillPassivate(),重新加载sessionDidActivate();</li>
</ul>
<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User implements HttpSessionBindingListener,HttpSessionActivationListener,Serializable &#123;</span><br><span class="line"></span><br><span class="line">	private String username;</span><br><span class="line">	private String password;</span><br><span class="line">	</span><br><span class="line">	public void valueBound(HttpSessionBindingEvent httpsessionbindingevent) &#123;</span><br><span class="line">		System.out.println(&quot;valueBound Name:&quot;+httpsessionbindingevent.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void valueUnbound(HttpSessionBindingEvent httpsessionbindingevent) &#123;</span><br><span class="line">		System.out.println(&quot;valueUnbound Name:&quot;+httpsessionbindingevent.getName());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getUsername() &#123;</span><br><span class="line">		return username;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setUsername(String username) &#123;</span><br><span class="line">		this.username &#x3D; username;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String getPassword() &#123;</span><br><span class="line">		return password;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public void setPassword(String password) &#123;</span><br><span class="line">		this.password &#x3D; password;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;钝化</span><br><span class="line">	public void sessionWillPassivate(HttpSessionEvent httpsessionevent) &#123;</span><br><span class="line">		System.out.println(&quot;sessionWillPassivate &quot;+httpsessionevent.getSource());</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;&#x2F;活化</span><br><span class="line">	public void sessionDidActivate(HttpSessionEvent httpsessionevent) &#123;</span><br><span class="line">		System.out.println(&quot;sessionDidActivate &quot;+httpsessionevent.getSource());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>init.jsp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; import&#x3D;&quot;java.util.*&quot; pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String path &#x3D; request.getContextPath();</span><br><span class="line">String basePath &#x3D; request.getScheme()+&quot;:&#x2F;&#x2F;&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;&#x2F;&quot;;</span><br><span class="line">request.getSession().setAttribute(&quot;currentUser&quot;, new com.forezp.entity.User());</span><br><span class="line"></span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href&#x3D;&quot;&lt;%&#x3D;basePath%&gt;&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;title&gt;My JSP &#39;init.jsp&#39; starting page&lt;&#x2F;title&gt;</span><br><span class="line">    </span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;pragma&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;cache-control&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;0&quot;&gt;    </span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;keywords&quot; content&#x3D;&quot;keyword1,keyword2,keyword3&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;description&quot; content&#x3D;&quot;This is my page&quot;&gt;</span><br><span class="line">	&lt;!--</span><br><span class="line">	&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;styles.css&quot;&gt;</span><br><span class="line">	--&gt;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    这是初始化值的界面</span><br><span class="line">    &lt;button onclick&#x3D;&quot;location.href&#x3D;&#39;&lt;%&#x3D;request.getContextPath()%&gt;&#x2F;init.jsp&#39;;&quot;&gt;Init&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button onclick&#x3D;&quot;location.href&#x3D;&#39;&lt;%&#x3D;request.getContextPath()%&gt;&#x2F;destory.jsp&#39;;&quot;&gt;Destory&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>destroy.jsp</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; import&#x3D;&quot;java.util.*&quot; pageEncoding&#x3D;&quot;UTF-8&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String path &#x3D; request.getContextPath();</span><br><span class="line">String basePath &#x3D; request.getScheme()+&quot;:&#x2F;&#x2F;&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;&#x2F;&quot;;</span><br><span class="line"></span><br><span class="line">request.getSession().removeAttribute(&quot;currentUser&quot;);</span><br><span class="line">%&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href&#x3D;&quot;&lt;%&#x3D;basePath%&gt;&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;title&gt;My JSP &#39;destory.jsp&#39; starting page&lt;&#x2F;title&gt;</span><br><span class="line">    </span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;pragma&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;cache-control&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;0&quot;&gt;    </span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;keywords&quot; content&#x3D;&quot;keyword1,keyword2,keyword3&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;description&quot; content&#x3D;&quot;This is my page&quot;&gt;</span><br><span class="line">	&lt;!--</span><br><span class="line">	&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;styles.css&quot;&gt;</span><br><span class="line">	--&gt;</span><br><span class="line"></span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    这是销毁界面</span><br><span class="line">    &lt;button onclick&#x3D;&quot;location.href&#x3D;&#39;&lt;%&#x3D;request.getContextPath()%&gt;&#x2F;init.jsp&#39;;&quot;&gt;Init&lt;&#x2F;button&gt;</span><br><span class="line">    &lt;button onclick&#x3D;&quot;location.href&#x3D;&#39;&lt;%&#x3D;request.getContextPath()%&gt;&#x2F;destory.jsp&#39;;&quot;&gt;Destory&lt;&#x2F;button&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当访问init.jsp，再访问destroy.jsp;再访问init,jsp，再关闭服务器，重启；log日志如下：</p>
<blockquote>
<p>valueBound Name:currentUser</p>
</blockquote>
<blockquote>
<p>valueUnbound Name:currentUser</p>
</blockquote>
<blockquote>
<p>sessionWillPassivate org.apache.catalina.session.StandardSessionFacade@33f3be1</p>
</blockquote>
<blockquote>
<p>sessionDidActivate<br>org.apache.catalina.session.StandardSessionFacade@33f3be1</p>
</blockquote>
<h3 id="六、显示在线人数："><a href="#六、显示在线人数：" class="headerlink" title="六、显示在线人数："></a>六、显示在线人数：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@WebListener</span><br><span class="line">public class MyHttpSessionListener implements HttpSessionListener &#123;</span><br><span class="line">	</span><br><span class="line">	private int userNumber &#x3D; 0;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void sessionCreated(HttpSessionEvent arg0) &#123;</span><br><span class="line">		userNumber++;</span><br><span class="line">		arg0.getSession().getServletContext().setAttribute(&quot;userNumber&quot;, userNumber);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void sessionDestroyed(HttpSessionEvent arg0) &#123;</span><br><span class="line">		userNumber--;</span><br><span class="line">arg0.getSession().getServletContext().setAttribute(&quot;userNumber&quot;, userNumber);</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>jsp中显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    当前在线用户人数:$&#123;userNumber &#125;&lt;br&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这是一个简答的统计在线人数的方法，如果你需要知道这些人来自哪里，需要配合httpRequestListener配合，也可以实现单登陆，在这里不写代码了。</p>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>Java常见安全算法</title>
    <url>/2015/05/04/java-2015-05-04-common-auth/</url>
    <content><![CDATA[<p>本文整理了常见的安全算法，包括MD5、SHA、DES、AES、RSA等，并写了完整的工具类（Java 版），工具类包含测试。</p>
<span id="more"></span>

<h2 id="一、数字摘要算法"><a href="#一、数字摘要算法" class="headerlink" title="一、数字摘要算法"></a>一、数字摘要算法</h2><blockquote>
<p>数字摘要也称为消息摘要，它是一个唯一对应一个消息或文本的固定长度的值，它由一个单向Hash函数对消息进行计算而产生。如果消息在传递的途中改变了，接收者通过对收到消息采用相同的Hash重新计算，新产生的摘要与原摘要进行比较，就可知道消息是否被篡改了，因此消息摘要能够验证消息的完整性。消息摘要采用单向Hash函数将需要计算的内容”摘要”成固定长度的串，这个串亦称为数字指纹。这个串有固定的长度，且不同的明文摘要成密文，其结果总是不同的(相对的)，而同样的明文其摘要必定一致。这样这串摘要便可成为验证明文是否是”真身”的”指纹”了。</p>
</blockquote>
<h3 id="1-Md5"><a href="#1-Md5" class="headerlink" title="1. Md5"></a>1. Md5</h3><p>MD5即Message Digest Algorithm 5(信息摘要算法5)，是数字摘要算法一种实现，用于确保信息传输完整性和一致性，摘要长度为128位。 MD5由MD4、 MD3、 MD2改进而来，主要增强算法复杂度和不可逆性，该算法因其普遍、稳定、快速的特点，在产业界得到了极为广泛的使用，目前主流的编程语言普遍都已有MD5算法实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import java.security.MessageDigest;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Message Digest Algorithm 5(信息摘要算法5)</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MD5Util &#123;</span><br><span class="line">	&#x2F;**</span><br><span class="line">	 * Constructs the MD5Util object and sets the string whose MD5Util is to be</span><br><span class="line">	 * computed.</span><br><span class="line">	 * </span><br><span class="line">	 * @param inStr</span><br><span class="line">	 *    the &lt;code&gt;String&lt;&#x2F;code&gt; whose MD5Util is to be computed</span><br><span class="line">	 *&#x2F;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public final static String COMMON_KEY&#x3D;&quot;zhongzhuoxin#@!321&quot;;</span><br><span class="line">	public MD5Util() &#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public final static String str2MD5(String inStr) &#123;</span><br><span class="line">		char hexDigits[] &#x3D; &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,</span><br><span class="line">				&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; &#125;;</span><br><span class="line">		try &#123;</span><br><span class="line">			byte[] strTemp &#x3D; inStr.getBytes(&quot;UTF-8&quot;);</span><br><span class="line">			MessageDigest mdTemp &#x3D; MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">			mdTemp.update(strTemp);</span><br><span class="line">			byte[] md &#x3D; mdTemp.digest();</span><br><span class="line">			int j &#x3D; md.length;</span><br><span class="line">			char str[] &#x3D; new char[j * 2];</span><br><span class="line">			int k &#x3D; 0;</span><br><span class="line">			for (int i &#x3D; 0; i &lt; j; i++) &#123;</span><br><span class="line">				byte byte0 &#x3D; md[i];</span><br><span class="line">				str[k++] &#x3D; hexDigits[byte0 &gt;&gt;&gt; 4 &amp; 0xf];</span><br><span class="line">				str[k++] &#x3D; hexDigits[byte0 &amp; 0xf];</span><br><span class="line">			&#125;</span><br><span class="line">			return new String(str);</span><br><span class="line">		&#125; catch (Exception e) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;--MD5Util</span><br><span class="line">	private static final char HEX_DIGITS[] &#x3D; &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;,</span><br><span class="line">			&#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39; &#125;;</span><br><span class="line"></span><br><span class="line">	public static String toHexString(byte[] b) &#123; &#x2F;&#x2F; String to byte</span><br><span class="line">		StringBuilder sb &#x3D; new StringBuilder(b.length * 2);</span><br><span class="line">		for (int i &#x3D; 0; i &lt; b.length; i++) &#123;</span><br><span class="line">			sb.append(HEX_DIGITS[(b[i] &amp; 0xf0) &gt;&gt;&gt; 4]);</span><br><span class="line">			sb.append(HEX_DIGITS[b[i] &amp; 0x0f]);</span><br><span class="line">		&#125;</span><br><span class="line">		return sb.toString();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static String AndroidMd5(String s) &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; Create MD5Util Hash</span><br><span class="line">			MessageDigest digest &#x3D; MessageDigest</span><br><span class="line">					.getInstance(&quot;MD5&quot;);</span><br><span class="line">			digest.update(s.getBytes());</span><br><span class="line">			byte messageDigest[] &#x3D; digest.digest();</span><br><span class="line"></span><br><span class="line">			return toHexString(messageDigest);</span><br><span class="line">		&#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		return &quot;&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">		String m &#x3D; MD5Util.str2MD5(&quot;swwwwwwwwwwdkinner&quot;);</span><br><span class="line"></span><br><span class="line">		System.out.print(m.length() + &quot;    &quot;);</span><br><span class="line">		System.out.println(m);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>###2.SHA</p>
<p>SHA的全称是Secure Hash Algorithm，即安全散列算法。 1993年，安全散列算法(SHA)由美国国家标准和技术协会（NIST)提出，并作为联邦信息处理标准(FIPS PUB 180)公布， 1995年又发布了一个修订版FIPS PUB 180-1，通常称之为SHA-1。 SHA-1是基于MD4算法的，现在已成为公认的最安全的散列算法之一，并被广泛使用。SHA-1算法生成的摘要信息的长度为160位，由于生成的摘要信息更长，运算的过程更加复杂，在相同的硬件上， SHA-1的运行速度比MD5更慢，但是也更为安全。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import com.google.common.base.Strings;</span><br><span class="line"></span><br><span class="line">import java.security.MessageDigest;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * SHA的全称是Secure Hash Algorithm，即安全散列算法</span><br><span class="line"> * Created by chris  on 2017&#x2F;3&#x2F;21.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class SHAUtil &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 定义加密方式</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static String KEY_SHA &#x3D; &quot;SHA&quot;;</span><br><span class="line">    private final static String KEY_SHA1 &#x3D; &quot;SHA-1&quot;;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 全局数组</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private final static String[] hexDigits &#x3D; &#123; &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;,</span><br><span class="line">            &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot; &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 构造函数</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public SHAUtil() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * SHA 加密</span><br><span class="line">     * @param data 需要加密的字节数组</span><br><span class="line">     * @return 加密之后的字节数组</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static byte[] encryptSHA(byte[] data) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 创建具有指定算法名称的信息摘要</span><br><span class="line">&#x2F;&#x2F;        MessageDigest sha &#x3D; MessageDigest.getInstance(KEY_SHA);</span><br><span class="line">        MessageDigest sha &#x3D; MessageDigest.getInstance(KEY_SHA1);</span><br><span class="line">        &#x2F;&#x2F; 使用指定的字节数组对摘要进行最后更新</span><br><span class="line">        sha.update(data);</span><br><span class="line">        &#x2F;&#x2F; 完成摘要计算并返回</span><br><span class="line">        return sha.digest();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * SHA 加密</span><br><span class="line">     * @param data 需要加密的字符串</span><br><span class="line">     * @return 加密之后的字符串</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String encryptSHA(String data) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 验证传入的字符串</span><br><span class="line">        if (Strings.isNullOrEmpty(data)) &#123;</span><br><span class="line">            return &quot;&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 创建具有指定算法名称的信息摘要</span><br><span class="line">        MessageDigest sha &#x3D; MessageDigest.getInstance(KEY_SHA);</span><br><span class="line">        &#x2F;&#x2F; 使用指定的字节数组对摘要进行最后更新</span><br><span class="line">        sha.update(data.getBytes());</span><br><span class="line">        &#x2F;&#x2F; 完成摘要计算</span><br><span class="line">        byte[] bytes &#x3D; sha.digest();</span><br><span class="line">        &#x2F;&#x2F; 将得到的字节数组变成字符串返回</span><br><span class="line">        return byteArrayToHexString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 将一个字节转化成十六进制形式的字符串</span><br><span class="line">     * @param b 字节数组</span><br><span class="line">     * @return 字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteToHexString(byte b) &#123;</span><br><span class="line">        int ret &#x3D; b;</span><br><span class="line">        &#x2F;&#x2F;System.out.println(&quot;ret &#x3D; &quot; + ret);</span><br><span class="line">        if (ret &lt; 0) &#123;</span><br><span class="line">            ret +&#x3D; 256;</span><br><span class="line">        &#125;</span><br><span class="line">        int m &#x3D; ret &#x2F; 16;</span><br><span class="line">        int n &#x3D; ret % 16;</span><br><span class="line">        return hexDigits[m] + hexDigits[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 转换字节数组为十六进制字符串</span><br><span class="line">     * @param bytes 字节数组</span><br><span class="line">     * @return 十六进制字符串</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static String byteArrayToHexString(byte[] bytes) &#123;</span><br><span class="line">        StringBuffer sb &#x3D; new StringBuffer();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; bytes.length; i++) &#123;</span><br><span class="line">            sb.append(byteToHexString(bytes[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 测试方法</span><br><span class="line">     * @param args</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String key &#x3D; &quot;123&quot;;</span><br><span class="line">        System.out.println(encryptSHA(key));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="二、对称加密"><a href="#二、对称加密" class="headerlink" title="二、对称加密"></a>二、对称加密</h2><blockquote>
<p>对称加密算法是应用较早的加密算法，技术成熟。在对称加密算法中，数据发送方将明文(原始数据)和加密密钥一起经过特殊加密算法处理后，生成复杂的加密密文进行发送，数据接收方收到密文后，若想读取原文，则需要使用加密使用的密钥及相同算法的逆算法对加密的密文进行解密，才能使其恢复成可读明文。在对称加密算法中，使用的密钥只有一个，发送和接收双方都使用这个密钥对数据进行加密和解密，这就要求加密和解密方事先都必须知道加密的密钥。</p>
</blockquote>
<h3 id="1-DES算法"><a href="#1-DES算法" class="headerlink" title="1. DES算法"></a>1. DES算法</h3><p>1973 年，美国国家标准局(NBS)在认识到建立数据保护标准既明显又急迫的情况下，开始征集联邦数据加密标准的方案。 1975 年3月17日， NBS公布了IBM公司提供的密码算法，以标准建议的形式在全国范围内征求意见。经过两年多的公开讨论之后， 1977 年7月15日， NBS宣布接受这建议，作为联邦信息处理标准46 号数据加密标准(Data Encryptin Standard)，即DES正式颁布，供商业界和非国防性政府部门使用。DES算法属于对称加密算法，明文按64位进行分组，密钥长64位，但事实上只有56位参与DES<br>运算(第8、 16、 24、 32、 40、 48、 56、 64位是校验位，使得每个密钥都有奇数个1),分组后的明文和56位的密钥按位替代或交换的方法形成密文。由于计算机运算能力的增强，原版DES密码的密钥长度变得容易被暴力破解，因此演变出了3DES算法。 3DES是DES向AES过渡的加密算法，它使用3条56位的密钥对数据进行三次加密，是DES的一个更安全的变形</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line">import javax.crypto.Cipher;</span><br><span class="line">import javax.crypto.SecretKey;</span><br><span class="line">import javax.crypto.SecretKeyFactory;</span><br><span class="line">import javax.crypto.spec.DESKeySpec;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import sun.misc.BASE64Decoder;</span><br><span class="line">import sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Data Encryptin Standard</span><br><span class="line"> * 数据加密标准</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class DESUtil &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private final static String DES &#x3D; &quot;DES&quot;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Description 根据键值进行加密</span><br><span class="line">     *</span><br><span class="line">     * @param data</span><br><span class="line">     * @param key  加密键byte数组</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String encrypt(String data, String key) throws Exception &#123;</span><br><span class="line">        byte[] bt &#x3D; encrypt(data.getBytes(), key.getBytes());</span><br><span class="line">        String strs &#x3D; new BASE64Encoder().encode(bt);</span><br><span class="line">        return strs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Description 根据键值进行解密</span><br><span class="line">     *</span><br><span class="line">     * @param data</span><br><span class="line">     * @param key  加密键byte数组</span><br><span class="line">     * @return</span><br><span class="line">     * @throws IOException</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String decrypt(String data, String key) throws Exception,</span><br><span class="line">            Exception &#123;</span><br><span class="line">        if (data &#x3D;&#x3D; null)</span><br><span class="line">            return null;</span><br><span class="line">        BASE64Decoder decoder &#x3D; new BASE64Decoder();</span><br><span class="line">        byte[] buf &#x3D; decoder.decodeBuffer(data);</span><br><span class="line">        byte[] bt &#x3D; decrypt(buf, key.getBytes());</span><br><span class="line">        return new String(bt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Description 根据键值进行加密</span><br><span class="line">     *</span><br><span class="line">     * @param data</span><br><span class="line">     * @param key  加密键byte数组</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] encrypt(byte[] data, byte[] key) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 生成一个可信任的随机数源</span><br><span class="line">        SecureRandom sr &#x3D; new SecureRandom();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 从原始密钥数据创建DESKeySpec对象</span><br><span class="line">        DESKeySpec dks &#x3D; new DESKeySpec(key);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span><br><span class="line">        SecretKeyFactory keyFactory &#x3D; SecretKeyFactory.getInstance(DES);</span><br><span class="line">        SecretKey securekey &#x3D; keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Cipher对象实际完成加密操作</span><br><span class="line">        Cipher cipher &#x3D; Cipher.getInstance(DES);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 用密钥初始化Cipher对象</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, securekey, sr);</span><br><span class="line"></span><br><span class="line">        return cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * Description 根据键值进行解密</span><br><span class="line">     *</span><br><span class="line">     * @param data</span><br><span class="line">     * @param key  加密键byte数组</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static byte[] decrypt(byte[] data, byte[] key) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; 生成一个可信任的随机数源</span><br><span class="line">        SecureRandom sr &#x3D; new SecureRandom();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 从原始密钥数据创建DESKeySpec对象</span><br><span class="line">        DESKeySpec dks &#x3D; new DESKeySpec(key);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 创建一个密钥工厂，然后用它把DESKeySpec转换成SecretKey对象</span><br><span class="line">        SecretKeyFactory keyFactory &#x3D; SecretKeyFactory.getInstance(DES);</span><br><span class="line">        SecretKey securekey &#x3D; keyFactory.generateSecret(dks);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Cipher对象实际完成解密操作</span><br><span class="line">        Cipher cipher &#x3D; Cipher.getInstance(DES);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 用密钥初始化Cipher对象</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, securekey, sr);</span><br><span class="line"></span><br><span class="line">        return cipher.doFinal(data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[]args)throws Exception&#123;</span><br><span class="line">       String  sStr&#x3D;encrypt(&quot;122222112222:12343232323:jajwwwwslwskwkkwksk&quot;,&quot;wew2323w233321ws233w&quot;);</span><br><span class="line">       System.out.println(sStr);</span><br><span class="line">       String mStr&#x3D;decrypt(sStr,&quot;wew2323w233321ws233w&quot;);</span><br><span class="line">       System.out.println(mStr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="2-AES"><a href="#2-AES" class="headerlink" title="2. AES"></a>2. AES</h3><p>AES的全称是Advanced Encryption Standard，即高级加密标准，该算法由比利时密码学家Joan Daemen和Vincent Rijmen所设计，结合两位作者的名字，又称Rijndael加密算法，是美国联邦政府采用的一种对称加密标准，这个标准用来替代原先的DES算法，已经广为全世界所使用，已然成为对称加密算法中最流行的算法之一。AES算法作为新一代的数据加密标准汇聚了强安全性、高性能、高效率、易用和灵活等优<br>点，设计有三个密钥长度:128,192,256位，比DES算法的加密强度更高，更为安全。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.UnsupportedEncodingException;</span><br><span class="line">import java.security.InvalidKeyException;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.security.SecureRandom;</span><br><span class="line">import java.util.Base64;</span><br><span class="line">import java.util.Scanner;</span><br><span class="line"></span><br><span class="line">import javax.crypto.BadPaddingException;</span><br><span class="line">import javax.crypto.Cipher;</span><br><span class="line">import javax.crypto.IllegalBlockSizeException;</span><br><span class="line">import javax.crypto.KeyGenerator;</span><br><span class="line">import javax.crypto.NoSuchPaddingException;</span><br><span class="line">import javax.crypto.SecretKey;</span><br><span class="line">import javax.crypto.spec.SecretKeySpec;</span><br><span class="line"></span><br><span class="line">import sun.misc.BASE64Decoder;</span><br><span class="line">import sun.misc.BASE64Encoder;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;3&#x2F;21.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AESUtil &#123;</span><br><span class="line"></span><br><span class="line">    static  byte[]  key &#x3D; &quot;w@#$4@#$s^&amp;3*&amp;^4&quot;.getBytes();</span><br><span class="line">    final static String algorithm&#x3D;&quot;AES&quot;;</span><br><span class="line"></span><br><span class="line">    public static String encrypt(String data)&#123;</span><br><span class="line"></span><br><span class="line">        byte[] dataToSend &#x3D; data.getBytes();</span><br><span class="line">        Cipher c &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            c &#x3D; Cipher.getInstance(algorithm);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchPaddingException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        SecretKeySpec k &#x3D;  new SecretKeySpec(key, algorithm);</span><br><span class="line">        try &#123;</span><br><span class="line">            c.init(Cipher.ENCRYPT_MODE, k);</span><br><span class="line">        &#125; catch (InvalidKeyException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        byte[] encryptedData &#x3D; &quot;&quot;.getBytes();</span><br><span class="line">        try &#123;</span><br><span class="line">            encryptedData &#x3D; c.doFinal(dataToSend);</span><br><span class="line">        &#125; catch (IllegalBlockSizeException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (BadPaddingException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        byte[] encryptedByteValue &#x3D;     Base64.getEncoder().encode(encryptedData);</span><br><span class="line">        return  new String(encryptedByteValue);&#x2F;&#x2F;.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static String decrypt(String data)&#123;</span><br><span class="line"></span><br><span class="line">        byte[] encryptedData  &#x3D;  Base64.getDecoder().decode(data);</span><br><span class="line">        Cipher c &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            c &#x3D; Cipher.getInstance(algorithm);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (NoSuchPaddingException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        SecretKeySpec k &#x3D;</span><br><span class="line">                new SecretKeySpec(key, algorithm);</span><br><span class="line">        try &#123;</span><br><span class="line">            c.init(Cipher.DECRYPT_MODE, k);</span><br><span class="line">        &#125; catch (InvalidKeyException e1) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        byte[] decrypted &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            decrypted &#x3D; c.doFinal(encryptedData);</span><br><span class="line">        &#125; catch (IllegalBlockSizeException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (BadPaddingException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return new String(decrypted);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        String password&#x3D;encrypt(&quot;12233440988:1239874389888:dd333&quot;);</span><br><span class="line">        System.out.println(password);</span><br><span class="line">        System.out.println(decrypt(password));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>##三、非对称加密</p>
<blockquote>
<p>非对称加密算法又称为公开密钥加密算法，它需要两个密钥，一个称为公开密钥(public key)，即公钥，另一个称为私有密钥(private key)，即私钥。公钥与私钥需要配对使用，如果用公钥对数据进行加密，只有用对应的私钥才能进行解密，而如果使用私钥对数据进行加密，那么只有用对应的公钥才能进行解密。因为加密和解密使用的是两个不同的密钥，所以这种算法称为非对称加密算法。非对称加密算法实现机密信息交换的基本过程是：甲方生成一对密钥并将其中的一把作为公钥向其它人公开，得到该公钥的乙方使用该密钥对机密信息进行加密后再发送给甲方，甲方再使用自己保存的另一把专用密钥，即私钥，对加密后的信息进行解密。</p>
</blockquote>
<h3 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h3><p>RSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发的， RSA取名来自开发他们三者的名字。 RSA是目前最有影响力的非对称加密算法，它能够抵抗到目前为止已知的所有密码攻击，已被ISO推荐为公钥数据加密标准。 RSA算法基于一个十分简单的数论事实：将两个大素数相乘十分容易，但反过来想要对其乘积进行因式分解却极其困难，因此可以将乘积公开作为加密密钥。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;3&#x2F;21.</span><br><span class="line"> * RSA ：RSA非对称加密算法是1977年由Ron Rivest、 Adi Shamirh和LenAdleman开发   *  的， RSA取名来</span><br><span class="line"> *  自开发他们三者的名字。</span><br><span class="line"> * 参考：http:&#x2F;&#x2F;blog.csdn.net&#x2F;wangqiuyun&#x2F;article&#x2F;details&#x2F;42143957</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line">import java.security.InvalidKeyException;</span><br><span class="line">import java.security.KeyFactory;</span><br><span class="line">import java.security.KeyPair;</span><br><span class="line">import java.security.KeyPairGenerator;</span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.security.SecureRandom;</span><br><span class="line"></span><br><span class="line">import java.security.interfaces.RSAPrivateKey;</span><br><span class="line">import java.security.interfaces.RSAPublicKey;</span><br><span class="line">import java.security.spec.InvalidKeySpecException;</span><br><span class="line">import java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line">import java.security.spec.X509EncodedKeySpec;</span><br><span class="line">import java.util.Base64;</span><br><span class="line"></span><br><span class="line">import javax.crypto.BadPaddingException;</span><br><span class="line">import javax.crypto.Cipher;</span><br><span class="line">import javax.crypto.IllegalBlockSizeException;</span><br><span class="line">import javax.crypto.NoSuchPaddingException;</span><br><span class="line">public class RSAUtil &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 字节数据转字符串专用集合</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private static final char[] HEX_CHAR &#x3D; &#123; &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;,</span><br><span class="line">            &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39; &#125;;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 随机生成密钥对</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static void genKeyPair(String filePath) &#123;</span><br><span class="line">        &#x2F;&#x2F; KeyPairGenerator类用于生成公钥和私钥对，基于RSA算法生成对象</span><br><span class="line">        KeyPairGenerator keyPairGen &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            keyPairGen &#x3D; KeyPairGenerator.getInstance(&quot;RSA&quot;);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            &#x2F;&#x2F; TODO Auto-generated catch block</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F; 初始化密钥对生成器，密钥大小为96-1024位</span><br><span class="line">        keyPairGen.initialize(1024,new SecureRandom());</span><br><span class="line">        &#x2F;&#x2F; 生成一个密钥对，保存在keyPair中</span><br><span class="line">        KeyPair keyPair &#x3D; keyPairGen.generateKeyPair();</span><br><span class="line">        &#x2F;&#x2F; 得到私钥</span><br><span class="line">        RSAPrivateKey privateKey &#x3D; (RSAPrivateKey) keyPair.getPrivate();</span><br><span class="line">        &#x2F;&#x2F; 得到公钥</span><br><span class="line">        RSAPublicKey publicKey &#x3D; (RSAPublicKey) keyPair.getPublic();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 得到公钥字符串</span><br><span class="line">            &#x2F;&#x2F; 得到私钥字符串</span><br><span class="line">            String privateKeyString &#x3D;new String( Base64.getEncoder().encode(privateKey.getEncoded()));</span><br><span class="line">            String publicKeyString &#x3D;new String( Base64.getEncoder().encode(publicKey.getEncoded()));</span><br><span class="line">            &#x2F;&#x2F; 将密钥对写入到文件</span><br><span class="line"></span><br><span class="line">            File file1&#x3D;new File(filePath + &quot;publicKey.keystore&quot;);</span><br><span class="line">            File file2&#x3D;new File(filePath + &quot;privateKey.keystore&quot;);</span><br><span class="line">            if(!file1.exists()) &#123;</span><br><span class="line">                file1.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            if(!file2.exists()) &#123;</span><br><span class="line">                file2.createNewFile();</span><br><span class="line">            &#125;</span><br><span class="line">            FileWriter pubfw &#x3D; new FileWriter(filePath + &quot;&#x2F;publicKey.keystore&quot;);</span><br><span class="line">            FileWriter prifw &#x3D; new FileWriter(filePath + &quot;&#x2F;privateKey.keystore&quot;);</span><br><span class="line">            BufferedWriter pubbw &#x3D; new BufferedWriter(pubfw);</span><br><span class="line">            BufferedWriter pribw &#x3D; new BufferedWriter(prifw);</span><br><span class="line">            pubbw.write(publicKeyString);</span><br><span class="line">            pribw.write(privateKeyString);</span><br><span class="line">            pubbw.flush();</span><br><span class="line">            pubbw.close();</span><br><span class="line">            pubfw.close();</span><br><span class="line">            pribw.flush();</span><br><span class="line">            pribw.close();</span><br><span class="line">            prifw.close();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从文件中输入流中加载公钥</span><br><span class="line">     *</span><br><span class="line">     * @param</span><br><span class="line">     *</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *             加载公钥时产生的异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String loadPublicKeyByFile(String path) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            BufferedReader br &#x3D; new BufferedReader(new FileReader(path</span><br><span class="line">                    + &quot;&#x2F;publicKey.keystore&quot;));</span><br><span class="line">            String readLine &#x3D; null;</span><br><span class="line">            StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">            while ((readLine &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                sb.append(readLine);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">            return sb.toString();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new Exception(&quot;公钥数据流读取错误&quot;);</span><br><span class="line">        &#125; catch (NullPointerException e) &#123;</span><br><span class="line">            throw new Exception(&quot;公钥输入流为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从字符串中加载公钥</span><br><span class="line">     *</span><br><span class="line">     * @param publicKeyStr</span><br><span class="line">     *            公钥数据字符串</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *             加载公钥时产生的异常</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static RSAPublicKey loadPublicKeyByStr(String publicKeyStr)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] buffer &#x3D; Base64.getDecoder().decode(publicKeyStr);</span><br><span class="line">            KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">            X509EncodedKeySpec keySpec &#x3D; new X509EncodedKeySpec(buffer);</span><br><span class="line">            return (RSAPublicKey) keyFactory.generatePublic(keySpec);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            throw new Exception(&quot;无此算法&quot;);</span><br><span class="line">        &#125; catch (InvalidKeySpecException e) &#123;</span><br><span class="line">            throw new Exception(&quot;公钥非法&quot;);</span><br><span class="line">        &#125; catch (NullPointerException e) &#123;</span><br><span class="line">            throw new Exception(&quot;公钥数据为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 从文件中加载私钥</span><br><span class="line">     *</span><br><span class="line">     * @param</span><br><span class="line">     *</span><br><span class="line">     * @return 是否成功</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String loadPrivateKeyByFile(String path) throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            BufferedReader br &#x3D; new BufferedReader(new FileReader(path</span><br><span class="line">                    + &quot;&#x2F;privateKey.keystore&quot;));</span><br><span class="line">            String readLine &#x3D; null;</span><br><span class="line">            StringBuilder sb &#x3D; new StringBuilder();</span><br><span class="line">            while ((readLine &#x3D; br.readLine()) !&#x3D; null) &#123;</span><br><span class="line">                sb.append(readLine);</span><br><span class="line">            &#125;</span><br><span class="line">            br.close();</span><br><span class="line">            return sb.toString();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            throw new Exception(&quot;私钥数据读取错误&quot;);</span><br><span class="line">        &#125; catch (NullPointerException e) &#123;</span><br><span class="line">            throw new Exception(&quot;私钥输入流为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static RSAPrivateKey loadPrivateKeyByStr(String privateKeyStr)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            byte[] buffer &#x3D; Base64.getDecoder().decode(privateKeyStr);</span><br><span class="line">            PKCS8EncodedKeySpec keySpec &#x3D; new PKCS8EncodedKeySpec(buffer);</span><br><span class="line">            KeyFactory keyFactory &#x3D; KeyFactory.getInstance(&quot;RSA&quot;);</span><br><span class="line">            return (RSAPrivateKey) keyFactory.generatePrivate(keySpec);</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            throw new Exception(&quot;无此算法&quot;);</span><br><span class="line">        &#125; catch (InvalidKeySpecException e) &#123;</span><br><span class="line">            throw new Exception(&quot;私钥非法&quot;);</span><br><span class="line">        &#125; catch (NullPointerException e) &#123;</span><br><span class="line">            throw new Exception(&quot;私钥数据为空&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 公钥加密过程</span><br><span class="line">     *</span><br><span class="line">     * @param publicKey</span><br><span class="line">     *            公钥</span><br><span class="line">     * @param plainTextData</span><br><span class="line">     *            明文数据</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *             加密过程中的异常信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static byte[] encrypt(RSAPublicKey publicKey, byte[] plainTextData)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        if (publicKey &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new Exception(&quot;加密公钥为空, 请设置&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Cipher cipher &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用默认RSA</span><br><span class="line">            cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line">            &#x2F;&#x2F; cipher&#x3D; Cipher.getInstance(&quot;RSA&quot;, new BouncyCastleProvider());</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">            byte[] output &#x3D; cipher.doFinal(plainTextData);</span><br><span class="line">            return output;</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            throw new Exception(&quot;无此加密算法&quot;);</span><br><span class="line">        &#125; catch (NoSuchPaddingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125; catch (InvalidKeyException e) &#123;</span><br><span class="line">            throw new Exception(&quot;加密公钥非法,请检查&quot;);</span><br><span class="line">        &#125; catch (IllegalBlockSizeException e) &#123;</span><br><span class="line">            throw new Exception(&quot;明文长度非法&quot;);</span><br><span class="line">        &#125; catch (BadPaddingException e) &#123;</span><br><span class="line">            throw new Exception(&quot;明文数据已损坏&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 私钥加密过程</span><br><span class="line">     *</span><br><span class="line">     * @param privateKey</span><br><span class="line">     *            私钥</span><br><span class="line">     * @param plainTextData</span><br><span class="line">     *            明文数据</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *             加密过程中的异常信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static byte[] encrypt(RSAPrivateKey privateKey, byte[] plainTextData)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        if (privateKey &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new Exception(&quot;加密私钥为空, 请设置&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Cipher cipher &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用默认RSA</span><br><span class="line">            cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line">            cipher.init(Cipher.ENCRYPT_MODE, privateKey);</span><br><span class="line">            byte[] output &#x3D; cipher.doFinal(plainTextData);</span><br><span class="line">            return output;</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            throw new Exception(&quot;无此加密算法&quot;);</span><br><span class="line">        &#125; catch (NoSuchPaddingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125; catch (InvalidKeyException e) &#123;</span><br><span class="line">            throw new Exception(&quot;加密私钥非法,请检查&quot;);</span><br><span class="line">        &#125; catch (IllegalBlockSizeException e) &#123;</span><br><span class="line">            throw new Exception(&quot;明文长度非法&quot;);</span><br><span class="line">        &#125; catch (BadPaddingException e) &#123;</span><br><span class="line">            throw new Exception(&quot;明文数据已损坏&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 私钥解密过程</span><br><span class="line">     *</span><br><span class="line">     * @param privateKey</span><br><span class="line">     *            私钥</span><br><span class="line">     * @param cipherData</span><br><span class="line">     *            密文数据</span><br><span class="line">     * @return 明文</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *             解密过程中的异常信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static byte[] decrypt(RSAPrivateKey privateKey, byte[] cipherData)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        if (privateKey &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new Exception(&quot;解密私钥为空, 请设置&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Cipher cipher &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用默认RSA</span><br><span class="line">            cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line">            &#x2F;&#x2F; cipher&#x3D; Cipher.getInstance(&quot;RSA&quot;, new BouncyCastleProvider());</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">            byte[] output &#x3D; cipher.doFinal(cipherData);</span><br><span class="line">            return output;</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            throw new Exception(&quot;无此解密算法&quot;);</span><br><span class="line">        &#125; catch (NoSuchPaddingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125; catch (InvalidKeyException e) &#123;</span><br><span class="line">            throw new Exception(&quot;解密私钥非法,请检查&quot;);</span><br><span class="line">        &#125; catch (IllegalBlockSizeException e) &#123;</span><br><span class="line">            throw new Exception(&quot;密文长度非法&quot;);</span><br><span class="line">        &#125; catch (BadPaddingException e) &#123;</span><br><span class="line">            throw new Exception(&quot;密文数据已损坏&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 公钥解密过程</span><br><span class="line">     *</span><br><span class="line">     * @param publicKey</span><br><span class="line">     *            公钥</span><br><span class="line">     * @param cipherData</span><br><span class="line">     *            密文数据</span><br><span class="line">     * @return 明文</span><br><span class="line">     * @throws Exception</span><br><span class="line">     *             解密过程中的异常信息</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static byte[] decrypt(RSAPublicKey publicKey, byte[] cipherData)</span><br><span class="line">            throws Exception &#123;</span><br><span class="line">        if (publicKey &#x3D;&#x3D; null) &#123;</span><br><span class="line">            throw new Exception(&quot;解密公钥为空, 请设置&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Cipher cipher &#x3D; null;</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F; 使用默认RSA</span><br><span class="line">            cipher &#x3D; Cipher.getInstance(&quot;RSA&quot;);</span><br><span class="line">            &#x2F;&#x2F; cipher&#x3D; Cipher.getInstance(&quot;RSA&quot;, new BouncyCastleProvider());</span><br><span class="line">            cipher.init(Cipher.DECRYPT_MODE, publicKey);</span><br><span class="line">            byte[] output &#x3D; cipher.doFinal(cipherData);</span><br><span class="line">            return output;</span><br><span class="line">        &#125; catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">            throw new Exception(&quot;无此解密算法&quot;);</span><br><span class="line">        &#125; catch (NoSuchPaddingException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125; catch (InvalidKeyException e) &#123;</span><br><span class="line">            throw new Exception(&quot;解密公钥非法,请检查&quot;);</span><br><span class="line">        &#125; catch (IllegalBlockSizeException e) &#123;</span><br><span class="line">            throw new Exception(&quot;密文长度非法&quot;);</span><br><span class="line">        &#125; catch (BadPaddingException e) &#123;</span><br><span class="line">            throw new Exception(&quot;密文数据已损坏&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 字节数据转十六进制字符串</span><br><span class="line">     *</span><br><span class="line">     * @param data</span><br><span class="line">     *            输入数据</span><br><span class="line">     * @return 十六进制内容</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static String byteArrayToString(byte[] data) &#123;</span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; data.length; i++) &#123;</span><br><span class="line">            &#x2F;&#x2F; 取出字节的高四位 作为索引得到相应的十六进制标识符 注意无符号右移</span><br><span class="line">            stringBuilder.append(HEX_CHAR[(data[i] &amp; 0xf0) &gt;&gt;&gt; 4]);</span><br><span class="line">            &#x2F;&#x2F; 取出字节的低四位 作为索引得到相应的十六进制标识符</span><br><span class="line">            stringBuilder.append(HEX_CHAR[(data[i] &amp; 0x0f)]);</span><br><span class="line">            if (i &lt; data.length - 1) &#123;</span><br><span class="line">                stringBuilder.append(&#39; &#39;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return stringBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        String filepath&#x3D;&quot;F:&#x2F;temp&#x2F;&quot;;</span><br><span class="line">        File file&#x3D;new File(filepath);</span><br><span class="line">        if(!file.exists())&#123;</span><br><span class="line">            file.mkdir();</span><br><span class="line">        &#125;</span><br><span class="line">        genKeyPair(filepath);</span><br><span class="line">        System.out.println(&quot;--------------公钥加密私钥解密过程-------------------&quot;);</span><br><span class="line">        String plainText&#x3D;&quot;1223333323:8783737321232:dewejj28i33e92hhsxxxx&quot;;</span><br><span class="line">        &#x2F;&#x2F;公钥加密过程</span><br><span class="line">        byte[] cipherData&#x3D;encrypt(loadPublicKeyByStr(loadPublicKeyByFile(filepath)),plainText.getBytes());</span><br><span class="line">        String cipher&#x3D;new String(Base64.getEncoder().encode(cipherData));</span><br><span class="line">        &#x2F;&#x2F;私钥解密过程</span><br><span class="line">        byte[] res&#x3D;decrypt(loadPrivateKeyByStr(loadPrivateKeyByFile(filepath)), Base64.getDecoder().decode(cipher));</span><br><span class="line">        String restr&#x3D;new String(res);</span><br><span class="line">        System.out.println(&quot;原文：&quot;+plainText);</span><br><span class="line">        System.out.println(&quot;加密密文：&quot;+cipher);</span><br><span class="line">        System.out.println(&quot;解密：&quot;+restr);</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注： 文字部分复制了《大型电商分布式系统实践 第一版 讲师 陈康贤》的第三课。代码来源于自己的整理，全部测试通过，应该没有坑。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java 安全算法</tag>
      </tags>
  </entry>
  <entry>
    <title>阿里巴巴Java开发手册阅读笔记</title>
    <url>/2015/05/04/java-2015-05-04-java-kfsc-alibab/</url>
    <content><![CDATA[<p>1.抽象类命名使用 Abstract 或 Base 开头； 异常类命名使用 Exception 结尾； 测试类命名以它要测试的类的名称开始，以 Test 结尾。</p>
<p>2.POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。</p>
<span id="more"></span>

<blockquote>
<p>反例： 定义为基本数据类型 boolean isSuccess； 的属性，它的方法也是 isSuccess()， RPC框架在反向解析的时候， “以为”对应的属性名称是 success，导致属性获取不到，进而抛出异常。</p>
</blockquote>
<p>3.任何运算符左右必须加一个空格。</p>
<blockquote>
<p>说明： 运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号、三目运行符等。</p>
</blockquote>
<p>4.单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：</p>
<blockquote>
<p>1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。</p>
<p>2） 运算符与下文一起换行。</p>
</blockquote>
<blockquote>
<p>3） 方法调用的点符号与下文一起换行。</p>
</blockquote>
<blockquote>
<p>4） 在多个参数超长，逗号后进行换行。</p>
</blockquote>
<blockquote>
<p>5） 在括号前不要换行，见反例</p>
</blockquote>
<p>5.构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。同理getter setter</p>
<p>6.类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*<em>内容</em>/格式，不得使用//xxx 方式。</p>
<blockquote>
<p>说明： 在 IDE 编辑窗口中， Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释； 在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</p>
</blockquote>
<p>7.应用中不可直接使用日志系统（Log4j、 Logback） 中的 API，而应依赖使用日志框架SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p>
<p>8.可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别， error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别</p>
<p>9.字段允许适当冗余，以提高性能，但是必须考虑数据同步的情况。冗余字段应遵循：</p>
<blockquote>
<p>1） 不是频繁修改的字段。<br>2） 不是 varchar 超长字段，更不能是 text 字段。</p>
</blockquote>
<p>10.单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。</p>
<blockquote>
<p>说明： 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p>
</blockquote>
<p>11.如果有 order by 的场景，请注意利用索引的有序性。 order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。</p>
<blockquote>
<p>正例： where a=? and b=? order by c; 索引： a_b_c</p>
</blockquote>
<p>12.利用延迟关联或者子查询优化超多分页场景。</p>
<blockquote>
<p>正例： 先快速定位需要获取的 id 段，然后再关联：<br>SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p>
</blockquote>
<p>13.不得使用外键与级联，一切外键概念必须在应用层解决。</p>
<blockquote>
<p>说明： （概念解释） 学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群； 级联更新是强阻塞，存在数据库更新风暴的风险； 外键影响数据库的插入速度。</p>
</blockquote>
<p>14.禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p>
<p>15.数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p>
<p>16.在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</p>
<blockquote>
<p>说明： 1） 增加查询分析器解析成本。 2） 增减字段容易与 resultMap 配置不一致。</p>
</blockquote>
<p>17.POJO 类的 boolean 属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。</p>
<blockquote>
<p>说明： 参见定义 POJO 类以及数据库字段定义规定，在 sql.xml 增加映射，是必须的。</p>
</blockquote>
<p>18.xml 配置中参数注意使用： #{}， #param# 不要使用${} 此种方式容易出现 SQL 注入。</p>
<p>19.分层领域模型规约：</p>
<ul>
<li> DO（Data Object） ：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li>
<li>DTO（Data Transfer Object） ：数据传输对象， Service 和 Manager 向外传输的对象。</li>
<li>BO（Business Object） ：业务对象。 可以由 Service 层输出的封装业务逻辑的对象。</li>
<li>QUERY：数据查询对象，各层接收上层的查询请求。 注：超过 2 个参数的查询封装，禁止<br>使用 Map 类来传输。</li>
<li>VO（View Object） ：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li>
</ul>
<p>20.用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。</p>
<p>21.表单、 AJAX 提交必须执行 CSRF 安全过滤。</p>
<blockquote>
<p>说明： CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。</p>
</blockquote>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjava(3)</title>
    <url>/2015/05/05/java-2015-05-05-rxjava3/</url>
    <content><![CDATA[<h1 id="组合操作符"><a href="#组合操作符" class="headerlink" title="组合操作符"></a>组合操作符</h1><p>继上一篇讲述了过滤操作符，这一篇讲述组合操作符，组合操作符可用于组合多个Observable。组合操作符相对于过滤操作符要复杂很多，也较难以理解，需要花费时间去看文档查资料，写demo才能有一定的理解，这系列文章的例子将会在系列文章写完同意上传，敬请期待。</p>
<span id="more"></span>

<h2 id="1-starWith操作符"><a href="#1-starWith操作符" class="headerlink" title="1.starWith操作符"></a>1.starWith操作符</h2><p>starWith是在数据序列的开头插入一条指定的项;<br>如果你想要一个Observable在发射数据之前先发射一个指定的数据序列，可以使用 StartWith  操作符，原理如图所示。（如果你想一个Observable发射的数据末尾追加一个数据序列可以使用 Concat  操作符，与startwith 相反）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-71062490ed7f7636.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="04c9acfc-6e16-4aac-b683-2fc8a634c72e.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.just(1,2,3,4,5).startWith(9,8)</span><br><span class="line">   .subscribe(new Action1&lt;Integer&gt;() &#123;</span><br><span class="line">              @Override</span><br><span class="line">              public void call(Integer integer) &#123;</span><br><span class="line">                  Log.e(TAG,&quot;&quot;+integer);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>程序运行结果：</p>
<blockquote>
<p>9,8,1,2,3,4,5</p>
</blockquote>
<h2 id="2-CombineLatest操作符"><a href="#2-CombineLatest操作符" class="headerlink" title="2.CombineLatest操作符"></a>2.CombineLatest操作符</h2><p>当两个Observables中的任何一个发射了数据时，使用一个函数结合每个Observable发射的最近数据项，并且基于这个函数的结果发射数据。原理如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-821c0ab87c57f11d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="b8c10d40-2182-4489-a86e-3fb97e167a1f.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.combineLatest(Observable.just(1, 2, 3), </span><br><span class="line">    Observable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;), new Func2&lt;Integer, String,       String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call(Integer integer, String s) &#123;</span><br><span class="line">                Log.e(TAG,&quot;combineLatest:&quot;+&quot;integer:&quot;+integer+&quot;&gt;&gt;String:&quot;+s);</span><br><span class="line">                return integer+s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(String s) &#123;</span><br><span class="line">                Log.e(TAG,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>3a 3b 3c 3d </p>
</blockquote>
<p>CombineLatest  在原始的Observable中任意一个发射了数据<br>时发射一条数据。当原始Observables的任何一个发射了一条数据时， CombineLatest  使用一个函数结合它们最近发射的数据，然后发射这个函数的返回值。</p>
<h2 id="3-Merge"><a href="#3-Merge" class="headerlink" title="3.Merge"></a>3.Merge</h2><p>合并多个Observables的发射物;<br>使用 Merge  操作符你可以将多个Observables的输出合并，就好像它们是一个单个的Observable一样。Merge  可能会让合并的Observables发射的数据交错（有一个类似的操作符 Concat  不会让数据交错，它会按顺序一个接着一个发射多个Observables的发射物）。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-2b74ed91c6fb5d64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="d4d07187-1e98-4393-b6a3-54e285b7b338.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.merge(Observable.just(1,3,4,5),Observable.just(22,33,44))</span><br><span class="line">    .subscribe(new Action1&lt;Integer&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(Integer integer) &#123;</span><br><span class="line">                Log.e(TAG,&quot;&quot;+integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<blockquote>
<p>1,2,3,4,5,22,33,44</p>
</blockquote>
<h2 id="4-zip"><a href="#4-zip" class="headerlink" title="4.zip"></a>4.zip</h2><p>Zip  操作符返回一个Obversable，它使用这个函数按顺序结合两个或多个Observables发射的数据项，然后它发射这个函数返回的结果。它按照严格的顺序应用这个函数。它只发射与发射数据项最少的那个Observable一样多的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.zip(Observable.just(1, 2, 3, 4, 5), </span><br><span class="line">      Observable.just(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;), new      Func2&lt;Integer, String, String&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public String call(Integer integer, String integer2) &#123;</span><br><span class="line">              return integer+integer2;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">      .subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">          @Override</span><br><span class="line">          public void call(String s) &#123;</span><br><span class="line">              Log.e(TAG,&quot;&quot;+s);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<blockquote>
<p>1a ,2b,3c</p>
</blockquote>
<p>所有的组合操作符：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-9b1e320c8a193b3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<p>这些组合操作符都不是这么容易理解的，需要自己慢慢的领悟，学好rxjava需要投入一定时间和精力，总之多多练习就好了，需要我的这系列文章能够帮助到像我一样对rxjava热爱的人，感谢大家。</p>
<p>(<a target="_blank" rel="noopener" href="https://github.com/forezp/banya">https://github.com/forezp/banya</a>)<br> 项目地址：<a target="_blank" rel="noopener" href="https://github.com/forezp/banya">https://github.com/forezp/banya</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂设计模式</title>
    <url>/2015/05/05/java-2016-05-05-factory-mode/</url>
    <content><![CDATA[<p>##工厂设计模式</p>
<p>###一.什么是工厂设计模式</p>
<blockquote>
<p>工厂模式是我们最常用的实例化对象模式了，是用工厂方法代替new操作的一种模式。因为工厂模式就相当于创建实例对象的new，虽然这样做，可能多做一些工作，但会给你系统带来更大的可扩展性和尽量少的修改量。工厂模式最直接的作用就是将创建对象和对象的业务逻辑相分离。</p>
</blockquote>
<span id="more"></span>

<p>工厂模式最常见的三种：</p>
<ul>
<li>简单工厂模式</li>
<li>工厂方法模式</li>
<li>抽象工厂</li>
</ul>
<h3 id="二、简单工厂模式"><a href="#二、简单工厂模式" class="headerlink" title="二、简单工厂模式"></a>二、简单工厂模式</h3><p>以下是我看《headefirst设计模式》的工厂模式的笔记。非常有意思，但是篇幅有点长，所以打算总结下，写个简洁版的。</p>
<p>假如你有个pizza店，你可以为客人做很多 pizza。</p>
<p>首先，你需要很多pizza对象，定义一个pizza抽象类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class Pizza &#123;</span><br><span class="line">    abstract void prepared();</span><br><span class="line">    abstract void bake();</span><br><span class="line">    abstract void cut();</span><br><span class="line">    abstract void box();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>中式 pizza:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ChineasePizza extends Pizza &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepared() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void bake() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void cut() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void box() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>美式pizza:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class AmericanPizza extends Pizza &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepared() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void bake() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void cut() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void box() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当我需要为客人准备一份pizza，我们可能会需要这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Pizza orderPizza(String type)&#123;</span><br><span class="line">        Pizza pizza &#x3D; null;</span><br><span class="line">        if(type.equals(&quot;c&quot;))&#123;</span><br><span class="line">            pizza&#x3D;new ChineasePizza();</span><br><span class="line">        &#125;else if(type.equals(&quot;a&quot;))&#123;</span><br><span class="line">            pizza&#x3D;new AmericanPizza();</span><br><span class="line">        &#125;else if(type.equals(&quot;e&quot;))&#123;</span><br><span class="line">            pizza&#x3D;new EnglishPizza();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            pizza&#x3D;new ChineasePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        pizza.prepared();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>当你有很多种pizza的时候，这个else if()特别的长：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(type.equals(&quot;c&quot;))&#123;</span><br><span class="line">           pizza&#x3D;new ChineasePizza();</span><br><span class="line">       &#125;else if(type.equals(&quot;a&quot;))&#123;</span><br><span class="line">           pizza&#x3D;new AmericanPizza();</span><br><span class="line">       &#125;else if(type.equals(&quot;e&quot;))&#123;</span><br><span class="line">           pizza&#x3D;new EnglishPizza();</span><br><span class="line">       &#125;else if(...)&#123;</span><br><span class="line">       ....</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           pizza&#x3D;new ChineasePizza();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>你需要创建一个工厂来管理这些pizza的创建实例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class SimplePizzaFactory &#123;</span><br><span class="line"></span><br><span class="line">    public Pizza createPizza(String type) &#123;</span><br><span class="line"></span><br><span class="line">        Pizza pizza &#x3D; null;</span><br><span class="line">        if(type.equals(&quot;c&quot;))&#123;</span><br><span class="line">            pizza&#x3D;new ChineasePizza();</span><br><span class="line">        &#125;else if(type.equals(&quot;a&quot;))&#123;</span><br><span class="line">            pizza&#x3D;new AmericanPizza();</span><br><span class="line">        &#125;else if(type.equals(&quot;e&quot;))&#123;</span><br><span class="line">            pizza&#x3D;new EnglishPizza();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            pizza&#x3D;new ChineasePizza();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>有了工厂之后的你代码应该这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class PizzaStore &#123;</span><br><span class="line"></span><br><span class="line">    private SimplePizzaFactory simplePizzaFactory;</span><br><span class="line">    public PizzaStore(SimplePizzaFactory simplePizzaFactory)&#123;</span><br><span class="line">        this.simplePizzaFactory&#x3D;simplePizzaFactory;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Pizza orderPizza(String type) &#123;</span><br><span class="line">       Pizza pizza&#x3D; simplePizzaFactory.createPizza(type);</span><br><span class="line">        pizza.prepared();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>就是简单的工厂模式，工厂处理创建对象的细节。工厂模式将创建对象和对象的业务逻辑相分离，降低了代码的耦合性，提高了代码的可读性。</p>
<h3 id="三、工厂方法模式"><a href="#三、工厂方法模式" class="headerlink" title="三、工厂方法模式"></a>三、工厂方法模式</h3><p>当你需要开很多pizza店的时候，你可能需要创建的pizztore抽象类,这个抽象类只专注于卖pizza的业务逻辑，不专注pizza是怎么来的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public abstract class APizzaStore &#123;</span><br><span class="line"></span><br><span class="line">    public Pizza orderPizza(String type) &#123;</span><br><span class="line">        Pizza pizza&#x3D; createPizza(type);</span><br><span class="line">        pizza.prepared();</span><br><span class="line">        pizza.bake();</span><br><span class="line">        pizza.cut();</span><br><span class="line">        pizza.box();</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">    abstract Pizza createPizza(String type);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它的子类需要专注于pizza 是怎么来的，你需要在北京开一家pizza店：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class BeijingtPizzaStore extends APizzaStore&#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    Pizza createPizza(String type) &#123;</span><br><span class="line">        Pizza pizza;</span><br><span class="line">        if(type.equals(&quot;a&quot;))&#123;</span><br><span class="line">            pizza&#x3D;new AmericanPizza();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            pizza&#x3D;new ChineasePizza();</span><br><span class="line">        &#125;</span><br><span class="line">        return pizza;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你在北京卖pizza之需要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BeijingtPizzaStore bps&#x3D;new BeijingtPizzaStore();</span><br><span class="line">bps.orderPizza();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 同理,你需要在深圳开pizza店：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class ShenZhengPizzaStore extends APizzaStore &#123;</span><br><span class="line">    @Override</span><br><span class="line">    Pizza createPizza(String type) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>工厂方法用来处理对象的创建，并将这样的行为封装在子类中。超类的代码和子类的对象创建代码就解耦了。</p>
<h3 id="四、抽象工厂模式"><a href="#四、抽象工厂模式" class="headerlink" title="四、抽象工厂模式"></a>四、抽象工厂模式</h3><p>你制造pizza的时候，需要很多原料，这时需要一个工厂来制造：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IngredientFactory &#123;</span><br><span class="line">    Dauch createDauch();</span><br><span class="line">    Sauce createSauch();</span><br><span class="line">    Cheese createCheese();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个中国原料工厂：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ChineaseIngredientFactory implements IngredientFactory &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Dauch createDauch() &#123;</span><br><span class="line">        return new Dauch();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Sauce createSauch() &#123;</span><br><span class="line">        return new Sauce();　&#x2F;&#x2F;这里我简便的写，其实也可以说Sauch的子类。</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Cheese createCheese() &#123;</span><br><span class="line">        return new Cheese();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>同理也可以创建美国原料工厂：</p>
<p>这时我们可以重做pizza:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public abstract class Pizza &#123;    </span><br><span class="line">                                 </span><br><span class="line">    String name;                 </span><br><span class="line">    Dauch dauch;                 </span><br><span class="line">    Sauce sauch;            </span><br><span class="line">    Cheese  cheese ;     </span><br><span class="line">                                 </span><br><span class="line">    abstract void prepared();    </span><br><span class="line">    abstract void bake();        </span><br><span class="line">    abstract void cut();         </span><br><span class="line">    abstract void box();         </span><br><span class="line">&#125;                                </span><br><span class="line">                                 </span><br><span class="line">                                                                                  </span><br></pre></td></tr></table></figure>


<p>中国式pizza:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ChineasePizza extends Pizza &#123;</span><br><span class="line">    </span><br><span class="line">    private ChineaseIngredientFactory ingredientFactory;</span><br><span class="line">    </span><br><span class="line">    public ChineasePizza(ChineaseIngredientFactory ingredientFactory)&#123;</span><br><span class="line">        this.ingredientFactory&#x3D;ingredientFactory;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void prepared() &#123;</span><br><span class="line">        dauch&#x3D;ingredientFactory.createDauch();</span><br><span class="line">        sauch&#x3D;ingredientFactory.createSauch();</span><br><span class="line">        cheese&#x3D;ingredientFactory.createCheese();</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void bake() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void cut() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void box() &#123;</span><br><span class="line">        &#x2F;&#x2F;TODO</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时候我们再看，利用抽象工厂模式，可以为pizza创建原料，pizza只关注于它自身的业务逻辑，而不用关注pizza原料从哪里来，这样的pizza和pizza原料的解耦。</p>
<blockquote>
<p>通过抽象工厂所提供的接口，可以创建产品的家族，利用这个接口写代码，我们的代码将实际工厂解耦，以便在不同的工厂，制造出不同的产品。</p>
</blockquote>
<p>到此为止，三种工厂模式已经讲解完毕，<a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9757759">源码下载</a>。</p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>java8 lambda</title>
    <url>/2015/05/05/java-2016-05-05-java8-lambda/</url>
    <content><![CDATA[<p>λ表达式本质上是一个匿名方法。让我们来看下面这个例子：</p>
<pre><code>public int add(int x, int y) &#123;
    return x + y;
&#125;
</code></pre>
<span id="more"></span>

<p>转成λ表达式后是这个样子：</p>
<pre><code>(int x, int y) -&gt; x + y;
</code></pre>
<p>参数类型也可以省略，Java编译器会根据上下文推断出来：</p>
<pre><code>(x, y) -&gt; x + y; //返回两数之和
</code></pre>
<p>或者</p>
<pre><code>(x, y) -&gt; &#123; return x + y; &#125; //显式指明返回值
</code></pre>
<p>可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。</p>
<p>下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：</p>
<pre><code>() -&gt; &#123; System.out.println(&quot;Hello Lambda!&quot;); &#125;
</code></pre>
<p>如果只有一个参数且可以被Java推断出类型，那么参数列表的括号也可以省略：</p>
<pre><code>c -&gt; &#123; return c.size(); &#125;
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">		Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; &#123;</span><br><span class="line">			System.out.print( e +&quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">		&#125; );</span><br><span class="line">		System.out.print( &quot;\n--------------------------&quot; );</span><br><span class="line">		Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * 可见λ表达式有三部分组成：参数列表，箭头（-&gt;），以及一个表达式或语句块。</span><br><span class="line">		 * 下面这个例子里的λ表达式没有参数，也没有返回值（相当于一个方法接受0个参数，返回void，其实就是Runnable里run方法的一个实现）：</span><br><span class="line">		 * () -&gt; &#123; System.out.println(&quot;Hello Lambda!&quot;); &#125;</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		Thread t2&#x3D;new Thread(()-&gt;&#123;</span><br><span class="line">			System.out.println(&quot;This is from an anonymous method (lambda exp).\n&quot;);</span><br><span class="line">		&#125;);</span><br><span class="line">		t2.start();</span><br><span class="line">		&#x2F;**</span><br><span class="line">		 * 迭代LIST</span><br><span class="line">		 *&#x2F;</span><br><span class="line">		List&lt;String&gt; listStr&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">		listStr.add(&quot;sss&quot;);</span><br><span class="line">		listStr.add(&quot;1111&quot;);</span><br><span class="line">		listStr.forEach(e-&gt;&#123;</span><br><span class="line">			if(e.equals(&quot;sss&quot;))&#123;</span><br><span class="line">				System.out.print(e);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjava(2)</title>
    <url>/2015/05/05/java-2016-05-05-rxjava1/</url>
    <content><![CDATA[<p>上一篇文章介绍了rxjava的基本用法，和一些常用的操作符，以及rxjava的链式操作带来的好处。由于rxjava非常的强大，让我如此的痴迷，我打算写五篇文章，专门讲解rxjava 常见的操作符和用法，敬请期待。这篇文章主要讲解过滤操作符。</p>
<span id="more"></span>

<h3 id="1-distinct操作符"><a href="#1-distinct操作符" class="headerlink" title="1.distinct操作符"></a>1.distinct操作符</h3><p>过滤掉重复的数据项，只让还没有发送过数据项通过。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-8680622b8795115f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"> rx.Observable.just(&quot;1&quot;,&quot;2&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;)</span><br><span class="line">   .distinct(new Func1&lt;String, String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String call(String s) &#123;</span><br><span class="line">                return &quot;key&quot;+s;&#x2F;&#x2F;这时候比较的是key+s  而不是比较s</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    .subscribe(new Action1&lt;String&gt;() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void call(String s) &#123;</span><br><span class="line">                Log.e(TAG,s);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#96;&#96;&#96;       </span><br><span class="line"></span><br><span class="line">*运行程序，输出结果 ：*   </span><br><span class="line"></span><br><span class="line">&gt; 1 </span><br><span class="line">&gt; </span><br><span class="line">&gt; 2 </span><br><span class="line">&gt; </span><br><span class="line">&gt; 3 </span><br><span class="line">&gt; </span><br><span class="line">&gt; 4                                                                      </span><br><span class="line"></span><br><span class="line">它的作用是去掉相同的元素，例如例子中去掉了2 </span><br><span class="line"></span><br><span class="line">###  2.ElementAt</span><br><span class="line"></span><br><span class="line">只发射第n项数据</span><br><span class="line"></span><br><span class="line">![Paste_Image.png](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;2279594-b85704b90b77d603.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   rx.Observable.just(“1”,”2”,”3”)<br>   .elementAt(1)<br>   .subscribe(new Action1<String>() {//只发射第二个元素<br>            @Override<br>            public void call(String s) {<br>                Log.e(TAG,s);<br>            }<br>        });</p>
<pre><code>    rx.Observable.just(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;)
    .elementAtOrDefault(11,&quot;11111&quot;)
    .subscribe(new Action1&lt;String&gt;() &#123;//只发射第二个元素
        @Override
        public void call(String s) &#123;
            Log.e(TAG,s);
        &#125;
    &#125;);       
                        
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*运行结果：*  </span><br><span class="line">&gt; 2</span><br><span class="line">&gt; </span><br><span class="line">&gt; 11111  </span><br><span class="line">                                                                      </span><br><span class="line">elemntAt(1)发射第二项数据；elementAtOrDefault(11,&quot;11111&quot;)，由于observable没有11找个索引元素，所以发送了默认的11111</span><br><span class="line"></span><br><span class="line">### 3.first操作符</span><br><span class="line"></span><br><span class="line">只发射第一项数据或者满足条件的第一项数据，如果你需要第一项数据，或者满足条件的第一项数据，可以使用该操作符</span><br><span class="line"></span><br><span class="line">![Paste_Image.png](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;2279594-595749c0400c2c06.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rx.Observable.just(“1”,”2”,”3”)<br>  .first()<br>  .subscribe(new Action1<String>() {<br>            @Override<br>            public void call(String s) {<br>                Log.e(TAG,s);<br>            }<br>        });</p>
<p>rx.Observable.just(1,2,3)<br>   .first(new Func1&lt;Integer, Boolean&gt;() {<br>          @Override<br>        public Boolean call(Integer integer) {<br>           if(integer&gt;2) return true;<br>              return false;<br>          }<br>        })<br>    .subscribe(new Action1<Integer>() {<br>        @Override<br>        public void call(Integer integer) {<br>             Log.e(TAG,integer+””);<br>          }<br>      }); </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*运行结果：*</span><br><span class="line">&gt; 1</span><br><span class="line">&gt; </span><br><span class="line">&gt; 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###  4.last 操作符</span><br><span class="line"></span><br><span class="line">last只发射最后一项数据，和first 正好相反。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rx.Observable.just(1,2,3,4)<br>.last().subscribe(new Action1<Integer>() {<br>            @Override<br>            public void call(Integer integer) {<br>                Log.e(TAG,integer+””);<br>            }<br>        });</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">允许结果：</span><br><span class="line">&gt;4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.sample操作符</span><br><span class="line"></span><br><span class="line">定期采样并发射 observable 最近的数据</span><br><span class="line"></span><br><span class="line">![Paste_Image.png](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;2279594-45bd255cbbe2e731.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rx.Observable.interval(300, TimeUnit.MILLISECONDS)<br>   .sample(2,TimeUnit.SECONDS)<br>   .subscribe(new Action1<Long>() {<br>            @Override<br>            public void call(Long aLong) {<br>                Log.e(TAG,aLong+””);<br>            }<br>        });</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">*运行结果：*</span><br><span class="line">&gt; 6</span><br><span class="line">&gt;  </span><br><span class="line">&gt; 13</span><br><span class="line">&gt; </span><br><span class="line">&gt; ....</span><br><span class="line"></span><br><span class="line">observal 每300ms发射一个从0到n的数据，sample 每隔2s取一个observal 最近发射的数据，并发射出去。</span><br><span class="line"></span><br><span class="line">### 6.skip操作符</span><br><span class="line">跳过前n项数据，也就说不发射前n项数据。</span><br><span class="line"></span><br><span class="line">![Paste_Image.png](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;2279594-44976b1de9c347f5.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>rx.Observable.just(1,2,4,5,6)<br>    .skip(2)<br>    .subscribe(new Action1<Integer>() {<br>            @Override<br>            public void call(Integer integer) {<br>                Log.e(TAG,integer+””);<br>            }<br>        });</p>
<pre><code>
*运行结果:*
&gt;4
&gt;
&gt;5
&gt;
&gt;6

前面2项数据跳过不发射。



所有的过滤操作符：

![Paste_Image.png](http://upload-images.jianshu.io/upload_images/2279594-08fb0157814ac222.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

好了，今天的讲解了过滤操作符，写了这篇文章相信你很快就会理解。
过滤操作符不止这些，另外还有很多其他的过滤操作符，需要你们自己一个一个的摸索了。感谢大家，如果觉得可以点个赞吧，哈哈……^_^
</code></pre>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjava(1)</title>
    <url>/2015/05/05/java-2016-05-05-rxjava2/</url>
    <content><![CDATA[<p>Rxjava在目前的开发中已经是如火如荼，非常的流行，唯一的就是上手不太容易，学习成本高，学习rxjava有一段时间了，也看了<a target="_blank" rel="noopener" href="http://www.apkbus.com/forum.php?mod=viewthread&tid=257703&extra=page=1&filter=author&orderby=dateline&_dsign=43e9b95f">老罗的rxjava视频</a>，决定自己总结下。 </p>
<p>另外欢迎star我的另一个项目,<a target="_blank" rel="noopener" href="https://github.com/forezp/banya">瓣呀，一个基于豆瓣API模仿网易云音乐的开源app</a> </p>
<span id="more"></span>

<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>在android工程中的gradle.build中配置，为了更好的理解，所以导入java8 的lambda 表达式。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &#39;io.reactivex:rxjava:1.2.1&#39;</span><br><span class="line">compile &#39;io.reactivex:rxandroid:1.2.1&#39;</span><br></pre></td></tr></table></figure>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p> rxjava 中有两个核心的对象Observable（被观察者，它会发出一系列的事件源）和Subscribers（观察者，接受事件源），Observable发出事件后，中间可以有一系列的操作、变化，可以精确的控制事件，最终被观察者所接收。其中Observable每发出一个事件就会，就会调用他的subscriber 的onext()，直到发生错误onerror()或onComplete()结束。</p>
<p>1.用Observable.create去创建一个Observable对象，并发射一个”hi Rxjava”，就结束。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable&lt;String&gt; observable&#x3D; Observable.create(</span><br><span class="line">      new Observable.OnSubscribe&lt;String&gt;() &#123;    </span><br><span class="line">   @Override   </span><br><span class="line">   public void call(Subscriber&lt;? super String&gt;    subscriber)</span><br><span class="line">   &#123;  </span><br><span class="line">      subscriber.onNext(&quot;hi RxJava&quot;);           </span><br><span class="line">      subscriber.onCompleted();   </span><br><span class="line">  &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>然后，我们需要去创建一个subscriber去处理observable发射过来的数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Subscriber&lt;String&gt; subscriber&#x3D;new Subscriber&lt;String&gt;() &#123;</span><br><span class="line">   @Override  </span><br><span class="line">   public void onCompleted() &#123;     </span><br><span class="line">      Log.e(TAG,&quot;onCompleted&quot;); </span><br><span class="line">   &#125;   </span><br><span class="line">  @Override  </span><br><span class="line">   public void onError(Throwable e) &#123;                    </span><br><span class="line">      Log.e(TAG,e.getMessage());   </span><br><span class="line">   &#125;    </span><br><span class="line">  @Override</span><br><span class="line">  public void onNext(String s) &#123;     </span><br><span class="line">      Log.e(TAG,s);   </span><br><span class="line">  &#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>最后需要，subscribe函数把observable对象和subscriber对象关联起来，这样就完成了subscriber对observable的订阅。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">observable.subscribe(subscriber);</span><br></pre></td></tr></table></figure>
<p>程序运行一下：<br><img src="http://upload-images.jianshu.io/upload_images/2279594-47628cd15faae8fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"><br>可能你觉得这样太复杂了，但是涉及到了与之前不一样的变成思想，即响应式编程。</p>
<p>2.用just去创建observable，just英语意思是仅仅的意思，如果只发出一个事件可以用这种方式。另外在创建Subscriber的时候，如果仅仅关心onNext()，这时可以用Action1这个对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.just(&quot;hi Rxjava2&quot;).subscribe(new Action1&lt;String&gt;() &#123;    </span><br><span class="line">   @Override </span><br><span class="line">   public void call(String s) &#123;       </span><br><span class="line">      Log.e(TAG,s);  </span><br><span class="line">  &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-ea911afc524c4f35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>3.用from创建observable，这种方式创建，需要传入一个集合，它会一个一个的发射，在subscriber上它会一个一个的接收。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String [] strs&#x3D;&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;&#125;;</span><br><span class="line">Observable.from(Arrays.asList(strs))</span><br><span class="line">.subscribe(new Action1&lt;String&gt;() &#123;   </span><br><span class="line">   @Override   </span><br><span class="line">    public void call(String s) &#123;       </span><br><span class="line">        Log.e(TAG,s);    </span><br><span class="line"> &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-c92425b80e17d822.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>是不是有点像高级for循环－.－  。</p>
<p>4.操作符map，是用在observable和subcriber中间，是为了操作observable发射的数据，操作之后的数据，会被subcriber 接收。rxjava有很多操作符，map操作符是将一个事件转换为另一个事件的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.just(&quot;hi rxjava&quot;)</span><br><span class="line">.map(new Func1&lt;String, String&gt;() &#123;  </span><br><span class="line">  @Override    </span><br><span class="line">  public String call(String s) &#123;    </span><br><span class="line">    return s+&quot; ,你好rxjava&quot;;   </span><br><span class="line">   &#125;&#125;)</span><br><span class="line">.subscribe(new Action1&lt;String&gt;() &#123;    </span><br><span class="line">     @Override    </span><br><span class="line">     public void call(String s) &#123;    </span><br><span class="line">        Log.e(TAG,s);   </span><br><span class="line">  &#125;&#125;);</span><br></pre></td></tr></table></figure>

<p>运行程序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-ffb680d3ef2f5347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>另外,map操作符可以将转换类型，比如string 转int .</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.just(&quot;hi rxjava&quot;)</span><br><span class="line">.map(new Func1&lt;String, Integer&gt;() &#123; </span><br><span class="line">   @Override    </span><br><span class="line">    public Integer call(String s) &#123; </span><br><span class="line">       return s.hashCode();    </span><br><span class="line">   &#125;&#125;)</span><br><span class="line">.subscribe(new Action1&lt;Object&gt;() &#123; </span><br><span class="line">   @Override  </span><br><span class="line">    public void call(Object s) &#123;    </span><br><span class="line">       Log.e(TAG,s+&quot;&quot;);   </span><br><span class="line"> &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>5.flatmap操作符<br>flatMap操作符接收一个Observable的输出作为输入，同时输出另外一个Observable。在flatMap操作符中，我们可以做一系列的事情，然后输出的新的Observable，这个Observable是我们在Subscriber想要接收的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.create(new Observable.OnSubscribe&lt;List&lt;String&gt;&gt;() &#123;    </span><br><span class="line">  @Override   </span><br><span class="line">  public void call(Subscriber&lt;? super List&lt;String&gt;&gt; subscriber) &#123;           </span><br><span class="line">      String [] strs&#x3D;&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;&#125;;           </span><br><span class="line">      subscriber.onNext(Arrays.asList(strs));   </span><br><span class="line"> &#125;&#125;)</span><br><span class="line">.flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;?&gt;&gt;() &#123;    </span><br><span class="line">   @Override </span><br><span class="line">   public Observable&lt;?&gt; call(List&lt;String&gt; list) &#123;     </span><br><span class="line">      return Observable.from(list);  </span><br><span class="line">   &#125;&#125;)</span><br><span class="line">.subscribe(new Action1&lt;Object&gt;() &#123; </span><br><span class="line">   @Override   </span><br><span class="line">   public void call(Object o) &#123;  </span><br><span class="line">      Log.e(TAG,o.toString());  </span><br><span class="line">  &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>首先Observable发出一个list<String> , 然后经过flatmap 将其变成from创建的Observable，这个Observable将list中的元素一个一个的发射，然后，subcriber 中接收。</p>
<p>运行程序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-1ab20874bc9d5feb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>6.filter 操作符，对Observable发射的数据进行过滤操作，哪有subcriber接收 ，哪些不接收。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.create(new Observable.OnSubscribe&lt;List&lt;String&gt;&gt;() &#123;    </span><br><span class="line">   @Override </span><br><span class="line">   public void call(Subscriber&lt;? super List&lt;String&gt;&gt; subscriber) &#123;        </span><br><span class="line">      String [] strs&#x3D;&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;&#125;;          </span><br><span class="line">      subscriber.onNext(Arrays.asList(strs));   </span><br><span class="line">   &#125;&#125;)</span><br><span class="line">.flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;?&gt;&gt;() &#123;    </span><br><span class="line">   @Override </span><br><span class="line">   public Observable&lt;?&gt; call(List&lt;String&gt; list) &#123;   </span><br><span class="line">     return Observable.from(list);  </span><br><span class="line">  &#125;&#125;)</span><br><span class="line">.filter(new Func1&lt;Object, Boolean&gt;() &#123;&#x2F;&#x2F;filter 操作符，去掉“1”;    </span><br><span class="line">   @Override </span><br><span class="line">   public Boolean call(Object o) &#123;        </span><br><span class="line">     if(o.toString().equals(&quot;1&quot;))return false;   </span><br><span class="line">     return true;    </span><br><span class="line">&#125;&#125;)</span><br><span class="line">.subscribe(new Action1&lt;Object&gt;() &#123;</span><br><span class="line">  @Override    </span><br><span class="line">  public void call(Object o) &#123;        </span><br><span class="line">    Log.e(TAG,o.toString()); </span><br><span class="line"> &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-485551ccdee1c0ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>7.take操作符，固定返回数量。take(2)，返回2个结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable.create(new Observable.OnSubscribe&lt;List&lt;String&gt;&gt;() &#123;    </span><br><span class="line">  @Override  </span><br><span class="line">  public void call(Subscriber&lt;? super List&lt;String&gt;&gt; subscriber) &#123;        </span><br><span class="line">    String [] strs&#x3D;&#123;&quot;1&quot;,&quot;2&quot;,&quot;3&quot;,&quot;4&quot;,&quot;5&quot;,&quot;6&quot;,&quot;7&quot;&#125;;        </span><br><span class="line">    subscriber.onNext(Arrays.asList(strs));    </span><br><span class="line"> &#125;&#125;)</span><br><span class="line">.flatMap(new Func1&lt;List&lt;String&gt;, Observable&lt;?&gt;&gt;() &#123;    </span><br><span class="line">  @Override   </span><br><span class="line">   public Observable&lt;?&gt; call(List&lt;String&gt; list) &#123;  </span><br><span class="line">      return Observable.from(list);  </span><br><span class="line">  &#125;&#125;)</span><br><span class="line">.filter(new Func1&lt;Object, Boolean&gt;() &#123;&#x2F;&#x2F;filter 操作符，去掉“1”;    </span><br><span class="line">   @Override   </span><br><span class="line">   public Boolean call(Object o) &#123;        </span><br><span class="line">     if(o.toString().equals(&quot;1&quot;))return false;     </span><br><span class="line">     return true;    </span><br><span class="line"> &#125;&#125;)</span><br><span class="line">.take(2)</span><br><span class="line">.subscribe(new Action1&lt;Object&gt;() &#123;&#x2F;&#x2F;take 操作符，最多输出的数量    </span><br><span class="line">   @Override  </span><br><span class="line">   public void call(Object o) &#123;     </span><br><span class="line">       Log.e(TAG,o.toString());  </span><br><span class="line">  &#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>运行程序：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-2f265edfc90d5640.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行结果"></p>
<p>rxjava中还有很多操作符，具体见<a target="_blank" rel="noopener" href="http://reactivex.io/RxJava/javadoc/">官网文档</a>和<a target="_blank" rel="noopener" href="https://mcxiaoke.gitbooks.io/rxdocs/content/">中文文档</a>，操作符可以让你对数据流做任何操作。多个操作符配合起来，可以让很复杂的逻辑变得简单，同时，在操作数据的过程中，subcriber并不需要知道中间做了那些操作，只需要知道返回的结果，操作数据也变的简单。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/forezp/RxJavaDemo">源码下载</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>java 线程池、信号量</title>
    <url>/2015/05/05/java-2016-05-05-threadpool/</url>
    <content><![CDATA[<p>当我们需要执行一个异步任务时，通常会创建一个线程并启动它，通常任务执行完，线程会被回收，这的确很方便。但我们有大量的任务需要去执行，高并发的情况下，我们都需要不断的创建线程，创建线程和执行线程任务时非常耗费系统资源的，所以我们需要使用线程池，线程池很好的避免了这种情况，并且能很好的控制线程的执行。</p>
<span id="more"></span>

<p>java中的主要是ThreadPoolExecutor这个类，具体的可以参考下<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3932921.html">海子的博客</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class ExcutorService &#123;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		 ThreadPoolExecutor executor &#x3D; new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,</span><br><span class="line">                 new ArrayBlockingQueue&lt;Runnable&gt;(5));</span><br><span class="line">          </span><br><span class="line">         for(int i&#x3D;0;i&lt;15;i++)&#123;</span><br><span class="line">             MyTask myTask &#x3D; new MyTask(i);</span><br><span class="line">             executor.execute(myTask);</span><br><span class="line">             System.out.println(&quot;线程池中线程数目：&quot;+executor.getPoolSize()+&quot;，队列中等待执行的任务数目：&quot;+</span><br><span class="line">             executor.getQueue().size()+&quot;，已执行玩别的任务数目：&quot;+executor.getCompletedTaskCount());</span><br><span class="line">         &#125;</span><br><span class="line">         executor.shutdown();</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意上述代码，如何任务数超过15 会出一场，因为我们在new线程池的时候，就已经指定了个数，即5＋10</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">public class MyTask implements Runnable&#123;</span><br><span class="line">	</span><br><span class="line">	private int taskNum;</span><br><span class="line">    </span><br><span class="line">    public MyTask(int num) &#123;</span><br><span class="line">        this.taskNum &#x3D; num;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;正在执行task &quot;+taskNum);</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.currentThread().sleep(4000);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;task &quot;+taskNum+&quot;执行完毕&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ThreadPoolExecutor这个类可以很好的控制任务的执行。<br>当我们需要控制最多5个线程同时进行时，我们需要使用信号量，<br>acquire()表示需要获取一个许可，当没有许可的时候，线程阻塞，release()表示释放一个许可，下一个阻塞的线程会获取许可，得到执行，通过信号量可以控制现场并发的个数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	</span><br><span class="line">	Semaphore semaphore&#x3D;new Semaphore(5);</span><br><span class="line">	ExecutorService executorService&#x3D;Executors.newFixedThreadPool(5) ;</span><br><span class="line"></span><br><span class="line">	for( int i&#x3D;0;i&lt;100;i++)&#123;</span><br><span class="line">		final String temp&#x3D;&quot;&quot;+i;</span><br><span class="line">		</span><br><span class="line">		Runnable run &#x3D;new Runnable() &#123;</span><br><span class="line"></span><br><span class="line">			@Override</span><br><span class="line">			public void run() &#123;</span><br><span class="line">				try &#123;</span><br><span class="line">					semaphore.acquire();</span><br><span class="line">					</span><br><span class="line">					System.out.println(temp);</span><br><span class="line">					Thread.sleep((long)Math.random()*2000);</span><br><span class="line">					semaphore.release();</span><br><span class="line">				&#125; catch (Exception e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			</span><br><span class="line">				</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		executorService.execute(run);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 注解详解</title>
    <url>/2017/09/16/java-2017-09-16-java-annotation/</url>
    <content><![CDATA[<p>在使用SpringBoot作为Web敏捷开发的框架之后，SpringBoot除了自动装配配置的便捷之外，在很多时候需要基于注解来开发。注解不仅增加了代码的可读性，还增加了开发的速度。这篇文章主要讲述Java 注解。</p>
<span id="more"></span>

<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解用于注解其他注解的。Java 5.0定义了4个标准的元注解，如下：</p>
<ul>
<li>@Target</li>
<li>@Retention</li>
<li>@Documented</li>
<li>Inherited</li>
</ul>
<p>现在来说说这四个元注解有什么作用。</p>
<h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p>　@Target注解用于声明注解的作用范围，例如作用范围为类、接口、方法等。它的取值以及值所对应的范围如下：</p>
<ul>
<li> CONSTRUCTOR:用于描述构造器</li>
<li> FIELD:用于描述域</li>
<li> LOCAL_VARIABLE:用于描述局部变量</li>
<li> METHOD:用于描述方法</li>
<li> PACKAGE:用于描述包</li>
<li> PARAMETER:用于描述参数</li>
<li> TYPE:用于描述类、接口(包括注解类型) 或enum声明</li>
</ul>
<h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p>该注解声明了注解的生命周期，即注解在什么范围内有效。</p>
<ul>
<li>SOURCE:在源文件中有效</li>
<li>CLASS:在class文件中有效</li>
<li>RUNTIME:在运行时有效（即运行时保留）</li>
</ul>
<p>大多数注解都为RUNTIME</p>
<h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p>是一个标记注解，有该注解的注解会在生成 java 文档中保留。</p>
<h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p>该注解表明子类是有继承了父类的注解。比如一个注解被该元注解修饰，并且该注解的作用在父类上，那么子类有持有该注解。如果注解没有被该元注解修饰，则子类不持有父类的注解。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>在Java开发者，JDK自带了一些注解，在第三方框架Spring  带了大量的注解，这些注解称为第三方注解。在很多实际开发过程中，我们需要定义自己的注解。那么现在以案例的方式来讲解自定义注解。</p>
<p>在注解中，需要使用四种元注解来声明注解的作用范围、生命周期、继承，是否生成文档等。另外在注解中也可以有自己的成员变量，如果一个注解没有成员变量则称为标记注解。注解的成员变量，只支持原始类型、Class、Enumeration、Annoation。</p>
<p>现在定义一个@Writer注解，该注解被Retention、Documented、Inherited、Target修饰，表明该注解的作用范围为类、接口和方法，生命周期为运行时、该注解生成文档，并且子类可继承该注解。该注解有2个成员变量，一个为name一个为 age,代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@Target(&#123;ElementType.TYPE,ElementType.METHOD&#125;)</span><br><span class="line">public @interface Writer &#123;</span><br><span class="line"></span><br><span class="line">    String name();</span><br><span class="line"></span><br><span class="line">    int age();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>那么有了该注解，怎么用呢？</p>
<p>该注解的作用范围为类、方法，写一个WriterTest，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Writer(name &#x3D; &quot;forezp&quot;, age &#x3D; 12)</span><br><span class="line">public class WriterTest &#123;</span><br><span class="line"></span><br><span class="line">    @Writer(name &#x3D; &quot;miya&quot;, age &#x3D; 10)</span><br><span class="line">    public void writeBlog() &#123;</span><br><span class="line">        System.out.println(&quot;writing blog&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>该类有了这个注解有何用？</p>
<p>一般来说，用该类修饰的类，需要通过反射来做一下逻辑的开发的工作，可广泛用于AOP、程序的配置等。现在写一个方法通过反射来解析该注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws ClassNotFoundException &#123;</span><br><span class="line">      Class c &#x3D; Class.forName(&quot;com.forezp.annotation.WriterTest&quot;);</span><br><span class="line">      if (c.isAnnotationPresent(Writer.class)) &#123;</span><br><span class="line">          Writer w &#x3D; (Writer) c.getAnnotation(Writer.class);</span><br><span class="line">          System.out.println(&quot;name:&quot; + w.name() + &quot;   age:&quot; + w.age());</span><br><span class="line">      &#125;</span><br><span class="line">      Method[] methods &#x3D; c.getMethods();</span><br><span class="line">      for (Method method : methods) &#123;</span><br><span class="line">          if (method.isAnnotationPresent(Writer.class)) &#123;</span><br><span class="line">              Writer w &#x3D; method.getAnnotation(Writer.class);</span><br><span class="line">              System.out.println(&quot;name:&quot; + w.name() + &quot;   age:&quot; + w.age());</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这些代码基本为反射的内容，因为反射在另一篇文章已经详细讲述过，不再重复，运行该Main方法,控制台打印出如下内容：</p>
<blockquote>
<p>name:forezp   age:12</p>
<p>name:miya   age:10</p>
</blockquote>
<h2 id="案例实战"><a href="#案例实战" class="headerlink" title="案例实战"></a>案例实战</h2><p>有了上述的讲解，你可能对注解有所了解，但是对注解的具体应用并不是很深刻。现在以一个案例来详细讲述。</p>
<p>大家都对ORM框架Mybitis都非常的熟悉，在这个框架中用了大量的注解。现在模仿这个框架，通过自定义注解，来解析sql 的查询语句。实现过程大概如下：</p>
<ul>
<li>定义@Table @Colum注解</li>
<li>定义一个实体User，定义一些基本的字段，并用注解修饰</li>
<li>用User类new对象，给对象的某些字段赋值</li>
<li>通过反射和注解来生成sql 的查询语句</li>
</ul>
<p>首先定义个一个Table注解，它的作用范围为类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface Table &#123;</span><br><span class="line">    String value() default &quot;&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义一个Column注解，作用范围为字段，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Target(ElementType.FIELD)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">public @interface Column &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义一个User类，在该类的加上@Table注解，在具体的字段上 @Column注解，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Table(&quot;user&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @Column(&quot;id&quot;)</span><br><span class="line">    private int id;</span><br><span class="line">    @Column(&quot;name&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @Column(&quot;age&quot;)</span><br><span class="line">    private int age;</span><br><span class="line">    @Column(&quot;address&quot;)</span><br><span class="line">    private String address;</span><br><span class="line">    ..&#x2F;&#x2F;省略getter setter</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>写一个生成sql语句的类，它是通过反射来获取表名、字段名，加上判断实体对象的字段值来生成 查询的 sql 语句的。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GenUserSql &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException &#123;</span><br><span class="line">        User u1 &#x3D; new User();</span><br><span class="line">        User u2 &#x3D; new User();</span><br><span class="line">        u1.setId(1);</span><br><span class="line">        u2.setName(&quot;forezp&quot;);</span><br><span class="line">        genSql(u2);</span><br><span class="line">        genSql(u1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void genSql(User user) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;</span><br><span class="line">        Class c &#x3D; user.getClass();</span><br><span class="line">        StringBuilder stringBuilder &#x3D; new StringBuilder();</span><br><span class="line">        stringBuilder.append(&quot;select * from &quot;);</span><br><span class="line">        if (c.isAnnotationPresent(Table.class)) &#123;</span><br><span class="line">            Table table &#x3D; (Table) c.getAnnotation(Table.class);</span><br><span class="line">            String tableName &#x3D; table.value();</span><br><span class="line">            stringBuilder.append(tableName).append(&quot; where 1&#x3D;1 and &quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        Field[] fields &#x3D; c.getDeclaredFields();</span><br><span class="line">        for (Field field : fields) &#123;</span><br><span class="line">            String columnName;</span><br><span class="line">            if (field.isAnnotationPresent(Column.class)) &#123;</span><br><span class="line">                Column column &#x3D; field.getAnnotation(Column.class);</span><br><span class="line">                columnName &#x3D; column.value();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            String fieldName &#x3D; field.getName();</span><br><span class="line">            String getMethodName &#x3D; &quot;get&quot; + fieldName.substring(0, 1).toUpperCase() + fieldName.substring(1);</span><br><span class="line">                       Method method &#x3D; c.getMethod(getMethodName);</span><br><span class="line">            Object fieldValue &#x3D; method.invoke(user);</span><br><span class="line">            if (fieldValue &#x3D;&#x3D; null || ((fieldValue instanceof Integer) &amp;&amp; (Integer) fieldValue &#x3D;&#x3D; 0)) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if (fieldValue instanceof Integer) &#123;</span><br><span class="line">                stringBuilder.append(columnName + &quot;&#x3D;&quot; + fieldValue);</span><br><span class="line">            &#125;</span><br><span class="line">            if (fieldValue instanceof String) &#123;</span><br><span class="line">                stringBuilder.append(columnName + &quot;&#x3D;&quot; + &quot;&#39;&quot; + fieldValue + &quot;&#39;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(stringBuilder.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行程序，控制台打印如下：</p>
<blockquote>
<p>select * from user where 1=1 and name=’forezp’</p>
</blockquote>
<p>select * from user where 1=1 and id=1</p>
<blockquote>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html">http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html</a></p>
<p>慕课网视频</p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/java-study">https://github.com/forezp/java-study</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何快速玩转swagger</title>
    <url>/2020/11/28/java-2020-11-28-%E7%8E%A9%E8%BD%ACswagger/</url>
    <content><![CDATA[<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/%E5%9B%BE%E6%80%AA%E5%85%BD_d7ba37f67b9d5621a717ccfb7d239a8a_55997.png" style="zoom:90%;" />

<p>Spring Boot 框架是目前非常流行的微服务框架，我们很多情况下使用它来提供 Rest API。而对于 Rest API 来说很重要的一部分内容就是文档，Swagger 为我们提供了一套通过代码和注解自动生成文档的方法，这一点对于保证 API 文档的及时性将有很大的帮助。</p>
<span id="more"></span>

<p>本文将使用 Swagger 2 规范的 Springfox 实现来了展示如何在 Spring Boot 项目中使用 Swagger，主要包含了如何使用 Swagger 自动生成文档、使用 Swagger 文档以及 Swagger 相关的一些高级配置和注解。</p>
<h3 id="Swagger-简介"><a href="#Swagger-简介" class="headerlink" title="Swagger 简介"></a>Swagger 简介</h3><blockquote>
<p>Swagger 是一套基于 OpenAPI 规范构建的开源工具，可以帮助我们设计、构建、记录以及使用 Rest API。Swagger 主要包含了以下三个部分：</p>
</blockquote>
<ul>
<li><p>Swagger Editor ：基于浏览器的编辑器，我们可以使用它编写我们 OpenAPI 规范。</p>
</li>
<li><p>Swagger UI：它会将我们编写的 OpenAPI 规范呈现为交互式的 API 文档，后文我将使用浏览器来查看并且操作我们的 Rest API。</p>
</li>
<li><p>Swagger Codegen：它可以通过为 OpenAPI（以前称为 Swagger）规范定义的任何 API 生成服务器存根和客户端 SDK 来简化构建过程。</p>
</li>
</ul>
<h3 id="为什么要使用-Swagger"><a href="#为什么要使用-Swagger" class="headerlink" title="为什么要使用 Swagger"></a>为什么要使用 Swagger</h3><p>当下很多公司都采取前后端分离的开发模式，前端和后端的工作由不同的工程师完成。在这种开发模式下，维持一份及时更新且完整的 Rest API 文档将会极大的提高我们的工作效率。传统意义上的文档都是后端开发人员手动编写的，相信大家也都知道这种方式很难保证文档的及时性，这种文档久而久之也就会失去其参考意义，反而还会加大我们的沟通成本。而 Swagger 给我们提供了一个全新的维护 API 文档的方式，下面我们就来了解一下它的优点：</p>
<ul>
<li>代码变，文档变。只需要少量的注解，Swagger 就可以根据代码自动生成 API 文档，很好的保证了文档的时效性。<br>跨语言性，支持 40 多种语言。</li>
<li>Swagger UI 呈现出来的是一份可交互式的 API 文档，我们可以直接在文档页面尝试 API 的调用，省去了准备复杂的调用参数的过程。</li>
<li>还可以将文档规范导入相关的工具（例如 SoapUI）, 这些工具将会为我们自动地创建自动化测试。</li>
</ul>
<p>以上这些优点足以说明我们为什么要使用 Swagger 了，您是否已经对 Swagger 产生了浓厚的兴趣了呢？下面我们就将一步一步地在 Spring Boot 项目中集成和使用 Swagger，让我们从准备一个 Spring Boot 的 Web 项目开始吧。</p>
<h3 id="准备-Spring-Boot-Web-项目"><a href="#准备-Spring-Boot-Web-项目" class="headerlink" title="准备 Spring Boot Web 项目"></a>准备 Spring Boot Web 项目</h3><p>在这一步我们将准备一个基础的 Spring Boot 的 Web 项目，并且提供后面所需要的所有 API。</p>
<h3 id="创建一个空的-Spring-Boot-项目"><a href="#创建一个空的-Spring-Boot-项目" class="headerlink" title="创建一个空的 Spring Boot 项目"></a>创建一个空的 Spring Boot 项目</h3><p>您可以通过 Spring Initializr 页面 生成一个空的 Spring Boot 项目，当然也可以下载 springboot-pom.xml 文件，然后使用 Maven 构建一个 Spring Boot 项目。项目创建完成后，为了方便后面代码的编写您可以将其导入到您喜欢的 IDE 中，我这里选择了 Intelli IDEA 打开。</p>
<h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>由于创建的是一个 Web 项目，所以我们需要依赖 Spring Boot 的 Web 组件，只需要在 pom.xml 增加如下内容即可：</p>
<h4 id="清单-1-添加-Web-依赖"><a href="#清单-1-添加-Web-依赖" class="headerlink" title="清单 1. 添加 Web 依赖"></a>清单 1. 添加 Web 依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>


<h4 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h4><ul>
<li>首先我们创建三个包：cn.smalltech.swagger.controller、cn.smalltech.swagger.testcontroller 以及 cn.smalltech.swagger.model。</li>
<li>在 controller 包下新建 UserController.java 类，在 testcontroller 包下新建 TestController.java 类，在 model 包下新建 User.java 类。</li>
<li>UserController 提供用户的增、删、改、查四个接口，TestContrller 提供一个测试接口，这里粘上 UserController.java 的代码，其余代码可以查看源码 。</li>
</ul>
<h4 id="清单-2-UserController-java-代码"><a href="#清单-2-UserController-java-代码" class="headerlink" title="清单 2. UserController.java 代码"></a>清单 2. UserController.java 代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;user&quot;)</span><br><span class="line">public class UserController &#123;</span><br><span class="line">    @PostMapping(&quot;&#x2F;add&quot;)</span><br><span class="line">    public boolean addUser(@RequestBody User user) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    @GetMapping(&quot;&#x2F;find&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public User findById(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return new User();</span><br><span class="line">    &#125;</span><br><span class="line">    @PutMapping(&quot;&#x2F;update&quot;)</span><br><span class="line">    public boolean update(@RequestBody User user) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    @DeleteMapping(&quot;&#x2F;delete&#x2F;&#123;id&#125;&quot;)</span><br><span class="line">    public boolean delete(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="集成-Swagger2"><a href="#集成-Swagger2" class="headerlink" title="集成 Swagger2"></a>集成 Swagger2</h3><p>经过上面的步骤，我们已经拥有了五个接口，分别是:</p>
<ul>
<li>/user/add：新增用户。</li>
<li>/user/find/{id}：根据 id 查询用户。</li>
<li>/user/update：更新用户。</li>
<li>/user/delete/{id}：根据 id 删除用户。</li>
<li>/test/test：测试接口。<br>下面我们将通过集成 Swagger2，然后为这 5 个 Rest API 自动生成接口文档。</li>
</ul>
<h3 id="添加依赖-1"><a href="#添加依赖-1" class="headerlink" title="添加依赖"></a>添加依赖</h3><p>首先要做的自然是添加 Swagger2 所需要的依赖包：</p>
<h4 id="清单-3-添加-Swagger-依赖"><a href="#清单-3-添加-Swagger-依赖" class="headerlink" title="清单 3. 添加 Swagger 依赖"></a>清单 3. 添加 Swagger 依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>


<h3 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h3><p>Springfox 提供了一个 Docket 对象，让我们可以灵活的配置 Swagger 的各项属性。下面我们新建一个 cn.itweknow.sbswagger.conf.SwaggerConfig.java 类，并增加如下内容:</p>
<h4 id="清单-4-Swagger-Java-配置"><a href="#清单-4-Swagger-Java-配置" class="headerlink" title="清单 4. Swagger Java 配置"></a>清单 4. Swagger Java 配置</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket api() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.any())</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意: @Configuration 是告诉 Spring Boot 需要加载这个配置类， @EnableSwagger2 是启用 Swagger2，如果没加的话自然而然也就看不到后面的验证效果了。</p>
<p>验证<br>至此，我们已经成功的在 Spring Boot 项目中集成了 Swagger2，启动项目后，我们可以通过在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:8080/v2/api-docs">http://localhost:8080/v2/api-docs</a> 来验证，您会发现返回的结果是一段 JSON 串，可读性非常差。幸运的是 Swagger2 为我们提供了可视化的交互界面 SwaggerUI，下面我们就一起来试试吧。</p>
<p>集成 Swagger UI<br>添加依赖<br>和之前一样，集成的第一步就是添加相关依赖，在 pom.xml 中添加如下内容即可：</p>
<p>清单 5. 添加 Swagger UI 依赖</p>
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.9.2</version>
</dependency>


<h3 id="访问验证"><a href="#访问验证" class="headerlink" title="访问验证"></a>访问验证</h3><p>其实就只需要添加一下依赖就可以了，我们重新启动一下项目，然后在浏览器中访问 <a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> 就可以看到如下的效果了:</p>
<p>图 1. Swagger UI</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl44nler8oj31d20u0k0p.jpg"></p>
<p>可以看到虽然可读性好了一些，但对接口的表述还不是那么的清楚，接下来我们就通过一些高级配置，让这份文档变的更加的易读。</p>
<h3 id="高级配置"><a href="#高级配置" class="headerlink" title="高级配置"></a>高级配置</h3><p>文档相关描述配置</p>
<ul>
<li>1.通过在控制器类上增加 @Api 注解，可以给控制器增加描述和标签信息。</li>
</ul>
<h4 id="清单-6-给-Controller-添加描述信息"><a href="#清单-6-给-Controller-添加描述信息" class="headerlink" title="清单 6. 给 Controller 添加描述信息"></a>清单 6. 给 Controller 添加描述信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Api(tags &#x3D; &quot;用户相关接口&quot;, description &#x3D; &quot;提供用户相关的 Rest API&quot;)</span><br><span class="line">public class UserController</span><br></pre></td></tr></table></figure>

<ul>
<li>2.通过在接口方法上增加 @ApiOperation 注解来展开对接口的描述，当然这个注解还可以指定很多内容，我们在下面的相关注解说明章节中详细解释。</li>
</ul>
<h4 id="清单-7-给接口添加描述信息"><a href="#清单-7-给接口添加描述信息" class="headerlink" title="清单 7. 给接口添加描述信息"></a>清单 7. 给接口添加描述信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiOperation(&quot;新增用户接口&quot;)</span><br><span class="line">@PostMapping(&quot;&#x2F;add&quot;)</span><br><span class="line">public boolean addUser(@RequestBody User user) &#123;</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>3.实体描述，我们可以通过 @ApiModel 和 @ApiModelProperty 注解来对我们 API 中所涉及到的对象做描述。</li>
</ul>
<h4 id="清单-8-给实体类添加描述信息"><a href="#清单-8-给实体类添加描述信息" class="headerlink" title="清单 8. 给实体类添加描述信息"></a>清单 8. 给实体类添加描述信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiModel(&quot;用户实体&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    @ApiModelProperty(&quot;用户 id&quot;)</span><br><span class="line">private int id;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>4.文档信息配置，Swagger 还支持设置一些文档的版本号、联系人邮箱、网站、版权、开源协议等等信息，但与上面几条不同的是这些信息不是通过注解配置，而是通过创建一个 ApiInfo 对象，并且使用 Docket.appInfo() 方法来设置，我们在 SwaggerConfig.java 类中新增如下内容即可。</li>
</ul>
<h4 id="清单-9-配置文档信息"><a href="#清单-9-配置文档信息" class="headerlink" title="清单 9. 配置文档信息"></a>清单 9. 配置文档信息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public Docket api() &#123;</span><br><span class="line">return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">.select()</span><br><span class="line">            .apis(RequestHandlerSelectors.any())</span><br><span class="line">            .paths(PathSelectors.any())</span><br><span class="line">            .build()</span><br><span class="line">            .apiInfo(apiInfo());</span><br><span class="line">&#125;</span><br><span class="line">private ApiInfo apiInfo() &#123;</span><br><span class="line">return new ApiInfo(</span><br><span class="line">            &quot;Spring Boot 项目集成 Swagger 实例文档&quot;,</span><br><span class="line">            &quot;我的博客网站：https:&#x2F;&#x2F;smalltechnologyjun.com，欢迎大家访问。&quot;,</span><br><span class="line">            &quot;API V1.0&quot;,</span><br><span class="line">            &quot;Terms of service&quot;,</span><br><span class="line">            new Contact(&quot;名字想好没&quot;, &quot;https:&#x2F;&#x2F;smalltechnologyjun.com&quot;, &quot;xxxxx@gmail.com&quot;),</span><br><span class="line">                &quot;Apache&quot;, &quot;http:&#x2F;&#x2F;www.apache.org&#x2F;&quot;, Collections.emptyList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>经过上面的步骤，我们的文档将会变成下图的样子，现在看起来就清楚很多了。</p>
<p>图 2. 补全信息后的 Swagger 文档界面</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl44ocdbwaj31410ki75x.jpg"></p>
<h3 id="接口过滤"><a href="#接口过滤" class="headerlink" title="接口过滤"></a>接口过滤</h3><p>有些时候我们并不是希望所有的 Rest API 都呈现在文档上，这种情况下 Swagger2 提供给我们了两种方式配置，一种是基于 @ApiIgnore 注解，另一种是在 Docket 上增加筛选。</p>
<ol>
<li>@ApiIgnore 注解。</li>
</ol>
<p>如果想在文档中屏蔽掉删除用户的接口（user/delete），那么只需要在删除用户的方法上加上 @ApiIgnore 即可。</p>
<h4 id="清单-10-ApiIgnore-使用实例"><a href="#清单-10-ApiIgnore-使用实例" class="headerlink" title="清单 10. @ApiIgnore 使用实例"></a>清单 10. @ApiIgnore 使用实例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiIgnore</span><br><span class="line">public boolean delete(@PathVariable(&quot;id&quot;) int id)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 Docket 上增加筛选。Docket 类提供了 apis() 和 paths() 两个方法来帮助我们在不同级别上过滤接口：</li>
</ol>
<ul>
<li>apis() ：这种方式我们可以通过指定包名的方式，让 Swagger 只去某些包下面扫描。</li>
<li>paths() ：这种方式可以通过筛选 API 的 url 来进行过滤。<br>在集成 Swagger2 的章节中我们这两个方法指定的都是扫描所有，没有指定任何过滤条件。如果我们在我们修改之前定义的 Docket 对象的 apis() 方法和 paths() 方法为下面的内容，那么接口文档将只会展示 /user/add 和 /user/find/{id} 两个接口。</li>
</ul>
<h4 id="清单-11-使用-Docket-配置接口筛选"><a href="#清单-11-使用-Docket-配置接口筛选" class="headerlink" title="清单 11. 使用 Docket 配置接口筛选"></a>清单 11. 使用 Docket 配置接口筛选</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.apis(RequestHandlerSelectors.basePackage(&quot;cn.itweknow.sbswagger.controller&quot;))</span><br><span class="line">.paths(Predicates.or(PathSelectors.ant(&quot;&#x2F;user&#x2F;add&quot;),</span><br><span class="line">        PathSelectors.ant(&quot;&#x2F;user&#x2F;find&#x2F;*&quot;)))</span><br></pre></td></tr></table></figure>

<p>图 3. 经过筛选过后的 Swagger 文档界面</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl44oubk55j313y07jgls.jpg"></p>
<h3 id="自定义响应消息"><a href="#自定义响应消息" class="headerlink" title="自定义响应消息"></a>自定义响应消息</h3><p>Swagger 允许我们通过 Docket 的 globalResponseMessage() 方法全局覆盖 HTTP 方法的响应消息，但是首先我们得通过 Docket 的 useDefaultResponseMessages 方法告诉 Swagger 不使用默认的 HTTP 响应消息，假设我们现在需要覆盖所有 GET 方法的 500 和 403 错误的响应消息，我们只需要在 SwaggerConfig.java 类中的 Docket Bean 下添加如下内容：</p>
<h4 id="清单-12-自定义响应消息"><a href="#清单-12-自定义响应消息" class="headerlink" title="清单 12. 自定义响应消息"></a>清单 12. 自定义响应消息</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.useDefaultResponseMessages(false)</span><br><span class="line">.globalResponseMessage(RequestMethod.GET, newArrayList(</span><br><span class="line">new ResponseMessageBuilder()</span><br><span class="line">              .code(500)</span><br><span class="line">              .message(&quot;服务器发生异常&quot;)</span><br><span class="line">              .responseModel(new ModelRef(&quot;Error&quot;))</span><br><span class="line">              .build(),</span><br><span class="line">       new ResponseMessageBuilder()</span><br><span class="line">              .code(403)</span><br><span class="line">              .message(&quot;资源不可用&quot;)</span><br><span class="line">              .build()</span><br><span class="line">));</span><br></pre></td></tr></table></figure>

<p>添加如上面的代码后，如下图所示，您会发现在 SwaggerUI 页面展示的所有 GET 类型请求的 403 以及 500 错误的响应消息都变成了我们自定义的内容。</p>
<p>图 4. 自定义响应消息</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl44pbhwovj312r02vjr7.jpg"></p>
<h3 id="Swagger-UI-的使用"><a href="#Swagger-UI-的使用" class="headerlink" title="Swagger UI 的使用"></a>Swagger UI 的使用</h3><h4 id="接口查看"><a href="#接口查看" class="headerlink" title="接口查看"></a>接口查看</h4><p>SwaggerUI 会以列表的方式展示所有扫描到的接口，初始状态是收缩的，我们只需要点击展开就好，而且会在左边标识接口的请求方式（GET、POST、PUT、DELETE 等等）。</p>
<p>图 5. Swagger 接口列表界面</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl44pn42gij315205ojrk.jpg"></p>
<h4 id="接口调用"><a href="#接口调用" class="headerlink" title="接口调用"></a>接口调用</h4><p>如下图所示，点击接口展开后页面右上角的 Try it out 按钮后，页面会变成如图所示：</p>
<p>图 6. 接口详情界面</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl44pw3x2yj31400gw0tn.jpg"></p>
<p>SwaggerUI 会给我们自动填充请求参数的数据结构，我们需要做的只是点击 Execute 即可发起调用</p>
<p>图 7. 接口调用界面</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl44q5dtaqj314g0l9q3s.jpg"></p>
<h3 id="Model"><a href="#Model" class="headerlink" title="Model"></a>Model</h3><p>如下图所示，SwaggerUI 会通过我们在实体上使用的 @ApiModel 注解以及 @ApiModelProperty 注解来自动补充实体以及其属性的描述和备注。</p>
<p>图 8. 实体界面</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gl44qk33alj314g08ijri.jpg"></p>
<h3 id="相关注解说明"><a href="#相关注解说明" class="headerlink" title="相关注解说明"></a>相关注解说明</h3><p>在本文中我将给出一些 Swagger 中常用的注解以及其常用的属性，并对其一一解释，方便您查看。</p>
<h3 id="Controller-相关注解"><a href="#Controller-相关注解" class="headerlink" title="Controller 相关注解"></a>Controller 相关注解</h3><p>@Api: 可设置对控制器的描述。</p>
<h4 id="表-1-Api-主要属性"><a href="#表-1-Api-主要属性" class="headerlink" title="表 1. @Api 主要属性"></a>表 1. @Api 主要属性</h4><table>
<thead>
<tr>
<th>注解属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>tags</td>
<td>String[]</td>
<td>控制器标签。</td>
</tr>
<tr>
<td>description</td>
<td>String</td>
<td>控制器描述（该字段被申明为过期）</td>
</tr>
</tbody></table>
<h4 id="表-2-ApiOperation-主要属性"><a href="#表-2-ApiOperation-主要属性" class="headerlink" title="表 2. @ApiOperation 主要属性"></a>表 2. @ApiOperation 主要属性</h4><table>
<thead>
<tr>
<th>注解属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>String</td>
<td>接口说明</td>
</tr>
<tr>
<td>notes</td>
<td>String</td>
<td>接口发布说明。</td>
</tr>
<tr>
<td>tags</td>
<td>Stirng[]</td>
<td>标签。</td>
</tr>
<tr>
<td>response</td>
<td>Class&lt;?&gt;</td>
<td>接口返回类型。</td>
</tr>
<tr>
<td>httpMethod</td>
<td>String</td>
<td>接口请求方式。</td>
</tr>
</tbody></table>
<p>@ApiIgnore: Swagger 文档不会显示拥有该注解的接口。 @ApiImplicitParams: 用于描述接口的非对象参数集。 @ApiImplicitParam: 用于描述接口的非对象参数，一般与 @ApiImplicitParams 组合使用。</p>
<h4 id="表-3-ApiModelProperty-主要属性"><a href="#表-3-ApiModelProperty-主要属性" class="headerlink" title="表 3. @ApiModelProperty 主要属性"></a>表 3. @ApiModelProperty 主要属性</h4><table>
<thead>
<tr>
<th>注解属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>String</td>
<td>字段说明。</td>
</tr>
<tr>
<td>name</td>
<td>String</td>
<td>重写字段名称。</td>
</tr>
<tr>
<td>dataType</td>
<td>Stirng</td>
<td>重写字段类型。</td>
</tr>
<tr>
<td>required</td>
<td>boolean</td>
<td>是否必填。</td>
</tr>
<tr>
<td>example</td>
<td>Stirng</td>
<td>举例说明。</td>
</tr>
<tr>
<td>hidden</td>
<td>boolean</td>
<td>是否在文档中隐藏该字段。</td>
</tr>
<tr>
<td>allowEmptyValue</td>
<td>boolean</td>
<td>是否允许为空。</td>
</tr>
<tr>
<td>allowableValues</td>
<td>String</td>
<td>该字段允许的值，当我们 API 的某个参数为枚举类型时，使用这个属性就可以清楚地告诉 API 使用者该参数所能允许传入的值。</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存结构</title>
    <url>/2020/10/12/jvm-2020-10-09-jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>1.7和1.8之间JVM内存结构以及它们的差异</p>
<span id="more"></span>

<h4 id="JVM-内存分配"><a href="#JVM-内存分配" class="headerlink" title="JVM 内存分配"></a>JVM 内存分配</h4><p>根据 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">JVM 规范</a>，JVM 内存分为虚拟机栈、堆、方法区、程序计数器、本地方法 stack5个部分。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.programmersought.com/article/74164482693/">https://www.programmersought.com/article/74164482693/</a></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjk8684wiqj30w70lh47l.jpg"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>特征</th>
<th>作用</th>
<th>配置参数</th>
<th>异常</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>占用内存小，线程私有，生命周期与线程相同</td>
<td>字节码行号指示器</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>线程私有，生命周期与线程相同，使用连续的内存空间</td>
<td>Java方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息</td>
<td>-Xss</td>
<td>StackOverflowError/OutOfMemoryError</td>
</tr>
<tr>
<td>堆</td>
<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>
<td>保存对象实例，所有对象实例（包括数组）都要在堆上分配</td>
<td>-Xms -Xsx -Xmn</td>
<td>OutOfMemoryError</td>
</tr>
<tr>
<td>方法区</td>
<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>
<td>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</td>
<td>-XX:PermSize:16M -XX:MaxPermSize64M / -XX:MetaspaceSize=16M -XX:MaxMetaspaceSize=64M</td>
<td>OutOfMemoryError</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>线程私有</td>
<td>为虚拟机使用到的 Native 方法服务</td>
<td>无</td>
<td>StackOverflowError/OutOfMemoryError</td>
</tr>
</tbody></table>
<h4 id="1-7和1-8之间JVM内存结构以及它们的差异"><a href="#1-7和1-8之间JVM内存结构以及它们的差异" class="headerlink" title="1.7和1.8之间JVM内存结构以及它们的差异"></a>1.7和1.8之间JVM内存结构以及它们的差异</h4><p>事实上，移除永久代的工作是从 JDK 1.7开始的。在 JDK 1.7中，存储在永久生成中的部分数据已经转移到 Java 堆或本机堆。</p>
<p>然而，JDK 1.7中的永久代仍然存在，并且没有被完全删除。</p>
<p>例如，将符号引用转移到本机堆; 将类的文本变量(内嵌字符串)和静态变量转移到 Java 堆。</p>
<p>JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。</p>
<p>不过元空间与永久代之间最大的区别在于：元数据区并不在虚拟机中，而是使用本地内存。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjk6ksulhlj31920mctca.jpg"></p>
<blockquote>
<p>方法区是java虚拟机规范中定义的一种概念上的区域，不同的厂商可以对虚拟机进行不同的实现。我们通常使用的Java SE都是由Sun JDK和OpenJDK所提供，这也是应用最广泛的版本。而该版本使用的VM就是HotSpot VM。通常情况下，我们所讲的java虚拟机指的就是HotSpot的版本</p>
</blockquote>
<ul>
<li><p>PermGen(永久代)</p>
<p>Java7及以前版本的Hotspot中方法区位于永久代中。同时，永久代和堆是相互隔离的，但它们使用的物理内存是连续的，永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。</p>
<p>Java7中永久代中存储的部分数据已经开始转移到Java Heap或Native Memory中了。比如，符号引用(Symbols)转移到了Native Memory；字符串常量池(interned strings)转移到了Java Heap；类的静态变量(class statics)转移到了Java Heap。</p>
<p>绝大部分Java程序员应该都见过java.lang.OutOfMemoryError: PremGen space异常。这里的PermGen space其实指的就是方法区。不过方法区和PermGen space又有着本质的区别。前者是JVM的规范，而后者则是JVM规范的一种实现，并且只有HotSpot才有PermGen space，而对于其他类型的虚拟机，如JRockit(Oracle)、J9(IBM)并没有PermGen space。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。并且JDK 1.8中永久代的参数PermSize和MaxPermSize已经失效。</p>
</li>
<li><p>Metaspace(元空间)</p>
<p>对于Java8，HotSpot取消了永久代，那么是不是就没有方法区了呢？当然不是，方法区只是一个规范，只不过它的实现变了。</p>
<p>在Java8中，元空间(Metaspace)登上舞台，方法区存在于元空间(Metaspace)。同时，元空间不再与堆连续，而且是存在于本地内存（Native memory）。</p>
<p>JDK1.7后对JVM架构进行了改造，将类元数据放到本地内存中，另外，将字符串常量池和静态变量放到Java堆里。HotSpot VM将会为类的元数据明确分配和释放本地内存。在这种架构下，类元信息就突破了原来 -XX:MaxPermSize的限制，现在可以使用更多的本地内存。这样就从一定程度上解决了原来在运行时生成大量类造成经常Full GC问题，如运行时使用反射、代理等。所以升级以后Java堆空间可能会增加。</p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间的最大区别在于：元空间并不在虚拟机中，而是使用本地内存。本地内存（Native memory），也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。默认情况下元空间是可以无限使用本地内存的，但为了不让它如此膨胀，JVM同样提供了参数来限制它使用的使用。</p>
<p>-XX:MetaspaceSize，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。</p>
<p>-XX：MaxMetaspaceSize，可以为class metadata分配的最大空间。默认是没有限制的。</p>
<p>-XX：MinMetaspaceFreeRatio,在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集。</p>
<p>-XX:MaxMetaspaceFreeRatio,在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集。</p>
</li>
<li><p>对于方法区，Java8之后的变化</p>
<p>移除了永久代（PermGen），替换为元空间（Metaspace）</p>
<p>永久代中的class metadata（类元信息）转移到了native memory（本地内存，而不是虚拟机）</p>
<p>永久代中的interned Strings（字符串常量池） 和 class static variables（类静态变量）转移到了Java heap</p>
<p>永久代参数（PermSize MaxPermSize）-&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize</p>
</li>
<li><p>Java8为什么要将永久代替换成Metaspace？</p>
<p>字符串存在永久代中，容易出现性能问题和内存溢出。</p>
<p>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困 难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p>
<p>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p>
</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程：JMM和volatile关键字</title>
    <url>/2017/11/12/java-concurrent-2017-08-25-jmm-volatile/</url>
    <content><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>随着计算机的CPU的飞速发展，CPU的运算能力已经远远超出了从主内存（运行内存）中读取的数据的能力，为了解决这个问题，CPU厂商设计出了CPU内置高速缓存区。高速缓存区的加入使得CPU在运算的过程中直接从高速缓存区读取数据，在一定程度上解决了性能的问题。但也引起了另外一个问题，在CPU多核的情况下，每个处理器都有自己的缓存区，数据如何保持一致性。为了保证多核处理器的数据一致性，引入多处理器的数据一致性的协议，这些协议包括MOSI、Synapse、Firely、DragonProtocol等。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-98d10d5cb7acf7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JMM内存模型.png"></p>
<span id="more"></span>

<p>JVM在执行多线程任务时，共享数据保存在主内存中，每一个线程（执行再不同的处理器）有自己的高速缓存，线程对共享数据进行修改的时候，首先是从主内存拷贝到线程的高速缓存，修改之后，然后从高速缓存再拷贝到主内存。当有多个线程执行这样的操作的时候，会导致共享数据出现不可预期的错误。</p>
<p>举个例子：</p>
<blockquote>
<p>i++;//操作</p>
</blockquote>
<p>这个i++操作，线程首先从主内存读取i的值，比如i=0，然后复制到自己的高速缓存区，进行i++操作，最后将操作后的结果从高速缓存区复制到主内存中。如果是两个线程通过操作i++,预期的结果是2。这时结果真的为2吗？答案是否定的。线程1读取主内存的i=0,复制到自己的高速缓存区，这时线程2也读取i=0,复制到自己的高速缓存区，进行i++操作，怎么最终得到的结构为1，而不是2。</p>
<p>为了解决缓存不一致的问题，有两种解决方案：</p>
<ul>
<li>在总线加锁，即同时只有一个线程能执行i++操作（包括读取、修改等）。</li>
<li>通过缓存一致性协议</li>
</ul>
<p>第一种方式就没什么好说的，就是同步代码块或者同步方法。也就只能一个线程能进行对共享数据的读取和修改，其他线程处于线程阻塞状态。<br>第二种方式就是缓存一致性协议，比如Intel 的MESI协议，它的核心思想就是当某个处理器写变量的数据，如果其他处理器也存在这个变量，会发出信号量通知该处理器高速缓存的数据设置为无效状态。当其他处理需要读取该变量的时候，会让其重新从主内存中读，然后再复制到高速缓存区。</p>
<h2 id="编发编程的概念"><a href="#编发编程的概念" class="headerlink" title="编发编程的概念"></a>编发编程的概念</h2><p>并发编程的有三个概念，包括原子性、可见性、有序性。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指，操作为原子性的，要么成功，要么失败，不存在第三种情况。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s&#x3D;&quot;abc&quot;;</span><br></pre></td></tr></table></figure>

<p>这个复杂操作是原子性的。再比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i&#x3D;0;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure>

<p>i=0这是一个赋值操作，这一步是原子性操作；那么i++是原子性操作吗？当然不是，首先它需要读取i=0，然后需要执行运算，写入i的新值1，它包含了读取和写入两个步骤，所以不是原子性操作。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指共享数据的时候，一个线程修改了数据，其他线程知道数据被修改，会重新读取最新的主存的数据。<br>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i&#x3D;0;&#x2F;&#x2F;主内存</span><br><span class="line"></span><br><span class="line">i++;&#x2F;&#x2F;线程1</span><br><span class="line"></span><br><span class="line">j&#x3D;i;&#x2F;&#x2F;线程2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>线程1修改了i值，但是没有将i值复制到主内存中，线程2读取i的值，并将i的值赋值给j,我们期望j=1,但是由于线程1修改了，没有来得及复制到主内存中，线程2读取了i,并赋值给j，这时j的值为0。<br>也就是线程i值被修改，其他线程并不知道。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>是指代码执行的有序性，因为代码有可能发生指令重排序（Instruction Reorder）。</p>
<p>Java 语言提供了 volatile 和 synchronized 两个关键字来线程代码操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 在单线程中执行代码，无论指令是否重排，最终的执行结果是一致的。</p>
<h2 id="volatile详解"><a href="#volatile详解" class="headerlink" title="volatile详解"></a>volatile详解</h2><h3 id="volatile关键字作用"><a href="#volatile关键字作用" class="headerlink" title="volatile关键字作用"></a>volatile关键字作用</h3><p>被volatile关键字修饰变量，起到了2个作用：</p>
<blockquote>
<p>1.某个线程修改了被volatile关键字修饰变量是，根据数据一致性的协议，通过信号量，更改其他线程的高速缓存中volatile关键字修饰变量状态为无效状态，其他线程如果需要重写读取该变量会再次从主内存中读取，而不是读取自己的高速缓存中的。</p>
<p>2.被volatile关键字修饰变量不会指令重排序。</p>
</blockquote>
<h3 id="volatile能够保证可见性和防止指令重排"><a href="#volatile能够保证可见性和防止指令重排" class="headerlink" title="volatile能够保证可见性和防止指令重排"></a>volatile能够保证可见性和防止指令重排</h3><p>在Java并发编程实战一书中有这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NoVisibility &#123;</span><br><span class="line">    private static boolean ready;</span><br><span class="line">    private static int a;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new ReadThread().start();</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        a &#x3D; 32;</span><br><span class="line">        ready &#x3D; true;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ReadThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述代码中，有可能（概率非常小，但是有这种可能性）永远不会打印a的值，因为线程ReadThread读取了主内存的ready为false,主线程虽然更新了ready，但是ReadThread的高速缓存中并没有更新。<br>另外：</p>
<blockquote>
<p>a = 32;</p>
<p>ready = true;</p>
</blockquote>
<p>这两行代码有可能发生指令重排。也就是可以打印出a的值为0。</p>
<p>如果在变量加上volatile关键字，可以防止上述两种不正常的情况的发生。</p>
<h3 id="volatile不能保证原子性"><a href="#volatile不能保证原子性" class="headerlink" title="volatile不能保证原子性"></a>volatile不能保证原子性</h3><p>首先用一段代码测试下，开起了10个线程，这10个线程共享一个变量inc（被volatile修饰），并在每个线程循环1000次对inc进行inc++操作。我们预期的结果是10000.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class VolatileTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public volatile int inc &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final VolatileTest test &#x3D; new VolatileTest();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 1000; j++)</span><br><span class="line">                    test.increase();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;保证前面的线程都执行完</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多次运行main函数，你会发现结果永远都不会为10000，都是小于10000。可能有这样的疑问，volatile保证了共享数据的可见性，线程1修改了inc变量线程2会重新从主内存中重新读，这样就能保证inc++的正确性了啊，可为什么没有得到我们预期的结果呢？</p>
<p>在之前已经讲述过inc++这样的操作不是一个原子性操作，它分为读、加加、写。一种情况，当线程1读取了inc的值，还没有修改，线程2也读取了，线程1修改完了，通知线程2将线程的缓存的 inc的值无效需要重读，可这时它不需要读取inc ，它仍执行写操作，然后赋值给主线程，这时数据就会出现问题。</p>
<p>所以volatile不能保证原子性 。这时需要用锁来保证,在increase方法加上synchronized，重新运行打印的结果为10000 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public synchronized void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="volatile的使用场景"><a href="#volatile的使用场景" class="headerlink" title="volatile的使用场景"></a>volatile的使用场景</h3><h4 id="状态标记"><a href="#状态标记" class="headerlink" title="状态标记"></a>状态标记</h4><p>volatile最常见的使用场景是状态标记，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private volatile boolean asheep ;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程1</span><br><span class="line"> </span><br><span class="line">while(!asleep)&#123;</span><br><span class="line">    countSheep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程2</span><br><span class="line">asheep&#x3D;true;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="防止指令重排"><a href="#防止指令重排" class="headerlink" title="防止指令重排"></a>防止指令重排</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile boolean inited &#x3D; false;</span><br><span class="line">&#x2F;&#x2F;线程1:</span><br><span class="line">context &#x3D; loadContext();  </span><br><span class="line">inited &#x3D; true;  </span><br><span class="line">&#x2F;&#x2F;上面两行代码如果不用volatile修饰，可能会发生指令重排，导致报错</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Java 并发编程实战》</p>
<p>《深入理解JVM》</p>
<p>海子的博客：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3920373.html">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
]]></content>
      <categories>
        <category>java并发编程</category>
      </categories>
      <tags>
        <tag>java java并发编程 volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程：线程封闭和ThreadLocal详解</title>
    <url>/2017/11/12/java-concurrent-2017-08-27-cjava-threadlocal/</url>
    <content><![CDATA[<h2 id="什么是线程封闭"><a href="#什么是线程封闭" class="headerlink" title="什么是线程封闭"></a>什么是线程封闭</h2><p>![测试](<a target="_blank" rel="noopener" href="http://chris/">http://chris</a> .oss-cn-hangzhou.aliyuncs.com/WechatIMG1.jpeg)<br>当访问共享变量时，往往需要加锁来保证数据同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了。这种技术称为线程封闭。在Java语言中，提供了一些类库和机制来维护线程的封闭性，例如局部变量和ThreadLocal类，本文主要深入讲解如何使用ThreadLocal类来保证线程封闭。</p>
<span id="more"></span>

<h2 id="理解ThreadLocal类"><a href="#理解ThreadLocal类" class="headerlink" title="理解ThreadLocal类"></a>理解ThreadLocal类</h2><p>ThreadLocal类能使线程中的某个值与保存值的对象关联起来，它提供了get、set方法，这些方法为每个使用该变量的线程保存一份独立的副本，因此get总是set当前线程的set最新值。</p>
<p>首先我们来看个例子，这个例子来自于<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3920407.html">http://www.cnblogs.com/dolphin0520/p/3920407.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal &#x3D; new ThreadLocal&lt;Long&gt;();</span><br><span class="line">    ThreadLocal&lt;String&gt; stringLocal &#x3D; new ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void set() &#123;</span><br><span class="line">        longLocal.set(Thread.currentThread().getId());</span><br><span class="line">        stringLocal.set(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getLong() &#123;</span><br><span class="line">        return longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getString() &#123;</span><br><span class="line">        return stringLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Test1 test &#x3D; new Test1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        test.set();</span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread thread1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            test.set();</span><br><span class="line">            System.out.println(test.getLong());</span><br><span class="line">            System.out.println(test.getString());</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行该程序，代码输出的结果为：</p>
<blockquote>
<p>1</p>
<p>main</p>
<p>10</p>
<p>Thread-0</p>
<p>1</p>
<p>main</p>
</blockquote>
<p>从这段代码可以看出在mian线程和thread1线程确实都保存着各自的副本，它们的副本各自不干扰。</p>
<h2 id="ThreadLocal源码解析"><a href="#ThreadLocal源码解析" class="headerlink" title="ThreadLocal源码解析"></a>ThreadLocal源码解析</h2><p>来从源码的角度来解析ThreadLocal这个类，这个类存放在java.lang包，这个类有很多方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-903e2b9e3a60cee5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p>
<p>它内部又个ThreadLocalMap类，主要有set()、get()、setInitialValue 等方法。</p>
<p>首先来看下set方法，获取当前Thread的 map，如果不存在则新建一个并设置值，如果存在设置值，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">        if (map !&#x3D; null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>跟踪createMap，可以发现它根据Thread创建来一个ThreadLocalMap。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">      t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>t.threadLocals为当前线程的一个变量，也就是ThreadLocal的数据都是存放在当前线程的threadLocals变量里面的，由此可见用ThreadLocal存放的数据是线程安全的。因为它对于不同的线程来，使用ThreadLocal的set方法都会根据线程判断该线程是否存在它的threadLocals成员变量，如果没有就建一个，有的话就存下数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap为ThreadLocal的一个内部类，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">       static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">           &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               super(k);</span><br><span class="line">               value &#x3D; v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。</p>
<p>在使用ThreadLocal的get方法之前一定要先set，要不然会报空指针异常。还有一种方式就是在初始化的时候调用initialValue（）方法赋值。改造下之前的例子，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal &#x3D; new ThreadLocal&lt;Long&gt;()&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Long initialValue() &#123;</span><br><span class="line">            return Thread.currentThread().getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ThreadLocal&lt;String&gt; stringLocal &#x3D; new ThreadLocal&lt;String&gt;()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected String initialValue() &#123;</span><br><span class="line">            return Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public long getLong() &#123;</span><br><span class="line">        return longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getString() &#123;</span><br><span class="line">        return stringLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Test2 test &#x3D; new Test2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread thread1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">          </span><br><span class="line">            System.out.println(test.getLong());</span><br><span class="line">            System.out.println(test.getString());</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行该程序，代码输出的结果为：</p>
<blockquote>
<p>1</p>
<p>main</p>
<p>10</p>
<p>Thread-0</p>
<p>1</p>
<p>main</p>
</blockquote>
<h2 id="ThreadLocal常用的使用场景"><a href="#ThreadLocal常用的使用场景" class="headerlink" title="ThreadLocal常用的使用场景"></a>ThreadLocal常用的使用场景</h2><p>通常讲JDBC连接保存在ThreadLocal对象中，每个对象都有属于自己的连接，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">&#x3D; new ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">    public Connection initialValue() &#123;</span><br><span class="line">       return DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">public static Connection getConnection() &#123;</span><br><span class="line">    return connectionHolder.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Java并发编程实战》</p>
<p>《深入理解JVM》</p>
]]></content>
      <categories>
        <category>java并发编程</category>
      </categories>
      <tags>
        <tag>java java并发编程 volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper 安装教程</title>
    <url>/2020/06/29/kafka-2020-06-29-zookeeper-mac%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="brew安装"><a href="#brew安装" class="headerlink" title="brew安装"></a>brew安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install zookeeper</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;homebrew.bintray.com&#x2F;bottles&#x2F;zookeeper-3.4.13.mojave.bottle.tar.gz</span><br><span class="line">&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;akamai.bintray.com&#x2F;d1&#x2F;d1e4e7738cd147dceb3d91b32480c20ac5da27d129905f336ba51c0c01b8a476?__gd</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">&#x3D;&#x3D;&gt; Pouring zookeeper-3.4.13.mojave.bottle.tar.gz</span><br><span class="line">&#x3D;&#x3D;&gt; Caveats</span><br><span class="line">To have launchd start zookeeper now and restart at login:</span><br><span class="line">  brew services start zookeeper</span><br><span class="line">Or, if you don&#39;t want&#x2F;need a background service you can just run:</span><br><span class="line">  zkServer start</span><br><span class="line">&#x3D;&#x3D;&gt; Summary</span><br><span class="line">🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;zookeeper&#x2F;3.4.13: 244 files, 33.4MB</span><br></pre></td></tr></table></figure>
<p>查看zookeeper 信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">brew info zookeeper</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">zookeeper: stable 3.4.13 (bottled), HEAD</span><br><span class="line">Centralized server for distributed coordination of services</span><br><span class="line">https:&#x2F;&#x2F;zookeeper.apache.org&#x2F;</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;zookeeper&#x2F;3.4.13 (244 files, 33.4MB) *</span><br><span class="line">  Poured from bottle on 2020-06-30 at 17:51:47</span><br><span class="line">From: https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-core&#x2F;blob&#x2F;master&#x2F;Formula&#x2F;zookeeper.rb</span><br><span class="line">&#x3D;&#x3D;&gt; Options</span><br><span class="line">--HEAD</span><br><span class="line">	Install HEAD version</span><br><span class="line">&#x3D;&#x3D;&gt; Caveats</span><br><span class="line">To have launchd start zookeeper now and restart at login:</span><br><span class="line">  brew services start zookeeper</span><br><span class="line">Or, if you don&#39;t want&#x2F;need a background service you can just run:</span><br><span class="line">  zkServer start</span><br><span class="line">&#x3D;&#x3D;&gt; Analytics</span><br><span class="line">install: 7,043 (30 days), 21,263 (90 days), 79,252 (365 days)</span><br><span class="line">install_on_request: 2,192 (30 days), 6,831 (90 days), 25,814 (365 days)</span><br><span class="line">build_error: 0 (30 days)</span><br></pre></td></tr></table></figure>
<p>brew nstall 完成之后 对应配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;zookeeper</span><br><span class="line">chengkejundeMacBook-Pro:zookeeper c.kj$ ls</span><br><span class="line">defaults		log4j.properties	zoo.cfg			zoo_sample.cfg</span><br><span class="line">chengkejundeMacBook-Pro:zookeeper c.kj$</span><br></pre></td></tr></table></figure>
<p>修改 zoo.cfg 搭建集群修改这些配置 因为只需要搭建一个伪集群所以没有修改其中参数，感兴趣的可以自己搜索一些教程～</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># The number of ticks that the initial</span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># The number of ticks that can pass between</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just</span><br><span class="line"># example sakes.</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;zookeeper&#x2F;data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the</span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了能够在任意目录启动zookeeper集群，我们需要配置环境变量.<br> <br> ps:你也可以不配，这不是搭建集群的必要操作，只不过如果你不配置环境变量，那么每次启动zookeeper需要到安装文件的 bin 目录下去启动。<br> <br> 配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">chengkejundeMacBook-Pro:data c.kj$ open -e ~&#x2F;.bash_profile</span><br><span class="line">chengkejundeMacBook-Pro:data c.kj$ cat ~&#x2F;.bash_profile</span><br><span class="line">export M3_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;mvn&#x2F;apache-maven-3.3.9</span><br><span class="line">export GRADLE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;gradle&#x2F;5.2.1</span><br><span class="line">export SCALA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;scala&#x2F;2.12.8</span><br><span class="line">export ZK_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;zookeeper&#x2F;3.4.13</span><br><span class="line">export PATH&#x3D;$M3_HOME&#x2F;bin:$PATH:$GRADLE_HOME&#x2F;bin:$SCALA_HOME&#x2F;bin:$ZK_HOME&#x2F;binchengkejundeMacBook-Pro:data c.kj$</span><br><span class="line">chengkejundeMacBook-Pro:data c.kj$</span><br><span class="line">chengkejundeMacBook-Pro:data c.kj$ source ~&#x2F;.bash_profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动命令：<br><code>zkServer start</code></p>
<p>停止命令：<br><code>zkServer stop</code></p>
<p>重启命令：<br><code>zkServer restart</code></p>
<p>查看集群节点状态：<br><code>zkServer status</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">chengkejundeMacBook-Pro:~ c.kj$ zkServer start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: &#x2F;usr&#x2F;local&#x2F;etc&#x2F;zookeeper&#x2F;zoo.cfg</span><br><span class="line">Starting zookeeper ... already running as process 49422.</span><br><span class="line">chengkejundeMacBook-Pro:~ c.kj$ zkServer status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: &#x2F;usr&#x2F;local&#x2F;etc&#x2F;zookeeper&#x2F;zoo.cfg</span><br><span class="line">Mode: standalone</span><br><span class="line">chengkejundeMacBook-Pro:~ c.kj$</span><br></pre></td></tr></table></figure>
<p>end ~</p>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解kafka系列-生产者</title>
    <url>/2020/07/01/kafka-2020-06-30-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3kafka%E7%B3%BB%E5%88%97-%E7%94%9F%E4%BA%A7%E8%80%85/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>整个Kafka体系结构中引入了以下3个术语。</p>
</blockquote>
<p> （1）Producer：生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到Kafka中。</p>
<p> （2）Consumer：消费者，也就是接收消息的一方。消费者连接到Kafka上并接收消息，进而进行相应的业务逻辑处理。</p>
<span id="more"></span>
<p> （3）Broker：服务代理节点。对于Kafka而言，Broker可以简单地看作一个独立的Kafka服务节点或Kafka服务实例。大多数情况下也可以将Broker看作一台Kafka服务器，前提是这台服务器上只部署了一个Kafka实例。一个或多个Broker组成了一个Kafka集群。一般而言，我们更习惯使用首字母小写的broker来表示服务代理节点。</p>
<p>  在Kafka中还有两个特别重要的概念—主题（Topic）与分区（Partition）。Kafka中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题（发送到Kafka集群中的每一条消息都要指定一个主题），而消费者负责订阅主题并进行消费。</p>
<p>  主题是一个逻辑上的概念，它还可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区称为主题分区（Topic-Partition）。同一主题下的不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的日志（Log）文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。offset是消息在分区中的唯一标识，Kafka通过它来保证消息在分区内的顺序性，不过offset并不跨越分区，也就是说，Kafka保证的是分区有序而不是主题有序。如图所示，主题中有 4 个分区，消息被顺序追加到每个分区日志文件的尾部。Kafka中的分区可以分布在不同的服务器（broker）上，也就是说，一个主题可以横跨多个broker，以此来提供比单个broker更强大的性能。</p>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggao5l941cj30u00km0zz.jpg"></p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><blockquote>
<p>消息在真正发往Kafka之前，有可能需要经历拦截器（Interceptor）、序列化器（Serializer）和分区器（Partitioner）等一系列的作用，那么在此之后又会发生什么呢？下面我们来看一下生产者客户端的整体架构.</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggall9855yj30wk0qsh18.jpg"></p>
<h4 id="producer-流程："><a href="#producer-流程：" class="headerlink" title="producer 流程："></a>producer 流程：</h4><p>  整个生产者客户端由两个线程协调运行，这两个线程分别为主线程和Sender线程（发送线程）。</p>
<p>  在主线程中由KafkaProducer创建消息，然后通过可能的拦截器、序列化器和分区器的作用之后缓存到消息累加器（RecordAccumulator，也称为消息收集器）中。</p>
<p>  Sender 线程负责从RecordAccumulator中获取消息并将其发送到Kafka中。</p>
<h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>   <font color=#C7063  size=3>生产者拦截器</font> 可以用来在消息发送前做一些准备工作，比如按照某个规则过滤不符合要求的消息、修改消息的内容等，也可以用来在发送回调逻辑前做一些定制化的需求，比如统计类工作。生产者拦截器的使用也很方便，主要是自定义实现 org.apache.kafka.clients.producer.ProducerInterceptor接口。ProducerInterceptor接口中包含3个方法<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggaombbbfoj31bk0u0ncu.jpg"></p>
<p>KafkaProducer() 在将消息序列化和计算分区之前会调用生产者拦截器的onSend（）方法来对消息进行相应的定制化操作。</p>
<p>KafkaProducer() 在消息被应答（Acknowledgement）之前或消息发送失败时调用生产者拦截器的onAcknowledgement（）方法，优先于用户设定的 Callback 之前执行。</p>
<p>close() 主要用于在关闭拦截器时执行一些资源的清理工作。在这 3 个方法中抛出的异常都会被捕获并记录到日志中，但并不会再向上传递。</p>
<p>  <font color=#C7063  size=3>序列化器</font> 生产者需要用序列化器（Serializer) 把对象转换成字节数组才能通过网络发送给Kafka，消费者需要用反序列化器（Deserializer）把从 Kafka 中收到的字节数组转换成相应的对象,Serializer接口中包含3个方法</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggapcp91uuj31tq0qg113.jpg"></p>
<p>configure() 方法用来配置当前类</p>
<p>serialize() 方法用来执行序列化操作</p>
<p>close() 方法用来关闭当前的序列化器，一般情况下 close（）是一个空方法，如果实现了此方法，则必须确保此方法的幂等性，因为这个方法很可能会被KafkaProducer调用多次。</p>
<p><font color=#C7063  size=3>分区器</font> 分区器的作用就是为消息分配分区。序列化器是必需的。消息经过序列化之后就需要确定它发往的分区，如果消息ProducerRecord中指定了partition字段，那么就不需要分区器的作用，因为partition代表的就是所要发往的分区号。</p>
<h4 id="消息累加器-RecordAccumulator"><a href="#消息累加器-RecordAccumulator" class="headerlink" title="消息累加器 RecordAccumulator"></a>消息累加器 RecordAccumulator</h4><p> RecordAccumulator 主要用来缓存消息以便 Sender 线程可以批量发送，进而减少网络传输的资源消耗以提升性能。RecordAccumulator 缓存的大小可以通过生产者客户端参数buffer.memory 配置，默认值为 32MB。<br>  如果生产者发送消息的速度超过发送到服务器的速度，则会导致生产者空间不足，这个时候KafkaProducer的send（）方法调用要么被阻塞，要么抛出异常，这个取决于参数max.block.ms的配置，此参数的默认值为60000，即60秒。</p>
<p> 主线程中发送过来的消息都会被追加到RecordAccumulator的某个双端队列（Deque）中，在RecordAccumulator 的内部为每个分区都维护了一个双端队列，队列中的内容就是ProducerBatch，即 Deque＜ProducerBatch＞。消息写入缓存时，追加到双端队列的尾部；Sender读取消息时，从双端队列的头部读取。注意ProducerBatch不是ProducerRecord，ProducerBatch中可以包含一至多个 ProducerRecord。</p>
<p> 通俗地说，ProducerRecord 是生产者中创建的消息，而ProducerBatch是指一个消息批次，ProducerRecord会被包含在ProducerBatch中，这样可以使字节的使用更加紧凑。与此同时，将较小的ProducerRecord拼凑成一个较大的ProducerBatch,也可以减少网络请求的次数以提升整体的吞吐量</p>
<h4 id="sender-线程"><a href="#sender-线程" class="headerlink" title="sender 线程"></a>sender 线程</h4><p> Sender 从 RecordAccumulator 中获取缓存的消息之后，会进一步将原本＜分区，Deque＜ProducerBatch＞＞的保存形式转变成＜Node，List＜ ProducerBatch＞的形式，其中Node表示Kafka集群的broker节点,Sender 还会进一步封装成＜Node，Request＞的形式，这样就可以将Request请求发往各个Node了，这里的Request是指Kafka的各种协议请求,请求在从Sender线程发往Kafka之前还会保存到InFlightRequests中，InFlightRequests保存对象的具体形式为Map＜NodeId，Deque＜Request＞＞<br> 它的主要作用是缓存了已经发出去但还没有收到响应的请求（NodeId 是一个 String 类型，表示节点的 id 编号)。</p>
<blockquote>
<p>原创不易，如果觉得有点用的话，请毫不留情点个赞，转发一下，这将是我持续输出优质文章的最强动力。</p>
</blockquote>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解kafka系列-消费者</title>
    <url>/2020/06/29/kafka-2020-06-31-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3kafka%E7%B3%BB%E5%88%97-%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>与生产者对应的是消费者，应用程序可以通过KafkaConsumer来订阅主题，并从订阅的主题中拉取消息。不过在使用KafkaConsumer消费消息之前需要先了解消费者和消费组的概念，否则无法理解如何使用KafkaConsumer。</p>
</blockquote>
<span id="more"></span>



<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul>
<li> 消费者（Consumer）负责订阅Kafka中的主题（Topic），并且从订阅的主题上拉取消息。与其他一些消息中间件不同的是：在Kafka的消费理念中还有一层消费组（Consumer Group）的概念，每个消费者都有一个对应的消费组。</li>
</ul>
<p>   当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者。如图所示，某个主题中共有4个分区（Partition）：P0、P1、P2、P3。有两个消费组A和B都订阅了这个主题，消费组A中有4个消费者（C0、C1、C2和C3），消费组B中有2个消费者（C4和C5）。按照Kafka默认的规则，最后的分配结果是消费组A中的每一个消费者分配到1个分区，消费组B中的每一个消费者分配到2个分区，两个消费组之间互不影响。每个消费者只能消费所分配到的分区中的消息。换言之，每一个分区只能被一个消费组中的一个消费者所消费。</p>
<p>   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcvc5xbflj30vw0fu45f.jpg"></p>
<h3 id="分区分配的演变（Rebalance）"><a href="#分区分配的演变（Rebalance）" class="headerlink" title="分区分配的演变（Rebalance）"></a>分区分配的演变（Rebalance）</h3><p>   我们再来看一下消费组内的消费者个数变化时所对应的分区分配的演变。假设目前某消费组内只有一个消费者C0，订阅了一个主题，这个主题包含 7 个分区：P0、P1、P2、P3、P4、P5、P6。也就是说，这个消费者C0订阅了7个分区，具体分配情形如图。</p>
<p>   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcw1dy1irj30v00n478h.jpg"></p>
<p>   消费者与消费组此时消费组内又加入了一个新的消费者C1，按照既定的逻辑，需要将原来消费者C0的部分分区分配给消费者C1消费，如下图所示。消费者C0和C1各自负责消费所分配到的分区，彼此之间并无逻辑上的干扰。</p>
<p>   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcw48m6p6j30w40nq0x8.jpg"></p>
<p>   紧接着消费组内又加入了一个新的消费者C2，消费者C0、C1和C2按照下图方式各自负责消费所分配到的分区。</p>
<p>   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcw48m6p6j30w40nq0x8.jpg"></p>
<p>   消费者与消费组这种模型可以让整体的消费能力具备横向伸缩性，我们可以增加（或减少）消费者的个数来提高（或降低）整体的消费能力。对于分区数固定的情况，一味地增加消费者并不会让消费能力一直得到提升，如果消费者过多，出现了消费者的个数大于分区个数的情况，就会有消费者分配不到任何分区。参考图如下，一共有8个消费者，7个分区，那么最后的消费者C7由于分配不到任何分区而无法消费任何消息。   </p>
<p>   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcwbn8b1mj30vg0hudje.jpg"></p>
<h3 id="投递模式"><a href="#投递模式" class="headerlink" title="投递模式"></a>投递模式</h3><p>   以上分配逻辑都是基于默认的分区分配策略进行分析的，可以通过消费者客户端参数partition.assignment.strategy 来设置消费者与订阅主题之间的分区分配策略，有关分区分配的更多细节可以再接下来的系列继续聊。</p>
<p>   对于消息中间件而言，一般有两种消息投递模式：</p>
<p>   点对点（P2P，Point-to-Point）模式:  点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息。</p>
<p>   发布/订阅（Pub/Sub）模式: 发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（Topic），主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅消息。主题使得消息的订阅者和发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。</p>
<p>   Kafka 同时支持两种消息投递模式，而这正是得益于消费者与消费组模型的契合：</p>
<ul>
<li>如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用。</li>
<li> 如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布/订阅模式的应用</li>
</ul>
<p>   消费组是一个逻辑上的概念，它将旗下的消费者归为一类，每一个消费者只隶属于一个消费组。每一个消费组都会有一个固定的名称，消费者在进行消费前需要指定其所属消费组的名称，这个可以通过消费者客户端参数group.id来配置，默认值为空字符串。消费者并非逻辑上的概念，它是实际的应用实例，它可以是一个线程，也可以是一个进程。同一个消费组内的消费者既可以部署在同一台机器上，也可以部署在不同的机器上。</p>
<h3 id="创建一个Kafka消费者"><a href="#创建一个Kafka消费者" class="headerlink" title="创建一个Kafka消费者"></a>创建一个Kafka消费者</h3><ul>
<li>以下代码段显示了如何创建KafkaConsumer：</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Properties props &#x3D; new Properties();</span><br><span class="line">  props.put(&quot;bootstrap.servers&quot;, &quot;broker1:9092,broker2:9092&quot;);</span><br><span class="line">  props.put(&quot;group.id&quot;, &quot;CountryCounter&quot;);</span><br><span class="line">  props.put(&quot;key.deserializer&quot;,</span><br><span class="line">      &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">  props.put(&quot;value.deserializer&quot;,</span><br><span class="line">      &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">  </span><br><span class="line">  KafkaConsumer&lt;String, String&gt; consumer &#x3D;</span><br><span class="line">      new KafkaConsumer&lt;String, String&gt;(props);</span><br></pre></td></tr></table></figure>
<ul>
<li>订阅主题</li>
</ul>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(Collections.singletonList(&quot;customerCountries&quot;));</span><br></pre></td></tr></table></figure>
<ul>
<li>要订阅所有test主题，我们可以：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(Pattern.compile(&quot;test.*&quot;));</span><br></pre></td></tr></table></figure>
<ul>
<li>轮询循环</li>
</ul>
<p>   消费者API的核心是一个简单的循环，用于轮询服务器以获取更多数据。<br>   一旦用户订阅了主题，轮询循环便会处理协调，分区重新平衡，心跳和数据获取的所有详细信息，从而为开发人员提供了一个干净的API，该API仅从分配的分区中返回可用数据。<br>   消费者的主体如下所示</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    while (true) &#123; 1</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records &#x3D; consumer.poll(100); 2</span><br><span class="line">        for (ConsumerRecord&lt;String, String&gt; record : records) 3</span><br><span class="line">        &#123;</span><br><span class="line">            log.debug(&quot;topic &#x3D; %s, partition &#x3D; %d, offset &#x3D; %d,&quot;</span><br><span class="line">                customer &#x3D; %s, country &#x3D; %s\n&quot;,</span><br><span class="line">                record.topic(), record.partition(), record.offset(),</span><br><span class="line">                record.key(), record.value());</span><br><span class="line"></span><br><span class="line">            int updatedCount &#x3D; 1;</span><br><span class="line">            if (custCountryMap.countainsKey(record.value())) &#123;</span><br><span class="line">                updatedCount &#x3D; custCountryMap.get(record.value()) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            custCountryMap.put(record.value(), updatedCount)</span><br><span class="line"></span><br><span class="line">            JSONObject json &#x3D; new JSONObject(custCountryMap);</span><br><span class="line">            System.out.println(json.toString(4)) 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    consumer.close(); 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>反序列化</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StringDeserializer implements Deserializer&lt;String&gt; &#123;</span><br><span class="line">    private String encoding &#x3D; &quot;UTF8&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(Map&lt;String, ?&gt; configs, boolean isKey) &#123;</span><br><span class="line">        String propertyName &#x3D; isKey ? &quot;key.deserializer.encoding&quot; : &quot;value.deserializer.encoding&quot;;</span><br><span class="line">        Object encodingValue &#x3D; configs.get(propertyName);</span><br><span class="line">        if (encodingValue &#x3D;&#x3D; null)</span><br><span class="line">            encodingValue &#x3D; configs.get(&quot;deserializer.encoding&quot;);</span><br><span class="line">        if (encodingValue instanceof String)</span><br><span class="line">            encoding &#x3D; (String) encodingValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String deserialize(String topic, byte[] data) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (data &#x3D;&#x3D; null)</span><br><span class="line">                return null;</span><br><span class="line">            else</span><br><span class="line">                return new String(data, encoding);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            throw new SerializationException(&quot;Error when deserializing byte[] to string due to unsupported encoding &quot; + encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>消息消费</li>
</ul>
<p>  Kafka中的消费是基于拉模式的。消息的消费一般有两种模式：推模式和拉模式。推模式是服务端主动将消息推送给消费者，而拉模式是消费者主动向服务端发起请求来拉取消息。从轮询循环代码清单中可以看出，Kafka中的消息消费是一个不断轮询的过程，消费者所要做的就是重复地调用poll（）方法，而poll（）方法返回的是所订阅的主题（分区）上的一组消息。对于poll（）方法而言，如果某些分区中没有可供消费的消息，那么此分区对应的消息拉取的结果就为空；如果订阅的所有分区中都没有可供消费的消息，那么poll（）方法返回为空的消息集合。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcyw50wbjj31nw0eeaib.jpg"></p>
<p>poll（long）方法中timeout的时间单位固定为毫秒，而poll（Duration）方法可以根据Duration中的ofMillis（）、ofSeconds（）、ofMinutes（）、ofHours（）等多种不同的方法指定不同的时间单位，灵活性更强。并且 poll（long）方法也已经被标注为@Deprecated，虽然目前还可以使用，如果条件允许的话，还是推荐使用poll（Duration）的方式。</p>
<p>我们在消费消息的时候可以直接对 ConsumerRecord 中感兴趣的字段进行具体的业务逻辑处理。</p>
<p>poll（）方法的返回值类型是 ConsumerRecords，它用来表示一次拉取操作所获得的消息集，内部包含了若干ConsumerRecord，它提供了一个iterator（）方法来循环遍历消息集内部的消息，iterator（）方法的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Iterator&lt;ConsumerRecord&lt;K, V&gt;&gt; iterator() &#123;</span><br><span class="line">    return new ConcatenatedIterable&lt;&gt;(records.values()).iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在 ConsumerRecords 类中还提供了几个方法来方便开发人员对消息集进行处理：count（）方法用来计算出消息集中的消息个数，返回类型是int；isEmpty（）方法用来判断消息集是否为空，返回类型是boolean；empty（）方法用来获取一个空的消息集，返回类型是ConsumerRecord＜K，V＞。</p>
<p>到目前为止，可以简单地认为poll（）方法只是拉取一下消息而已，但就其内部逻辑而言并不简单，它涉及消费位移、消费者协调器、组协调器、消费者的选举、分区分配的分发、再均衡的逻辑、心跳等内容</p>
<ul>
<li>位移提交</li>
</ul>
<p>  对于Kafka中的分区而言，它的每条消息都有唯一的offset，用来表示消息在分区中对应的位置。对于消费者而言，它也有一个offset的概念，消费者使用offset来表示消费到分区中某个消息所在的位置。单词“offset”可以翻译为“偏移量”，也可以翻译为“位移”，很多同学可能并没有过多地在意这一点：在很多中文资料中都会交叉使用“偏移量”和“位移”这两个词，并没有很严谨地进行区分。</p>
<p>  我对offset做了一些区分：对于消息在分区中的位置，我们将offset称为“偏移量”；对于消费者消费到的位置，将 offset 称为“位移”，有时候也会更明确地称之为“消费位移”。做这一区分的目的是让读者在遇到 offset 的时候可以很容易甄别出是在讲分区存储层面的内容，还是在讲消费层面的内容</p>
<p>  在每次调用poll（）方法时，它返回的是还没有被消费过的消息集（当然这个前提是消息已经存储在Kafka 中了，并且暂不考虑异常情况的发生），在旧消费者客户端中，消费位移是存储在ZooKeeper中的。而在新消费者客户端中，消费位移存储在Kafka内部的主题__consumer_offsets中。这里把将消费位移存储起来（持久化）的动作称为“提交”，消费者在消费完消息之后需要执行消费位移的提交。</p>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggd02ca45zj30w40f2q5a.jpg"></p>
<ul>
<li> 指定位移消费</li>
</ul>
<p>  正是有了消费位移的持久化，才使消费者在关闭、崩溃或者在遇到再均衡的时候，可以让接替的消费者能够根据存储的消费位移继续进行消费 ,可是有一个问题则是 _consumer_offsets 位移信息过期而被删除后，它也没有可以查找的消费位移 ，这个时候就会根据消费者客户端参数auto.offset.reset的配置来决定从何处开始进行消费</p>
<p>  除了查找不到消费位移，位移越界也会触发 auto.offset.reset 参数的执行 ，然而有些时候，我们需要一种更细粒度的掌控，可以让我们从特定的位移处开始拉取消息，哎 ！这个时候 KafkaConsumer 中的 seek（）方法正好提供了这个功能，让我们得以追前消费或回溯消费。seek（）方法的具体定义如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void seek(TopicPartition partition, long offset) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>seek（）方法为我们提供了从特定位置读取消息的能力，我们可以通过这个方法来向前跳过若干消息，也可以通过这个方法来向后回溯若干消息，这样为消息的消费提供了很大的灵活性</p>
<blockquote>
<p>原创不易，如果觉得有点用的话，请毫不留情点个赞，转发一下，这将是我持续输出优质文章的最强动力。</p>
</blockquote>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5-Reactor函数式编程</title>
    <url>/2020/07/10/kafka-2020-07-10-Spring5-Reactor%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>反应式编程是一种可以替代命令式编程的编程范式。这种可替代性存在的原因在于反应式编程解决了命令式编程中的一些限制。理解这些限制，有助于你更好地理解反应式编程模型的优点</p>
<span id="more"></span>

<h3 id="反应式流规范"><a href="#反应式流规范" class="headerlink" title="反应式流规范"></a>反应式流规范</h3><ul>
<li>对比 Java 中的流</li>
</ul>
<p>  Java的流和反应式流Java的流和反应式流之间有很多相似之处。首先，它们的名字中都有流（Stream）这个词。</p>
<p>  它们还提供了用于处理数据的函数式API。事实上，正如你稍后将会在介绍Reactor时看到的那样，它们甚至可以共享许多相同的操作。</p>
<p>  Java的流通常都是同步的，并且只能处理有限的数据集。从本质上来说，它们只是使用函数来对集合进行迭代的一种方式。</p>
<p>  反应式流支持异步处理任意大小的数据集，同样也包括无限数据集。只要数据就绪，它们就能实时地处理数据，并且能够通过回压来避免压垮数据的消费者。</p>
<ul>
<li>反应式流规范</li>
</ul>
<p>  反应式流规范可以总结为4个接口：Publisher、Subscriber、Subscription和Processor。</p>
<p>  Publisher负责生成数据，并将数据发送给Subscription（每个Subscriber对应一个Subscription）。</p>
<p>  Publisher接口声明了一个方法subscribe()，Subscriber可以通过该方法向Publisher发起订阅。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface Publisher&lt;T&gt; &#123;</span><br><span class="line">    void subscribe(Subscriber&lt;? super T&gt; var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface Publisher&lt;T&gt; &#123;</span><br><span class="line">    void subscribe(Subscriber&lt;? super T&gt; var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Subscriber&lt;T&gt; &#123;</span><br><span class="line">    void onSubscribe(Subscription var1);</span><br><span class="line"></span><br><span class="line">    void onNext(T var1);</span><br><span class="line"></span><br><span class="line">    void onError(Throwable var1);</span><br><span class="line"></span><br><span class="line">    void onComplete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Subscription &#123;</span><br><span class="line">    void request(long var1);</span><br><span class="line"></span><br><span class="line">    void cancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="初识Reactor"><a href="#初识Reactor" class="headerlink" title="初识Reactor"></a>初识Reactor</h3><p>Reactor项目是反应式流规范的一个实现，提供了一组用于组装反应式流的函数式API。</p>
<p>反应式编程要求我们采取和命令式编程不一样的思维方式。此时我们不会再描述每一步要进行的步骤，反应式编程意味着要构建数据将要流经的管道。当数据流经管道时，可以对它们进行某种形式的修改或者使用。</p>
<p>命令式编程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String a &#x3D; &quot;Apple&quot;;</span><br><span class="line">String s &#x3D; a.toUpperCase();</span><br><span class="line">String s1 &#x3D; &quot;hello&quot; + s + &quot;!&quot;;</span><br><span class="line">System.out.println(s1);</span><br></pre></td></tr></table></figure>

<p>反应式编程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Mono.just(&quot;Apple&quot;)</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .map(x-&gt; &quot;hello&quot; + x + &quot;!&quot;)</span><br><span class="line"> .subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">控制台：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>helloAPPLE!<br>14:36:38.685 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>helloAPPLE!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这个例子中的Mono是Reactor的两种核心类型之一，另一个类型是Flux。两者都实现了反应式流的Publisher接口。Flux代表具有零个、一个或者多个（可能是无限个）数据项的管道.</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlgy1gglvncheldj31aw0jcai2.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 添加Reactor依赖</span><br><span class="line"></span><br><span class="line">要开始使用Reactor，请将下面的依赖项添加到项目的构建文件中：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>    &lt;!--reactor core--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-core&lt;/artifactId&gt;
&lt;/dependency&gt;
    &lt;!--reactor test--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;
    &lt;version&gt;3.2.6.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
    
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 使用常见的反应式操作</span><br><span class="line"></span><br><span class="line">Flux和Mono是Reactor提供的最基础的构建块，而这两种反应式类型所提供的操作符则是组合使用它们以构建数据流动管线的黏合剂。</span><br><span class="line"></span><br><span class="line">Flux和Mono共有500多个操作，这些操作都可以大致归类为：</span><br><span class="line"></span><br><span class="line">•创建操作；</span><br><span class="line"></span><br><span class="line">•组合操作；</span><br><span class="line"></span><br><span class="line">•转换操作；</span><br><span class="line"></span><br><span class="line">•逻辑操作。</span><br><span class="line"></span><br><span class="line">* 1 创建</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<pre><code>   Flux&lt;String&gt; fruitFlux = Flux.just(&quot;Apple&quot;,&quot;Orange&quot;);

   fruitFlux.subscribe(System.out::println);
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里传递给subscribe()方法的lambda表达式实际上是一个java.util.Consumer，用来创建反应式流的Subscriber。在调用subscribe()之后，数据会开始流动。在这个例子中，没有中间操作，所以数据从Flux直接流向订阅者</span><br><span class="line"></span><br><span class="line">要验证预定义的数据是否流经了fruitFlux，我们可以编写如下所示的测试代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>   StepVerifier.create(fruitFlux)
   .expectNext(&quot;Apple&quot;)
   .expectNext(&quot;Orange&quot;)
   .verifyComplete();
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在这个例子中，StepVerifier订阅了fruitFlux，然后断言Flux中的每个数据项是否与预期的水果名称相匹配。最后，它验证Flux在发布完“Strawberry”之后，整个fruitFlux正常完成。</span><br><span class="line"></span><br><span class="line">还可以从数组 集合 Java Stream来作为Flux的源。</span><br></pre></td></tr></table></figure>
<pre><code>  List&lt;String&gt; list = Lists.newArrayList();
    list.add(&quot;Apple&quot;);
    list.add(&quot;Orange&quot;);
    Flux&lt;String&gt; stringFlux = Flux.fromIterable(list);
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlgy1gglweh3r7uj322k0u0ay8.jpg)</span><br><span class="line"></span><br><span class="line">例如，要创建一个每秒发布一个值的Flux，你可以使用Flux上的静态interval() 方法，如下所示：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   Flux<Long> take = Flux.interval(Duration.ofSeconds(1)).take(5);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过interval()方法创建的Flux会从0开始发布值，并且后续的条目依次递增。此外，因为interval()方法没有指定最大值，所以它可能会永远运行。我们也可以使用take()方法将结果限制为前5个条目</span><br><span class="line"></span><br><span class="line">* 2 组合反应式类型</span><br><span class="line"></span><br><span class="line">有时候，我们会需要操作两种反应式类型，并以某种方式将它们合并在一起。或者，在其他情况下，我们可能需要将Flux拆分为多种反应式类型</span><br><span class="line"></span><br><span class="line">合并:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  Flux<String> fruitFluxA = Flux.just(“Apple”,”Orange”);</p>
<p>  Flux<String> fruitFluxB = Flux.just(“Banana”,”watermelon”);</p>
<p>  fruitFluxA.mergeWith(fruitFluxB).subscribe(System.out::println);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p> com.ckj.superlearn.superlearn.base.ReactorStrategy<br>16:03:07.343 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>Apple<br>Orange<br>Banana<br>watermelon</p>
<p>Process finished with exit code 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlgy1gglzay93rfj30xs0esafw.jpg)</span><br><span class="line"></span><br><span class="line">mergeWith()方法不能完美地保证源Flux之间的先后顺序，所以我们可以考虑使用zip()方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  Flux<String> fruitFluxA = Flux.just(“Apple”,”Orange”).delayElements(Duration.ofMillis(10));</p>
<p>  Flux<String> fruitFluxB = Flux.just(“Banana”,”watermelon”).delayElements(Duration.ofMillis(50));</p>
<p>  Flux<String> allFlux = fruitFluxA.mergeWith(fruitFluxB);</p>
<p>  allFlux.subscribe(x-&gt; System.out.println(“allFlux:”+x));</p>
<p>  Flux&lt;Tuple2&lt;String, String&gt;&gt; zip = Flux.zip(fruitFluxA, fruitFluxB);</p>
<p>  zip.subscribe(x-&gt; System.out.println(“zip:”+x));</p>
<p>  Thread.sleep(1000);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlgy1gglzc3zljuj312k0fqq76.jpg)</span><br><span class="line"></span><br><span class="line">控制台：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>/com.ckj.superlearn.superlearn.base.ReactorStrategy<br>16:49:44.543 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>allFlux:Apple<br>allFlux:Orange<br>allFlux:Banana<br>zip:[Apple,Banana]<br>allFlux:watermelon<br>zip:[Orange,watermelon]</p>
<p>Process finished with exit code 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 3 转换和过滤反应式流</span><br><span class="line"></span><br><span class="line">针对具有多个数据项的Flux，skip操作将创建一个新的Flux，它会首先跳过指定数量的数据项，然后从源Flux中发布剩余的数据项。下面的测试方法展示如何使用skip()方法：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  Flux<String> fruitFluxA = Flux.just(“Apple”,”Orange”,”Banana”,”watermelon”).skip(2);</p>
<pre><code>fruitFluxA.subscribe(x-&gt;&#123;

    System.out.println(x);

    &#125;);
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>/com.ckj.superlearn.superlearn.base.ReactorStrategy<br>17:05:00.141 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>Banana<br>watermelon</p>
<p>Process finished with exit code 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">与之对应相反的是take()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> Flux<String> fruitFluxA = Flux.just(“Apple”,”Orange”,”Banana”,”watermelon”).take(2);</p>
<pre><code>    fruitFluxA.subscribe(x-&gt;&#123;

        System.out.println(x);

    &#125;);
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p> com.ckj.superlearn.superlearn.base.ReactorStrategy<br>17:20:59.483 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>Apple<br>Orange</p>
<p>Process finished with exit code 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter()的过滤效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  Flux<String> fruitFluxA = Flux.just(“Apple”,”Orange”,”Banana”,”watermelon”).take(2);</p>
<p>  fruitFluxA.filter(x-&gt;x.equals(“Apple”)).subscribe(x-&gt;{</p>
<pre><code> System.out.println(x);

 &#125;);
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>com.ckj.superlearn.superlearn.base.ReactorStrategy<br>17:24:03.242 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>Apple</p>
<p>Process finished with exit code 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如何使用flatMap()方法和subscribeOn()方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  Flux<String> fruitFluxA = Flux.just(“Apple”, “Orange”, “Banana”, “watermelon”, “Apple”, “Orange”, “Banana”,<br>                “watermelon”, “Apple”, “Orange”, “Banana”, “watermelon”, “Apple”, “Orange”, “Banana”, “watermelon”);</p>
<p>   fruitFluxA.flatMap(Mono::just).map(String::toUpperCase).subscribeOn(Schedulers.parallel());</p>
<pre><code>![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm1rjb3naj31580kgguh.jpg)

使用flatMap()和subscribeOn()的好处是：我们可以在多个并行线程之间拆分工作，从而增加流的吞吐量。因为工作是并行完成的，无法保证哪项工作首先完成，所以结果Flux中数据项的发布顺序是未知的


  &gt; 原创不易，如果觉得有点用的话，请毫不留情点个赞，转发一下，这将是我持续输出优质文章的最强动力。
</code></pre>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解kafka系列-主题</title>
    <url>/2020/07/03/kafka-2020-07-03-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3kafka%E7%B3%BB%E5%88%97-%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>主题和分区是Kafka 的两个核心概念，前面系列中讲述的生产者和消费者的设计理念所针对的都是主题和分区层面的操作。主题作为消息的归类，可以再细分为一个或多个分区，分区也可以看作对消息的二次归类。分区的划分不仅为Kafka提供了可伸缩性、水平扩展的功能，还通过多副本机制来为Kafka提供数据冗余以提高数据可靠性。</p>
</blockquote>
<p>从Kafka的底层实现来说，主题和分区都是逻辑上的概念，分区可以有一至多个副本，每个副本对应一个日志文件，每个日志文件对应一至多个日志分段（LogSegment），每个日志分段还可以细分为索引文件、日志存储文件和快照文件等。不过对于使用Kafka进行消息收发的普通用户而言，了解到分区这一层面足以应对大部分的使用场景,这里暂时只说到主题和分区,更底层的内容会在后续这个系列持续讲解~</p>
<span id="more"></span>


<h3 id="主题的管理"><a href="#主题的管理" class="headerlink" title="主题的管理"></a>主题的管理</h3><p>主题的管理包括创建主题、查看主题信息、修改主题和删除主题等操作。可以通过 Kafka提供的 kafka-topics.sh脚本来执行这些操作，这个脚本位于$KAFKA_HOME/bin/目录下，其核心代码仅有一行，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec $(dirname $0)&#x2F;kafka-run-class.sh kafka.admin.TopicCommand &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<p>当然主题的管理并非只有使用 kafka-topics.sh 脚本这一种方式，我们还可以通过KafkaAdminClient 的方式实现（这种方式实质上是通过发送 CreateTopicsRequest、DeleteTopicsRequest 等请求来实现的,甚至我们还可以通过直接操纵日志文件和ZooKeeper节点来实现,这个后续我会单独抽出来放在这个系列继续讲解~</p>
<ul>
<li>1 创建主题</li>
</ul>
<p> 如果broker端配置参数auto.create.topics.enable设置为true（默认值就是true），那么当生产者向一个尚未创建的主题发送消息时，会自动创建一个分区数为num.partitions （默认值为1）、副本因子为default.replication.factor（默认值为1）的主题。不建议这样操作,topic 未知难以维护,建议下面这种方式:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --create --zookeeper localhost:2181&#x2F;kafka100 --topic topic-create --replication-factor 2 --partitions 4</span><br></pre></td></tr></table></figure>
<p> 上面的示例中创建了一个分区数为 4、副本因子为 2 的主题.</p>
<p> 三个broker节点一共创建了8个文件夹，这个数字8实质上是分区数4与副本因子2的乘积。每个副本（或者更确切地说应该是日志，副本与日志一一对应）才真正对应了一个命名形式如＜topic＞-＜partition＞的文件夹。主题、分区、副本和 Log（日志）的关系如图所示</p>
<p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gghbnbj175j30wi082adz.jpg"></p>
<p>同一个分区中的多个副本必须分布在不同的broker中，这样才能提供有效的数据冗余。对于示例中的分区数为4、副本因子为2、broker数为3的情况下，按照2、3、3的分区副本个数分配给各个broker是最优的选择。再比如在分区数为3、副本因子为3，并且broker数同样为3的情况下，分配3、3、3的分区副本个数给各个broker是最优的选择，也就是每个broker中都拥有所有分区的一个副本。</p>
<ul>
<li>2 分区副本的分配</li>
</ul>
<p>这里的分区分配是指为集群制定创建主题时的分区副本分配方案，即在哪个broker中创建哪些分区的副本<br>在创建主题时，如果使用了replica-assignment参数，那么就按照指定的方案来进行分区副本的创建；如果没有使用replica-assignment参数，那么就需要按照内部的逻辑来计算分配方案了。使用kafka-topics.sh脚本创建主题时的内部分配逻辑按照机架信息划分成两种策略：未指定机架信息和指定机架信息。如果集群中所有的 broker节点都没有配置broker.rack参数，或者使用disable-rack-aware参数来创建主题，那么采用的就是未指定机架信息的分配策略，否则采用的就是指定机架信息的分配策略</p>
<ul>
<li>3 查看主题</li>
</ul>
<p>kafka-topics.sh脚本有5种指令类型：create、list、describe、alter和delete。其中list和describe指令可以用来方便地查看主题信息,通过list指令可以查看当前所有可用的主题，示例如下:<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --zookeeper localhost:2181 --list</span><br></pre></td></tr></table></figure><br> 查看指定topic信息<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --zookeeper localhost:2181 --describe --topic topic-create</span><br></pre></td></tr></table></figure></p>
<ul>
<li>4 修改主题</li>
</ul>
<p>当一个主题被创建之后，依然允许我们对其做一定的修改，比如修改分区个数、修改配置等，这个修改的功能就是由kafka-topics.sh脚本中的alter指令提供的。我们首先来看如何增加主题的分区数。以前面的主题topic-config为例，当前分区数为1，修改为3，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bin&#x2F;kafka-topics.sh --zookeeper localhost:2181&#x2F;kafka --alter --topic topic-config --partitions 3</span><br><span class="line">WARNING: If partitions are increased for a topic that has a key, the partition logic or ordering of the messages will be affected</span><br><span class="line">Adding partitions succeeded!</span><br><span class="line"> </span><br><span class="line"># bin&#x2F;kafka-topics.sh --zookeeper localhost:2181&#x2F;kafka --describe --topic topic-create</span><br><span class="line">Topic:topic-config    PartitionCount:3  ReplicationFactor:1   Configs:</span><br><span class="line">Topic: topic-config    Partition: 0 Leader: 2    Replicas: 2  Isr: 2</span><br><span class="line">Topic: topic-config    Partition: 1 Leader: 0    Replicas: 0  Isr: 0</span><br><span class="line">Topic: topic-config    Partition: 2 Leader: 1    Replicas: 1  Isr: 1</span><br></pre></td></tr></table></figure>
<p>当主题中的消息包含key时（即key不为null），根据key计算分区的行为就会受到影响,对于基于key计算的主题而言，建议在一开始就设置好分区数量，避免以后对其进行调整。目前Kafka只支持增加分区数而不支持减少分区数.</p>
<ul>
<li>5 删除主题</li>
</ul>
<p>如果确定不再使用一个主题，那么最好的方式是将其删除，这样可以释放一些资源，比如磁盘、文件句柄等。kafka-topics.sh脚本中的delete指令就可以用来删除主题，比如删除一个主题topic-delete.</p>
<h3 id="初识KafkaAdminClient"><a href="#初识KafkaAdminClient" class="headerlink" title="初识KafkaAdminClient"></a>初识KafkaAdminClient</h3><p>一般情况下，我们都习惯使用kafka-topics.sh脚本来管理主题，但有时候我们希望将主题管理类的功能集成到公司内部的系统中，打造集管理、监控、运维、告警为一体的生态平台.</p>
<p>KafkaAdminClient继承了org.apache.kafka.clients.admin.AdminClient抽象类，并提供了多种方法。篇幅限制，下面只列出与本章内容相关的一些方法。</p>
<ul>
<li> 创建主题：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreateTopicsResult createTopics（Collection＜NewTopic＞newTopics）</span><br></pre></td></tr></table></figure>

<ul>
<li> 删除主题：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DeleteTopicsResult deleteTopics（Collection＜String＞topics）。</span><br></pre></td></tr></table></figure>

<ul>
<li> 列出所有可用的主题：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ListTopicsResult listTopics（）。</span><br></pre></td></tr></table></figure>

<ul>
<li> 查看主题的信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DescribeTopicsResult describeTopics（Collection＜String＞topicNames）</span><br></pre></td></tr></table></figure>

<ul>
<li> 查询配置信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DescribeConfigsResult describeConfigs（Collection＜ConfigResource＞resources）</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AlterConfigsResult alterConfigs（Map＜ConfigResource，Config＞configs）</span><br></pre></td></tr></table></figure>

<ul>
<li>增加分区：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreatePartitionsResult createPartitions（Map＜String，NewPartitions＞newPartitions）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原创不易，如果觉得有点用的话，请毫不留情点个赞，转发一下，这将是我持续输出优质文章的最强动力。</p>
</blockquote>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2016/05/29/linux-2016-05-05-linux-cmd/</url>
    <content><![CDATA[<p>最近一段时间工作实在是太忙了，所以好久没有写文章了，趁着周末把linux 的相关知识，整理了下。这一篇文件主要记录了一些linux的基础命令。需要读者有linux服务器或者有mac电脑去练习。^`^.</p>
<span id="more"></span>

<p>###一、命令的基本格式</p>
<blockquote>
<p>[root@localhost~]</p>
<p>root为用户名</p>
<p>～表示当前所在位置</p>
<p>localhost主机名</p>
<p>‘#’超级用户</p>
<p>‘$”  普通用户</p>
</blockquote>
<p>命令的基本格式：</p>
<blockquote>
<p>命令  [选项]  [参数]</p>
</blockquote>
<h3 id="二、查询目录的内容"><a href="#二、查询目录的内容" class="headerlink" title="二、查询目录的内容"></a>二、查询目录的内容</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls [选项][文件或目录]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>选项：</p>
<p>-a 所有文件</p>
<p>-l  查看详情</p>
<p>-d查看目录属性</p>
<p>-h显示文件大小</p>
</blockquote>
<p>###三、文件处理命令</p>
<p>1、建立目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p [目录名]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p表述递归建文件夹</p>
</blockquote>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir japan</span><br><span class="line"></span><br><span class="line">mkdir -p japan&#x2F;cangjk</span><br></pre></td></tr></table></figure>

<p>2.切换目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd [目录]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简化操作：</p>
<blockquote>
<p>cd~  进入当前用户目录</p>
<p>cd- 上次目录</p>
<p>cd.. 进入上一级目录</p>
<p>pwd查看当前目录所在位置</p>
</blockquote>
<p>3.删除目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir [目录]  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除所有文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf [目录]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除目录所有文件</p>
</blockquote>
<p>4.复制目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp[选项][原文件目录][目标目录]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>选项：</p>
<p>-r复制目录</p>
<p>-p连文件属性一起复制</p>
<p>-a 相当于-pdr</p>
</blockquote>
<p>5.剪切、改名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv[原文件目录][目标文件目录]</span><br></pre></td></tr></table></figure>

<p>6.常见目录作用</p>
<blockquote>
<p>/ 根目录</p>
<p>/bin 命令保存目录</p>
<p>/boot  启动目录</p>
<p>/dev  设备文件命令</p>
<p>/etc  配置文件保存目录</p>
<p>/home  家目录</p>
<p>/lib  系统库保存命令</p>
<p>/mnt  系统挂载目录</p>
</blockquote>
<h3 id="三、文件搜索命令"><a href="#三、文件搜索命令" class="headerlink" title="三、文件搜索命令"></a>三、文件搜索命令</h3><p>1.locate </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate [文件名]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在系统数据库中查找文件的</p>
</blockquote>
<blockquote>
<p>新建的文件，要执行updatedb操作之后才能搜到</p>
</blockquote>
<p>2.命令搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis [选项] [命令名]</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">which [选项][命令名]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>选项：</p>
<p>-b 只查找可执行文件</p>
<p>-m 只查找帮助文件</p>
</blockquote>
<p>3.文件搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find [搜索范围][选项][条件]</span><br></pre></td></tr></table></figure>

<p>直接举例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find  &#x2F;  -name install.log  </span><br><span class="line">在根目录下查找名为install.log文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;root  -inname install.log</span><br><span class="line">忽略大小写查找文件</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;var&#x2F;log -mtime +10</span><br><span class="line"></span><br><span class="line">其中-mtime 文件修改时间</span><br><span class="line">-atime 文件访问时间</span><br><span class="line">-ctime 改变文件属性时间</span><br><span class="line"></span><br><span class="line">+10 10天前</span><br><span class="line">10  10天</span><br><span class="line">-10 10天内</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -size +20M</span><br><span class="line"></span><br><span class="line">查找文件大于20M的文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四、压缩与解压缩命令"><a href="#四、压缩与解压缩命令" class="headerlink" title="四、压缩与解压缩命令"></a>四、压缩与解压缩命令</h3><p>常见压缩格式：.zip  、 .gz 、 .bz2、<br>.tar.gz  、 .tar.bz2</p>
<p>1.zip格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;压缩文件</span><br><span class="line">zip [压缩文件名][原文件]</span><br><span class="line">&#x2F;&#x2F;压缩目录</span><br><span class="line">zip -r  [压缩文件名][原文件]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch jp&#x2F;cangls</span><br><span class="line"></span><br><span class="line">touch jp&#x2F;longls</span><br><span class="line"></span><br><span class="line">zip -r jp.zip jp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#解压：</span><br><span class="line">unzip [压缩文件名]</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>gz格式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 压缩为gz格式，原文件不保留</span><br><span class="line">gzip [原文件]</span><br><span class="line"></span><br><span class="line">#压缩.gz格式，原文件保留</span><br><span class="line"></span><br><span class="line">gzip -c 原文件 &gt; 压缩文件</span><br><span class="line"># 压缩目录：</span><br><span class="line">gzip -r  目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解压：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guzip [文件]</span><br><span class="line"></span><br><span class="line">guzip -r [目录]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.tar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打包</span><br><span class="line">tar -cvf  打包文件名 原文件</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line"></span><br><span class="line">tar -xvf jp.tar</span><br></pre></td></tr></table></figure>

<p>4.tar.gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打包</span><br><span class="line">tar -zcvf 压缩包名.tar.gz  原文件</span><br><span class="line"></span><br><span class="line">#解压</span><br><span class="line">tar -zxvf  压缩包名.tar.gz</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="五、关机和重启"><a href="#五、关机和重启" class="headerlink" title="五、关机和重启"></a>五、关机和重启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutdown [选项][时间]</span><br><span class="line"></span><br><span class="line">#选项：</span><br><span class="line">-c 取消前一个关机命令</span><br><span class="line">-h 关机</span><br><span class="line">-r 重启</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init 6重启</span><br><span class="line"></span><br><span class="line">init 0关机</span><br><span class="line"></span><br><span class="line">logout退出登陆</span><br></pre></td></tr></table></figure>

<p>###六、查看用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w</span><br><span class="line">who</span><br><span class="line">last</span><br><span class="line">lastlog</span><br></pre></td></tr></table></figure>

<p>###七、shell基础</p>
<p>1.什么是shell<br> shell是命令行解释器。</p>
<p>2.echo 输出命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo[选项][输出内容]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<blockquote>
<p>-e:支持转义</p>
</blockquote>
<p>３.创建一个脚本</p>
<p>创建hello.sh</p>
<blockquote>
<p>vim hello.sh<br>进入编辑：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   #!&#x2F;bin&#x2F;bash</span><br><span class="line">   # the first program</span><br><span class="line">echo &quot;hello world!&quot;</span><br></pre></td></tr></table></figure>
<p> 执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 755 hello.sh</span><br><span class="line"></span><br><span class="line">.&#x2F;hello.sh    </span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash hello.sh</span><br></pre></td></tr></table></figure>

<p>###八、历史命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history 查看历史命令</span><br><span class="line">history [选项][历史保存文件]</span><br><span class="line">选项：</span><br><span class="line">-c清空历史</span><br><span class="line">-w把缓存中的历史写入历史命令保存文件</span><br></pre></td></tr></table></figure>

<p>###九、输出重定向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令&gt;文件   以覆盖的方式，把正确的命令输出到指定文件</span><br><span class="line">命令&gt;&gt;文件  以追加的方式，把正确的命令输出到指定文件、</span><br><span class="line">错误命令 2&gt; 文件  以覆盖的方式把错误的命令覆盖到指定文件</span><br><span class="line">错误命令 2&gt;&gt; 文件  以追击的方式把错误的命令覆盖到指定文件</span><br><span class="line"></span><br><span class="line"> 命令&gt;&gt;文件 2&gt;&amp;1  同时追加正确命令和错误命令到 指定文件</span><br><span class="line">命令 &gt;&gt;文件1 2&gt;&gt;文件2   把正确的命令输出到文件1错误的文件2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;bin&#x2F;bash</span><br><span class="line">while command</span><br><span class="line">do</span><br><span class="line">curl -d &quot;userid&#x3D;123343,action&#x3D;getuserinfo&quot; https:&#x2F;&#x2F;app.testasss.com.cn&#x2F; &gt;test.txt</span><br><span class="line">time&#x3D;$(date)</span><br><span class="line">cat&#x3D;$(cat test.txt |cut -d \: -f 3|cut -d \&quot; -f 2)</span><br><span class="line">echo &quot;$time $cat&quot; &gt;&gt;test.log</span><br><span class="line">sleep 15s</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<p>###十、网络相关</p>
<p>1.ifconfig查看ip</p>
<p>举个例子：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig&gt;&gt; ip.log</span><br><span class="line">cat ip.log</span><br></pre></td></tr></table></figure>

<p>2.查看网络状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat [选项]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<blockquote>
<p>-t: 列出tcp 协议端口<br>-u: 列出upd协议端口<br>-n  ip地址个端口号<br>-l 列出监听状态的<br>-a 所有</p>
</blockquote>
<p>3.查看路由列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -rn</span><br><span class="line">或者</span><br><span class="line">route -n</span><br></pre></td></tr></table></figure>

<p>4.查看某域名与自己的电脑的网络状态</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping www.baodu.com</span><br></pre></td></tr></table></figure>

<p>###十一、vi编辑器<br>vi的升级版是vim</p>
<p>1.vim的操作模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commond mode  命令模式</span><br><span class="line">inser tmode  编辑模式</span><br><span class="line">lastline mode  底行模式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.模式切换<br>i  进入编辑模式<br>esc  进入命令行模式</p>
<p>3.命令模式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim [文件]         进入文件或者创建文件（文件不存在的情况下）</span><br><span class="line">vim + [文件名]   进入文件尾部</span><br><span class="line">vim +&#x2F;[字符串] [文件名]  光标定位到文件第一次出现该字符串的位置</span><br></pre></td></tr></table></figure>
<p>4.底行模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:w  保存</span><br><span class="line">:q 退出</span><br><span class="line">:! 强制</span><br><span class="line">:15  定位的第15行</span><br><span class="line">&#x2F;[字符串]  光标位置向后搜索该字符串</span><br><span class="line">?[字符串]  光标位置向前搜索该字符串</span><br><span class="line">dd  删除光标所在行</span><br><span class="line"></span><br><span class="line">ctr+f   向下翻页</span><br><span class="line">ctr+b  向上翻页</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>###十二、常用操作快捷键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctr+c  终止当前命令</span><br><span class="line">ctr+l 清屏  相当于 clear</span><br><span class="line">ctr+a  光标移到行首</span><br><span class="line">ctr+e  光标移到行尾</span><br><span class="line">ctr+u  把光标所在位置删除到行首</span><br><span class="line">ctr+z  把命令放入后台</span><br><span class="line">ctr+r  在历史命令中搜索</span><br></pre></td></tr></table></figure>
<h3 id="十三、其他"><a href="#十三、其他" class="headerlink" title="十三、其他"></a>十三、其他</h3><p>常用工具：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vmware  虚拟机</span><br><span class="line">centos.iso   centos系统镜像 ,绝大多数服务器是这个系统</span><br><span class="line">SecureCRT  远程登陆工具</span><br><span class="line">Xshell 远程登陆工具</span><br><span class="line">winscp copy文件工具</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我的springCloud专栏：<a target="_blank" rel="noopener" href="http://blog.csdn.net/column/details/15197.html">http://blog.csdn.net/column/details/15197.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>我说如何根据豆瓣api来理解Restful API设计的</title>
    <url>/2017/05/06/micorservice-2017-05-06-douban-rest-api/</url>
    <content><![CDATA[<h3 id="1-什么是REST"><a href="#1-什么是REST" class="headerlink" title="1.什么是REST"></a>1.什么是REST</h3><p>REST全称是Representational State Transfer,表述状态转移的意思。它是在Roy Fielding博士论文首次提出。REST本身没有创造新的技术、组件或服务，它的理念就是在现有的技术之上，更好的使用现有的 web规范。用REST规范的web服务器，能够更好的展现资源，客户端能够更好的使用资源。每个资源都由URI/ID标识。REST本身跟http无关，但是目前http是与它相关的唯一实例。REST有着优雅、简洁的特性，本文是根据豆瓣api来谈谈自己对restful的一些理解。</p>
<span id="more"></span>

<h3 id="2-URI规范"><a href="#2-URI规范" class="headerlink" title="2.URI规范"></a>2.URI规范</h3><ul>
<li>URI(Uniform Resource Identifiers) 统一资源标示符</li>
<li>URL(Uniform Resource Locator) 统一资源定位符</li>
</ul>
<p>URI 的格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">URI的格式定义如下：  </span><br><span class="line">URI &#x3D; scheme &quot;:&#x2F;&#x2F;&quot; authority &quot;&#x2F;&quot; path [ &quot;?&quot; query ] [ &quot;#&quot; fragment ]  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>uri代表的是一种资源，要做到优雅、简洁。</li>
<li>最好在api地址标明版本</li>
</ul>
<p>比如 </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.douban.com&#x2F;v2</span><br></pre></td></tr></table></figure>

<ul>
<li>关于分隔符“／”，比如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;&#x2F;&quot;分隔符一般用来对资源层级的划分,比如：</span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;api.douban.com&#x2F;v2&#x2F;book&#x2F;1220562</span><br><span class="line"></span><br><span class="line">表述了豆瓣api，version2下的图书仓库下的编号为1220562的图书。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>URI尽量使用“-”代替下划线“_“。</li>
<li>URI统一使用小写字母</li>
<li>URI不包含文件扩展名</li>
<li>使用？用来过滤资源，比如？limit=10 :指定返回10条记录。</li>
<li>不使用无意义的字符串、数字，要做到简洁。</li>
</ul>
<h3 id="3-正确使用method"><a href="#3-正确使用method" class="headerlink" title="3.正确使用method"></a>3.正确使用method</h3><ul>
<li>get -只用做资源的读取。</li>
<li>post-通过用作创建一个新的资源。</li>
<li>delete-通过用作资源的删除。</li>
<li>put -通过用作更新资源或者创建资源</li>
<li>head-只获取某个资源的头部信息。</li>
</ul>
<p>比如 <a target="_blank" rel="noopener" href="https://developers.douban.com/wiki/?title=book_v2">豆瓣图书api</a>：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>method</th>
<th>api</th>
</tr>
</thead>
<tbody><tr>
<td>获取图书信息</td>
<td>get</td>
<td>/v2/book/:id</td>
</tr>
<tr>
<td>用户收藏某本图书</td>
<td>post</td>
<td>/v2/book/:id/collection</td>
</tr>
<tr>
<td>用户修改对某本图书的收藏</td>
<td>put</td>
<td>/v2/book/:id/collection</td>
</tr>
<tr>
<td>用户删除对某个图书的收藏</td>
<td>delete</td>
<td>/v2/book/:id/collection</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>另外，在一些不符合curd的情况下，使用　post。</li>
<li>把动作转换成资源</li>
</ul>
<p> 比如，上述接口中，用户收藏某本书对外暴露的接口是”/v2/book/:id/collection”,收藏动作通过post方法来展现，而不直接写着api中，collection “收藏”，名次，动作直接转换成了资源。</p>
<p>###4.选择合适的状态码</p>
<p>http请求需要返回状态码，约定俗成的状态码能够帮助开发团队提高沟通效率。</p>
<ul>
<li>2xx: 请求正常处理并返回</li>
<li>3xx: 重定向</li>
<li>4xx: 客户端请求有错误</li>
<li>5xx: 服务端请求有错误</li>
</ul>
<p>比如豆瓣api返回的状态码说明：</p>
<table>
<thead>
<tr>
<th>状态码</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>200</td>
<td>ok</td>
<td>请求成功</td>
</tr>
<tr>
<td>201</td>
<td>created</td>
<td>创建成功</td>
</tr>
<tr>
<td>202</td>
<td>accepted</td>
<td>更新成功</td>
</tr>
<tr>
<td>400</td>
<td>bad request</td>
<td>请求不存在</td>
</tr>
<tr>
<td>401</td>
<td>unauthorized</td>
<td>未授权</td>
</tr>
<tr>
<td>403</td>
<td>forbidden</td>
<td>禁止访问</td>
</tr>
<tr>
<td>404</td>
<td>not found</td>
<td>资源不存在</td>
</tr>
<tr>
<td>500</td>
<td>internal server error</td>
<td>内部错误</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="5-使用通用的错误码"><a href="#5-使用通用的错误码" class="headerlink" title="5.使用通用的错误码"></a>5.使用通用的错误码</h3><p>  通用错误码，具体产品由具体产品api给出。比如豆瓣api:</p>
<table>
<thead>
<tr>
<th>错误码</th>
<th>错误信息</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>999</td>
<td>unknow_v2_error</td>
<td>未知错误</td>
</tr>
<tr>
<td>1000</td>
<td>need_permission</td>
<td>需要权限</td>
</tr>
<tr>
<td>1001</td>
<td>uri_not_found</td>
<td>资源不存在</td>
</tr>
<tr>
<td>…</td>
<td>….</td>
<td>…</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>太多了，只列出几条，具体见豆瓣 api。</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="6-安全"><a href="#6-安全" class="headerlink" title="6. 安全"></a>6. 安全</h3><p>这部分内容不属于这篇文章，但是稍微说明下：</p>
<ul>
<li>使用https </li>
<li>使用jwt验证</li>
<li>使用参数签名，防止参数被篡改。</li>
<li>使用权限验证，shiro ,或者自己建数据库（用户、角色、权限）  </li>
</ul>
<h3 id="7-api文档"><a href="#7-api文档" class="headerlink" title="7.api文档"></a>7.api文档</h3><p>接口文档的编写至关重要，最好是写一个在线接口文档。接口文档能够方便团队查阅，减少不必要的沟通。如果对外公开api，api文档的质量直接反应了一个公司的技术水平，甚至一个公司的文化气质。</p>
<h3 id="8-参考资料"><a href="#8-参考资料" class="headerlink" title="8.参考资料"></a>8.参考资料</h3><p>本文参考了以下的资料:</p>
<p><a target="_blank" rel="noopener" href="https://developers.douban.com/wiki/?title=book_v2">豆瓣api</a></p>
<p><a target="_blank" rel="noopener" href="http://mccxj.github.io/blog/20130530_introduce-to-rest.html">理解restful架构</a></p>
<p><a target="_blank" rel="noopener" href="https://www.tutorialspoint.com/restful/restful_introduction.htm">restful introduction</a></p>
<p><a target="_blank" rel="noopener" href="http://cizixs.com/2016/12/12/restful-api-design-guide">跟着github学习restful api设计</a></p>
<p><a target="_blank" rel="noopener" href="http://wangwei.info/about-rest-api/">REST接口设计规范</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html">restful api 设计指南</a></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>漫谈大型网站技术架构</title>
    <url>/2017/05/06/micorservice-2017-05-06-dxjsjg/</url>
    <content><![CDATA[<p>本文的内容来自阿里巴巴员工李智慧的著作《大型网站技术架构 核心原理与案例分析》，这本书很值得一看，故整理之。</p>
<span id="more"></span>

<h3 id="一、大型网站的架构演化"><a href="#一、大型网站的架构演化" class="headerlink" title="一、大型网站的架构演化"></a>一、大型网站的架构演化</h3><h4 id="1-1-大型网站软件的特点"><a href="#1-1-大型网站软件的特点" class="headerlink" title="1.1 大型网站软件的特点"></a>1.1 大型网站软件的特点</h4><ul>
<li>高并发、大流量</li>
<li>高可用：系统7*24小时不间断提供服务</li>
<li>海量数据</li>
<li>用户分布广泛</li>
<li>安全环境恶劣</li>
<li>需求变更快，发布频繁</li>
<li>渐进式发展</li>
</ul>
<h4 id="1-2-大型网站架构演化发展历程"><a href="#1-2-大型网站架构演化发展历程" class="headerlink" title="1.2 大型网站架构演化发展历程"></a>1.2 大型网站架构演化发展历程</h4><ul>
<li> <strong>初始阶段的网站架构：</strong>例如 LAMP 架构</li>
<li><strong>应用和数据服务分离：</strong>三台服务器：应用服务器，文件服务器和数据库服务器</li>
<li><strong>使用缓存改善网站性能：</strong>分为两种，缓存在应用服务器上的本地缓存和缓存在专门的分布式缓存服务器的远程缓存</li>
<li><strong>使用应用服务器集群改善网站并发处理能力：</strong>通过负载均衡调度服务器来分发请求到应用服务器集群中的任何一台机器</li>
<li><strong>数据库读写分离：</strong>  主写从读。</li>
<li><strong>使用反向代理和 CDN 加速网站响应：</strong>这两者基本原理都是缓存。反向代理部署在网站的中心机房，CDN 部署在网络提供商的机房。</li>
<li><strong>使用分布式文件系统和分布式数据库系统：</strong> 将不同的业务分布，将不同的业务的数据库部署在不同的机器上。</li>
<li><strong>使用 NoSQL 和搜索引擎：</strong> 源自互联网技术，对可伸缩的分布式有更好的支持。</li>
<li><strong>业务拆分：</strong>将整个网站通过分而治之的手段将网站业务分成不同的产品线。</li>
<li><strong>分布式服务：</strong> 比如最近流行的微服务，横行、纵向切片，将服务集群化，相互关联化。</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-ef8d365fc37a0f5e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="架构设计_分布式服务.png"></p>
<h4 id="1-3-大型网站架构演化的价值观"><a href="#1-3-大型网站架构演化的价值观" class="headerlink" title="1.3 大型网站架构演化的价值观"></a>1.3 大型网站架构演化的价值观</h4><ul>
<li>大型网站架构的核心价值是随网站所需灵活应对</li>
<li>驱动大型网站技术发展的主要力量是网站的业务发展</li>
</ul>
<h4 id="1-4-网站架构设计误区"><a href="#1-4-网站架构设计误区" class="headerlink" title="1.4 网站架构设计误区"></a>1.4 网站架构设计误区</h4><ul>
<li>一味追随大公司的解决方案</li>
<li>为了技术而技术</li>
<li>企图用技术解决所有问题</li>
</ul>
<h3 id="二、大型网站架构模式"><a href="#二、大型网站架构模式" class="headerlink" title="二、大型网站架构模式"></a>二、大型网站架构模式</h3><h4 id="2-1-网站架构模式"><a href="#2-1-网站架构模式" class="headerlink" title="2.1 网站架构模式"></a>2.1 网站架构模式</h4><ul>
<li>分层</li>
<li>分割</li>
<li>分布式<ul>
<li>分布式应用和服务</li>
<li>分布式静态资源</li>
<li>分布式数据和存储</li>
<li>分布式计算</li>
</ul>
</li>
<li>集群</li>
<li>缓存<ul>
<li>Cdn</li>
<li>反向代理</li>
<li>本地缓存</li>
<li>分布式缓存</li>
</ul>
</li>
<li>异步<ul>
<li>提供系统可用性</li>
<li>加快网站响应速度</li>
<li>消除高并发访问高峰</li>
</ul>
</li>
<li>冗余 服务器冗余运行，数据库冗余备份</li>
<li>自动化</li>
<li>安全 ： 防止XSS攻击、sql注入</li>
</ul>
<h3 id="三、大型网站核心架构要素"><a href="#三、大型网站核心架构要素" class="headerlink" title="三、大型网站核心架构要素"></a>三、大型网站核心架构要素</h3><ul>
<li>性能</li>
<li>可用性</li>
<li>伸缩性 不断地向服务器集群加服务器</li>
<li>扩张性</li>
</ul>
<h3 id="四、瞬时响应：网站的高性能架构"><a href="#四、瞬时响应：网站的高性能架构" class="headerlink" title="四、瞬时响应：网站的高性能架构"></a>四、瞬时响应：网站的高性能架构</h3><h4 id="4-1-网站性能测试"><a href="#4-1-网站性能测试" class="headerlink" title="4.1 网站性能测试"></a>4.1 网站性能测试</h4><ul>
<li>不同视角下网站的性能<ul>
<li>用户视角网站性能 响应时间</li>
<li>开发人员视角的网站性能 响应时间、并发亮</li>
<li>运维人员视角的网站性能  资源</li>
</ul>
</li>
<li>性能测试指标<ul>
<li>响应时间</li>
<li>并发数</li>
<li>吞吐量 qps tps hps</li>
<li>性能计数器</li>
</ul>
</li>
<li>性能测试方法<ul>
<li>性能测试</li>
<li>负载测试</li>
<li>压力测试</li>
<li>稳定性测试</li>
</ul>
</li>
<li>性能测试报告</li>
<li>性能优化策略<ul>
<li>性能分析</li>
<li>性能优化</li>
</ul>
</li>
</ul>
<h4 id="4-2-web前端性能优化"><a href="#4-2-web前端性能优化" class="headerlink" title="4.2 web前端性能优化"></a>4.2 web前端性能优化</h4><ul>
<li>浏览器访问优化<ul>
<li>减少http请求</li>
<li>使用浏览器缓存</li>
<li>启用压缩</li>
<li>css放在网页最上面 js最下面</li>
<li>减少cookie传输</li>
</ul>
</li>
<li>CDN加速。（content distribute network)</li>
<li>反向代理</li>
</ul>
<h4 id="4-3-应用服务器性能优化"><a href="#4-3-应用服务器性能优化" class="headerlink" title="4.3 应用服务器性能优化"></a>4.3 应用服务器性能优化</h4><ul>
<li>分布式缓存<ul>
<li>缓存的基本原理</li>
<li>合理的使用缓存<ul>
<li>频繁修改数据</li>
<li>没有热点的访问</li>
<li>数据不一致与脏读</li>
<li>缓存可用性</li>
<li>缓存预热</li>
<li>缓存穿透 缓存不存在，直接访问数据库</li>
</ul>
</li>
<li>分布式缓存架构</li>
<li>Memcached</li>
</ul>
</li>
<li>异步操作</li>
<li>使用集群</li>
<li>代码优化<ul>
<li>多线程</li>
<li>资源复用</li>
<li>数据结构</li>
<li>垃圾回收</li>
</ul>
</li>
</ul>
<h4 id="4-4-存储性能优化"><a href="#4-4-存储性能优化" class="headerlink" title="4.4 存储性能优化"></a>4.4 存储性能优化</h4><ul>
<li>机械硬盘 vs. 固态硬盘</li>
<li>B+ 树 vs. LSM 树</li>
<li>RAID vs. HDFS</li>
</ul>
<h3 id="五、万无一失：网站的高可用架构"><a href="#五、万无一失：网站的高可用架构" class="headerlink" title="五、万无一失：网站的高可用架构"></a>五、万无一失：网站的高可用架构</h3><h4 id="5-1-网站可用性的度量和考核"><a href="#5-1-网站可用性的度量和考核" class="headerlink" title="5.1 网站可用性的度量和考核"></a>5.1 网站可用性的度量和考核</h4><ul>
<li>网站可行性度量</li>
<li>网站可用性考核</li>
</ul>
<h4 id="5-2-高可用的网站架构"><a href="#5-2-高可用的网站架构" class="headerlink" title="5.2 高可用的网站架构"></a>5.2 高可用的网站架构</h4><h4 id="5-3-高可用的应用"><a href="#5-3-高可用的应用" class="headerlink" title="5.3 高可用的应用"></a>5.3 高可用的应用</h4><ul>
<li>通过负载均衡进行无状态服务的失效转移</li>
<li>应用服务器集群的session管理<ul>
<li>session复制</li>
<li>session绑定</li>
<li>利用cookie记录 session</li>
<li>session服务器</li>
</ul>
</li>
</ul>
<h4 id="5-4-高可用的应用"><a href="#5-4-高可用的应用" class="headerlink" title="5.4 高可用的应用"></a>5.4 高可用的应用</h4><ul>
<li>分级管理</li>
<li>超时设置</li>
<li>异步调用</li>
<li>服务降级 随机拒绝访问（twitter)</li>
<li>幂等性设计</li>
</ul>
<h4 id="5-5-高可用的数据"><a href="#5-5-高可用的数据" class="headerlink" title="5.5 高可用的数据"></a>5.5 高可用的数据</h4><ul>
<li>CAP原理<ul>
<li>数据持久性</li>
<li>数据可访问性</li>
<li>数据一致性<ul>
<li>数据强一致性</li>
<li>数据用户一致性</li>
<li>数据最终一致性</li>
</ul>
</li>
</ul>
</li>
<li>数据备份</li>
<li>失效转移<ul>
<li>失效确认</li>
<li>访问转移</li>
<li>数据恢复</li>
</ul>
</li>
</ul>
<h4 id="5-6-高可用软件质量保障"><a href="#5-6-高可用软件质量保障" class="headerlink" title="5.6 高可用软件质量保障"></a>5.6 高可用软件质量保障</h4><ul>
<li>网站发布</li>
<li>自动化测试</li>
<li>预发布验证</li>
<li>代码控制<ul>
<li>主干开发，分支发布</li>
<li>分支开发，主干发布</li>
</ul>
</li>
<li>自动化发布</li>
<li>灰度发布</li>
</ul>
<h4 id="5-7-网站运行监控"><a href="#5-7-网站运行监控" class="headerlink" title="5.7 网站运行监控"></a>5.7 网站运行监控</h4><ul>
<li>监控数据采集<ul>
<li>用户行为日志收集</li>
<li>服务器性能检测</li>
<li>运行数据报告</li>
</ul>
</li>
<li>监控管理<ul>
<li>系统报警</li>
<li>失效转移</li>
<li>自动优雅降级</li>
</ul>
</li>
</ul>
<h3 id="六、永无止尽：网站的伸缩性架构"><a href="#六、永无止尽：网站的伸缩性架构" class="headerlink" title="六、永无止尽：网站的伸缩性架构"></a>六、永无止尽：网站的伸缩性架构</h3><h4 id="6-1-网站伸缩性设计"><a href="#6-1-网站伸缩性设计" class="headerlink" title="6.1 网站伸缩性设计"></a>6.1 网站伸缩性设计</h4><ul>
<li>不同功能进行物理分离实现伸缩</li>
<li>单一功能通过集群实现伸缩</li>
</ul>
<h4 id="6-2-应用服务器集群伸缩设计"><a href="#6-2-应用服务器集群伸缩设计" class="headerlink" title="6.2 应用服务器集群伸缩设计"></a>6.2 应用服务器集群伸缩设计</h4><ul>
<li>http重定向负载均衡</li>
<li>Dns域名解析负载均衡</li>
<li>反向代理负载均衡</li>
<li>ip负载均衡</li>
<li>数据链路层负载均衡</li>
<li>负载均衡算法<ul>
<li>轮询</li>
<li>加权轮询</li>
<li>随机</li>
<li>最少链接</li>
<li>原地址散列</li>
</ul>
</li>
</ul>
<h4 id="6-3-分布式缓存集群的伸缩性设计"><a href="#6-3-分布式缓存集群的伸缩性设计" class="headerlink" title="6.3 分布式缓存集群的伸缩性设计"></a>6.3 分布式缓存集群的伸缩性设计</h4><ul>
<li>Memcached分布式缓存集群的访问模型</li>
<li>Memcached分布式缓存集群的伸缩性挑战</li>
<li>分布式缓存的一致性hash算法</li>
</ul>
<h4 id="6-4-数据存储服务器集群的伸缩性设计"><a href="#6-4-数据存储服务器集群的伸缩性设计" class="headerlink" title="6.4 数据存储服务器集群的伸缩性设计"></a>6.4 数据存储服务器集群的伸缩性设计</h4><ul>
<li>关系数据库集群的伸缩性设计</li>
<li>Nosql数据库的伸缩性设计</li>
</ul>
<h3 id="七、随机应变：网站的可扩展性架构"><a href="#七、随机应变：网站的可扩展性架构" class="headerlink" title="七、随机应变：网站的可扩展性架构"></a>七、随机应变：网站的可扩展性架构</h3><h4 id="7-1-构建可扩展性的网站架构"><a href="#7-1-构建可扩展性的网站架构" class="headerlink" title="7.1 构建可扩展性的网站架构"></a>7.1 构建可扩展性的网站架构</h4><h4 id="7-2-利用分布式消息队列降低系统耦合性"><a href="#7-2-利用分布式消息队列降低系统耦合性" class="headerlink" title="7.2 利用分布式消息队列降低系统耦合性"></a>7.2 利用分布式消息队列降低系统耦合性</h4><ul>
<li>事件驱动架构</li>
<li>分布式消息队列</li>
</ul>
<h4 id="7-3-利用分布式服务打造可复用的业务平台"><a href="#7-3-利用分布式服务打造可复用的业务平台" class="headerlink" title="7.3 利用分布式服务打造可复用的业务平台"></a>7.3 利用分布式服务打造可复用的业务平台</h4><ul>
<li>web service与企业级分布式服务</li>
<li>大型网站分布式服务的需求与特点<ul>
<li>负载均衡</li>
<li>失效转移</li>
<li>高效的远程通信</li>
<li>整合异构系统</li>
<li>对应用最少侵入</li>
<li>版本控制</li>
<li>实时监控</li>
</ul>
</li>
<li>分布式服务框架设计</li>
</ul>
<h4 id="7-4-可扩展的数据结构"><a href="#7-4-可扩展的数据结构" class="headerlink" title="7.4 可扩展的数据结构"></a>7.4 可扩展的数据结构</h4><h4 id="7-5-利用开放平台建设网站生态圈"><a href="#7-5-利用开放平台建设网站生态圈" class="headerlink" title="7.5 利用开放平台建设网站生态圈"></a>7.5 利用开放平台建设网站生态圈</h4><ul>
<li>api接口</li>
<li>协议转移</li>
<li>安全</li>
<li>审计</li>
<li>路由</li>
<li>流程</li>
</ul>
<h3 id="8、固若金汤：网站的安全架构"><a href="#8、固若金汤：网站的安全架构" class="headerlink" title="8、固若金汤：网站的安全架构"></a>8、固若金汤：网站的安全架构</h3><h4 id="8-1-道高一尺魔高一丈的网站应用攻击与防御"><a href="#8-1-道高一尺魔高一丈的网站应用攻击与防御" class="headerlink" title="8.1 道高一尺魔高一丈的网站应用攻击与防御"></a>8.1 道高一尺魔高一丈的网站应用攻击与防御</h4><ul>
<li>xss攻击<ul>
<li>消毒</li>
<li>httponly</li>
</ul>
</li>
<li>注入攻击<ul>
<li>开源</li>
<li>错误回显</li>
<li>盲注</li>
<li>消毒</li>
<li>参数绑定</li>
</ul>
</li>
<li>csrf攻击<ul>
<li>表单token</li>
<li>验证码</li>
<li>referer check</li>
</ul>
</li>
<li>其他攻击和漏洞<ul>
<li>error code</li>
<li>html注释</li>
<li>文件上传</li>
<li>路径遍历</li>
</ul>
</li>
<li>web应用防火墙</li>
<li>网站安全漏洞扫描</li>
</ul>
<h4 id="8-2-信息加密技术及密钥安全管理"><a href="#8-2-信息加密技术及密钥安全管理" class="headerlink" title="8.2 信息加密技术及密钥安全管理"></a>8.2 信息加密技术及密钥安全管理</h4><ul>
<li>单向散列加密</li>
<li>对称加密</li>
<li>非对称加密</li>
<li>密钥安全管理</li>
</ul>
<h4 id="8-3-信息过滤与反垃圾"><a href="#8-3-信息过滤与反垃圾" class="headerlink" title="8.3 信息过滤与反垃圾"></a>8.3 信息过滤与反垃圾</h4><ul>
<li>文本匹配</li>
<li>分类算法</li>
<li>黑名单</li>
</ul>
<h4 id="8-4-电子商务风险控制"><a href="#8-4-电子商务风险控制" class="headerlink" title="8.4 电子商务风险控制"></a>8.4 电子商务风险控制</h4><ul>
<li>风险<ul>
<li>账号风险</li>
<li>买家风险</li>
<li>卖家风险</li>
<li>交易风险</li>
</ul>
</li>
<li>风控<ul>
<li>规则引擎</li>
<li>统计模型</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>漫谈系列 架构</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用MongoDb实现分布式Id</title>
    <url>/2017/05/06/micorservice-2017-05-06-mongodb-id/</url>
    <content><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>如何实现分布式id，搜索相关的资料，一般会给出这几种方案：</p>
<ul>
<li>  使用数据库自增Id</li>
<li>  使用reids的incr命令</li>
<li>  使用UUID</li>
<li>  Twitter的snowflake算法</li>
<li>  利用zookeeper生成唯一ID</li>
<li>  MongoDB的ObjectId</li>
</ul>
<span id="more"></span>

<p>另外，在我通过爬取知乎用户id发现，知乎的用户id是32位的，初步断定知乎采用的是md5加密，然后全部转换成小写。至于如何爬取知乎用户信息，见我之前分享的文章。本文采取的技术方案采取的是mogoodb的objectId。</p>
<h3 id="二-mongodb如何实现分布式ID"><a href="#二-mongodb如何实现分布式ID" class="headerlink" title="二.mongodb如何实现分布式ID"></a>二.mongodb如何实现分布式ID</h3><p>MongoDB的ObjectId设计成轻量型的，不同的机器都能用全局唯一的同种方法方便地生成它。MongoDB 从一开始就设计用来作为分布式数据库，处理多个节点是一个核心要求。使其在分片环境中要容易生成得多。</p>
<p>它的格式：<br><img src="http://upload-images.jianshu.io/upload_images/2279594-fa59770ee4c176cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="mongo.png"></p>
<ul>
<li><p>前4 个字节是从标准纪元开始的时间戳，单位为秒。时间戳，与随后的5 个字节组合起来，提供了秒级别的唯一性。由于时间戳在前，这意味着ObjectId 大致会按照插入的顺序排列。这对于某些方面很有用，如将其作为索引提高效率。这4 个字节也隐含了文档创建的时间。绝大多数客户端类库都会公开一个方法从ObjectId 获取这个信息。 </p>
</li>
<li><p>接下来的3 字节是所在主机的唯一标识符。通常是机器主机名的散列值。这样就可以确保不同主机生成不同的ObjectId，不产生冲突。<br>为了确保在同一台机器上并发的多个进程产生的ObjectId 是唯一的，接下来的两字节来自产生ObjectId 的进程标识符（PID）。 </p>
</li>
<li><p>前9 字节保证了同一秒钟不同机器不同进程产生的ObjectId 是唯一的。</p>
</li>
<li><p>后3 字节就是一个自动增加的计数器，确保相同进程同一秒产生的ObjectId 也是不一样的。同一秒钟最多允许每个进程拥有2563（16 777 216）个不同的ObjectId。</p>
</li>
</ul>
<h3 id="三、编码"><a href="#三、编码" class="headerlink" title="三、编码"></a>三、编码</h3><p>在springboot中引入mongodb:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 开启web--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     &lt;!--mongodb --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个实体类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Customer &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    public String id;</span><br><span class="line"></span><br><span class="line">    public String firstName;</span><br><span class="line">    public String lastName;</span><br><span class="line"></span><br><span class="line">    public Customer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Customer(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName &#x3D; firstName;</span><br><span class="line">        this.lastName &#x3D; lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(</span><br><span class="line">                &quot;Customer[id&#x3D;%s, firstName&#x3D;&#39;%s&#39;, lastName&#x3D;&#39;%s&#39;]&quot;,</span><br><span class="line">                id, firstName, lastName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getFirstName() &#123;</span><br><span class="line">        return firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setFirstName(String firstName) &#123;</span><br><span class="line">        this.firstName &#x3D; firstName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getLastName() &#123;</span><br><span class="line">        return lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setLastName(String lastName) &#123;</span><br><span class="line">        this.lastName &#x3D; lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>创建mongodb 接口类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;1.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface CustomerRepository extends MongoRepository&lt;Customer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Customer findByFirstName(String firstName);</span><br><span class="line">    public List&lt;Customer&gt; findByLastName(String lastName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"> @Autowired</span><br><span class="line">    CustomerRepository customerRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line">public void mongodbIdTest()&#123;</span><br><span class="line">Customer customer&#x3D;new Customer(&quot;lxdxil&quot;,&quot;dd&quot;);</span><br><span class="line">        customer&#x3D;customerRepository.save(customer);</span><br><span class="line">        logger.info( &quot;mongodbId:&quot;+customer.getId());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/accessing-data-mongodb/">Accessing Data with MongoDB</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/xjk15082/archive/2011/09/18/2180792.html">MongoDB深究之ObjectId</a></p>
<p><a target="_blank" rel="noopener" href="http://www.runoob.com/mongodb/mongodb-databases-documents-collections.html">MongoDB 教程</a></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>如何使用RedLock实现分布式锁</title>
    <url>/2017/08/06/micorservice-2017-08-10-redlock-lock/</url>
    <content><![CDATA[<p>之前写过一篇文章<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/68957681">《如何在springcloud分布式系统中实现分布式锁？》</a>，由于自己仅仅是阅读了相关的书籍，和查阅了相关的资料，就认为那样的是可行的。那篇文章实现的大概思路是用setNx命令和setEx配合使用。 setNx是一个耗时操作，因为它需要查询这个键是否存在，就算redis的百万的qps，在高并发的场景下，这种操作也是有问题的。关于redis实现分布式锁，redis官方推荐使用redlock。</p>
<span id="more"></span>

<h2 id="一、redlock简介"><a href="#一、redlock简介" class="headerlink" title="一、redlock简介"></a>一、redlock简介</h2><p>在不同进程需要互斥地访问共享资源时，分布式锁是一种非常有用的技术手段。实现高效的分布式锁有三个属性需要考虑：</p>
<ul>
<li>安全属性：互斥，不管什么时候，只有一个客户端持有锁</li>
<li>效率属性A:不会死锁</li>
<li>效率属性B：容错，只要大多数redis节点能够正常工作，客户端端都能获取和释放锁。</li>
</ul>
<p>Redlock是redis官方提出的实现分布式锁管理器的算法。这个算法会比一般的普通方法更加安全可靠。关于这个算法的讨论可以看下<a target="_blank" rel="noopener" href="https://github.com/antirez/redis-doc/blob/master/topics/distlock.md">官方文档</a>。</p>
<h2 id="二、怎么用java使用-redlock"><a href="#二、怎么用java使用-redlock" class="headerlink" title="二、怎么用java使用 redlock"></a>二、怎么用java使用 redlock</h2><p>在pom文件引入redis和redisson依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- redis--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;!-- redisson--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.redisson&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;redisson&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;3.3.2&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>AquiredLockWorker接口类，，主要是用于获取锁后需要处理的逻辑：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;5.</span><br><span class="line"> * 获取锁后需要处理的逻辑</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface AquiredLockWorker&lt;T&gt; &#123;</span><br><span class="line">     T invokeAfterLockAquire() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>DistributedLocker 获取锁管理类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;5.</span><br><span class="line"> * 获取锁管理类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface DistributedLocker &#123;</span><br><span class="line"></span><br><span class="line">     &#x2F;**</span><br><span class="line">      * 获取锁</span><br><span class="line">      * @param resourceName  锁的名称</span><br><span class="line">      * @param worker 获取锁后的处理类</span><br><span class="line">      * @param &lt;T&gt;</span><br><span class="line">      * @return 处理完具体的业务逻辑要返回的数据</span><br><span class="line">      * @throws UnableToAquireLockException</span><br><span class="line">      * @throws Exception</span><br><span class="line">      *&#x2F;</span><br><span class="line">     &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker) throws UnableToAquireLockException, Exception;</span><br><span class="line"></span><br><span class="line">     &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker, int lockTime) throws UnableToAquireLockException, Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>UnableToAquireLockException ，不能获取锁的异常类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;5.</span><br><span class="line"> * 异常类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class UnableToAquireLockException extends RuntimeException &#123;</span><br><span class="line"></span><br><span class="line">    public UnableToAquireLockException() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UnableToAquireLockException(String message) &#123;</span><br><span class="line">        super(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public UnableToAquireLockException(String message, Throwable cause) &#123;</span><br><span class="line">        super(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>RedissonConnector 连接类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;5.</span><br><span class="line"> * 获取RedissonClient连接类</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class RedissonConnector &#123;</span><br><span class="line">    RedissonClient redisson;</span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init()&#123;</span><br><span class="line">        redisson &#x3D; Redisson.create();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public RedissonClient getClient()&#123;</span><br><span class="line">        return redisson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>RedisLocker 类，实现了DistributedLocker：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.redisson.api.RLock;</span><br><span class="line">import org.redisson.api.RedissonClient;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;5.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class RedisLocker  implements DistributedLocker&#123;</span><br><span class="line"></span><br><span class="line">    private final static String LOCKER_PREFIX &#x3D; &quot;lock:&quot;;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RedissonConnector redissonConnector;</span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker) throws InterruptedException, UnableToAquireLockException, Exception &#123;</span><br><span class="line"></span><br><span class="line">        return lock(resourceName, worker, 100);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public &lt;T&gt; T lock(String resourceName, AquiredLockWorker&lt;T&gt; worker, int lockTime) throws UnableToAquireLockException, Exception &#123;</span><br><span class="line">        RedissonClient redisson&#x3D; redissonConnector.getClient();</span><br><span class="line">        RLock lock &#x3D; redisson.getLock(LOCKER_PREFIX + resourceName);</span><br><span class="line">      &#x2F;&#x2F; Wait for 100 seconds seconds and automatically unlock it after lockTime seconds</span><br><span class="line">        boolean success &#x3D; lock.tryLock(100, lockTime, TimeUnit.SECONDS);</span><br><span class="line">        if (success) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                return worker.invokeAfterLockAquire();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        throw new UnableToAquireLockException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">  RedisLocker distributedLocker;</span><br><span class="line">  @RequestMapping(value &#x3D; &quot;&#x2F;redlock&quot;)</span><br><span class="line">  public String testRedlock() throws Exception&#123;</span><br><span class="line"></span><br><span class="line">      CountDownLatch startSignal &#x3D; new CountDownLatch(1);</span><br><span class="line">      CountDownLatch doneSignal &#x3D; new CountDownLatch(5);</span><br><span class="line">      for (int i &#x3D; 0; i &lt; 5; ++i) &#123; &#x2F;&#x2F; create and start threads</span><br><span class="line">          new Thread(new Worker(startSignal, doneSignal)).start();</span><br><span class="line">      &#125;</span><br><span class="line">      startSignal.countDown(); &#x2F;&#x2F; let all threads proceed</span><br><span class="line">      doneSignal.await();</span><br><span class="line">      System.out.println(&quot;All processors done. Shutdown connection&quot;);</span><br><span class="line">      return &quot;redlock&quot;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">   class Worker implements Runnable &#123;</span><br><span class="line">      private final CountDownLatch startSignal;</span><br><span class="line">      private final CountDownLatch doneSignal;</span><br><span class="line"></span><br><span class="line">      Worker(CountDownLatch startSignal, CountDownLatch doneSignal) &#123;</span><br><span class="line">          this.startSignal &#x3D; startSignal;</span><br><span class="line">          this.doneSignal &#x3D; doneSignal;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public void run() &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              startSignal.await();</span><br><span class="line">              distributedLocker.lock(&quot;test&quot;,new AquiredLockWorker&lt;Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                  @Override</span><br><span class="line">                  public Object invokeAfterLockAquire() &#123;</span><br><span class="line">                      doTask();</span><br><span class="line">                      return null;</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">              &#125;);</span><br><span class="line">          &#125;catch (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      void doTask() &#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + &quot; start&quot;);</span><br><span class="line">          Random random &#x3D; new Random();</span><br><span class="line">          int _int &#x3D; random.nextInt(200);</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + &quot; sleep &quot; + _int + &quot;millis&quot;);</span><br><span class="line">          try &#123;</span><br><span class="line">              Thread.sleep(_int);</span><br><span class="line">          &#125; catch (InterruptedException e) &#123;</span><br><span class="line">              e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + &quot; end&quot;);</span><br><span class="line">          doneSignal.countDown();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行测试类：</p>
<blockquote>
<p>Thread-48 start<br>Thread-48 sleep 99millis<br>Thread-48 end<br>Thread-49 start<br>Thread-49 sleep 118millis<br>Thread-49 end<br>Thread-52 start<br>Thread-52 sleep 141millis<br>Thread-52 end<br>Thread-50 start<br>Thread-50 sleep 28millis<br>Thread-50 end<br>Thread-51 start<br>Thread-51 sleep 145millis<br>Thread-51 end</p>
</blockquote>
<p>从运行结果上看，在异步任务的情况下，确实是获取锁之后才能运行线程。不管怎么样，这是redis官方推荐的一种方案，可靠性比较高。有什么问题欢迎留言。</p>
<h2 id="三、参考资料"><a href="#三、参考资料" class="headerlink" title="三、参考资料"></a>三、参考资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/redisson/redisson">https://github.com/redisson/redisson</a></p>
<p><a target="_blank" rel="noopener" href="http://ifeve.com/redis-lock/">《Redis官方文档》用Redis构建分布式锁</a></p>
<p><a target="_blank" rel="noopener" href="https://dzone.com/articles/java-distributed-in-memory-data-model-powered-by-r">A Look at the Java Distributed In-Memory Data Model (Powered by Redis)</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>微服务 分布式锁</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT简介</title>
    <url>/2017/08/11/micorservice-2017-08-11-jwt/</url>
    <content><![CDATA[<p>##什么是JWT</p>
<p>这篇文章选择性翻译于<a target="_blank" rel="noopener" href="https://jwt.io/introduction/">https://jwt.io/introduction/</a></p>
<p>JSON Web Token（JWT）是一种开放标准（RFC 7519），它定义了一种紧凑且字自包含的标准，用于将各方之间的信息地传输为JSON对象。 该信息是通过数字签名进行验证。使用HMAC算法或使用RSA的公钥/私钥对JWT进行签名，所以它的安全性非常高。</p>
<span id="more"></span>

<blockquote>
<p>进一步解释它的特点或者概念：<br>•    紧凑型（compact）：由于是加密后的字符串，JWT数据体积非常的小，可通过 POST参数或HTTP请求头发送。 另外，数据体积小意味着传输速度很快。<br>•    自包含(self-contained)：JWT包含了用户的所有信心，所以避免了每次查询数据库，降低了服务器的负载。</p>
</blockquote>
<h3 id="JWT应用场景"><a href="#JWT应用场景" class="headerlink" title="JWT应用场景"></a>JWT应用场景</h3><p>  一般什么时候应该使用JWT呢？，一般使用在以下场景：</p>
<blockquote>
<p>•    验证：这是使用JWT的最常见的场景。 一旦用户登录，每个后续请求将包括JWT，允许用户访问该令牌允许的路由，服务和资源。 单点登录是一个广泛使用JWT的功能，因为它的开销很小，并且能够在不同的域中轻松使用。<br>•    信息交换：JWT是在各方之间安全传输信息的好方法，因为它们可以被签名，例如使用公钥/私钥对. 另外，当使用标题和有效载荷计算签名时，还可以验证内容是否未被篡改。 </p>
</blockquote>
<h3 id="JWT结构"><a href="#JWT结构" class="headerlink" title="JWT结构"></a>JWT结构</h3><p>JWT由三个部分组成，分别为“.”分隔，三部分组成如下：</p>
<ul>
<li>   Header（头）</li>
<li>   Payload（有效载荷）</li>
<li>   Signature（签名）<br>因此，JWT通常格式如下：</li>
</ul>
<blockquote>
<p>xxxxx.yyyyy.zzzzz</p>
</blockquote>
<p>   现在，依次对这三个组成部分，分开讲解：</p>
<p>####1.    Header<br>标题通常由两部分组成：令牌的类型，即JWT，以及使用的哈希算法，如HMAC SHA256或RSA。<br>比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  “alg”：“HS256”，</span><br><span class="line">  “typ”：“JWT”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将header进行Base64 编码作为JWT的第一部分。</p>
<h4 id="2-Payload"><a href="#2-Payload" class="headerlink" title="2.    Payload"></a>2.    Payload</h4><p>这是JWT的第二部分，包含了用户的一些信息和Cliam(声明、权利)，有三种类型的Cliam：保留，公开和私人声明。<br>一个典型的payload应该如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;admin&quot;: true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将payload进行Base64 编码作为JWT的第二部分。</p>
<h4 id="3-Signature"><a href="#3-Signature" class="headerlink" title="3.    Signature"></a>3.    Signature</h4><pre><code>要创建签名部分，需要使用到用Base64编码后header和payloader，以及秘钥，将它们签名，一个典型的格式如下： 
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure>

<h3 id="JWT是如何使用的"><a href="#JWT是如何使用的" class="headerlink" title="JWT是如何使用的"></a>JWT是如何使用的</h3><p>  <img src="http://img.blog.csdn.net/20170529221517610?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>来说下最常见的应用场景，即认证方面，如图所示。客户端通过用户名密码向服务器请求获取某用户的信息，包括用户一些额外信息，比如权限，这些信息经过加密以JWT形式返回。获取到该JWT的客户端，在以后的每次请求中，都需要携带该JWT，这样做的好处就是每次不需要查询数据库获取该用户的信息，在微服务这样的分布式系统中，可以实现单点登录。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud jwt</tag>
      </tags>
  </entry>
  <entry>
    <title>kong api gateway 初体验</title>
    <url>/2017/09/06/micorservice-2017-09-17-kong-api-gateway/</url>
    <content><![CDATA[<p>kong api gateway 初体验（first sight?）。</p>
<p>Kong是一个可扩展的开源API层（也称为API网关或API中间件）。 Kong运行在任何RESTful API的前面，并通过插件扩展，它们提供超出核心平台的额外功能和服务。<br>Kong最初是在Mashape建立的，用于为其API Marketplace提供超过15,000个API和Microservices，并为超过20万的开发者每月生成数十亿个请求。 今天，Kong被用于小型和大型组织的关键任务部署</p>
<p><img src="https://getkong.org/assets/images/docs/kong-architecture.jpg"></p>
<span id="more"></span>

<h2 id="使用的软件"><a href="#使用的软件" class="headerlink" title="使用的软件"></a>使用的软件</h2><ul>
<li>Unbuntu 虚拟机（有自己的服务器更好）</li>
<li>PostgreSQL</li>
<li>kong </li>
<li>kong-dashboard</li>
<li>docker</li>
<li>spring boot</li>
</ul>
<h2 id="安装-PostgreSQL"><a href="#安装-PostgreSQL" class="headerlink" title="安装 PostgreSQL"></a>安装 PostgreSQL</h2><p>kong 需要使用到数据库，目前支持PostgreSQL和Cassandran ,我选择大象数据库，安装过程省略，可以参考这篇文章。<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html">http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html</a></p>
<p>安装完后建一个kong的用户、密码为kong、建一个kong 数据库:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE USER kong; CREATE DATABASE kong OWNER kong;</span><br></pre></td></tr></table></figure>

<h2 id="安装kong"><a href="#安装kong" class="headerlink" title="安装kong"></a>安装kong</h2><p>下载kong的源文件，下载地址：<a target="_blank" rel="noopener" href="https://getkong.org/install/ubuntu/">https://getkong.org/install/ubuntu/</a></p>
<p>下载完成之后会有这样一个文件kong-community-edition-0.11.0.*.deb，cd到这个文件的目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line">$ sudo apt-get install openssl libpcre3 procps perl</span><br><span class="line">$ sudo dpkg -i kong-community-edition-0.11.0.*.deb</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="配置kong"><a href="#配置kong" class="headerlink" title="配置kong"></a>配置kong</h2><p>配置文档在这里：</p>
<p><a target="_blank" rel="noopener" href="https://getkong.org/docs/0.9.x/configuration/">https://getkong.org/docs/0.9.x/configuration/</a></p>
<p>复制配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cp &#x2F;etc&#x2F;kong&#x2F;kong.conf.default &#x2F;etc&#x2F;kong&#x2F;kong.conf</span><br></pre></td></tr></table></figure>

<p>配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;etc&#x2F;kong&#x2F;kong.conf</span><br><span class="line">&#x2F;etc&#x2F;kong.conf</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开配置文件，里面可以修改很多配置，修改数据库连接，用户名、密码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pg_host &#x3D; 127.0.0.1             # The PostgreSQL host to connect to.</span><br><span class="line">pg_port &#x3D; 5432                  # The port to connect to.</span><br><span class="line">pg_user &#x3D; kong                  # The username to authenticate if required.</span><br><span class="line">pg_password &#x3D; kong              # The password to authenticate if required.</span><br><span class="line">pg_database &#x3D; kong</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>执行以下整合命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kong migrations up [-c &#x2F;path&#x2F;to&#x2F;kong.conf]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动kong :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kong start -c &#x2F;etc&#x2F;kong&#x2F;kong.conf --vv</span><br></pre></td></tr></table></figure>
<p>打开浏览器访问：localhost:8001，浏览器显示了一大串关于kong的json字符串，则启动成功。<br>kong管理端口为8001, 监控端口为8000。</p>
<p>管理端口用rest api对api进行操作，文档地址:<a target="_blank" rel="noopener" href="https://getkong.org/docs/0.8.x/admin-api">https://getkong.org/docs/0.8.x/admin-api</a></p>
<h2 id="安装-kong-dashboard"><a href="#安装-kong-dashboard" class="headerlink" title="安装 kong-dashboard"></a>安装 kong-dashboard</h2><p>kong管理端的第三方网页，地址：<a target="_blank" rel="noopener" href="https://github.com/PGBI/kong-dashboard">https://github.com/PGBI/kong-dashboard</a></p>
<p>支持npm启动，但是没有成功过，直接选择了docker启动。<br>要求先安装docker,docker启动镜像</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Start Kong Dashboard  8080端口启动</span><br><span class="line">docker run -d -p 8080:8080 pgbi&#x2F;kong-dashboard:v2</span><br><span class="line"></span><br><span class="line"># Start Kong Dashboard on a custom port  指定一个端口启动</span><br><span class="line">docker run -d -p [port]:8080 pgbi&#x2F;kong-dashboard:v2</span><br><span class="line"></span><br><span class="line"># Start Kong Dashboard with basic auth  8080端口启动，带一个用户基本认证</span><br><span class="line">docker run -d -p 8080:8080 pgbi&#x2F;kong-dashboard:v2 -a user&#x3D;password</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="演示实例"><a href="#演示实例" class="headerlink" title="演示实例"></a>演示实例</h2><p>在电脑上开启一个spring boot 工程有一个api接口为<a target="_blank" rel="noopener" href="http://10.10.20.187:8762/hi">http://10.10.20.187:8762/hi</a></p>
<p>其实kong管理api有一系列的接口，直接用crul 就可以完成管理，但是有第三个kong-dashboard，我就用了kong-dashboard的管理界面进行操作。</p>
<p>在上一小节启动docker之后，打开网页<a href="http://192.168.86.128:8080（我unbuntu虚拟机的host为192.168.86.128）,填写kong的管理urlhttp://192.168.86.128:8001，就可以进入了。">http://192.168.86.128:8080（我unbuntu虚拟机的host为192.168.86.128）,填写kong的管理urlhttp://192.168.86.128:8001，就可以进入了。</a></p>
<p>![](<a target="_blank" rel="noopener" href="http://chris/">http://chris</a> .oss-cn-hangzhou.aliyuncs.com/blog/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170830111958.png?x-oss-process=style/caijai)</p>
<p>在kong管理界面创建一个api接口：</p>
<p>填写相关的参数即可，创建完成后如下：</p>
<p>![](<a target="_blank" rel="noopener" href="http://chris/">http://chris</a> .oss-cn-hangzhou.aliyuncs.com/blog/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170830112038.png?x-oss-process=style/caijai)</p>
<p>在浏览器上访问：<a target="_blank" rel="noopener" href="http://192.168.86.128:8000/hi">http://192.168.86.128:8000/hi</a></p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>添加api限流插件,一个ip一分钟10次。</p>
<p>![](<a target="_blank" rel="noopener" href="http://chris/">http://chris</a> .oss-cn-hangzhou.aliyuncs.com/blog/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170830112602.png?x-oss-process=style/caijai)</p>
<p>访问超过10次后，会拒绝访问。</p>
<p>添加file-log的插件,文件存放目录为/temp/file.log  ：</p>
<p>![](<a target="_blank" rel="noopener" href="http://chris/">http://chris</a> .oss-cn-hangzhou.aliyuncs.com/blog/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20170830114620.png?x-oss-process=style/caijai)</p>
<p>再次访问：<a target="_blank" rel="noopener" href="http://192.168.86.128:8000/hi">http://192.168.86.128:8000/hi</a></p>
<p>可以在打开/temp/file.log看见里面的日志信息。</p>
<p>kong 支持了20中插件，插件地址：<a target="_blank" rel="noopener" href="https://getkong.org/plugins/">https://getkong.org/plugins/</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://getkong.org/about/">https://getkong.org/about/</a></p>
<p><a target="_blank" rel="noopener" href="http://www.cnblogs.com/SummerinShire/category/861287.html">http://www.cnblogs.com/SummerinShire/category/861287.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/f9a2210f6722">http://www.jianshu.com/p/f9a2210f6722</a></p>
<p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/63180">https://yq.aliyun.com/articles/63180</a></p>
<p><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html">http://www.ruanyifeng.com/blog/2013/12/getting_started_with_postgresql.html</a></p>
]]></content>
      <categories>
        <category>nginx kong</category>
      </categories>
      <tags>
        <tag>nginx kong</tag>
      </tags>
  </entry>
  <entry>
    <title>openresty最佳案例案例-汇总</title>
    <url>/2018/01/01/openresty-2018-01-01-openresty-all/</url>
    <content><![CDATA[<p>权限控制在任何的系统中都为一个基本模块，没有权限，就不要谈系统。权限控制的重要性不言而喻。在我所做的Spring Cloud微服务系统，采用的权限控制框架为Spring Cloud Oauth2和Spring Boot Securtiy，这两个框架组合构成了一个强大的权限安全模块。搭建好，设置好，其实是非常简单的。Spring Boot Securtiy是对方法层面的控制，所以要在方法上加注解。随着业务的扩张，注解这种方式无疑给开发人员带来了非常大的工作量，由于开发人员的不规范，甚至连注解都不愿意写了。我在思考能不能废弃掉Spring Cloud Oauth2和Spring Boot Securtiy，废弃掉注解，让开发人员从注解中解放出来。</p>
<p>带着这样的思考，我首先想到的是kong api gateway，kong提供了非常多的插件化的模块，能够满足大部分的业务需求，但不能满足RBAC（基于角色的权限控制）。后来就想自己去实现。实现的过程就是不断学习和探索的过程，我从0基础的lua和openresty，花了三天的时间就实现了本系列文章所写的全部功能。另外花了两个周末把这系列文章整理出来。</p>
<p>之所以说是整理文章，因为很多东西并非我原创，甚至直接拿了很多资料、博客的代码，直接复制粘贴。那我为什么要粘贴，为什么不自己写？一是个人时间精力有限，二是已经有了轮子，为什么要自己造一个？三是，为了保证系列文章的完整性。感谢openresty的作者章亦春、openresty 最佳实践的作者<a target="_blank" rel="noopener" href="https://github.com/moonbingbing">WenMing</a>、<a target="_blank" rel="noopener" href="http://jinnianshilongnian.iteye.com/">张开涛</a>等众多开源者和知名博主。</p>
<span id="more"></span>


<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/78616591">Openresty最佳案例 | 第1篇：Nginx介绍</a></li>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/78616622">Openresty最佳案例 | 第2篇：Lua入门</a></li>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/78616645">Openresty最佳案例 | 第3篇：Openresty安装</a></li>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/78616660">Openresty最佳案例 | 第4篇：OpenResty常见的api</a></li>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/78616672">Openresty最佳案例 | 第5篇：http和c_json模块</a></li>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/78616698">Openresty最佳案例 | 第6篇：OpenResty连接Mysql</a></li>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/78616714">Openresty最佳案例 | 第7篇：模块开发、OpenResty连接Redis</a></li>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/78616738">Openresty最佳案例 | 第8篇：RBAC介绍、sql和redis模块工具类</a></li>
<li> <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/78616779">Openresty最佳案例 | 第9篇：Openresty实现的网关权限控制</a></li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>所以在此说明下，我参考了甚至copy了以下的博客或者资料：</p>
<p>openresty官方网站：<a target="_blank" rel="noopener" href="http://openresty.org/en/">http://openresty.org/en/</a> </p>
<p>openresty 最佳实践： <a target="_blank" rel="noopener" href="http://wiki.jikexueyuan.com/project/openresty/">http://wiki.jikexueyuan.com/project/openresty/</a></p>
<p>跟我学Nginx+Lua开发：<a target="_blank" rel="noopener" href="http://www.iteye.com/blogs/subjects/nginx-lua">http://www.iteye.com/blogs/subjects/nginx-lua</a></p>
<p>lua入门教程：<a target="_blank" rel="noopener" href="http://www.runoob.com/lua/lua-tutorial.html">http://www.runoob.com/lua/lua-tutorial.html</a></p>
<h2 id="系列文章的源码下载"><a href="#系列文章的源码下载" class="headerlink" title="系列文章的源码下载"></a>系列文章的源码下载</h2><p>本系列的文章源码下载地址：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/openresty-best-samples">https://github.com/forezp/openresty-best-samples</a></p>
]]></content>
      <categories>
        <category>Openresty</category>
      </categories>
      <tags>
        <tag>Openresty Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Openresrt最佳案例 | 第1篇：Nginx介绍</title>
    <url>/2018/01/01/openresty-2018-01-01-openresty-best-practice-1-Nginx/</url>
    <content><![CDATA[<p>Nginx是一个高性能的Web 服务器，同时是一个高效的反向代理服务器，它还是一个IMAP/POP3/SMTP<br>代理服务器。</p>
<p>由于Nginx采用的是事件驱动的架构，能够处理并发百万级别的tcp连接，高度的模块化设计和自由的BSD许可，使得Nginx有着非常丰富的第三方模块。比如Openresty、API网关Kong。</p>
<blockquote>
<p>BSD开源协议是一个给予使用者很大自由的协议。基本上使用者可以”为所欲为”,可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。</p>
</blockquote>
<span id="more"></span>

<h2 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a>Nginx的优点</h2><ul>
<li>高并发响应性能非常好，官方Nginx处理静态文件并发5w/s</li>
<li>反向代理性能非常强。（可用于负载均衡）</li>
<li>内存和cpu占用率低。（为Apache的1/5-1/10）</li>
<li>对后端服务有健康检查功能。</li>
<li>支持PHP cgi方式和fastcgi方式。</li>
<li>配置代码简洁且容易上手。</li>
</ul>
<h2 id="Nginx的安装"><a href="#Nginx的安装" class="headerlink" title="Nginx的安装"></a>Nginx的安装</h2><p>Centos系统安装，请参考这里<a target="_blank" rel="noopener" href="http://www.linuxidc.com/Linux/2016-09/134907.htm%E3%80%82%E5%85%88%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E4%B8%8B%E5%AE%83%E7%9A%84%E6%96%87%E7%AB%A0%E3%80%82">http://www.linuxidc.com/Linux/2016-09/134907.htm。先复制粘贴下它的文章。</a></p>
<h3 id="1-gcc-安装"><a href="#1-gcc-安装" class="headerlink" title="1.gcc 安装"></a>1.gcc 安装</h3><p>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p>
<blockquote>
<p>yum install gcc-c++</p>
</blockquote>
<h3 id="2-PCRE-pcre-devel-安装"><a href="#2-PCRE-pcre-devel-安装" class="headerlink" title="2.PCRE pcre-devel 安装"></a>2.PCRE pcre-devel 安装</h3><p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</p>
<blockquote>
<p>yum install -y pcre pcre-devel</p>
</blockquote>
<h3 id="3-zlib-安装"><a href="#3-zlib-安装" class="headerlink" title="3.zlib 安装"></a>3.zlib 安装</h3><p>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p>
<blockquote>
<p>yum install -y zlib zlib-devel</p>
</blockquote>
<h3 id="4-OpenSSL-安装"><a href="#4-OpenSSL-安装" class="headerlink" title="4.OpenSSL 安装"></a>4.OpenSSL 安装</h3><p>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p>
<blockquote>
<p>yum install -y openssl openssl-devel</p>
</blockquote>
<h3 id="5-官网下载"><a href="#5-官网下载" class="headerlink" title="5.官网下载"></a>5.官网下载</h3><p>1.直接下载.tar.gz安装包，地址：<a target="_blank" rel="noopener" href="https://nginx.org/en/download.html">https://nginx.org/en/download.html</a></p>
<p>2.使用wget命令下载（推荐）。</p>
<blockquote>
<p>wget -c <a target="_blank" rel="noopener" href="https://nginx.org/download/nginx-1.10.1.tar.gz">https://nginx.org/download/nginx-1.10.1.tar.gz</a></p>
</blockquote>
<h3 id="6-解压"><a href="#6-解压" class="headerlink" title="6.解压"></a>6.解压</h3><p>依然是直接命令：</p>
<blockquote>
<p>tar -zxvf nginx-1.10.1.tar.gz<br>cd nginx-1.10.1</p>
</blockquote>
<h3 id="7-配置"><a href="#7-配置" class="headerlink" title="7.配置"></a>7.配置</h3><p>其实在 nginx-1.10.1 版本中你就不需要去配置相关东西，默认就可以了。当然，如果你要自己配置目录也是可以的。<br>使用默认配置</p>
<blockquote>
<p>./configure</p>
</blockquote>
<h3 id="8-编译安装"><a href="#8-编译安装" class="headerlink" title="8.编译安装"></a>8.编译安装</h3><blockquote>
<p>make<br>make install</p>
</blockquote>
<p>查找安装路径：</p>
<blockquote>
<p>whereis nginx</p>
</blockquote>
<h2 id="Nginx的模块组成"><a href="#Nginx的模块组成" class="headerlink" title="Nginx的模块组成"></a>Nginx的模块组成</h2><p>Nginx的模块从结构上分为核心模块、基础模块和第三方模块：</p>
<ul>
<li>核心模块：HTTP模块、EVENT模块和MAIL模块</li>
<li>基础模块：HTTP Access模块、HTTP FastCGI模块、HTTP Proxy模块和HTTP Rewrite模块，</li>
<li>第三方模块：HTTP Upstream Request Hash模块、Notice模块和HTTP Access Key模块。</li>
</ul>
<p>Nginx的高并发得益于其采用了epoll模型，与传统的服务器程序架构不同，epoll是linux内核2.6以后才出现的。Nginx采用epoll模型，异步非阻塞，而Apache采用的是select模型。</p>
<ul>
<li>Select特点：select 选择句柄的时候，是遍历所有句柄，也就是说句柄有事件响应时，select需要遍历所有句柄才能获取到哪些句柄有事件通知，因此效率是非常低。</li>
<li>epoll的特点：epoll对于句柄事件的选择不是遍历的，是事件响应的，就是句柄上事件来就马上选择出来，不需要遍历整个句柄链表，因此效率非常高。</li>
</ul>
<h2 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h2><p>nginx 环境变量配置：</p>
<blockquote>
<p>export PATH=$PATH:/usr/servers/nginx/sbin</p>
</blockquote>
<ul>
<li>查看nginx进程<br>ps -ef|grep nginx</li>
</ul>
<ul>
<li><p>启动nginx<br>nginx<br>启动结果显示nginx的主线程和工作线程，工作线程的数量跟nginx.conf中的配置参数worker_processes有关。</p>
</li>
<li><p>平滑启动nginx<br>kill -HUP <code>cat /var/run/nginx.pid</code><br>或者<br>nginx -s reload</p>
</li>
<li><p>强制停止nginx<br>pkill -9 nginx</p>
</li>
<li><p>检查对nginx.conf文件的修改是否正确<br>nginx -t </p>
</li>
<li><p>停止nginx的命令<br>nginx -s stop或者pkill nginx</p>
</li>
<li><p>查看nginx的版本信息<br>nginx -v</p>
</li>
<li><p>查看完整的nginx的配置信息<br>nginx -V</p>
</li>
</ul>
<h2 id="Nginx的配置"><a href="#Nginx的配置" class="headerlink" title="Nginx的配置"></a>Nginx的配置</h2><p>通常情况下，Nginx的配置在Ngix的安装目录下的/conf/config.default 文件里,基本配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">worker_process # 表示工作进程的数量，一般设置为cpu的核数</span><br><span class="line"></span><br><span class="line">worker_connections # 表示每个工作进程的最大连接数</span><br><span class="line"></span><br><span class="line">server&#123;&#125; # 块定义了虚拟主机</span><br><span class="line">    listen # 监听端口</span><br><span class="line">    server_name # 监听域名</span><br><span class="line">    location &#123;&#125; # 是用来为匹配的 URI 进行配置，URI 即语法中的“&#x2F;uri&#x2F;”</span><br><span class="line">    location &#x2F;&#123;&#125; # 匹配任何查询，因为所有请求都以 &#x2F; 开头</span><br><span class="line">        root # 指定对应uri的资源查找路径，这里html为相对路径，完整路径为</span><br><span class="line">        # &#x2F;opt&#x2F;nginx-1.7.7&#x2F;html&#x2F;</span><br><span class="line">        index # 指定首页index文件的名称，可以配置多个，以空格分开。如有多</span><br><span class="line">        # 个，按配置顺序查找。</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>location 常用配置如下：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>location = /uri</td>
<td>= 表示精确匹配，只有完全匹配上才能生效</td>
</tr>
<tr>
<td>location ^~ /uri</td>
<td>^~ 开头对URL路径进行前缀匹配，并且在正则之前。</td>
</tr>
<tr>
<td>location ~ pattern</td>
<td>开头表示区分大小写的正则匹配</td>
</tr>
<tr>
<td>location ~* pattern</td>
<td>开头表示不区分大小写的正则匹配</td>
</tr>
<tr>
<td>location /uri</td>
<td>不带任何修饰符，也表示前缀匹配，但是在正则匹配之后</td>
</tr>
<tr>
<td>location /</td>
<td>通用匹配，任何未匹配到其它location的请求都会匹配到，相当于switch中的default</td>
</tr>
</tbody></table>
<p>Nginx的常用配置非常多，以下内容摘自于布尔教育课件，仅供参考：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#定义Nginx运行的用户和用户组</span><br><span class="line">user  www www;</span><br><span class="line">#启动进程,通常设置成和cpu的数量相等</span><br><span class="line">worker_processes  8;</span><br><span class="line">worker_cpu_affinity 00000001 00000010 00000100 00001000 00010000 00100000 01000000 10000000;</span><br><span class="line">#为每个进程分配cpu，上例中将8个进程分配到8个cpu，当然可以写多个，或者将一个进程分配到多个cpu。</span><br><span class="line">worker_rlimit_nofile 102400;</span><br><span class="line">#这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打</span><br><span class="line">#开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀</span><br><span class="line">#，所以最好与ulimit -n的值保持一致。</span><br><span class="line"></span><br><span class="line">#全局错误日志及PID文件</span><br><span class="line">error_log  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;error.log; </span><br><span class="line">#错误日志定义等级，[ debug | info | notice | warn | error | crit ]</span><br><span class="line">pid        &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;nginx.pid;</span><br><span class="line"></span><br><span class="line">#一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（系统的值ulimit -n）与nginx进程数相除，但是nginx分配请求并不均匀.</span><br><span class="line">#所以建议与ulimit -n的值保持一致。</span><br><span class="line">worker_rlimit_nofile 65535;</span><br><span class="line"></span><br><span class="line">#工作模式及连接数上限</span><br><span class="line">events &#123;</span><br><span class="line">    use   epoll;             	#epoll是多路复用IO(I&#x2F;O Multiplexing)中的一种方式,但是仅用于linux2.6以上内核,可以大大提高nginx的性能</span><br><span class="line">    worker_connections  102400;	#单个后台worker process进程的最大并发链接数 （最大连接数&#x3D;连接数*进程数）</span><br><span class="line">    multi_accept on; #尽可能多的接受请求</span><br><span class="line">&#125;</span><br><span class="line">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span><br><span class="line">http &#123;</span><br><span class="line">    #设定mime类型,类型由mime.type文件定义</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    #设定日志格式</span><br><span class="line">    access_log    &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;log&#x2F;nginx&#x2F;access.log;</span><br><span class="line">	 sendfile      on;</span><br><span class="line">    #sendfile 指令指定 nginx 是否调用 sendfile 函数（zero copy 方式）来输出文件，对于普通应用必须设为 on</span><br><span class="line">	#如果用来进行下载等应用磁盘IO重负载应用，可设置为 off，以平衡磁盘与网络I&#x2F;O处理速度，降低系统的uptime.</span><br><span class="line">	#autoindex  on;  #开启目录列表访问，合适下载服务器，默认关闭。</span><br><span class="line">	tcp_nopush on; #防止网络阻塞</span><br><span class="line">	keepalive_timeout 60;</span><br><span class="line">	#keepalive超时时间，客户端到服务器端的连接持续有效时间,当出现对服务器的后,继请求时,keepalive-timeout功能可避免建立或重新建立连接。</span><br><span class="line">    tcp_nodelay   on; #提高数据的实时响应性</span><br><span class="line">   #开启gzip压缩</span><br><span class="line">   gzip on;</span><br><span class="line">	gzip_min_length  1k;</span><br><span class="line">	gzip_buffers     4 16k;</span><br><span class="line">	gzip_http_version 1.1;</span><br><span class="line">	gzip_comp_level 2; #压缩级别大小，最大为9，值越小，压缩后比例越小，CPU处理更快。</span><br><span class="line">	#值越大，消耗CPU比较高。</span><br><span class="line">	gzip_types       text&#x2F;plain application&#x2F;x-javascript text&#x2F;css application&#x2F;xml;</span><br><span class="line">	gzip_vary on;</span><br><span class="line">	client_max_body_size 10m;      #允许客户端请求的最大单文件字节数</span><br><span class="line">    client_body_buffer_size 128k;  #缓冲区代理缓冲用户端请求的最大字节数，</span><br><span class="line">    proxy_connect_timeout 90;      #nginx跟后端服务器连接超时时间(代理连接超时)</span><br><span class="line">    proxy_send_timeout 90;         #后端服务器数据回传时间(代理发送超时)</span><br><span class="line">    proxy_read_timeout 90;         #连接成功后，后端服务器响应时间(代理接收超时)</span><br><span class="line">    proxy_buffer_size 4k;          #设置代理服务器（nginx）保存用户头信息的缓冲区大小</span><br><span class="line">    proxy_buffers 4 32k;           #proxy_buffers缓冲区，网页平均在32k以下的话，这样设置</span><br><span class="line">    proxy_busy_buffers_size 64k;   #高负荷下缓冲大小（proxy_buffers*2）</span><br><span class="line">	</span><br><span class="line">    #设定请求缓冲</span><br><span class="line">    large_client_header_buffers  4 4k;</span><br><span class="line">	client_header_buffer_size 4k;</span><br><span class="line">	#客户端请求头部的缓冲区大小，这个可以根据你的系统分页大小来设置，一般一个请求的头部大小不会超过1k</span><br><span class="line">	#不过由于一般系统分页都要大于1k，所以这里设置为分页大小。分页大小可以用命令getconf PAGESIZE取得。</span><br><span class="line">	open_file_cache max&#x3D;102400 inactive&#x3D;20s;</span><br><span class="line">	#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span><br><span class="line">	open_file_cache_valid 30s;</span><br><span class="line">	#这个是指多长时间检查一次缓存的有效信息。</span><br><span class="line">	open_file_cache_min_uses 1;</span><br><span class="line">	#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive</span><br><span class="line">    #包含其它配置文件，如自定义的虚拟主机</span><br><span class="line">    include vhosts.conf;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置详解2如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">	#这里为后端服务器wugk应用集群配置，根据后端实际情况修改即可，tdt_wugk为负载均衡名称，可以任意指定</span><br><span class="line">	#但必须跟vhosts.conf虚拟主机的pass段一致，否则不能转发后端的请求。weight配置权重，在fail_timeout内检查max_fails次数，失败则剔除均衡。</span><br><span class="line">	upstream tdt_wugk &#123;</span><br><span class="line">		server   127.0.0.1:8080 weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;30s;</span><br><span class="line">		server   127.0.0.1:8081 weight&#x3D;1 max_fails&#x3D;2 fail_timeout&#x3D;30s;</span><br><span class="line">	&#125;</span><br><span class="line">   #虚拟主机配置</span><br><span class="line">	server &#123;</span><br><span class="line">		#侦听80端口</span><br><span class="line">        listen       80;</span><br><span class="line">        #定义使用www.wuguangke.cn访问</span><br><span class="line">        server_name  www.wuguangke.cn;</span><br><span class="line">        #设定本虚拟主机的访问日志</span><br><span class="line">        access_log  logs&#x2F;access.log  main;</span><br><span class="line">			root   &#x2F;data&#x2F;webapps&#x2F;wugk;  #定义服务器的默认网站根目录位置</span><br><span class="line">        index index.php index.html index.htm;   #定义首页索引文件的名称</span><br><span class="line">        #默认请求</span><br><span class="line">        location ~ &#x2F;&#123;</span><br><span class="line">          root   &#x2F;data&#x2F;www&#x2F;wugk;      #定义服务器的默认网站根目录位置</span><br><span class="line">          index index.php index.html index.htm;   #定义首页索引文件的名称</span><br><span class="line">          #以下是一些反向代理的配置.</span><br><span class="line">		  proxy_next_upstream http_502 http_504 error timeout invalid_header;</span><br><span class="line">		  #如果后端的服务器返回502、504、执行超时等错误，自动将请求转发到upstream负载均衡池中的另一台服务器，实现故障转移。</span><br><span class="line">          proxy_redirect off;</span><br><span class="line">          #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span><br><span class="line">          proxy_set_header Host $host;</span><br><span class="line">          proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">          proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">		   proxy_pass  http:&#x2F;&#x2F;tdt_wugk;     #请求转向后端定义的均衡模块</span><br><span class="line">       &#125;</span><br><span class="line">	   </span><br><span class="line">        # 定义错误提示页面</span><br><span class="line">			error_page   500 502 503 504 &#x2F;50x.html;  </span><br><span class="line">            location &#x3D; &#x2F;50x.html &#123;</span><br><span class="line">            root   html;</span><br><span class="line">        &#125;</span><br><span class="line">		#配置Nginx动静分离，定义的静态页面直接从Nginx发布目录读取。</span><br><span class="line">		location ~ .*\.(html|htm|gif|jpg|jpeg|bmp|png|ico|txt|js|css)$</span><br><span class="line">		&#123;</span><br><span class="line">			root &#x2F;data&#x2F;www&#x2F;wugk;</span><br><span class="line">			#expires定义用户浏览器缓存的时间为3天，如果静态页面不常更新，可以设置更长，这样可以节省带宽和缓解服务器的压力。</span><br><span class="line">			expires      3d;</span><br><span class="line">		&#125;</span><br><span class="line">        #PHP脚本请求全部转发到 FastCGI处理. 使用FastCGI默认配置.</span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            root &#x2F;root;</span><br><span class="line">            fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">            fastcgi_index index.php;</span><br><span class="line">            fastcgi_param SCRIPT_FILENAME &#x2F;data&#x2F;www&#x2F;wugk$fastcgi_script_name;</span><br><span class="line">            include fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">        #设定查看Nginx状态的地址</span><br><span class="line">        location &#x2F;NginxStatus &#123;</span><br><span class="line">            stub_status  on;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Nginx-内置绑定变量"><a href="#Nginx-内置绑定变量" class="headerlink" title="Nginx 内置绑定变量"></a>Nginx 内置绑定变量</h2><table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>$arg_name</td>
<td>请求中的name参数</td>
</tr>
<tr>
<td>$args</td>
<td>请求中的参数</td>
</tr>
<tr>
<td>$binary_remote_addr</td>
<td>远程地址的二进制表示</td>
</tr>
<tr>
<td>$body_bytes_sent</td>
<td>已发送的消息体字节数</td>
</tr>
<tr>
<td>$content_length HTTP</td>
<td>请求信息里的”Content-Length”</td>
</tr>
<tr>
<td>$content_type</td>
<td>请求信息里的”Content-Type”</td>
</tr>
<tr>
<td>$document_root</td>
<td>针对当前请求的根路径设置值</td>
</tr>
<tr>
<td>$document_uri</td>
<td>与$uri相同; 比如 /test2/test.php</td>
</tr>
<tr>
<td>$host</td>
<td>请求信息中的”Host”，如果请求中没有Host行，则等于设置的服务器名</td>
</tr>
<tr>
<td>$hostname</td>
<td>机器名使用 gethostname系统调用的值</td>
</tr>
<tr>
<td>$http_cookie</td>
<td>cookie 信息</td>
</tr>
<tr>
<td>$http_referer</td>
<td>引用地址</td>
</tr>
<tr>
<td>$http_user_agent</td>
<td>客户端代理信息</td>
</tr>
<tr>
<td>$http_via</td>
<td>最后一个访问服务器的Ip地址。</td>
</tr>
<tr>
<td>$http_x_forwarded_for</td>
<td>相当于网络访问路径</td>
</tr>
<tr>
<td>$is_args</td>
<td>如果请求行带有参数，返回“?”，否则返回空字符串</td>
</tr>
<tr>
<td>$limit_rate</td>
<td>对连接速率的限制</td>
</tr>
<tr>
<td>$nginx_version</td>
<td>当前运行的nginx版本号</td>
</tr>
<tr>
<td>$pid worker</td>
<td>进程的PID</td>
</tr>
<tr>
<td>$query_string</td>
<td>与$args相同</td>
</tr>
<tr>
<td>$realpath_root</td>
<td>按root指令或alias指令算出的当前请求的绝对路径。其中的符号链接都会解析成真是文件路径，使用 Nginx 内置绑定变量</td>
</tr>
<tr>
<td>207$remote_addr</td>
<td>客户端IP地址</td>
</tr>
<tr>
<td>$remote_port</td>
<td>客户端端口号</td>
</tr>
<tr>
<td>$remote_user</td>
<td>客户端用户名，认证用</td>
</tr>
<tr>
<td>$request</td>
<td>用户请求</td>
</tr>
<tr>
<td>$request_body</td>
<td>这个变量（0.7.58+） 包含请求的主要信息。在使用proxy_pass或fastcgi_pass指令的location中比较有意义</td>
</tr>
<tr>
<td>$request_body_file</td>
<td>客户端请求主体信息的临时文件名</td>
</tr>
<tr>
<td>$request_completion</td>
<td>如果请求成功，设为”OK”；如果请求未完成或者不是一系列请求中最后一部分则设为空</td>
</tr>
<tr>
<td>$request_filename</td>
<td>当前请求的文件路径名，比如/opt/nginx/www/test.php</td>
</tr>
<tr>
<td>$request_method</td>
<td>请求的方法，比如”GET”、”POST”等</td>
</tr>
<tr>
<td>$request_uri</td>
<td>请求的URI，带参数</td>
</tr>
<tr>
<td>$scheme</td>
<td>所用的协议，比如http或者是https</td>
</tr>
<tr>
<td>$server_addr</td>
<td>服务器地址，如果没有用listen指明服务器地址，使用这个变量将发起一次系统调用以取得地址(造成资源浪费)</td>
</tr>
<tr>
<td>$server_name</td>
<td>请求到达的服务器名</td>
</tr>
<tr>
<td>$server_port</td>
<td>请求到达的服务器端口号</td>
</tr>
<tr>
<td>$server_protocol</td>
<td>请求的协议版本，”HTTP/1.0”或”HTTP/1.1”</td>
</tr>
<tr>
<td>$uri</td>
<td>请求的URI，可能和最初的值有不同，比如经过重定向之类的</td>
</tr>
</tbody></table>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://www.linuxidc.com/Linux/2016-09/134907.htm">http://www.linuxidc.com/Linux/2016-09/134907.htm</a></p>
<p><a target="_blank" rel="noopener" href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx/nginx.html">https://moonbingbing.gitbooks.io/openresty-best-practices/content/ngx/nginx.html</a></p>
<p>布尔教育课件</p>
]]></content>
      <categories>
        <category>Openresty</category>
      </categories>
      <tags>
        <tag>Openresty Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Openresrt最佳案例 | 第2篇：Lua入门</title>
    <url>/2018/01/01/openresty-2018-01-01-openresty-best-practice-2-Lua/</url>
    <content><![CDATA[<blockquote>
<p>Lua 是一种轻量小巧的脚本语言，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能。</p>
</blockquote>
<blockquote>
<p>Lua 是巴西里约热内卢天主教大学（Pontifical Catholic University of Rio de Janeiro）里的一个研究小组，由Roberto Ierusalimschy、Waldemar Celes 和 Luiz Henrique de Figueiredo所组成并于1993年开发。<br>               —摘抄 <a target="_blank" rel="noopener" href="http://www.runoob.com/lua/lua-tutorial.html">http://www.runoob.com/lua/lua-tutorial.html</a></p>
</blockquote>
<span id="more"></span>

<h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>注意： 在上一篇文章中，OpenResty已经有了Lua的环境，这里安装的是单独的Lua环境，用于学习和开发Lua。大多数的电脑是Windowds版本的电脑，Windows版本下载地址<a target="_blank" rel="noopener" href="http://luaforge.net/projects/luaforwindows/%E3%80%82">http://luaforge.net/projects/luaforwindows/。</a></p>
<p>Linux和Mac电脑下载地址：<a target="_blank" rel="noopener" href="http://luajit.org/download.html%EF%BC%8C%E5%AE%89%E8%A3%85%E5%91%BD%E4%BB%A4%E5%A6%82%E4%B8%8B%EF%BC%9A">http://luajit.org/download.html，安装命令如下：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget http:&#x2F;&#x2F;luajit.org&#x2F;download&#x2F;LuaJIT-2.1.0-beta1.tar.gz</span><br><span class="line"></span><br><span class="line">tar -xvf LuaJIT-2.1.0-beta1.tar.gz</span><br><span class="line">cd LuaJIT-2.1.0-beta1</span><br><span class="line">make</span><br><span class="line">sudo make install</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>使用IDEA开发的同学，可以通过安装插件的形式来集成Lua的环境，插件名为EmmyLua，安装插件后，在Idea的右侧栏就会出现Lua的图标，点击图标，就会出现运行Lua代码的窗口。建议使用该插件，可以免去安装Lua环境的麻烦。</p>
<h2 id="第一个Lua程序"><a href="#第一个Lua程序" class="headerlink" title="第一个Lua程序"></a>第一个Lua程序</h2><p>安装好环境后，我采用EmmyLua插件的形式，对Lua的入门语法进行一个简单的讲解。<br>打开EmmyLua的终端，在终端上输入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;hi you&quot;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>按ctrl+enter，终端显示：</p>
<blockquote>
<p>hi you</p>
</blockquote>
<h2 id="Lua基本数据类型"><a href="#Lua基本数据类型" class="headerlink" title="Lua基本数据类型"></a>Lua基本数据类型</h2><p>lua的基本数据类型有nil、string、boolean、number、function类型。</p>
<h3 id="nil-类型"><a href="#nil-类型" class="headerlink" title="nil 类型"></a>nil 类型</h3><p>nil类似于Java中的null ，表示空值。变量第一次赋值为nil。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local num</span><br><span class="line">print(num)</span><br><span class="line">num&#x3D;100</span><br><span class="line">print(num)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>终端输出：</p>
<blockquote>
<p>nil</p>
<p>100</p>
</blockquote>
<h3 id="number-数字"><a href="#number-数字" class="headerlink" title="number (数字)"></a>number (数字)</h3><p>Number 类型用于表示实数，和 Java里面的 double 类型很类似。可以使用数学函数<br>math.floor（向下取整） 和 math.ceil（向上取整） 进行取整操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">local order &#x3D; 3.99</span><br><span class="line">local score &#x3D; 98.01</span><br><span class="line">print(math.floor(order))</span><br><span class="line">print(math.ceil(score))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出：</p>
<blockquote>
<p>3</p>
<p>99</p>
</blockquote>
<h3 id="string-字符串"><a href="#string-字符串" class="headerlink" title="string 字符串"></a>string 字符串</h3><p>Lua 中有三种方式表示字符串:<br>1、使用一对匹配的单引号。例：’hello’。<br>2、使用一对匹配的双引号。例：”abclua<br>3.字符串还可以用一种长括号（即[[ ]]） 括起来的方式定义</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ocal str1 &#x3D; &#39;hello world&#39;</span><br><span class="line">local str2 &#x3D; &quot;hello lua&quot;</span><br><span class="line">local str3 &#x3D; [[&quot;add\name&quot;,&#39;hello&#39;]]</span><br><span class="line">local str4 &#x3D; [&#x3D;[string have a [[]].]&#x3D;]</span><br><span class="line">print(str1) --&gt;output:hello world</span><br><span class="line">print(str2) --&gt;output:hello lua</span><br><span class="line">print(str3) --&gt;output:&quot;add\name&quot;,&#39;hello&#39;</span><br><span class="line">print(str4) --</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="table-表"><a href="#table-表" class="headerlink" title="table (表)"></a>table (表)</h3><p>Table 类型实现了一种抽象的“关联数组”。“关联数组”是一种具有特殊索引方式的数组，索引通常是字符串（string） 或者 number 类型，但也可以是除 nil 以外的任意类型的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local corp &#x3D; &#123;</span><br><span class="line">    web &#x3D; &quot;www.google.com&quot;, --索引为字符串，key &#x3D; &quot;web&quot;,</span><br><span class="line">                              -- value &#x3D; &quot;www.google.com&quot;</span><br><span class="line">    telephone &#x3D; &quot;12345678&quot;, --索引为字符串</span><br><span class="line">    staff &#x3D; &#123;&quot;Jack&quot;, &quot;Scott&quot;, &quot;Gary&quot;&#125;, --索引为字符串，值也是一个表</span><br><span class="line">    100876, --相当于 [1] &#x3D; 100876，此时索引为数字</span><br><span class="line">            -- key &#x3D; 1, value &#x3D; 100876</span><br><span class="line">    100191, --相当于 [2] &#x3D; 100191，此时索引为数字</span><br><span class="line">    [10] &#x3D; 360, --直接把数字索引给出</span><br><span class="line">    [&quot;city&quot;] &#x3D; &quot;Beijing&quot; --索引为字符串</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">print(corp.web) --&gt;output:www.google.com</span><br><span class="line">print(corp[&quot;telephone&quot;]) --&gt;output:12345678</span><br><span class="line">print(corp[2]) --&gt;output:100191</span><br><span class="line">print(corp[&quot;city&quot;]) --&gt;output:&quot;Beijing&quot;</span><br><span class="line">print(corp.staff[1]) --&gt;output:Jack</span><br><span class="line">print(corp[10]) --&gt;output:36</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="function-函数"><a href="#function-函数" class="headerlink" title="function(函数)"></a>function(函数)</h3><p>在 Lua 中，函数 也是一种数据类型，函数可以存储在变量中，可以通过参数传递给其他函<br>数，还可以作为其他函数的返回值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">local function foo()</span><br><span class="line">   print(&quot;in the function&quot;)</span><br><span class="line">   --dosomething()</span><br><span class="line">   local x &#x3D; 10</span><br><span class="line">   local y &#x3D; 20</span><br><span class="line">   return x + y</span><br><span class="line">end</span><br><span class="line">local a &#x3D; foo --把函数赋给变量</span><br><span class="line">print(a())</span><br><span class="line"></span><br><span class="line">--output:</span><br><span class="line">in the function</span><br><span class="line">30</span><br></pre></td></tr></table></figure>

<h2 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h2><blockquote>
<p>~=   不等于</p>
</blockquote>
<table>
<thead>
<tr>
<th>逻辑运算符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>and</td>
<td>逻辑与</td>
</tr>
<tr>
<td>or</td>
<td>逻辑或</td>
</tr>
<tr>
<td>not</td>
<td>逻辑非</td>
</tr>
</tbody></table>
<ul>
<li>a and b 如果 a 为 nil，则返回 a，否则返回 b;</li>
<li>a or b 如果 a 为 nil，则返回 b，否则返回 a。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local c &#x3D; nil</span><br><span class="line">local d &#x3D; 0</span><br><span class="line">local e &#x3D; 100</span><br><span class="line">print(c and d) --&gt;打印 nil</span><br><span class="line">print(c and e) --&gt;打印 nil</span><br><span class="line">print(d and e) --&gt;打印 100</span><br><span class="line">print(c or d) --&gt;打印 0</span><br><span class="line">print(c or e) --&gt;打印 100</span><br><span class="line">print(not c) --&gt;打印 true</span><br><span class="line">print(not d) --&gt; 打印 false</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在 Lua 中连接两个字符串，可以使用操作符“..”（两个点）.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;Hello &quot; .. &quot;World&quot;) --&gt;打印 Hello World</span><br><span class="line">print(0 .. 1) --&gt;打印 01</span><br></pre></td></tr></table></figure>

<h2 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h2><p>单个 if 分支 型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; 10</span><br><span class="line">if x &gt; 0 then</span><br><span class="line">    print(&quot;x is a positive number&quot;)</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>两个分支 if-else 型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; 10</span><br><span class="line">if x &gt; 0 then</span><br><span class="line">    print(&quot;x is a positive number&quot;)</span><br><span class="line">else</span><br><span class="line">    print(&quot;x is a non-positive number&quot;)</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>多个分支 if-elseif-else 型:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">score &#x3D; 90</span><br><span class="line">if score &#x3D;&#x3D; 100 then</span><br><span class="line">    print(&quot;Very good!Your score is 100&quot;)</span><br><span class="line">elseif score &gt;&#x3D; 60 then</span><br><span class="line">    print(&quot;Congratulations, you have passed it,your score greater or equal to 60&quot;)</span><br><span class="line">    --此处可以添加多个elseif</span><br><span class="line">else</span><br><span class="line">    print(&quot;Sorry, you do not pass the exam! &quot;)</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="for-控制结构"><a href="#for-控制结构" class="headerlink" title="for 控制结构"></a>for 控制结构</h2><p>Lua 提供了一组传统的、小巧的控制结构，包括用于条件判断的 if 用于迭代的 while、repeat<br>和 for，本章节主要介绍 for 的使用.</p>
<h3 id="for-数字型"><a href="#for-数字型" class="headerlink" title="for 数字型"></a>for 数字型</h3><p>for 语句有两种形式：数字 for（numeric for） 和范型 for（generic for） 。<br>数字型 for 的语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for var &#x3D; begin, finish, step do</span><br><span class="line">--body</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i &#x3D; 1, 5 do</span><br><span class="line">    print(i)</span><br><span class="line">end</span><br><span class="line">-- output:</span><br><span class="line">1 2 3 4 5</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>实例2：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i &#x3D; 1, 10, 2 do</span><br><span class="line">    print(i)</span><br><span class="line">end</span><br><span class="line">-- output:</span><br><span class="line">1 3 5 7 9</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="for-泛型"><a href="#for-泛型" class="headerlink" title="for 泛型"></a>for 泛型</h3><p>泛型 for 循环通过一个迭代器（iterator） 函数来遍历所有值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 打印数组a的所有值</span><br><span class="line"></span><br><span class="line">local a &#x3D; &#123;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;&#125;</span><br><span class="line">for i, v in ipairs(a) do</span><br><span class="line">    print(&quot;index:&quot;, i, &quot; value:&quot;, v)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">-- output:</span><br><span class="line">index: 1 value: a</span><br><span class="line">index: 2 value: b</span><br><span class="line">index: 3 value: c</span><br><span class="line">index: 4 value: d</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>lua的入门就到这里，因为lua语法虽少，但细节有很多，不可能花很多时间去研究这个。入个门，遇到问题再去查资料就行了。另外需要说明的是本文大部分内容为复制粘贴于OPenResty 最佳实践，感谢原作者的开源电子书，让我获益匪浅。更多内容请参考：</p>
<p>lua入门教程：<a target="_blank" rel="noopener" href="http://www.runoob.com/lua/lua-tutorial.html">http://www.runoob.com/lua/lua-tutorial.html</a></p>
<p>OPenResty 最佳实践： <a target="_blank" rel="noopener" href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/index.html">https://moonbingbing.gitbooks.io/openresty-best-practices/content/index.html</a></p>
]]></content>
      <categories>
        <category>Openresty</category>
      </categories>
      <tags>
        <tag>Openresty Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title> Openresty最佳案例 | 第3篇:Openresty的安装</title>
    <url>/2018/01/01/openresty-2018-01-01-openresty-best-practice-3-openresty-install/</url>
    <content><![CDATA[<p>我的服务器为一台全新的centos 7的服务器，所以从头安装openresty，并记录了安装过程中出现的问题，以及解决办法。 </p>
<span id="more"></span>

<h2 id="1-首先安装openresty"><a href="#1-首先安装openresty" class="headerlink" title="1.首先安装openresty"></a>1.首先安装openresty</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr</span><br><span class="line">mkdir servers</span><br><span class="line">mkdir downloads </span><br><span class="line"></span><br><span class="line">yum install libreadline-dev libncurses5-dev libpcre3-dev libssl-dev perl </span><br><span class="line"> </span><br><span class="line">cd &#x2F;usr&#x2F;servers</span><br><span class="line"> </span><br><span class="line">wget https:&#x2F;&#x2F;openresty.org&#x2F;download&#x2F;openresty-1.11.2.4.tar.gz</span><br><span class="line">tar -zxvf openresty-1.11.2.4.tar.gz</span><br><span class="line">cd &#x2F;usr&#x2F;servers&#x2F;bunble&#x2F;LuaJIT-2.1-20170405</span><br><span class="line"></span><br><span class="line">安装Lua</span><br><span class="line">make clean &amp;&amp; make &amp;&amp; make install  </span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>安装过程中出现以下的错误：</p>
<blockquote>
<p>gcc: Command not found</p>
</blockquote>
<h2 id="2-安装gcc"><a href="#2-安装gcc" class="headerlink" title="2.安装gcc"></a>2.安装gcc</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install gcc automake autoconf libtool make</span><br></pre></td></tr></table></figure>
<h2 id="3-重新make"><a href="#3-重新make" class="headerlink" title="3.重新make"></a>3.重新make</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">make clean &amp;&amp; make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line">ln -sf luajit-2.1.0-alpha &#x2F;usr&#x2F;local&#x2F;bin&#x2F;luajit  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="4-下载ngx-cache-purge模块，该模块用于清理nginx缓存"><a href="#4-下载ngx-cache-purge模块，该模块用于清理nginx缓存" class="headerlink" title="4.下载ngx_cache_purge模块，该模块用于清理nginx缓存"></a>4.下载ngx_cache_purge模块，该模块用于清理nginx缓存</h2><p>cd /usr/servers/ngx_openresty–1.11.2.4/bundle<br>wget <a target="_blank" rel="noopener" href="https://github.com/FRiCKLE/ngx_cache_purge/archive/2.3.tar.gz">https://github.com/FRiCKLE/ngx_cache_purge/archive/2.3.tar.gz</a><br>tar -xvf 2.3.tar.gz  </p>
<h2 id="5-下载nginx-upstream-check-module模块，该模块用于ustream健康检查"><a href="#5-下载nginx-upstream-check-module模块，该模块用于ustream健康检查" class="headerlink" title="5.下载nginx_upstream_check_module模块，该模块用于ustream健康检查"></a>5.下载nginx_upstream_check_module模块，该模块用于ustream健康检查</h2><p>cd /usr/servers/ngx_openresty-1.11.2.4/bundle<br>wget <a target="_blank" rel="noopener" href="https://github.com/yaoweibin/nginx_upstream_check_module/archive/v0.3.0.tar.gz">https://github.com/yaoweibin/nginx_upstream_check_module/archive/v0.3.0.tar.gz</a><br>tar -xvf v0.3.0.tar.gz   </p>
<h2 id="6-重新安装opresty"><a href="#6-重新安装opresty" class="headerlink" title="6.重新安装opresty"></a>6.重新安装opresty</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;servers&#x2F;ngx_openresty-1.11.2.4</span><br><span class="line"></span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;servers --with-http_realip_module  --with-pcre  --with-luajit --add-module&#x3D;.&#x2F;bundle&#x2F;ngx_cache_purge-2.3&#x2F; --add-module&#x3D;.&#x2F;bundle&#x2F;nginx_upstream_check_module-0.3.0&#x2F; -j2 </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提示错误，安装pcre库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&lt;1&gt; gcc 安装<br>安装 nginx 需要先将官网下载的源码进行编译，编译依赖 gcc 环境，如果没有 gcc 环境，则需要安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure>

<p>&lt;2&gt; PCRE pcre-devel 安装</p>
<p>PCRE(Perl Compatible Regular Expressions) 是一个Perl库，包括 perl 兼容的正则表达式库。nginx 的 http 模块使用 pcre 来解析正则表达式，所以需要在 linux 上安装 pcre 库，pcre-devel 是使用 pcre 开发的一个二次开发库。nginx也需要此库。命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure>

<p>&lt;3&gt; zlib 安装<br>zlib 库提供了很多种压缩和解压缩的方式， nginx 使用 zlib 对 http 包的内容进行 gzip ，所以需要在 Centos 上安装 zlib 库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure>

<p>&lt;4&gt; OpenSSL 安装<br>OpenSSL 是一个强大的安全套接字层密码库，囊括主要的密码算法、常用的密钥和证书封装管理功能及 SSL 协议，并提供丰富的应用程序供测试或其它目的使用。<br>nginx 不仅支持 http 协议，还支持 https（即在ssl协议上传输http），所以需要在 Centos 安装 OpenSSL 库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install -y openssl openssl-devel</span><br></pre></td></tr></table></figure>

<p>&lt;5&gt;.重新安装OpenResty</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;servers&#x2F;ngx_openresty-1.11.2.4</span><br><span class="line"></span><br><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;servers --with-http_realip_module  --with-pcre  --with-luajit --add-module&#x3D;.&#x2F;bundle&#x2F;ngx_cache_purge-2.3&#x2F; --add-module&#x3D;.&#x2F;bundle&#x2F;nginx_upstream_check_module-0.3.0&#x2F; -j2 </span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install  </span><br></pre></td></tr></table></figure>

<p>&lt;6&gt;.启动Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;servers&#x2F;nginx&#x2F;sbin&#x2F;nginx</span><br></pre></td></tr></table></figure>

<p>浏览器访问<a href="http://116.196.177.123：">http://116.196.177.123：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Welcome to OpenResty!</span><br><span class="line"></span><br><span class="line">If you see this page, the OpenResty web platform is successfully installed and working. Further configuration is required.</span><br><span class="line"></span><br><span class="line">For online documentation and support please refer to openresty.org.</span><br><span class="line"></span><br><span class="line">Thank you for flying OpenResty.</span><br></pre></td></tr></table></figure>
<p>安装成功了。</p>
<h2 id="6-配置nginx"><a href="#6-配置nginx" class="headerlink" title="6.配置nginx"></a>6.配置nginx</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;servers&#x2F;nginx&#x2F;conf&#x2F;nginx.conf  </span><br></pre></td></tr></table></figure>

<p>错误提示没有安装vim</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum -y install vim*</span><br></pre></td></tr></table></figure>

<p>1、在http部分添加如下配置 </p>
<p>lua模块路径，多个之间”;”分隔，其中”;;”表示默认搜索路径，默认到/usr/servers/nginx下找 </p>
<p>lua_package_path “/usr/servers/lualib/?.lua;;”;  #lua 模块<br>lua_package_cpath “/usr/servers/lualib/?.so;;”;  #c模块  </p>
<p>2、在nginx.conf中的http部分添加include lua.conf包含此文件片段<br>Java代码  收藏代码<br>include lua.conf;</p>
<p>在/usr/server/nginx/conf下</p>
<p>vim lua.conf </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#lua.conf  </span><br><span class="line">server &#123;  </span><br><span class="line">    listen       80;  </span><br><span class="line">    server_name  _;  </span><br><span class="line">    </span><br><span class="line">    location &#x2F;lua &#123;  </span><br><span class="line">    default_type &#39;text&#x2F;html&#39;;  </span><br><span class="line">        content_by_lua &#39;ngx.say(&quot;hello world&quot;)&#39;;  </span><br><span class="line">    &#125; </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="7-环境变量："><a href="#7-环境变量：" class="headerlink" title="7.环境变量："></a>7.环境变量：</h2><p>vim  /etc/profile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JAVA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;jdk&#x2F;jdk1.8.0_144</span><br><span class="line">JRE_HOME&#x3D;$JAVA_HOME&#x2F;jre</span><br><span class="line">PATH&#x3D;$PATH:$JAVA_HOME&#x2F;bin:$JRE_HOME&#x2F;bin</span><br><span class="line">CLASSPATH&#x3D;:$JAVA_HOME&#x2F;lib&#x2F;dt.jar:$JAVA_HOME&#x2F;lib&#x2F;tools.jar:$JRE_HOME&#x2F;lib&#x2F;dt.jar</span><br><span class="line">export JAVA_HOME JRE_HOME PATH CLASSPATH</span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;servers&#x2F;nginx&#x2F;sbin</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>source /etc/profile</p>
<p>测试：</p>
<p>nginx -t </p>
<blockquote>
<p>nginx: the configuration file /usr/servers/nginx/conf/nginx.conf syntax is ok<br>nginx: configuration file /usr/servers/nginx/conf/nginx.conf test is successful</p>
</blockquote>
<p>nginx  -s reload  </p>
<p>浏览器访问<a target="_blank" rel="noopener" href="http://116.196.177.123/lua">http://116.196.177.123/lua</a><br>，浏览器显示：</p>
<blockquote>
<p>hello world</p>
</blockquote>
<h2 id="8-将Lua项目化："><a href="#8-将Lua项目化：" class="headerlink" title="8.将Lua项目化："></a>8.将Lua项目化：</h2><blockquote>
<p>mkdir /usr/example<br> cp -r /usr/servers/lualib/  /usr/example/<br>mkdir /usr/example/lua</p>
</blockquote>
<blockquote>
<p>cd /usr/example<br>vim example.conf</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;  </span><br><span class="line">    listen       80;  </span><br><span class="line">    server_name  _;  </span><br><span class="line">  </span><br><span class="line">    location &#x2F;lua &#123;  </span><br><span class="line">        default_type &#39;text&#x2F;html&#39;;  </span><br><span class="line">        lua_code_cache off;  </span><br><span class="line">        content_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;test.lua;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vim /usr/example/lua/test.lua  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngx.say(&quot;hello world&quot;);  </span><br></pre></td></tr></table></figure>


<p>cd /usr/servers/nginx/conf/</p>
<p>vim nginx.conf</p>
<p>http模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    include       mime.types;</span><br><span class="line">    default_type  application&#x2F;octet-stream;</span><br><span class="line">    lua_package_path &quot;&#x2F;usr&#x2F;example&#x2F;lualib&#x2F;?.lua;;&quot;;  #lua 模块  </span><br><span class="line">    lua_package_cpath &quot;&#x2F;usr&#x2F;example&#x2F;lualib&#x2F;?.so;;&quot;;  #c模块   </span><br><span class="line">    include &#x2F;usr&#x2F;example&#x2F;example.conf;</span><br><span class="line"> ....</span><br><span class="line"> ....</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nginx -t </p>
<blockquote>
<p>nginx: [alert] lua_code_cache is off; this will hurt performance in /usr/example/example.conf:7<br>nginx: the configuration file /usr/servers/nginx/conf/nginx.conf syntax is ok<br>nginx: configuration file /usr/servers/nginx/conf/nginx.conf test is successful</p>
</blockquote>
<p>nginx -s reload </p>
<p>浏览器访问<a target="_blank" rel="noopener" href="http://116.196.177.123/lua">http://116.196.177.123/lua</a> ，</p>
<blockquote>
<p> hello world</p>
</blockquote>
<p>导出history的所有命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在你的账户目录下    输入命令</span><br><span class="line">ls -a   </span><br><span class="line">找到 .bash_history</span><br><span class="line">这个就是记录命令文件。</span><br><span class="line">输入命令：</span><br><span class="line">cat   .bash_history &gt;&gt; history.txt</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://www.linuxidc.com/Linux/2016-09/134907.htm">http://www.linuxidc.com/Linux/2016-09/134907.htm</a></p>
<p><a target="_blank" rel="noopener" href="http://jinnianshilongnian.iteye.com/blog/2186270">http://jinnianshilongnian.iteye.com/blog/2186270</a></p>
<p><a target="_blank" rel="noopener" href="https://openresty.org/en/">https://openresty.org/en/</a></p>
]]></content>
      <categories>
        <category>Openresty</category>
      </categories>
      <tags>
        <tag>Openresty Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Openresty最佳案例 | 第4篇：OpenResty常见的api</title>
    <url>/2018/01/01/openresty-2018-01-01-openresty-best-practice-4-openresty-api/</url>
    <content><![CDATA[<p>这篇文章主要讲解OpenResty常见的api。</p>
<span id="more"></span>

<p>vim  /usr/example/example.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua_var &#123;</span><br><span class="line">       default_type &#39;text&#x2F;plain&#39;;</span><br><span class="line">       content_by_lua_block &#123;</span><br><span class="line">        ngx.say(ngx.var.arg_a)</span><br><span class="line">       &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>重新加载nginx配置文件： nginx -s reload</p>
<p>在浏览器上访问<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_var?a=323,%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%EF%BC%9A">http://116.196.177.123/lua_var?a=323,浏览器显示：</a></p>
<blockquote>
<p>323</p>
</blockquote>
<p> 在上述代码中，涉及到了2个api, 一是ngx.say（直接返回请求结果）；二是ngx.var，它是获取请求的参数，比如本例子上的？a=323,获取之后，直接输出为请求结果。</p>
<h2 id="获取请求类型"><a href="#获取请求类型" class="headerlink" title="获取请求类型"></a>获取请求类型</h2><p>vim /usr/example/example.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua_request&#123;</span><br><span class="line">     default_type &#39;text&#x2F;html&#39;;</span><br><span class="line">     lua_code_cache off;</span><br><span class="line">     content_by_lua_file  &#x2F;usr&#x2F;example&#x2F;lua&#x2F;lua_request.lua;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vim /usr/example/lua/lua_request.lua ，添加一下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">local arg &#x3D; ngx.req.get_uri_args()</span><br><span class="line">for k,v in pairs(arg) do</span><br><span class="line">   ngx.say(&quot;[GET ] key:&quot;, k, &quot; v:&quot;, v)</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">ngx.req.read_body() -- 解析 body 参数之前一定要先读取 body</span><br><span class="line">local arg &#x3D; ngx.req.get_post_args()</span><br><span class="line">for k,v in pairs(arg) do</span><br><span class="line">   ngx.say(&quot;[POST] key:&quot;, k, &quot; v:&quot;, v)</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述例子中有以下的api:</p>
<ul>
<li>ngx.req.get_uri_args 获取在uri上的get类型参数，返回的是一个table类型的数据结构。</li>
<li>ngx.req.read_body 读取body，这在解析body之前，一定要先读取body。</li>
<li>ngx.req.get_post_args 获取form表单类型的参数，返回结果是一个table类型的数据。</li>
</ul>
<p>使用curl模拟请求：</p>
<blockquote>
<p>curl ‘<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_request?a=323&amp;b=ss&#39;">http://116.196.177.123/lua_request?a=323&amp;b=ss&#39;</a> -d ‘c=12w&amp;d=2se3’</p>
</blockquote>
<p>返回的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GET ] key:b v:ss</span><br><span class="line">[GET ] key:a v:323</span><br><span class="line">[POST] key:d v:2se3</span><br><span class="line">[POST] key:c v:12w</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取请求头"><a href="#获取请求头" class="headerlink" title="获取请求头"></a>获取请求头</h2><p>vim /usr/example/lua/lua_request.lua ，在原有的代码基础上，再添加一下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">local headers &#x3D; ngx.req.get_headers()</span><br><span class="line">ngx.say(&quot;headers begin&quot;, &quot;&lt;br&#x2F;&gt;&quot;)</span><br><span class="line">ngx.say(&quot;Host : &quot;, headers[&quot;Host&quot;], &quot;&lt;br&#x2F;&gt;&quot;)</span><br><span class="line">ngx.say(&quot;user-agent : &quot;, headers[&quot;user-agent&quot;], &quot;&lt;br&#x2F;&gt;&quot;)</span><br><span class="line">ngx.say(&quot;user-agent : &quot;, headers.user_agent, &quot;&lt;br&#x2F;&gt;&quot;)</span><br><span class="line">for k,v in pairs(headers) do</span><br><span class="line">    if type(v) &#x3D;&#x3D; &quot;table&quot; then</span><br><span class="line">        ngx.say(k, &quot; : &quot;, table.concat(v, &quot;,&quot;), &quot;&lt;br&#x2F;&gt;&quot;)</span><br><span class="line">    else</span><br><span class="line">        ngx.say(k, &quot; : &quot;, v, &quot;&lt;br&#x2F;&gt;&quot;)</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新加载nginx -s reload</p>
<p>使用curl模拟请求：</p>
<blockquote>
<p>curl ‘<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_request?a=323&amp;b=ss&#39;">http://116.196.177.123/lua_request?a=323&amp;b=ss&#39;</a> -d ‘c=12w&amp;d=2se3’</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GET ] key:b v:ss</span><br><span class="line">[GET ] key:a v:323</span><br><span class="line">[POST] key:d v:2se3</span><br><span class="line">[POST] key:c v:12w</span><br><span class="line">headers begin&lt;br&#x2F;&gt;</span><br><span class="line">Host : 116.196.77.157&lt;br&#x2F;&gt;</span><br><span class="line">user-agent : curl&#x2F;7.53.0&lt;br&#x2F;&gt;</span><br><span class="line">user-agent : curl&#x2F;7.53.0&lt;br&#x2F;&gt;</span><br><span class="line">host : 116.196.77.157&lt;br&#x2F;&gt;</span><br><span class="line">content-type : application&#x2F;x-www-form-urlencoded&lt;br&#x2F;&gt;</span><br><span class="line">accept : *&#x2F;*&lt;br&#x2F;&gt;</span><br><span class="line">content-length : 12&lt;br&#x2F;&gt;</span><br><span class="line">user-agent : curl&#x2F;7.53.0&lt;br&#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="获取http的其他方法"><a href="#获取http的其他方法" class="headerlink" title="获取http的其他方法"></a>获取http的其他方法</h2><p>vim /usr/example/lua/lua_request.lua ，在原有的代码基础上，再添加一下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngx.say(&quot;ngx.req.http_version : &quot;, ngx.req.http_version(), &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">--请求方法  </span><br><span class="line">ngx.say(&quot;ngx.req.get_method : &quot;, ngx.req.get_method(), &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">--原始的请求头内容  </span><br><span class="line">ngx.say(&quot;ngx.req.raw_header : &quot;,  ngx.req.raw_header(), &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">--请求的body内容体  </span><br><span class="line">ngx.say(&quot;ngx.req.get_body_data() : &quot;, ngx.req.get_body_data(), &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">ngx.say(&quot;&lt;br&#x2F;&gt;&quot;) </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新加载nginx -s reload</p>
<p>使用curl模拟请求：</p>
<blockquote>
<p>curl ‘<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_request?a=323&amp;b=ss&#39;">http://116.196.177.123/lua_request?a=323&amp;b=ss&#39;</a> -d ‘c=12w&amp;d=2se3’</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;....</span><br><span class="line">ngx.req.http_version : 1.1&lt;br&#x2F;&gt;</span><br><span class="line">ngx.req.get_method : POST&lt;br&#x2F;&gt;</span><br><span class="line">ngx.req.raw_header : POST &#x2F;lua_request?a&#x3D;323&amp;b&#x3D;ss HTTP&#x2F;1.1</span><br><span class="line">Host: 116.196.77.157</span><br><span class="line">User-Agent: curl&#x2F;7.53.0</span><br><span class="line">Accept: *&#x2F;*</span><br><span class="line">Content-Length: 12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="输出响应"><a href="#输出响应" class="headerlink" title="输出响应"></a>输出响应</h2><blockquote>
<p>vim /usr/example/example.conf，添加一个location,代码如下：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua_response&#123;</span><br><span class="line">       default_type &#39;text&#x2F;html&#39;;</span><br><span class="line">       lua_code_cache off;</span><br><span class="line">       content_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;lua_response.lua ;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>vim /usr/example/lua/lua_response.lua 添加一下代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngx.header.a&#x3D;&quot;1&quot;</span><br><span class="line">ngx.header.b&#x3D;&#123;&quot;a&quot;,&quot;b&quot;&#125;</span><br><span class="line">ngx.say(&quot;hello&quot;,&quot;&lt;&#x2F;br&gt;&quot;)</span><br><span class="line">ngx.print(&quot;sss&quot;)</span><br><span class="line">return ngx.exit(200)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中有以下api:</p>
<ul>
<li>ngx.header 向响应头输出内容</li>
<li>ngx.say 输出响应体</li>
<li>ngx.print输出响应体</li>
<li>ngx.exit 指定http状态码退出</li>
</ul>
<p>使用curl模拟请求， curl ‘<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_response&#39;">http://116.196.177.123/lua_response&#39;</a> ，获取的响应体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello</span><br><span class="line">sss</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h2><p>在配置文件vim /usr/example/example.conf 加上以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua_log&#123;</span><br><span class="line">      default_type &#39;text&#x2F;html&#39;;</span><br><span class="line">      lua_code_cache off;</span><br><span class="line">      content_by_lua_file  &#x2F;usr&#x2F;example&#x2F;lua&#x2F;lua_log.lua;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>vim /usr/example/lua/lua_log.lua ，加上以下代码：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">local log&#x3D;&quot;i&#39;m log&quot;</span><br><span class="line">local num &#x3D;10</span><br><span class="line">ngx.log(ngx.ERR, &quot;log&quot;,log)</span><br><span class="line">ngx.log(ngx.INFO,&quot;num:&quot; ,num)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重新加载配置文件nginx -s reload </p>
<blockquote>
<p>curl ‘<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_log&#39;">http://116.196.177.123/lua_log&#39;</a></p>
</blockquote>
<p>打开nginx 的logs目录下的error.log 文件：</p>
<blockquote>
<p>tail -fn 1000  /usr/servers/nginx/logs/error.log </p>
</blockquote>
<p>可以看到在日志文件中已经输出了日志，这种日志主要用于记录和测试。</p>
<p>日志级别：</p>
<ul>
<li>ngx.STDERR – 标准输出</li>
<li>ngx.EMERG – 紧急报错</li>
<li>ngx.ALERT – 报警</li>
<li>ngx.CRIT – 严重，系统故障，触发运维告警系统</li>
<li>ngx.ERR – 错误，业务不可恢复性错误</li>
<li>ngx.WARN – 告警，业务中可忽略错误</li>
<li>ngx.NOTICE – 提醒，业务比较重要信息</li>
<li>ngx.INFO – 信息，业务琐碎日志信息，包含不同情况判断等</li>
<li>ngx.DEBUG – 调试</li>
</ul>
<h2 id="内部调用"><a href="#内部调用" class="headerlink" title="内部调用"></a>内部调用</h2><p>vim /usr/example/example.conf 添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua_sum&#123;</span><br><span class="line">      # 只允许内部调用</span><br><span class="line">      internal;</span><br><span class="line">      # 这里做了一个求和运算只是一个例子，可以在这里完成一些数据库、</span><br><span class="line">      # 缓存服务器的操作，达到基础模块和业务逻辑分离目的</span><br><span class="line">      content_by_lua_block &#123;</span><br><span class="line">         local args &#x3D; ngx.req.get_uri_args()</span><br><span class="line">         ngx.say(tonumber(args.a) + tonumber(args.b))</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>internal 关键字，表示只允许内部调用。使用curl模拟请求，请求命令如下：</p>
<blockquote>
<p>$ curl ‘<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_sum?a=1&amp;b=2&#39;">http://116.196.177.123/lua_sum?a=1&amp;b=2&#39;</a></p>
</blockquote>
<p>由于该loction是一个内部调用的，外部不能返回，最终返回的结果为404，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;&lt;title&gt;404 Not Found&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body bgcolor&#x3D;&quot;white&quot;&gt;</span><br><span class="line">&lt;center&gt;&lt;h1&gt;404 Not Found&lt;&#x2F;h1&gt;&lt;&#x2F;center&gt;</span><br><span class="line">&lt;hr&gt;&lt;center&gt;openresty&#x2F;1.11.2.4&lt;&#x2F;center&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>vim /usr/example/example.conf 添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x3D; &#x2F;lua_sum_test &#123;</span><br><span class="line">   content_by_lua_block &#123;</span><br><span class="line">      local res &#x3D; ngx.location.capture(&quot;&#x2F;lua_sum&quot;, &#123;args&#x3D;&#123;a&#x3D;3, b&#x3D;8&#125;&#125;)</span><br><span class="line">      ngx.say(&quot;status:&quot;, res.status, &quot; response:&quot;, res.body)</span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述的代码通过ngx.location.capture去调用内部的location，并获得返回结果，最终将结果输出，采用curl模拟请求：</p>
<blockquote>
<p>$ curl ‘<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_sum_test&#39;">http://116.196.177.123/lua_sum_test&#39;</a></p>
</blockquote>
<p>返回结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">status:200 response:11</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>vim /usr</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua_redirect&#123;</span><br><span class="line">    default_type &#39;text&#x2F;html&#39;;</span><br><span class="line">    content_by_lua_file  &#x2F;usr&#x2F;example&#x2F;lua&#x2F;lua_redirect.lua;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>



<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngx.redirect(&quot;http:&#x2F;&#x2F;www.chris .com&quot;, 302)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="http://116.196.177.123/lua_redirect">http://116.196.177.123/lua_redirect</a></p>
<h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>vim /usr/servers/nginx/cong/nginx.conf</p>
<p>在http模块加上以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua_shared_dict shared_data 1m;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua_shared_dict&#123;</span><br><span class="line">    default_type &#39;text&#x2F;html&#39;;</span><br><span class="line">    content_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;lua_shared_dict.lua;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local shared_data &#x3D; ngx.shared.shared_data</span><br><span class="line">local i &#x3D; shared_data:get(&quot;i&quot;)</span><br><span class="line">if not i then</span><br><span class="line">  i &#x3D; 1</span><br><span class="line">  shared_data:set(&quot;i&quot;,i)</span><br><span class="line">end</span><br><span class="line">i &#x3D; shared_data:incr(&quot;i&quot;,1)</span><br><span class="line">ngx.say(&quot;i:&quot;,i)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多次访问 <a target="_blank" rel="noopener" href="http://116.196.177.123/lua_shared_dict%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%89%93%E5%8D%B0%EF%BC%9A">http://116.196.177.123/lua_shared_dict，浏览器打印：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i:1</span><br><span class="line">i:2</span><br><span class="line">i:3</span><br><span class="line">i:4</span><br><span class="line">i:5</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="OpenResty执行阶段的概念"><a href="#OpenResty执行阶段的概念" class="headerlink" title="OpenResty执行阶段的概念"></a>OpenResty执行阶段的概念</h2><p>以下内容来自于《openresty 最佳实践》</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-b9ceb17709093dc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="微信截图_20170929150427.png"></p>
<p>如上图所示，openresty的执行阶段分为</p>
<p>这样我们就可以根据我们的需要，在不同的阶段直接完成大部分典型处理了。</p>
<ul>
<li>set_by_lua* : 流程分支处理判断变量初始化</li>
<li>rewrite_by_lua* : 转发、重定向、缓存等功能(例如特定请求代理到外网) </li>
<li>access_by_lua* : IP 准入、接口权限等情况集中处理(例如配合 iptable 完成简单防火墙) </li>
<li>content_by_lua* : 内容生成</li>
<li>header_filter_by_lua* : 响应头部过滤处理(例如添加头部信息)</li>
<li>body_filter_by_lua* : 响应体过滤处理(例如完成应答内容统一成大写)</li>
</ul>
<p>执行阶段概念：</p>
<ul>
<li>log_by_lua* : 会话完成后本地异步完成日志记录(日志可以记录在本地，还可以同步到其 他机器)<br>实际上我们只使用其中一个阶段 </li>
<li>content_by_lua* ，也可以完成所有的处理。但这样做，会让 我们的代码比较臃肿，越到后期越发难以维护。把我们的逻辑放在不同阶段，分工明确，代 码独立，后期发力可以有很多有意思的玩法。</li>
</ul>
]]></content>
      <categories>
        <category>Openresty</category>
      </categories>
      <tags>
        <tag>Openresty Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Openresty最佳案例 | 第5篇：http和C_json模块</title>
    <url>/2018/01/01/openresty-2018-01-01-openresty-best-practice-5-httpclient/</url>
    <content><![CDATA[<p>Openresty没有提供默认的Http客户端，需要下载第三方的http客户端。</p>
<span id="more"></span>

<p>下载lua-resty-http到lualib目录下，使用以下的命令下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;example&#x2F;lualib&#x2F;resty&#x2F;  </span><br><span class="line">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;pintsized&#x2F;lua-resty-http&#x2F;master&#x2F;lib&#x2F;resty&#x2F;http_headers.lua  </span><br><span class="line"></span><br><span class="line">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;pintsized&#x2F;lua-resty-http&#x2F;master&#x2F;lib&#x2F;resty&#x2F;http.lua  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>lua-resty-http模块的地址为<a target="_blank" rel="noopener" href="https://github.com/pintsized/lua-resty-http">https://github.com/pintsized/lua-resty-http</a></p>
<p>安装成功后，通过require(“resty.http”)引入 lua_http模块，它有以下的api方法：</p>
<ul>
<li>syntax: httpc = http.new() 创建一个 http对象</li>
<li>syntax: res, err = httpc:request_uri(uri, params)根据参数获取内容，包括：<ul>
<li>status 状态码</li>
<li>headers 响应头</li>
<li>body 响应体</li>
</ul>
</li>
</ul>
<p>vim /usr/example/lua/test_http.lua，写以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local http &#x3D; require(&quot;resty.http&quot;)  </span><br><span class="line"></span><br><span class="line">local httpc &#x3D; http.new()  </span><br><span class="line">  </span><br><span class="line">local resp, err &#x3D; httpc:request_uri(&quot;http:&#x2F;&#x2F;s.taobao.com&quot;, &#123;  </span><br><span class="line">    method &#x3D; &quot;GET&quot;,  </span><br><span class="line">    path &#x3D; &quot;&#x2F;search?q&#x3D;hello&quot;,  </span><br><span class="line">    headers &#x3D; &#123;  </span><br><span class="line">        [&quot;User-Agent&quot;] &#x3D; &quot;Mozilla&#x2F;5.0 (Windows NT 6.1; WOW64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;40.0.2214.111 Safari&#x2F;537.36&quot;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;)  </span><br><span class="line">  </span><br><span class="line">if not resp then  </span><br><span class="line">    ngx.say(&quot;request error :&quot;, err)  </span><br><span class="line">    return  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">ngx.status &#x3D; resp.status  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">for k, v in pairs(resp.headers) do  </span><br><span class="line">    if k ~&#x3D; &quot;Transfer-Encoding&quot; and k ~&#x3D; &quot;Connection&quot; then  </span><br><span class="line">        ngx.header[k] &#x3D; v  </span><br><span class="line">    end  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">ngx.say(resp.body)  </span><br><span class="line">  </span><br><span class="line">httpc:close()  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vim /usr/example/example.conf 加上以下的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua_http &#123;</span><br><span class="line">  default_type &#39;text&#x2F;html&#39;;</span><br><span class="line">  lua_code_cache on;</span><br><span class="line">  content_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;test_http.lua;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Nginx的配置文件nginx.conf的http部分，加上以下dns解析：</p>
<p>vim /usr/servers/nginx/conf/nginx.conf</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resolver 8.8.8.8;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>浏览器访问：<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_http,%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E6%98%BE%E7%A4%BA%E6%B7%98%E5%AE%9D%E7%9A%84%E6%90%9C%E7%B4%A2%E9%A1%B5%E3%80%82">http://116.196.177.123/lua_http,浏览器会显示淘宝的搜索页。</a></p>
<h2 id="lua-cjson模块"><a href="#lua-cjson模块" class="headerlink" title="lua_cjson模块"></a>lua_cjson模块</h2><p>Json是一种常见的数据交换格式，常用于http通信协议和其他数据传输领域。在openresty默认内嵌了lua_cjson模块，用来序列化数据。</p>
<p>lua_cjson模块的地址：<a target="_blank" rel="noopener" href="https://www.kyne.com.au/~mark/software/lua-cjson-manual.html">https://www.kyne.com.au/~mark/software/lua-cjson-manual.html</a></p>
<p>它常用的API如下：</p>
<ul>
<li>local cjson = require “cjson” 获取一个cjson对象</li>
<li>local str = cjson.encode(obj) obj转换成string</li>
<li>local obj = cjson.decode(str) 将string转obj</li>
</ul>
<p>vim /usr/example/lua/test_cjson.lua，添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local cjson &#x3D; require(&quot;cjson&quot;)  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">local obj &#x3D; &#123;  </span><br><span class="line">    id &#x3D; 1,  </span><br><span class="line">    name &#x3D; &quot;zhangsan&quot;,  </span><br><span class="line">    age &#x3D; nil,  </span><br><span class="line">    is_male &#x3D; false,  </span><br><span class="line">    hobby &#x3D; &#123;&quot;film&quot;, &quot;music&quot;, &quot;read&quot;&#125;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">local str &#x3D; cjson.encode(obj)  </span><br><span class="line">ngx.say(str, &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">str &#x3D; &#39;&#123;&quot;hobby&quot;:[&quot;film&quot;,&quot;music&quot;,&quot;read&quot;],&quot;is_male&quot;:false,&quot;name&quot;:&quot;zhangsan&quot;,&quot;id&quot;:1,&quot;age&quot;:null&#125;&#39;  </span><br><span class="line">local obj &#x3D; cjson.decode(str)  </span><br><span class="line">  </span><br><span class="line">ngx.say(obj.age, &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">ngx.say(obj.age &#x3D;&#x3D; nil, &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">ngx.say(obj.age &#x3D;&#x3D; cjson.null, &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">ngx.say(obj.hobby[1], &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>vim /usr/example/example.conf添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ &#x2F;lua_cjson &#123;  </span><br><span class="line">  default_type &#39;text&#x2F;html&#39;;  </span><br><span class="line">  lua_code_cache on;  </span><br><span class="line">  content_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;test_cjson.lua;  </span><br><span class="line">&#125;   </span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在浏览器上访问<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_cjson%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9%EF%BC%9A">http://116.196.177.123/lua_cjson，浏览器显示以下内容：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;hobby&quot;:[&quot;film&quot;,&quot;music&quot;,&quot;read&quot;],&quot;is_male&quot;:false,&quot;name&quot;:&quot;zhangsan&quot;,&quot;id&quot;:1&#125;</span><br><span class="line">null</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">film</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Openresty</category>
      </categories>
      <tags>
        <tag>Openresty Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Openresty最佳案例 | 第6篇：OpenResty连接Mysql</title>
    <url>/2018/01/01/openresty-2018-01-01-openresty-best-practice-6-mysq/</url>
    <content><![CDATA[<p>Centos系统下安装mysql，先下载mysql-community-release-el7-5.noarch.rpm，然后通过yum安装，安装过程一直确定【Y】即可。</p>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;downloads&#x2F;</span><br><span class="line"></span><br><span class="line">wget http:&#x2F;&#x2F;dev.mysql.com&#x2F;get&#x2F;mysql-community-release-el7-5.noarch.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-release-el7-5.noarch.rpm</span><br><span class="line"></span><br><span class="line">yum install mysql-community-server</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>安装成功后，重启mysql，并进入mysql数据库，给root用户设置一个密码，密码为“123”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service mysqld restart</span><br><span class="line"></span><br><span class="line">mysql -u root -p</span><br><span class="line"></span><br><span class="line">set password for root@localhost &#x3D; password(&#39;123&#39;); </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="openresty连接mysql"><a href="#openresty连接mysql" class="headerlink" title="openresty连接mysql"></a>openresty连接mysql</h2><p>lua-resty-mysql模块的官方文档地址： <a target="_blank" rel="noopener" href="https://github.com/openresty/lua-resty-mysql">https://github.com/openresty/lua-resty-mysql</a></p>
<blockquote>
<p>lua-resty-mysql - Lua MySQL client driver for ngx_lua based on the cosocket API </p>
</blockquote>
<p>lua-resty-mysql模块是基于cosocket API 为ngx_lua提供的一个Lua MySQL客户端。它保证了100%非阻塞。</p>
<p>vim /usr/example/lua/test_mysql.lua，添加以下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local function close_db(db)  </span><br><span class="line">    if not db then  </span><br><span class="line">        return  </span><br><span class="line">    end  </span><br><span class="line">    db:close()  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">local mysql &#x3D; require(&quot;resty.mysql&quot;)  </span><br><span class="line"> </span><br><span class="line">local db, err &#x3D; mysql:new()  </span><br><span class="line">if not db then  </span><br><span class="line">    ngx.say(&quot;new mysql error : &quot;, err)  </span><br><span class="line">    return  </span><br><span class="line">end  </span><br><span class="line"></span><br><span class="line">db:set_timeout(1000)  </span><br><span class="line">  </span><br><span class="line">local props &#x3D; &#123;  </span><br><span class="line">    host &#x3D; &quot;127.0.0.1&quot;,  </span><br><span class="line">    port &#x3D; 3306,  </span><br><span class="line">    database &#x3D; &quot;mysql&quot;,  </span><br><span class="line">    user &#x3D; &quot;root&quot;,  </span><br><span class="line">    password &#x3D; &quot;123&quot;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">local res, err, errno, sqlstate &#x3D; db:connect(props)  </span><br><span class="line">  </span><br><span class="line">if not res then  </span><br><span class="line">   ngx.say(&quot;connect to mysql error : &quot;, err, &quot; , errno : &quot;, errno, &quot; , sqlstate : &quot;, sqlstate)  </span><br><span class="line">   return close_db(db)  </span><br><span class="line">end  </span><br><span class="line"> </span><br><span class="line">local drop_table_sql &#x3D; &quot;drop table if exists test&quot;  </span><br><span class="line">res, err, errno, sqlstate &#x3D; db:query(drop_table_sql)  </span><br><span class="line">if not res then  </span><br><span class="line">   ngx.say(&quot;drop table error : &quot;, err, &quot; , errno : &quot;, errno, &quot; , sqlstate : &quot;, sqlstate)  </span><br><span class="line">   return close_db(db)  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">local create_table_sql &#x3D; &quot;create table test(id int primary key auto_increment, ch varchar(100))&quot;  </span><br><span class="line">res, err, errno, sqlstate &#x3D; db:query(create_table_sql)  </span><br><span class="line">if not res then  </span><br><span class="line">   ngx.say(&quot;create table error : &quot;, err, &quot; , errno : &quot;, errno, &quot; , sqlstate : &quot;, sqlstate)  </span><br><span class="line">   return close_db(db)  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">local insert_sql &#x3D; &quot;insert into test (ch) values(&#39;hello&#39;)&quot;  </span><br><span class="line">res, err, errno, sqlstate &#x3D; db:query(insert_sql)  </span><br><span class="line">if not res then  </span><br><span class="line">   ngx.say(&quot;insert error : &quot;, err, &quot; , errno : &quot;, errno, &quot; , sqlstate : &quot;, sqlstate)  </span><br><span class="line">   return close_db(db)  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">res, err, errno, sqlstate &#x3D; db:query(insert_sql)  </span><br><span class="line">  </span><br><span class="line">ngx.say(&quot;insert rows : &quot;, res.affected_rows, &quot; , id : &quot;, res.insert_id, &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">  </span><br><span class="line"> </span><br><span class="line">local update_sql &#x3D; &quot;update test set ch &#x3D; &#39;hello2&#39; where id &#x3D;&quot; .. res.insert_id  </span><br><span class="line">res, err, errno, sqlstate &#x3D; db:query(update_sql)  </span><br><span class="line">if not res then  </span><br><span class="line">   ngx.say(&quot;update error : &quot;, err, &quot; , errno : &quot;, errno, &quot; , sqlstate : &quot;, sqlstate)  </span><br><span class="line">   return close_db(db)  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">ngx.say(&quot;update rows : &quot;, res.affected_rows, &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">  </span><br><span class="line">local select_sql &#x3D; &quot;select id, ch from test&quot;  </span><br><span class="line">res, err, errno, sqlstate &#x3D; db:query(select_sql)  </span><br><span class="line">if not res then  </span><br><span class="line">   ngx.say(&quot;select error : &quot;, err, &quot; , errno : &quot;, errno, &quot; , sqlstate : &quot;, sqlstate)  </span><br><span class="line">   return close_db(db)  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">for i, row in ipairs(res) do  </span><br><span class="line">   for name, value in pairs(row) do  </span><br><span class="line">     ngx.say(&quot;select row &quot;, i, &quot; : &quot;, name, &quot; &#x3D; &quot;, value, &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">   end  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">ngx.say(&quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">  </span><br><span class="line">local ch_param &#x3D; ngx.req.get_uri_args()[&quot;ch&quot;] or &#39;&#39;  </span><br><span class="line"> </span><br><span class="line">local query_sql &#x3D; &quot;select id, ch from test where ch &#x3D; &quot; .. ngx.quote_sql_str(ch_param)  </span><br><span class="line">res, err, errno, sqlstate &#x3D; db:query(query_sql)  </span><br><span class="line">if not res then  </span><br><span class="line">   ngx.say(&quot;select error : &quot;, err, &quot; , errno : &quot;, errno, &quot; , sqlstate : &quot;, sqlstate)  </span><br><span class="line">   return close_db(db)  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">for i, row in ipairs(res) do  </span><br><span class="line">   for name, value in pairs(row) do  </span><br><span class="line">     ngx.say(&quot;select row &quot;, i, &quot; : &quot;, name, &quot; &#x3D; &quot;, value, &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">   end  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">local delete_sql &#x3D; &quot;delete from test&quot;  </span><br><span class="line">res, err, errno, sqlstate &#x3D; db:query(delete_sql)  </span><br><span class="line">if not res then  </span><br><span class="line">   ngx.say(&quot;delete error : &quot;, err, &quot; , errno : &quot;, errno, &quot; , sqlstate : &quot;, sqlstate)  </span><br><span class="line">   return close_db(db)  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">ngx.say(&quot;delete rows : &quot;, res.affected_rows, &quot;&lt;br&#x2F;&gt;&quot;)  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">close_db(db)  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，展示了基本的创表、插入数据、修改数据、查询数据、删除数据的一些功能。</p>
<p>其中用到的lua-resty-mysql的一些API方法：</p>
<ul>
<li>syntax: db, err = mysql:new() 创建一个mysql数据库连接对象</li>
<li>syntax: ok, err = db:connect(options) 尝试远程连接mysql<ul>
<li> host mysql的主机名</li>
<li> port 端口</li>
<li> database 数据库名</li>
<li> user 用户名</li>
<li> password 密码</li>
<li> charset 编码</li>
</ul>
</li>
<li>syntax: db:set_timeout(time) 设置数据库连接超时时间</li>
<li>syntax: ok, err = db:set_keepalive(max_idle_timeout, pool_size) 设置连接池</li>
<li>syntax: ok, err = db:close() 关闭数据库</li>
<li>syntax: bytes, err = db:send_query(query) 发送查询</li>
</ul>
<p>lua-resty-mysql的一些关键的API方法，见<a target="_blank" rel="noopener" href="https://github.com/openresty/lua-resty-mysql#table-of-contents">https://github.com/openresty/lua-resty-mysql#table-of-contents</a></p>
<p>vim /usr/example/example.conf 在配置文件配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">location &#x2F;lua_mysql &#123;</span><br><span class="line">   default_type &#39;text&#x2F;html&#39;;</span><br><span class="line">   lua_code_cache on;</span><br><span class="line">   content_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;test_mysql.lua;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>浏览器访问<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_mysql%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E4%BB%A5%E4%B8%8B%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A">http://116.196.177.123/lua_mysql，浏览器显示以下的内容：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">insert rows : 1 , id : 2</span><br><span class="line">update rows : 1</span><br><span class="line">select row 1 : ch &#x3D; hello</span><br><span class="line">select row 1 : id &#x3D; 1</span><br><span class="line">select row 2 : ch &#x3D; hello2</span><br><span class="line">select row 2 : id &#x3D; 2</span><br><span class="line"></span><br><span class="line">delete rows : 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Openresty</category>
      </categories>
      <tags>
        <tag>Openresty Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Openresty最佳案例 | 第7篇： 模块开发、OpenResty连接Redis</title>
    <url>/2018/01/01/openresty-2018-01-01-openresty-best-practice-7-Redis/</url>
    <content><![CDATA[<p>在实际的开发过程中，不可能把所有的lua代码写在一个lua文件中，通常的做法将特定功能的放在一个lua文件中，即用lua模块开发。在lualib目录下，默认有以下的lua模块。</p>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lualib&#x2F;</span><br><span class="line">├── cjson.so</span><br><span class="line">├── ngx</span><br><span class="line">│   ├── balancer.lua</span><br><span class="line">│   ├── ocsp.lua</span><br><span class="line">│   ├── re.lua</span><br><span class="line">│   ├── semaphore.lua</span><br><span class="line">│   ├── ssl</span><br><span class="line">│   │   └── session.lua</span><br><span class="line">│   └── ssl.lua</span><br><span class="line">├── rds</span><br><span class="line">│   └── parser.so</span><br><span class="line">├── redis</span><br><span class="line">│   └── parser.so</span><br><span class="line">└── resty</span><br><span class="line">    ├── aes.lua</span><br><span class="line">    ├── core</span><br><span class="line">    │   ├── base64.lua</span><br><span class="line">    │   ├── base.lua</span><br><span class="line">    │   ├── ctx.lua</span><br><span class="line">    │   ├── exit.lua</span><br><span class="line">    │   ├── hash.lua</span><br><span class="line">    │   ├── misc.lua</span><br><span class="line">    │   ├── regex.lua</span><br><span class="line">    │   ├── request.lua</span><br><span class="line">    │   ├── response.lua</span><br><span class="line">    │   ├── shdict.lua</span><br><span class="line">    │   ├── time.lua</span><br><span class="line">    │   ├── uri.lua</span><br><span class="line">    │   ├── var.lua</span><br><span class="line">    │   └── worker.lua</span><br><span class="line">    ├── core.lua</span><br><span class="line">    ├── dns</span><br><span class="line">    │   └── resolver.lua</span><br><span class="line">    ├── limit</span><br><span class="line">    │   ├── conn.lua</span><br><span class="line">    │   ├── req.lua</span><br><span class="line">    │   └── traffic.lua</span><br><span class="line">    ├── lock.lua</span><br><span class="line">    ├── lrucache</span><br><span class="line">    │   └── pureffi.lua</span><br><span class="line">    ├── lrucache.lua</span><br><span class="line">    ├── md5.lua</span><br><span class="line">    ├── memcached.lua</span><br><span class="line">    ├── mysql.lua</span><br><span class="line">    ├── random.lua</span><br><span class="line">    ├── redis.lua</span><br><span class="line">    ├── sha1.lua</span><br><span class="line">    ├── sha224.lua</span><br><span class="line">    ├── sha256.lua</span><br><span class="line">    ├── sha384.lua</span><br><span class="line">    ├── sha512.lua</span><br><span class="line">    ├── sha.lua</span><br><span class="line">    ├── string.lua</span><br><span class="line">    ├── upload.lua</span><br><span class="line">    ├── upstream</span><br><span class="line">    │   └── healthcheck.lua</span><br><span class="line">    └── websocket</span><br><span class="line">        ├── client.lua</span><br><span class="line">        ├── protocol.lua</span><br><span class="line">        └── server.lua</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在使用这些模块之前，需要在nginx的配置文件nginx.conf中的http模块加上以下的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua_package_path &quot;&#x2F;usr&#x2F;example&#x2F;lualib&#x2F;?.lua;;&quot;;  #lua 模块  </span><br><span class="line">lua_package_cpath &quot;&#x2F;usr&#x2F;example&#x2F;lualib&#x2F;?.so;;&quot;;  #c模块   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在来简单的开发一个lua模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim &#x2F;usr&#x2F;example&#x2F;lualib&#x2F;module1.lua </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在module1.lua文件加上以下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local count &#x3D; 0  </span><br><span class="line">local function hello()  </span><br><span class="line">   count &#x3D; count + 1  </span><br><span class="line">   ngx.say(&quot;count : &quot;, count)  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line">local _M &#x3D; &#123;  </span><br><span class="line">   hello &#x3D; hello  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">return _M  </span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开发时将所有数据做成局部变量/局部函数；通过 _M导出要暴露的函数，实现模块化封装。</p>
<p>在／usr/example/lua目录下创建一个test_module_1.lua 文件，在该文件中引用上面的module1.lua文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">vim &#x2F;usr&#x2F;example&#x2F;lua&#x2F;test_module_1.lua </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加上以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local module1 &#x3D; require(&quot;module1&quot;)  </span><br><span class="line">  </span><br><span class="line">module1.hello() </span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>通过require(“模块名”)来加载模块，如果是多级目录，则需要通过require(“目录1.目录2.模块名”）加载。</p>
<p>在/user/example/example.conf中加上以下的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua_module_1 &#123;  </span><br><span class="line">    default_type &#39;text&#x2F;html&#39;;  </span><br><span class="line">    lua_code_cache on;  </span><br><span class="line">    content_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;test_module_1.lua;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>多次在浏览器上访问：<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_module_1%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%EF%BC%9A">http://116.196.177.123/lua_module_1，浏览器显示：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count : 1</span><br><span class="line">count : 2</span><br><span class="line">count : 3</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="安装redis"><a href="#安装redis" class="headerlink" title="安装redis"></a>安装redis</h2><p>linux下安装：<br>cd /usr/servers</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis-3.2.6.tar.gz</span><br><span class="line">$ tar xzf redis-3.2.6.tar.gz</span><br><span class="line">$ cd redis-3.2.6</span><br><span class="line">$ make</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动redis:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nohup &#x2F;usr&#x2F;servers&#x2F;redis-3.2.6&#x2F;src&#x2F;redis-server  &#x2F;usr&#x2F;servers&#x2F;redis-3.2.6&#x2F;redis.conf &amp;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看是否启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef |grep redis</span><br></pre></td></tr></table></figure>

<p>终端显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">root     20985 14268  0 18:49 pts&#x2F;0    00:00:00 &#x2F;usr&#x2F;servers&#x2F;redis-3.2.6&#x2F;src&#x2F;redis-server 127.0.0.1:6379</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可见redis已经启动。</p>
<h2 id="lua连接redis"><a href="#lua连接redis" class="headerlink" title="lua连接redis"></a>lua连接redis</h2><p>lua_resty_redis模块地址：<a target="_blank" rel="noopener" href="https://github.com/openresty/lua-resty-redis">https://github.com/openresty/lua-resty-redis</a></p>
<blockquote>
<p>lua-resty-redis - Lua redis client driver for the ngx_lua based on the cosocket API</p>
</blockquote>
<p>lua_resty_redis 它是一个基于cosocket API的为ngx_lua模块提供Lua redis客户端的驱动。</p>
<p>创建一个test_redis_basic.lua文件</p>
<p>vim /usr/example/lua/test_redis_basic.lua</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> local function close_redis(red)  </span><br><span class="line">    if not red then  </span><br><span class="line">        return  </span><br><span class="line">    end  </span><br><span class="line">  </span><br><span class="line">    local pool_max_idle_time &#x3D; 10000 --毫秒  </span><br><span class="line">    local pool_size &#x3D; 100 --连接池大小  </span><br><span class="line">    local ok, err &#x3D; red:set_keepalive(pool_max_idle_time, pool_size)  </span><br><span class="line">    if not ok then  </span><br><span class="line">        ngx.say(&quot;set keepalive error : &quot;, err)  </span><br><span class="line">    end  </span><br><span class="line">end    </span><br><span class="line">  </span><br><span class="line">local redis &#x3D; require(&quot;resty.redis&quot;)  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">local red &#x3D; redis:new()  </span><br><span class="line"> </span><br><span class="line">red:set_timeout(1000)  </span><br><span class="line"></span><br><span class="line">local ip &#x3D; &quot;127.0.0.1&quot;  </span><br><span class="line">local port &#x3D; 6379  </span><br><span class="line">local ok, err &#x3D; red:connect(ip, port)  </span><br><span class="line">if not ok then  </span><br><span class="line">    ngx.say(&quot;connect to redis error : &quot;, err)  </span><br><span class="line">    return close_redis(red)  </span><br><span class="line">end  </span><br><span class="line"> </span><br><span class="line">ok, err &#x3D; red:set(&quot;msg&quot;, &quot;hello world&quot;)  </span><br><span class="line">if not ok then  </span><br><span class="line">    ngx.say(&quot;set msg error : &quot;, err)  </span><br><span class="line">    return close_redis(red)  </span><br><span class="line">end  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">local resp, err &#x3D; red:get(&quot;msg&quot;)  </span><br><span class="line">if not resp then  </span><br><span class="line">    ngx.say(&quot;get msg error : &quot;, err)  </span><br><span class="line">    return close_redis(red)  </span><br><span class="line">end  </span><br><span class="line"></span><br><span class="line">if resp &#x3D;&#x3D; ngx.null then  </span><br><span class="line">    resp &#x3D; &#39;&#39;  </span><br><span class="line">end  </span><br><span class="line">ngx.say(&quot;msg : &quot;, resp)  </span><br><span class="line">  </span><br><span class="line">close_redis(red)  </span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>上面的代码很简单，通过连接池连接Redis，连接上redis后，通过set一对键值对（msg,helloword）到redis中，然后get(msg)，并通过ngx.say()返回给浏览器。</p>
<p>vim /usr/example/example.conf,添加以下的配置代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F;lua_redis_basic &#123;  </span><br><span class="line">    default_type &#39;text&#x2F;html&#39;;  </span><br><span class="line">    lua_code_cache on;  </span><br><span class="line">    content_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;test_redis_basic.lua;  </span><br><span class="line"> &#125;  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>浏览器访问：<a target="_blank" rel="noopener" href="http://116.196.177.123/lua_redis_basic">http://116.196.177.123/lua_redis_basic</a></p>
<p>浏览器显示：</p>
<blockquote>
<p>msg : hello world</p>
</blockquote>
<p>lua_resty_redis支持所有的redis指令，本身Redis就支持lua语言操作。所以lua_resty_redis模块能够提高所有的redis操作的功能。</p>
<p>在很多时候，Redis是设置了口令的，连接时，如果需要验证口令，需要添加 local res, err = red:auth(“foobared”)，示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local redis &#x3D; require &quot;resty.redis&quot;</span><br><span class="line">  local red &#x3D; redis:new()</span><br><span class="line"></span><br><span class="line">  red:set_timeout(1000) -- 1 sec</span><br><span class="line"></span><br><span class="line">  local ok, err &#x3D; red:connect(&quot;127.0.0.1&quot;, 6379)</span><br><span class="line">  if not ok then</span><br><span class="line">      ngx.say(&quot;failed to connect: &quot;, err)</span><br><span class="line">      return</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  local res, err &#x3D; red:auth(&quot;foobared&quot;)</span><br><span class="line">  if not res then</span><br><span class="line">      ngx.say(&quot;failed to authenticate: &quot;, err)</span><br><span class="line">      return</span><br><span class="line">  end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更多请关注的官方文档<a target="_blank" rel="noopener" href="https://github.com/openresty/lua-resty-redis">https://github.com/openresty/lua-resty-redis</a><br>和开涛的博客<a target="_blank" rel="noopener" href="http://jinnianshilongnian.iteye.com/blog/2187328">http://jinnianshilongnian.iteye.com/blog/2187328</a></p>
]]></content>
      <categories>
        <category>Openresty</category>
      </categories>
      <tags>
        <tag>Openresty Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title> Openresty最佳案例 | 第8篇：RBAC介绍、sql和redis模块工具类</title>
    <url>/2018/01/01/openresty-2018-01-01-openresty-best-practice-8-redis-sql-tool/</url>
    <content><![CDATA[<p>RBAC（Role-Based Access Control，基于角色的访问控制），用户基于角色的访问权限控制。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成“用户-角色-权限”的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般都是多对多的关系。如图所示：</p>
<span id="more"></span>

<p><img src="http://upload-images.jianshu.io/upload_images/2279594-d6c2a08e6c32cf53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20171105-214559@2x.png"></p>
<h2 id="sql-tool"><a href="#sql-tool" class="headerlink" title="sql_tool"></a>sql_tool</h2><p>在本案例中，采用的就是这种权限设计的方式。具体的sql语句脚本如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;user&#96; (</span><br><span class="line">&#96;id&#96;  int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">&#96;name&#96;  varchar(255) CHARACTER SET latin1 COLLATE latin1_swedish_ci NULL DEFAULT NULL ,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">)</span><br><span class="line">ENGINE&#x3D;InnoDB</span><br><span class="line">DEFAULT CHARACTER SET&#x3D;latin1 COLLATE&#x3D;latin1_swedish_ci</span><br><span class="line">AUTO_INCREMENT&#x3D;2</span><br><span class="line">ROW_FORMAT&#x3D;COMPACT</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE role(</span><br><span class="line">&#96;id&#96;  int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">&#96;name&#96;  varchar(255) CHARACTER SET latin5 NULL DEFAULT NULL ,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">)</span><br><span class="line">ENGINE&#x3D;InnoDB</span><br><span class="line">DEFAULT CHARACTER SET&#x3D;latin1 COLLATE&#x3D;latin1_swedish_ci</span><br><span class="line">AUTO_INCREMENT&#x3D;2</span><br><span class="line">ROW_FORMAT&#x3D;COMPACT</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">CREATE TABLE permission(</span><br><span class="line">&#96;id&#96;  int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">&#96;permission&#96;  varchar(255) CHARACTER SET latin1 COLLATE latin1_swedish_ci NULL DEFAULT NULL ,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">)</span><br><span class="line">ENGINE&#x3D;InnoDB</span><br><span class="line">DEFAULT CHARACTER SET&#x3D;latin1 COLLATE&#x3D;latin1_swedish_ci</span><br><span class="line">AUTO_INCREMENT&#x3D;3</span><br><span class="line">ROW_FORMAT&#x3D;COMPACT</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line">CREATE TABLE user_role(</span><br><span class="line">&#96;id&#96;  int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">&#96;user_id&#96;  int(11) NULL DEFAULT NULL ,</span><br><span class="line">&#96;role_id&#96;  int(11) NULL DEFAULT NULL ,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">)</span><br><span class="line">ENGINE&#x3D;InnoDB</span><br><span class="line">DEFAULT CHARACTER SET&#x3D;latin1 COLLATE&#x3D;latin1_swedish_ci</span><br><span class="line">AUTO_INCREMENT&#x3D;2</span><br><span class="line">ROW_FORMAT&#x3D;COMPACT</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CREATE TABLE role_permission(</span><br><span class="line">&#96;id&#96;  int(11) NOT NULL AUTO_INCREMENT ,</span><br><span class="line">&#96;role_id&#96;  int(11) NULL DEFAULT NULL ,</span><br><span class="line">&#96;permission_id&#96;  int(11) NULL DEFAULT NULL ,</span><br><span class="line">PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">)</span><br><span class="line">ENGINE&#x3D;InnoDB</span><br><span class="line">DEFAULT CHARACTER SET&#x3D;latin1 COLLATE&#x3D;latin1_swedish_ci</span><br><span class="line">AUTO_INCREMENT&#x3D;3</span><br><span class="line">ROW_FORMAT&#x3D;COMPACT</span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化以下的sql脚本，即给用户id为1的用户关联角色，角色并关联权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO &#96;permission&#96; VALUES (&#39;1&#39;, &#39;&#x2F;user&#x2F;orgs&#39;);</span><br><span class="line">INSERT INTO &#96;role&#96; VALUES (&#39;1&#39;, &#39;user&#39;);</span><br><span class="line">INSERT INTO &#96;role_permission&#96; VALUES (&#39;1&#39;, &#39;1&#39;, &#39;1&#39;);</span><br><span class="line">INSERT INTO &#96;user&#96; VALUES (&#39;1&#39;, &#39;forezp&#39;);</span><br><span class="line">INSERT INTO &#96;user_role&#96; VALUES (&#39;1&#39;, &#39;1&#39;, &#39;1&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在本案例中，需要根据user表中的Id获取该Id对应的权限。首先根据userId获取该用户对应的角色，再根据根据该角色获取相应的权限，往往一个用户具有多个角色，而角色又有多个权限。比如查询userId为1 的用户的权限的sql语句如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">SELECT  a.id,a.permission from permission a ,role_permission b,role c,user_role d,user e WHERE a.id&#x3D;b.permission_id and c.id&#x3D;b.role_id and d.role_id&#x3D;c.id and d.user_id&#x3D;e.id and e.id&#x3D;1&quot;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Openresty中怎么连接数据库，怎么查询sql语句，在之前的文章已将讲述过了。根据用户id获取用户的权限的功能是一个使用率极高的功能，所以考虑将这个功能模块化。</p>
<p>vim /usr/example/lualib/sql_tool.lua ,编辑加入以下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local mysql &#x3D; require(&quot;resty.mysql&quot;)  </span><br><span class="line"> </span><br><span class="line">local function close_db(db)  </span><br><span class="line">    if not db then  </span><br><span class="line">        return  </span><br><span class="line">    end  </span><br><span class="line">    db:close()  </span><br><span class="line">end  </span><br><span class="line"></span><br><span class="line">local function select_user_permission(user_id)</span><br><span class="line"></span><br><span class="line">   local db, err &#x3D; mysql:new()</span><br><span class="line">   if not db then  </span><br><span class="line">      ngx.say(&quot;new mysql error : &quot;, err)  </span><br><span class="line">      return  </span><br><span class="line">   end </span><br><span class="line">   db:set_timeout(1000)  </span><br><span class="line">  </span><br><span class="line">   local props &#x3D; &#123;  </span><br><span class="line">      host &#x3D; &quot;127.0.0.1&quot;,  </span><br><span class="line">      port &#x3D; 3306,  </span><br><span class="line">      database &#x3D; &quot;test&quot;,  </span><br><span class="line">      user &#x3D; &quot;root&quot;,  </span><br><span class="line">      password &#x3D; &quot;123&quot;  </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">  local res, err, errno, sqlstate &#x3D; db:connect(props)  </span><br><span class="line">  </span><br><span class="line">  if not res then  </span><br><span class="line">     ngx.say(&quot;connect to mysql error : &quot;, err, &quot; , errno : &quot;, errno, &quot; , sqlstate : &quot;, sqlstate)  </span><br><span class="line">     close_db(db)</span><br><span class="line">  end</span><br><span class="line">  </span><br><span class="line">  local select_sql &#x3D; &quot;SELECT  a.id,a.permission from permission a ,role_permission b,role c,user_role d,user e WHERE a.id&#x3D;b.permission_id and c.id&#x3D;b.role_id and d.role_id&#x3D;c.id and d.user_id&#x3D;e.id and e.id&#x3D;&quot;..user_id</span><br><span class="line">  res, err, errno, sqlstate &#x3D; db:query(select_sql)  </span><br><span class="line">  if not res then  </span><br><span class="line">     ngx.say(&quot;select error : &quot;, err, &quot; , errno : &quot;, errno, &quot; , sqlstate : &quot;, sqlstate)  </span><br><span class="line">     return close_db(db)  </span><br><span class="line">  end  </span><br><span class="line"></span><br><span class="line">   local permissions&#x3D;&#123;&#125;</span><br><span class="line">   for i, row in ipairs(res) do  </span><br><span class="line">     for name, value in pairs(row) do</span><br><span class="line">	if name &#x3D;&#x3D; &quot;permission&quot; then</span><br><span class="line">          table.insert(permissions, 1, value)</span><br><span class="line">        end  </span><br><span class="line"> </span><br><span class="line">     end  </span><br><span class="line">   end  </span><br><span class="line"> return permissions </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">local _M &#x3D; &#123;  </span><br><span class="line">    select_user_permission&#x3D; select_user_permission</span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line">return _M  </span><br><span class="line">  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上面的代码中，有一个select_user_permission(user_id)方法，该方法根据用户名获取该用户的权限。查出来存在一个table 类型的 local permissions={}中。</p>
<p>vim /usr/example/example.conf  加上以下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ &#x2F;sql_tool&#123;</span><br><span class="line">  default_type &#39;text&#x2F;html&#39;;</span><br><span class="line">  content_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;test_sql_tool.lua;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在浏览器上访问<a target="_blank" rel="noopener" href="http://116.196.177.123/sql_tool%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%E5%A6%82%E4%B8%8B%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%9A">http://116.196.177.123/sql_tool，浏览器显示如下的内容：</a></p>
<blockquote>
<p>/user/orgs</p>
</blockquote>
<h2 id="tokentool"><a href="#tokentool" class="headerlink" title="tokentool"></a>tokentool</h2><p>在之前的文章讲述了如何使用Openresty连接redis，并操作redis。 这小节将讲述如何使用openresty连接redis，并写几个方法，用于存储用户的token等，并将这些信息模块化，主要有以下几个方法：</p>
<ul>
<li>close_redis(red)  通过连接池的方式释放一个连接</li>
<li>connect() 连接redis</li>
<li>has_token(token) redis中存在token 与否</li>
<li>get_user_id(token) 根据token获取用户id</li>
<li>set_permissions(user_id,permissions) 根据userid设置权限</li>
<li>get_permissions(user_id)根据userid获取权限</li>
</ul>
<p>vim /usr/example/lualib/tokentool.lua 编辑一下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module(&quot;tokentool&quot;, package.seeall)</span><br><span class="line">local redis &#x3D; require &quot;resty.redis&quot;</span><br><span class="line">local str &#x3D; require &quot;resty.string&quot;</span><br><span class="line">local cjson &#x3D; require(&quot;cjson&quot;)  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">local redis_host &#x3D; &quot;127.0.0.1&quot;</span><br><span class="line">local redis_port &#x3D; 6379</span><br><span class="line"></span><br><span class="line">local function close_redis(red)  </span><br><span class="line">    if not red then  </span><br><span class="line">        return  </span><br><span class="line">    end  </span><br><span class="line">    local pool_max_idle_time &#x3D; 10000 --毫秒  </span><br><span class="line">    local pool_size &#x3D; 100 --连接池大小  </span><br><span class="line">    local ok, err &#x3D; red:set_keepalive(pool_max_idle_time, pool_size)  </span><br><span class="line">    if not ok then  </span><br><span class="line">        ngx.say(&quot;set keepalive error : &quot;, err)  </span><br><span class="line">    end  </span><br><span class="line">end </span><br><span class="line"></span><br><span class="line">local function connect()</span><br><span class="line">    local red &#x3D; redis:new()</span><br><span class="line">    red:set_timeout(1000)</span><br><span class="line">    local ok, err &#x3D; red:connect(redis_host, redis_port)</span><br><span class="line">    if not ok then</span><br><span class="line">        return false</span><br><span class="line">    end</span><br><span class="line">    --local res, err &#x3D; red:auth(&quot;xiaoantimes&quot;)</span><br><span class="line">    --if not res then</span><br><span class="line">     -- ngx.say(&quot;failed to authenticate: &quot;, err)</span><br><span class="line">     -- return false</span><br><span class="line">    --end</span><br><span class="line">    --ok, err &#x3D; red:select(1)</span><br><span class="line">    --if not ok then</span><br><span class="line">      --  return false</span><br><span class="line">    --end</span><br><span class="line">    return red</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function has_token(token)</span><br><span class="line">    local red &#x3D; connect()</span><br><span class="line">    if red &#x3D;&#x3D; false then</span><br><span class="line">        return false</span><br><span class="line">    end</span><br><span class="line"></span><br><span class="line">    local res, err &#x3D; red:get(token)</span><br><span class="line">    if not res then</span><br><span class="line">        return false</span><br><span class="line">    end</span><br><span class="line">    close_redis(red)  </span><br><span class="line">    return true</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function set_permissions(user_id,permissions)</span><br><span class="line">  if (permissions&#x3D;&#x3D;null) or( permissions&#x3D;&#x3D;ngx.null) then</span><br><span class="line">     return false</span><br><span class="line">  end </span><br><span class="line">  local str &#x3D; cjson.encode(permissions)  </span><br><span class="line">  ngx.log(ngx.ERR,&quot;set redis p:&quot;..str)</span><br><span class="line">  local red&#x3D;connect()</span><br><span class="line">  if red&#x3D;&#x3D; false then</span><br><span class="line">     return false</span><br><span class="line">  end</span><br><span class="line">  local ok, err &#x3D; red:set(user_id,str)</span><br><span class="line">  if not ok then</span><br><span class="line">     return false</span><br><span class="line">  end</span><br><span class="line">  return true </span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function get_permissions(user_id)</span><br><span class="line">  local red&#x3D;connect()</span><br><span class="line">  if red&#x3D;&#x3D; false then</span><br><span class="line">     return false</span><br><span class="line">  end</span><br><span class="line">  local res, err &#x3D; red:get(user_id)</span><br><span class="line">  if (not res) or (res &#x3D;&#x3D; ngx.null) then</span><br><span class="line">     return</span><br><span class="line">  end </span><br><span class="line">  ngx.log(ngx.ERR,&quot;get redis p:&quot;..res);</span><br><span class="line">  local permissions&#x3D;cjson.decode(res)  </span><br><span class="line">  return permissions</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">function get_user_id(token)</span><br><span class="line">    local red &#x3D; connect()</span><br><span class="line">    local resp, err &#x3D; red:get(token)  </span><br><span class="line">    if not resp then  </span><br><span class="line">      ngx.say(&quot;get msg error : &quot;, err)  </span><br><span class="line">      return close_redis(red)  </span><br><span class="line">    end  </span><br><span class="line">    close_redis(red)  </span><br><span class="line">    return resp</span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>vim /usr/example/lua/test_token_tool.lua，加上以下的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local tokentool&#x3D; require &quot;tokentool&quot;</span><br><span class="line">local ret &#x3D; tokentool.has_token(&quot;msg&quot;)</span><br><span class="line">ngx.log(ngx.ERR,ret)</span><br><span class="line">if ret &#x3D;&#x3D; true then</span><br><span class="line">   ngx.say(&quot;ok&quot;)</span><br><span class="line">else</span><br><span class="line">   ngx.say(&quot;oops,error&quot;)</span><br><span class="line">end</span><br><span class="line"> </span><br></pre></td></tr></table></figure>

<p>在/usr/example/example.conf加上以下的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location ~ &#x2F;token_tool&#123;</span><br><span class="line">    default_type &#39;text&#x2F;html&#39;;</span><br><span class="line">    lua_code_cache on;</span><br><span class="line">    content_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;test_token_tool.lua;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开浏览器访问<a target="_blank" rel="noopener" href="http://116.196.177.123/token_tool%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%EF%BC%9A">http://116.196.177.123/token_tool，浏览器显示：</a></p>
<blockquote>
<p>ok</p>
</blockquote>
]]></content>
      <categories>
        <category>Openresty</category>
      </categories>
      <tags>
        <tag>Openresty Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Openresty最佳案例 | 第9篇：Openresty实现的网关权限控制</title>
    <url>/2018/01/01/openresty-2018-01-01-openresty-best-practice-9-api-gateway/</url>
    <content><![CDATA[<p>采用openresty 开发出的api网关有很多，比如比较流行的kong、orange等。这些API 网关通过提供插件的形式，提供了非常多的功能。这些组件化的功能往往能够满足大部分的需求，如果要想达到特定场景的需求，可能需要二次开发，比如RBAC权限系统。本小节通过整合前面的知识点，来构建一个RBAC权限认证系统。</p>
<span id="more"></span>

<h2 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h2><p>本小节采用了以下的技术栈：</p>
<ul>
<li>Openresty(lua+nginx)</li>
<li>mysql</li>
<li>redis</li>
<li>cjson</li>
</ul>
<h2 id="验证流程"><a href="#验证流程" class="headerlink" title="验证流程"></a>验证流程</h2><ul>
<li>用户请求经过nginx，nginx的openresty的模块通过拦截请求来进行权限判断</li>
<li>openresty的access_by_lua_file模块，进行了一系列的判断<ul>
<li>用户的请求是否为白名单uri，如果为白名单uri，则直接通过验证，进入下一个验证环节content_by_lua_file,这个环节直接打印一句话：“恭喜，请求通过。”</li>
<li>如果用户请求不为白名单url，则需要取出请求header中的token,如果请求的header不存在token,则直接返回结果401，无权限访问。</li>
<li>如果用户请求的uri的请求头包含token ，则取出token，解密token取出用户id</li>
<li>根据取出的userid去查询数据库获取该用户的权限，如果权限包含了该请求的uri，请求可以通过，否则，请求不通过。</li>
</ul>
</li>
<li>请求如果通过access_by_lua_file模块，则进入到content_by_lua_file模块,该模块直接返回一个字符串给用户请求，在实际的开发中，可能为路由到具体的应用程序的服务器。</li>
</ul>
<p>验证流程图如下所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-182b922ba5df4321.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20171106-114542@2x.png"></p>
<p>vim /usr/example/example.conf ，加上以下的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">location &#x2F; &#123;</span><br><span class="line">   default_type &quot;text&#x2F;html&quot;;</span><br><span class="line">   access_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;api_access.lua;</span><br><span class="line">   content_by_lua_file &#x2F;usr&#x2F;example&#x2F;lua&#x2F;api_content.lua;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上的配置表示，要不符合已有location路径的所有请求，将走这个location为/  的路径。符合这个location的请求将进入 access_by_lua_file和 content_by_lua_file的模块判断。</p>
<p>vim /usr/example/lua/access_by_lua_file ，加上以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">local tokentool &#x3D; require &quot;tokentool&quot;</span><br><span class="line">local mysqltool &#x3D; require &quot;mysqltool&quot;</span><br><span class="line"></span><br><span class="line"> function is_include(value, tab)</span><br><span class="line">   for k,v in ipairs(tab) do</span><br><span class="line">      if v &#x3D;&#x3D; value then</span><br><span class="line">           return true</span><br><span class="line">       end</span><br><span class="line">    end</span><br><span class="line">    return false</span><br><span class="line"> end</span><br><span class="line"></span><br><span class="line">local white_uri&#x3D;&#123;&quot;&#x2F;user&#x2F;login&quot;,&quot;&#x2F;user&#x2F;validate&quot;&#125;</span><br><span class="line">  </span><br><span class="line">--local user_id &#x3D; ngx.req.get_uri_args()[&quot;userId&quot;]</span><br><span class="line">--获取header的token值</span><br><span class="line">local headers &#x3D; ngx.req.get_headers() </span><br><span class="line">local token&#x3D;headers[&quot;token&quot;]</span><br><span class="line">local url&#x3D;ngx.var.uri</span><br><span class="line">if ( not token) or (token&#x3D;&#x3D;null) or (token &#x3D;&#x3D;ngx.null) then</span><br><span class="line">  if is_include(url,white_uri)then</span><br><span class="line">     </span><br><span class="line">  else</span><br><span class="line">    return ngx.exit(401)</span><br><span class="line">  end  </span><br><span class="line">else </span><br><span class="line">  ngx.log(ngx.ERR,&quot;token:&quot;..token)</span><br><span class="line">  local user_id&#x3D;tokentool.get_user_id(token)</span><br><span class="line">  if (not user_id) or( user_id &#x3D;&#x3D;null) or ( user_id &#x3D;&#x3D; ngx.null) then</span><br><span class="line">      return ngx.exit(401)   </span><br><span class="line">  end </span><br><span class="line">  </span><br><span class="line">  ngx.log(ngx.ERR,&quot;user_id&quot;..user_id)</span><br><span class="line">  local permissions&#x3D;&#123;&#125;</span><br><span class="line">  permissions &#x3D;tokentool.get_permissions(user_id)</span><br><span class="line">  if(not permissions)or(permissions&#x3D;&#x3D;null)or( permissions &#x3D;&#x3D;ngx.null) then</span><br><span class="line">      permissions&#x3D; mysqltool.select_user_permission(user_id)</span><br><span class="line">      if permissions and permissions ~&#x3D; ngx.null then</span><br><span class="line">         tokentool.set_permissions(user_id,permissions)</span><br><span class="line">      end</span><br><span class="line">  end  </span><br><span class="line">  if(not permissions)or(permissions&#x3D;&#x3D;null)or( permissions &#x3D;&#x3D;ngx.null) then</span><br><span class="line">     return ngx.exit(401)</span><br><span class="line">  end </span><br><span class="line">  local is_contain_permission &#x3D; is_include(url,permissions) </span><br><span class="line"></span><br><span class="line">  if is_contain_permission &#x3D;&#x3D; true  then</span><br><span class="line">     -- ngx.say(&quot;congratuation! you have pass the api gateway&quot;)</span><br><span class="line">  else</span><br><span class="line">      return ngx.exit(401) </span><br><span class="line">  end   </span><br><span class="line">end</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述代码中：</p>
<ul>
<li>is_include(value, tab)，该方法判断某个字符串在不在这个table中。</li>
<li>white_uri={“/user/login”,”/user/validate”} 是一个白名单的列表。</li>
<li>local headers = ngx.req.get_headers()从请求的uri的请求头获取token</li>
<li>is_include(url,white_uri)判断该url是否为白名单url</li>
<li>local user_id=tokentool.get_user_id(token)根据token获取该token对应的用户的user_id，在常见情况下，是根据token解析出user_id，但在不同的语言加密和加密token存在盐值不一样的情况，比较麻烦，所以我偷了个懒，直接存了redis，用户登录成功后存一下。</li>
<li>permissions =tokentool.get_permissions(user_id)根据user_id<br>从redis获取该用户的权限。</li>
<li>permissions= mysqltool.select_user_permission(user_id)如果redis没有存该用户的权限，则从数据库读。</li>
<li>tokentool.set_permissions(user_id,permissions)，将从数据库中读取的权限点存在reddis中。</li>
<li>local is_contain_permission = is_include(url,permissions)，判断该url 在不在该用户对应的权限列表中。</li>
</ul>
<p>如果所有的判断通过，则该用户请求的具有权限访问，则进入content_by_lua_file模块，直接在这个模块给请求返回“congratulations! you have passed the api gateway”。</p>
<p>vim  /usr/example/lua/api_content.lua ,添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ngx.say(&quot;congratulations!&quot;,&quot; you have passed &quot;,&quot;the api gateway&quot;)  </span><br><span class="line">----200状态码退出  </span><br><span class="line">return ngx.exit(200)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="验证演示"><a href="#验证演示" class="headerlink" title="验证演示"></a>验证演示</h2><p>打开浏览器访问<a target="_blank" rel="noopener" href="http://116.196.177.123/user/login%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%EF%BC%9A">http://116.196.177.123/user/login，浏览器显示：</a></p>
<blockquote>
<p>congratulations! you have passed the api gateway</p>
</blockquote>
<p>/user/login这个url 在白名单的范围内，所以它是可以通过权限验证的。</p>
<p>打开浏览器访问<a target="_blank" rel="noopener" href="http://116.196.177.123/user/sss%EF%BC%8C%E6%98%BE%E7%A4%BA%E4%BB%A5%E4%B8%8B%E5%86%85%E5%AE%B9%EF%BC%9A">http://116.196.177.123/user/sss，显示以下内容：</a></p>
<blockquote>
<p>401 Authorization Required</p>
<p>openresty/1.11.2.4</p>
</blockquote>
<p>在redis中添加一对key-value，key为token_forezp，value为1，即token_forezp对应的用户的id为1.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;usr&#x2F;servers&#x2F;redis-3.2.6</span><br><span class="line"></span><br><span class="line">src&#x2F;redis-cli</span><br><span class="line"></span><br><span class="line">set token_forezp 1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>初始化以下的sql脚本，即给用户id为1的用户关联角色，角色并关联权限：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERT INTO &#96;permission&#96; VALUES (&#39;1&#39;, &#39;&#x2F;user&#x2F;orgs&#39;);</span><br><span class="line">INSERT INTO &#96;role&#96; VALUES (&#39;1&#39;, &#39;user&#39;);</span><br><span class="line">INSERT INTO &#96;role_permission&#96; VALUES (&#39;1&#39;, &#39;1&#39;, &#39;1&#39;);</span><br><span class="line">INSERT INTO &#96;user&#96; VALUES (&#39;1&#39;, &#39;forezp&#39;);</span><br><span class="line">INSERT INTO &#96;user_role&#96; VALUES (&#39;1&#39;, &#39;1&#39;, &#39;1&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>用postman请求，在请求头中加入token，值为token_forezp，请求结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-79defe538fe153a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="WX20171104-182432@2x.png"></p>
]]></content>
      <categories>
        <category>Openresty</category>
      </categories>
      <tags>
        <tag>Openresty Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT如何在Spring Cloud微服务系统中在服务相互调时传递</title>
    <url>/2018/01/01/openresty-2018-01-01-springcloud-jwt/</url>
    <content><![CDATA[<p>在微服务系统中，为了保证微服务系统的安全,常常使用jwt来鉴权，但是服务内部的相互调用呢。经常有人在微信上问我，我给出一个解决办法，采用Feign的拦截器。</p>
<span id="more"></span>

<p>在Feign中开启了hystrix，hystrix默认采用的是线程池作为隔离策略。线程隔离有一个难点需要处理，即隔离的线程无法获取当前请求线程的Jwt，这用ThredLocal类可以去解决，但是比较麻烦，所以我才用的是信号量模式。<br>在application.yml配置文件中使用一下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hystrix.command.default.execution.isolation.strategy: SEMAPHORE</span><br></pre></td></tr></table></figure>

<p>写一个Feign的拦截器，Feign在发送网络请求之前会执行以下的拦截器，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import feign.RequestInterceptor;</span><br><span class="line">import feign.RequestTemplate;</span><br><span class="line">import org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;7&#x2F;28.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Component</span><br><span class="line">public class JwtFeignInterceptor implements RequestInterceptor &#123;</span><br><span class="line"></span><br><span class="line">    private final String key &#x3D; &quot;Authorization&quot;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void apply(RequestTemplate template) &#123;</span><br><span class="line"></span><br><span class="line">        if (!template.headers().containsKey(key)) &#123;</span><br><span class="line">            String currentToken &#x3D; UserUtils.getCurrentToken();</span><br><span class="line">            if (!StrUtil.isEmpty(currentToken))&#123;</span><br><span class="line">                template.header(key, currentToken);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫，看看我最近博客都写了啥，带你制作高逼格的数据聚合云图</title>
    <url>/2017/04/04/python-2017-04-04-python-blogs/</url>
    <content><![CDATA[<p>今天一时兴起，想用python爬爬自己的博客，通过数据聚合，制作高逼格的云图(对词汇出现频率视觉上的展示)，看看最近我到底写了啥文章。</p>
<h2 id="一、直接上几张我的博客数据的云图"><a href="#一、直接上几张我的博客数据的云图" class="headerlink" title="一、直接上几张我的博客数据的云图"></a>一、直接上几张我的博客数据的云图</h2><h4 id="1-1-爬取文章的标题的聚合"><a href="#1-1-爬取文章的标题的聚合" class="headerlink" title="1.1 爬取文章的标题的聚合"></a>1.1 爬取文章的标题的聚合</h4><p><img src="http://upload-images.jianshu.io/upload_images/2279594-661382846e212a86.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="爬取的文章标题的数据聚合"></p>
<span id="more"></span>

<p><img src="http://upload-images.jianshu.io/upload_images/2279594-03d5c12e7a0309d7.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="爬取的文章标题的数据聚合"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-c7a31451ae8f9e2c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="爬取的文章标题的数据聚合"></p>
<h4 id="1-2-爬取文章的摘要的聚合"><a href="#1-2-爬取文章的摘要的聚合" class="headerlink" title="1.2 爬取文章的摘要的聚合"></a>1.2 爬取文章的摘要的聚合</h4><p><img src="http://upload-images.jianshu.io/upload_images/2279594-9e1ad67661db5d2c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="33.jpeg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-19e435f576714e3e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="34.jpeg"></p>
<h4 id="1-3-爬取文章的标题-摘要的聚合"><a href="#1-3-爬取文章的标题-摘要的聚合" class="headerlink" title="1.3 爬取文章的标题+摘要的聚合"></a>1.3 爬取文章的标题+摘要的聚合</h4><p><img src="http://upload-images.jianshu.io/upload_images/2279594-09f48b5098ee2f02.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21.jpeg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-7d75005594f939b4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22.jpeg"></p>
<p><strong>我最近写了SpringCloud系列教程，还有一些微服务架构方面，从云图上看，基本吻合。你若不信，可以进我的博客看看，数据还是非常准确的</strong></p>
<h2 id="二、技术栈"><a href="#二、技术栈" class="headerlink" title="二、技术栈"></a>二、技术栈</h2><ul>
<li>开发工具: pycharm</li>
<li>爬虫技术：bs64、requsts、jieba</li>
<li>分析工具：wordArt</li>
</ul>
<h2 id="三、爬虫构架设计"><a href="#三、爬虫构架设计" class="headerlink" title="三、爬虫构架设计"></a>三、爬虫构架设计</h2><p><img src="http://upload-images.jianshu.io/upload_images/2279594-c1c0cbb4a6c38d51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Azure.png"></p>
<p>整个爬虫架构非常简单：</p>
<ul>
<li>爬取我的博客：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">http://blog.csdn.net/forezp</a></li>
<li>获取数据</li>
<li>将数据用“结巴”库，分词。</li>
<li>将得到的数据在在artword上制作云图。</li>
<li>将制作出来的云图展示给用户。</li>
</ul>
<h2 id="四、具体实现"><a href="#四、具体实现" class="headerlink" title="四、具体实现"></a>四、具体实现</h2><p>先根据博客地址爬去数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;blog.csdn.net&#x2F;forezp&#39;</span><br><span class="line"></span><br><span class="line">titles&#x3D;set()</span><br><span class="line"></span><br><span class="line">def download(url):</span><br><span class="line">    if url is None:</span><br><span class="line">        return None</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; requests.get(url, headers&#x3D;&#123;</span><br><span class="line">            &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.143 Safari&#x2F;537.36&#39;,</span><br><span class="line">        &#125;)</span><br><span class="line">        if (response.status_code &#x3D;&#x3D; 200):</span><br><span class="line">            return response.content</span><br><span class="line">        return None</span><br><span class="line">    except:</span><br><span class="line">        return None</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解析标题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def parse_title(html):</span><br><span class="line">    if html is None:</span><br><span class="line">        return None</span><br><span class="line">    soup &#x3D; BeautifulSoup(html, &quot;html.parser&quot;)</span><br><span class="line">    links &#x3D; soup.find_all(&#39;a&#39;, href&#x3D;re.compile(r&#39;&#x2F;forezp&#x2F;article&#x2F;details&#39;))</span><br><span class="line">    for link in links:</span><br><span class="line"></span><br><span class="line">        titles.add(link.get_text())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解析摘要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def parse_descrtion(html):</span><br><span class="line">    if html is None:</span><br><span class="line">        return None</span><br><span class="line">    soup&#x3D;BeautifulSoup(html, &quot;html.parser&quot;)</span><br><span class="line">    disciptions&#x3D;soup.find_all(&#39;div&#39;,attrs&#x3D;&#123;&#39;class&#39;: &#39;article_description&#39;&#125;)</span><br><span class="line">    for link in disciptions:</span><br><span class="line"></span><br><span class="line">        titles.add(link.get_text())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 用“结巴”分词，”激8”分词怎么用，看这里：<a target="_blank" rel="noopener" href="https://github.com/fxsjy/jieba/">https://github.com/fxsjy/jieba/</a> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def jiebaSet():</span><br><span class="line">    strs&#x3D;&#39;&#39;</span><br><span class="line">    if titles.__len__()&#x3D;&#x3D;0:</span><br><span class="line">        return</span><br><span class="line">    for item in titles:</span><br><span class="line">        strs&#x3D;strs+item;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tags &#x3D; jieba.analyse.extract_tags(strs, topK&#x3D;100, withWeight&#x3D;True)</span><br><span class="line">    for item in tags:</span><br><span class="line">        print(item[0] + &#39;\t&#39; + str(int(item[1] * 1000)))</span><br></pre></td></tr></table></figure>
<p> 因为数据比较少，所以我直接打印在控制台，并把它复制下来，更好的方法是存在mongodb中。</p>
<p> 制作云图：<br> 用 artword在线工具，地址：<a target="_blank" rel="noopener" href="https://wordart.com/">https://wordart.com</a></p>
<p> 首先：<br> 导入从控制台复制过来的数据：</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/2279594-de72be046ecac0d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>令人尴尬的是，这个网站在绘制图的时候不支持中文，需要你从c:/windows/fonts下选择一个支持中文的字体，mac 用户从windows拷下文件夹也可以，或者在网上下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-fc5c023b1cf9f2c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>然后点击Visulize就可以生成高逼格的云图了。讲解完毕，有什么需要改进的请大家留言。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/ZhihuSpiderMan/tree/master/blogspider">https://github.com/forezp/ZhihuSpiderMan/tree/master/blogspider</a></p>
<h4 id="五、文章参考"><a href="#五、文章参考" class="headerlink" title="五、文章参考"></a>五、文章参考</h4><p><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/4fb27471295f">超简单：快速制作一款高逼格词云图</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/68951699">如何爬取百万知乎用户信息，并做了简单的分析</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何爬知乎的百万用户</title>
    <url>/2017/04/04/python-2017-04-04-python-zh/</url>
    <content><![CDATA[<h3 id="一、使用的技术栈："><a href="#一、使用的技术栈：" class="headerlink" title="一、使用的技术栈："></a>一、使用的技术栈：</h3><ul>
<li>爬虫：python27 +requests+json+bs4+time</li>
<li>分析工具： ELK套件</li>
<li>开发工具：pycharm</li>
</ul>
<h3 id="二、数据成果"><a href="#二、数据成果" class="headerlink" title="二、数据成果"></a>二、数据成果</h3><h3 id="三、简单的可视化分析"><a href="#三、简单的可视化分析" class="headerlink" title="三、简单的可视化分析"></a>三、简单的可视化分析</h3><p>1.性别分布</p>
<ul>
<li>0 绿色代表的是男性 ^ . ^</li>
<li>1 代表的是女性</li>
<li>-1 性别不确定</li>
</ul>
<p>可见知乎的用户男性颇多。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-22b13dd888296ab7.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="WechatIMG2.jpeg"></p>
<span id="more"></span>

<p>2.粉丝最多的top30</p>
<p>粉丝最多的前三十名：依次是张佳玮、李开复、黄继新等等，去知乎上查这些人，也差不多这个排名，说明爬取的数据具有一定的说服力。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-8a57509513af7829.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="粉丝最多的top30"></p>
<p>3.写文章最多的top30<br><img src="http://upload-images.jianshu.io/upload_images/2279594-c29b348c4eb380f9.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="写文章最多的top30"></p>
<h3 id="四、爬虫架构"><a href="#四、爬虫架构" class="headerlink" title="四、爬虫架构"></a>四、爬虫架构</h3><p>爬虫架构图如下：<br><img src="http://upload-images.jianshu.io/upload_images/2279594-26c9bd69af563fd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="爬虫架构图"></p>
<p>说明：</p>
<ul>
<li>选择一个活跃的用户（比如李开复）的url作为入口url.并将已爬取的url存在set中。</li>
<li>抓取内容，并解析该用户的关注的用户的列表url，添加这些url到另一个set中，并用已爬取的url作为过滤。</li>
<li>解析该用户的个人信息，并存取到本地磁盘。</li>
<li>logstash取实时的获取本地磁盘的用户数据，并给elsticsearch</li>
<li>kibana和elasticsearch配合，将数据转换成用户友好的可视化图形。</li>
</ul>
<h4 id="五-编码"><a href="#五-编码" class="headerlink" title="五.编码"></a>五.编码</h4><p>爬取一个url:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def download(url):</span><br><span class="line">    if url is None:</span><br><span class="line">        return None</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; requests.get(url, headers&#x3D;&#123;</span><br><span class="line">            &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.143 Safari&#x2F;537.36&#39;,</span><br><span class="line">            &#39;authorization&#39;: &#39;your authorization &#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        print (response.content)</span><br><span class="line">        if (response.status_code &#x3D;&#x3D; 200):</span><br><span class="line">            return response.content</span><br><span class="line">        return None</span><br><span class="line">    except:</span><br><span class="line">        return None</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解析内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def parse(response):</span><br><span class="line">    try:</span><br><span class="line">        print (response)</span><br><span class="line">        json_body &#x3D; json.loads(response);</span><br><span class="line">        json_data &#x3D; json_body[&#39;data&#39;]</span><br><span class="line">        for item in json_data:</span><br><span class="line">            if (not old_url_tokens.__contains__(item[&#39;url_token&#39;])):</span><br><span class="line">                if(new_url_tokens.__len__()&lt;2000):</span><br><span class="line">                   new_url_tokens.add(item[&#39;url_token&#39;])</span><br><span class="line">            if (not saved_users_set.__contains__(item[&#39;url_token&#39;])):</span><br><span class="line">                jj&#x3D;json.dumps(item)</span><br><span class="line">                save(item[&#39;url_token&#39;],jj )</span><br><span class="line">                saved_users_set.add(item[&#39;url_token&#39;])</span><br><span class="line"></span><br><span class="line">        if (not json_body[&#39;paging&#39;][&#39;is_end&#39;]):</span><br><span class="line">            next_url &#x3D; json_body[&#39;paging&#39;][&#39;next&#39;]</span><br><span class="line">            response2 &#x3D; download(next_url)</span><br><span class="line">            parse(response2)</span><br><span class="line"></span><br><span class="line">    except:</span><br><span class="line">        print (&#39;parse fail&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>存本地文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def save(url_token, strs):</span><br><span class="line">    f &#x3D; file(&quot;\\Users\\forezp\\Downloads\\zhihu\\user_&quot; + url_token + &quot;.txt&quot;, &quot;w+&quot;)</span><br><span class="line">    f.writelines(strs)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li>需要修改获取requests请求头的authorization。</li>
<li>需要修改你的文件存储路径。</li>
</ul>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/ZhihuSpiderMan">点击这里</a>，记得star哦！</p>
<h3 id="六-如何获取authorization"><a href="#六-如何获取authorization" class="headerlink" title="六.如何获取authorization"></a>六.如何获取authorization</h3><ul>
<li>打开chorme，打开<a target="_blank" rel="noopener" href="https://www.zhihu.com/%EF%BC%8C">https://www.zhihu.com/，</a>  </li>
<li>登陆，首页随便找个用户，进入他的个人主页，F12(或鼠标右键，点检查)</li>
<li>点击关注，刷新页面，见图：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0fa965cff3cddc64.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="如何获取authorization"></p>
<h3 id="七、可改进的地方"><a href="#七、可改进的地方" class="headerlink" title="七、可改进的地方"></a>七、可改进的地方</h3><ul>
<li>可增加线程池，提高爬虫效率</li>
<li>存储url的时候我才用的set(),并且采用缓存策略，最多只存2000个url，防止内存不够，其实可以存在redis中。</li>
<li>存储爬取后的用户我说采取的是本地文件的方式，更好的方式应该是存在mongodb中。</li>
<li>对爬取的用户应该有一个信息的过滤，比如用户的粉丝数需要大与100或者参与话题数大于10等才存储。防止抓取了过多的僵尸用户。</li>
</ul>
<h3 id="八-关于ELK套件"><a href="#八-关于ELK套件" class="headerlink" title="八.关于ELK套件"></a>八.关于ELK套件</h3><p>关于elk的套件安装就不讨论了，具体见官网就行了。网站：<a target="_blank" rel="noopener" href="https://www.elastic.co/">https://www.elastic.co/</a></p>
<p>另外logstash的配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">  # For detail config for log4j as input,</span><br><span class="line">  # See: https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;logstash&#x2F;current&#x2F;plugins-inputs-log4j.html</span><br><span class="line"></span><br><span class="line">    file &#123;</span><br><span class="line">        path &#x3D;&gt; &quot;&#x2F;Users&#x2F;forezp&#x2F;Downloads&#x2F;zhihu&#x2F;*&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  #Only matched data are send to output.</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  # For detail config for elasticsearch as output,</span><br><span class="line">  # See: https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;logstash&#x2F;current&#x2F;plugins-outputs-elasticsearch.html</span><br><span class="line"> elasticsearch &#123;</span><br><span class="line">    action &#x3D;&gt; &quot;index&quot;          #The operation on ES</span><br><span class="line">    hosts  &#x3D;&gt; &quot;localhost:9200&quot;   #ElasticSearch host, can be array.</span><br><span class="line">    index  &#x3D;&gt; &quot;zhihu&quot;         #The index to write data to.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="九、结语"><a href="#九、结语" class="headerlink" title="九、结语"></a>九、结语</h3><p>从爬取的用户数据可分析的地方很多，比如地域、学历、年龄等等，我就不一一列举了。另外，我觉得爬虫是一件非常有意思的事情，在这个内容消费升级的年代，如何在广阔的互联网的数据海洋中挖掘有价值的数据，是一件值得思考和需不断践行的事情。最后，本文仅用作交流学习。如果知乎告知我侵权，我会立刻删除本文。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python 爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 基础-数据结构-整数集合</title>
    <url>/2020/07/22/redis-2020-07-22-redis-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h4 id="整数集合定义"><a href="#整数集合定义" class="headerlink" title="整数集合定义:"></a>整数集合定义:</h4><p>整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p>
<h4 id="整数集合使用场景"><a href="#整数集合使用场景" class="headerlink" title="整数集合使用场景:"></a>整数集合使用场景:</h4><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 基础-数据结构-跳跃表</title>
    <url>/2020/07/22/redis-2020-07-22-redis-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="跳跃表定义"><a href="#跳跃表定义" class="headerlink" title="跳跃表定义:"></a>跳跃表定义:</h4><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<span id="more"></span>
<h4 id="跳跃表使用场景"><a href="#跳跃表使用场景" class="headerlink" title="跳跃表使用场景:"></a>跳跃表使用场景:</h4><p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现,<br>和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。</p>
<h4 id="跳跃表构成"><a href="#跳跃表构成" class="headerlink" title="跳跃表构成:"></a>跳跃表构成:</h4><p>Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义。</p>
<p> zskiplistNode结构用于表示跳跃表节点:</p>
<ul>
<li>层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。</li>
</ul>
<p>  每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</p>
<ul>
<li><p>后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</p>
</li>
<li><p> 分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</p>
</li>
<li><p> 成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。</p>
</li>
</ul>
<p>zskiplist结构:用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。</p>
<ul>
<li><p>header：指向跳跃表的表头节点。</p>
</li>
<li><p>tail：指向跳跃表的表尾节点</p>
</li>
<li><p>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）</p>
</li>
<li><p>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内</p>
</li>
</ul>
<h4 id="跳跃表展示图"><a href="#跳跃表展示图" class="headerlink" title="跳跃表展示图:"></a>跳跃表展示图:</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0013kywqj30w40c442f.jpg"></p>
<h4 id="zskiplistNod-结构详细介绍："><a href="#zskiplistNod-结构详细介绍：" class="headerlink" title="zskiplistNod 结构详细介绍："></a>zskiplistNod 结构详细介绍：</h4><ul>
<li>结构定义：</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh00aw82t7j317s0l041b.jpg"></p>
<p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh01aoczwpj30yc0c2tcy.jpg">  </p>
<p>查询遍历过程：</p>
<ul>
<li><p>1）迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中的第二个节点。</p>
</li>
<li><p>2）在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。</p>
</li>
<li><p>3）在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。</p>
</li>
<li><p>4）当程序再次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。</p>
</li>
</ul>
<p>举个查询例子：</p>
<p>假如要查询 数值为3.0的位置，从头节点出发遍历到3.0, 沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的位置为3。是不是很快！</p>
<h4 id="zskiplist-结构详细介绍："><a href="#zskiplist-结构详细介绍：" class="headerlink" title="zskiplist 结构详细介绍："></a>zskiplist 结构详细介绍：</h4><ul>
<li>结构定义：</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh00w61phgj316q0bumyv.jpg"></p>
<p>通过使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息</p>
<h4 id="跳跃表常见api"><a href="#跳跃表常见api" class="headerlink" title="跳跃表常见api"></a>跳跃表常见api</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh01ipeqxfj30r80miakt.jpg"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>跳跃表是有序集合的底层实现之一。</p>
</li>
<li><p>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</p>
</li>
<li><p>每个跳跃表节点的层高都是1至32之间的随机数。</p>
</li>
<li><p>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。❑跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 基础-5大对象</title>
    <url>/2020/07/22/redis-2020-07-27-redis-%E5%9F%BA%E7%A1%80-5%E5%A4%A7%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h4 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码:"></a>对象的类型与编码:</h4><p>对象类型-&gt;对象编码-&gt;对象所使用的数据结构</p>
<p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）</p>
<p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性</p>
<span id="more"></span>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1aokij6gj31860eumz2.jpg"></p>
<ul>
<li>类型</li>
</ul>
<p>对象的type属性记录了对象的类型，这个属性的值可以是列出的常量的其中一个。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1aqpij1xj30r20h6tdu.jpg"></p>
<p>一般键是字符串，值是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。</p>
<p>不同类型值对象的可以通过TYPE命令输出<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1avi4btfj30s20c8q7c.jpg"></p>
<ul>
<li>编码和底层实现</li>
</ul>
<p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1ay5hjl8j30sq0aatbf.jpg"></p>
<p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码，从而知道对应使用的数据结构。</p>
<p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率</p>
<p>举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：</p>
<p>❑因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</p>
<p>❑随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p>
<h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw，小与32字节编码设置则为embstr。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1be9pfucj31640b240y.jpg"></p>
<ul>
<li>embstr编码和raw编码对比：</li>
</ul>
<p>embstr编码 创建字符串对象分配一次内存，raw编码分配两次内存，同理释放内存也是，且embstr编码的字符串对象在内存上是连续的，更好的利用缓存的优势。</p>
<ul>
<li>编码的转换</li>
</ul>
<p>embstr编码的字符串对象在执行APPEND命令之后，对象的编码从embstr变为raw</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1btzg9ssj31fa0ewdi5.jpg"></p>
<ul>
<li>字符串命令的实现</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1bv1g61vj30wr0u0wzq.jpg"></p>
<h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象的编码可以是ziplist或者hashtable</p>
<p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p>
<ul>
<li><p>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</p>
</li>
<li><p>哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。</p>
</li>
</ul>
<p>举个例子，如果我们执行以下HSET命令，那么服务器将创建一个列表对象作为profile键的值：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1ceyr7ezj31fa0c040f.jpg"></p>
<p>如果profile键的值对象使用的是ziplist编码：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1cgljoefj31200jmn16.jpg"></p>
<p>profile哈希对象的压缩列表底层实现:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1chfkv5oj315w06eq4z.jpg"></p>
<p>如果profile键的值对象使用的是hashtable编码：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1cjz4sd9j310y0k8af6.jpg"></p>
<p>哈希命令的实现：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1cm3idw4j30zo0nggxk.jpg"></p>
<h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的编码可以是ziplist或者linkedlist</p>
<p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tcs5jd3j30z20863zu.jpg"></p>
<p>linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tdx6bicj313w086wgn.jpg"></p>
<p>StringObject 是字符串对象的简写,完整如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tei8lzsj30u404kdgu.jpg"></p>
<p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p>
<ul>
<li><p>列表对象保存的所有字符串元素的长度都小于64字节；</p>
</li>
<li><p>列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。</p>
</li>
</ul>
<p>列表命令的实现</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tfra0mkj30sa0o2h1l.jpg"></p>
<h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象的编码可以是intset或者hashtable。</p>
<p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tretdeqj30yg08y0uw.jpg"></p>
<p>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6trr0e0cj30we0ckaeb.jpg"></p>
<p>集合命令的实现</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tu7cmc0j30vw0is7h2.jpg"></p>
<h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合的编码可以是ziplist或者skiplist。</p>
<p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6twum182j310q0eo77q.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tx9fbsyj30x204g75r.jpg"></p>
<p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6ty5nhk6j318c074wf2.jpg"></p>
<ul>
<li>为什么有序集合需要同时使用跳跃表和字典来实现？</li>
</ul>
<p>理论上单独使用任何一种结构都可以实现有序集合，但从复杂度来说，<br>单独使用字典实现，虽然查找分值是O(1),但因为字典是无序的,所以排序O(NlogN）复杂度。<br>单独使用跳跃表实现，虽然可以有序，但是查询分值复杂度从O（1）上升为O（logN).</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6uc2evb0j30xk0gkgqe.jpg"></p>
<p>有序集合命令的实现</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6udkfts7j30xk0pe7jc.jpg"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 基础-数据结构-简单动态字符串</title>
    <url>/2020/07/28/redis-2020-07-28-redis-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="简单动态字符串定义"><a href="#简单动态字符串定义" class="headerlink" title="简单动态字符串定义:"></a>简单动态字符串定义:</h4><p>每个sds.h/sdshdr结构表示一个SDS值</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6v5tmf5jj31840eq0ur.jpg"></p>
<span id="more"></span>


<p>SDS示例:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6v6tnl68j30xy0d4wge.jpg"></p>
<p>SDS和C字符一样保留空字符结尾，但是不会计算在len属性里，自动分配1字节空间和末尾添加空字符都是sds函数自动完成的。</p>
<h4 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别:"></a>SDS与C字符串的区别:</h4><ul>
<li>常数复杂度获取字符串长度</li>
</ul>
<p>C字符串本身的长度不记录，所以获取对应的长度是O(n)复杂度。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vg9k270j313w0u0gv5.jpg"></p>
<p>因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O（1）.</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vh7vqaxj31180bqdhg.jpg"></p>
<p>这个结构确保了获取字符串长度的工作不会成为Redis的性能瓶颈。</p>
<ul>
<li>杜绝缓冲区溢出</li>
</ul>
<p>C字符串除了O(n)复杂度之外，还会存在缓冲区溢出（buffer overflow）</p>
<p>使用sds api对 sds修改的时候，会先检查其对应空间是否满足，不满足会自动拓展，在执行修改。</p>
<p>举个例子，SDS的API里面也有一个用于执行拼接操作的sdscat函数，它可以将一个C字符串拼接到给定SDS所保存的字符串的后面，</p>
<p>但是在执行拼接操作之前，sdscat会先检查给定SDS的空间是否足够，如果不够的话，sdscat就会先扩展SDS的空间，然后才执行拼接操作</p>
<p>拼接操作之前:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vni0q9ij30yk0aw0uf.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdscat(s,&quot; Cluster&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拼接操作之后:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vnxuvqtj30vk060dgr.jpg"></p>
<ul>
<li>减少修改字符串时带来的内存重分配次数</li>
</ul>
<p>每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作:</p>
<p>比如拼接操作（append），截断操作（trim）。</p>
<p>因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作。</p>
<p>为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录</p>
<p>SDS实现了空间预分配和惰性空间释放两种优化策略：</p>
<ul>
<li>1.空间预分配<ul>
<li>如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同</li>
<li>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间</li>
</ul>
</li>
</ul>
<blockquote>
<p>执行sdscat之前：</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vv4w7sdj30yg0bqq4v.jpg"></p>
<blockquote>
<p>执行sdscat之后：</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vyesgypj30zk066q3v.jpg"></p>
<blockquote>
<p>再次执行sdscat：</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vzveb5xj315k06e0tm.jpg"></p>
<blockquote>
<p>过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次</p>
</blockquote>
<ul>
<li>2.惰性空间释放</li>
</ul>
<p>  惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。</p>
<blockquote>
<p>执行sdstrim之前:</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6welfjn7j30u807it9m.jpg"></p>
<blockquote>
<p>执行sdstrim之后:</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6wg7f5aqj3140090jsd.jpg"></p>
<blockquote>
<p>再次执行sdscat之后：</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6wh8yuupj317k08yt9r.jpg"></p>
<p>  当然SDS也提供了相应的API，让我们可以在有需要时，真正地释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p>
<ul>
<li>二进制安全</li>
</ul>
<p>C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据  </p>
<p>为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDSAPI都会以处理二进制的方式来处理SDS存放在buf数组里的数据也是我们将SDS的buf属性称为字节数组的原因。</p>
<p>通过使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据</p>
<ul>
<li>C字符串和SDS之间的区别</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6wndju9hj30xg08k77q.jpg"></p>
<h4 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6wom8r58j30w80msds9.jpg"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1）常数复杂度获取字符串长度。</p>
<p>2）杜绝缓冲区溢出。</p>
<p>3）减少修改字符串长度时所需的内存重分配次数。</p>
<p>4）二进制安全。</p>
<p>5）兼容部分C字符串函数。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 基础-数据结构-字典</title>
    <url>/2020/07/29/redis-2020-07-29-redis-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h4 id="字典定义"><a href="#字典定义" class="headerlink" title="字典定义:"></a>字典定义:</h4><p>字典（dictionary）， 又名映射（map）或关联数组（associative array）， 是一种抽象数据结构， 由一集键值对（key-value pairs）组成， 各个键值对的键各不相同， 程序可以添加新的键值对到字典中， 或者基于键进行查找、更新或删除等操作。</p>
<span id="more"></span>

<p>字典的主要用途有以下两个： 1.实现数据库键空间（key space）2.用作 Hash 类型键的底层实现之一,具体可以看redis 5大对象那篇文章。</p>
<h4 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h4><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p>
<ul>
<li>哈希表</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6x5esz0sj317w0h4dim.jpg"></p>
<p>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点（键值对）的数量。sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面</p>
<p>一个大小为4的空哈希表:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6x8e3dn2j30xa0eeq62.jpg"></p>
<ul>
<li>哈希表节点</li>
</ul>
<p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7nrf2momj317o0icdhx.jpg"></p>
<p>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7nu7hg4qj312w08m0un.jpg"></p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7nx14aclj317s0hc413.jpg"></p>
<p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：</p>
<ul>
<li><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</p>
</li>
<li><p>而privdata属性则保存了需要传给那些类型特定函数的可选参数。</p>
</li>
</ul>
<p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用</p>
<p>除了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7o1vruinj316c0fygot.jpg"></p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当有新的键值对添加到字典中，需要根据key 算出对应的哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面</p>
<p>Redis计算哈希值和索引值的方法如下:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7o7ofn6gj318208odhy.jpg"></p>
<ul>
<li>举列：</li>
</ul>
<p>  我们要将一个键值对k0和v0添加到字典，先利用上面语句获取hash值，然后获取对应的索引值。</p>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7oaramw2j31560caacn.jpg"></p>
<h4 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h4><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）.</p>
<p>Redis的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。  </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7t7jdv02j30z40bgacf.jpg"></p>
<h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：</p>
<p>1）为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：</p>
<ul>
<li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2 n（2的n次方幂）；</li>
<li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2 n。</li>
</ul>
<p>2）将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</p>
<p>3）当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</p>
<blockquote>
<p>执行rehash之前的字典</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7tfuiudnj310a0hi0wp.jpg"></p>
<blockquote>
<p>为字典的ht[1]哈希表分配空间</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7tfuiudnj310a0hi0wp.jpg"></p>
<blockquote>
<p>将ht[0]包含的四个键值对都rehash到ht[1]</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7ticpjpwj314c0i8434.jpg"></p>
<blockquote>
<p>释放ht[0]，并将ht[1]设置为ht[0]，然后为ht[1]分配一个空白哈希表</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7tiy9y4vj310k0huwik.jpg"></p>
<p>另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作</p>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>背景：如果哈希表里保存的键值对数量不是四个，而是四百万、四千万甚至四亿个键值对，那么要一次性将这些键值对全部rehash到ht[1]的话，庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。</p>
<p>以下是哈希表渐进式rehash的详细步骤：</p>
<ul>
<li><p>1）为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</p>
</li>
<li><p>2）在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</p>
</li>
<li><p>3）在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</p>
</li>
<li><p>4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量</p>
</li>
</ul>
<p>在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。</p>
<h4 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7w8rgux8j31080bk0x6.jpg"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 的线程模型</title>
    <url>/2020/10/26/redis-2020-10-26-redis-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="Redis-的线程模型"><a href="#Redis-的线程模型" class="headerlink" title="Redis 的线程模型"></a>Redis 的线程模型</h3><p>Redis 内部使用文件事件处理器 file event handler ，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</p>
<span id="more"></span>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。</p>
<p>来看客户端与 Redis 的一次通信过程：</p>
<p>Redis-single-thread-model</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk2qyo3nu4j31c80r8n45.jpg"></p>
<p>要明白，通信是通过 socket 来完成的，不懂的同学可以先去看一看 socket 网络编程。</p>
<p>首先，Redis 服务端进程初始化的时候，会将 server socket 的 AE_READABLE 事件与连接应答处理器关联。</p>
<p>客户端 socket01 向 Redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。</p>
<p>假设此时客户端发送了一个 set key value 请求，此时 Redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 AE_READABLE 事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。</p>
<p>如果此时客户端准备好接收返回结果了，那么 Redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok ，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。</p>
<p>这样便完成了一次通信。</p>
<h3 id="为啥-Redis-单线程模型也能效率这么高？"><a href="#为啥-Redis-单线程模型也能效率这么高？" class="headerlink" title="为啥 Redis 单线程模型也能效率这么高？"></a>为啥 Redis 单线程模型也能效率这么高？</h3><ul>
<li>纯内存操作。</li>
<li>核心是基于非阻塞的 IO 多路复用机制。</li>
<li> C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。</li>
<li> 单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li>
</ul>
<h3 id="Redis-6-0-开始引入多线程"><a href="#Redis-6-0-开始引入多线程" class="headerlink" title="Redis 6.0 开始引入多线程"></a>Redis 6.0 开始引入多线程</h3><p>注意！ Redis 6.0 之后的版本抛弃了单线程模型这一设计，原本使用单线程运行的 Redis 也开始选择性地使用多线程模型。</p>
<p>前面还在强调 Redis 单线程模型的高效性，现在为什么又要引入多线程？这其实说明 Redis 在有些方面，单线程已经不具有优势了。因为读写网络的 Read/Write 系统调用在 Redis 执行期间占用了大部分 CPU 时间，如果把网络读写做成多线程的方式对性能会有很大提升。</p>
<p>Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。 之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务、LPUSH/LPOP 等等的并发问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 线程模型</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 的事物</title>
    <url>/2020/10/27/redis-2020-10-27-redis-%E7%9A%84%E4%BA%8B%E7%89%A9/</url>
    <content><![CDATA[<p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务的基础。</p>
<span id="more"></span>
<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<!--more-->
<p>EXEC 命令负责触发并执行事务中的所有命令：<br>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。<br>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。<br>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。<br>使用 redis-check-aof 程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p>
<ul>
<li>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。<br>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>MULTI 命令用于开启一个事务，它总是返回 OK 。</p>
<p>MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC 命令被调用时， 所有队列中的命令才会被执行。</p>
<p>另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。</p>
<p>以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br></pre></td></tr></table></figure>
<p>EXEC 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。</p>
<p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。</p>
<h3 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h3><p>使用事务时可能会遇上以下两种错误：</p>
<ul>
<li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</li>
<li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。<br>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</li>
</ul>
<p>不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</p>
<p>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。</p>
<p>至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。</p>
<p>从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line"></span><br><span class="line">MULTI</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">SET a 3</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">+QUEUED</span><br><span class="line">LPOP a</span><br><span class="line"></span><br><span class="line">+QUEUED</span><br><span class="line">EXEC</span><br><span class="line"></span><br><span class="line">*2</span><br><span class="line">+OK</span><br><span class="line">-ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>

<p>EXEC 返回两条批量回复（bulk reply）： 第一条是 OK ，而第二条是 -ERR 。 至于怎样用合适的方法来表示事务中的错误， 则是由客户端自己决定的。</p>
<p>最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。</p>
<p>以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：</p>
<p>MULTI<br>+OK</p>
<p>INCR a b c<br>-ERR wrong number of arguments for ‘incr’ command<br>因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。</p>
<h3 id="为什么-Redis-不支持回滚（roll-back）"><a href="#为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="为什么 Redis 不支持回滚（roll back）"></a>为什么 Redis 不支持回滚（roll back）</h3><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p>
<p>以下是这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。<br>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</li>
</ul>
<p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>
<h3 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h3><p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis&gt; SET foo 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET foo</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>
<h3 id="使用-check-and-set-操作实现乐观锁"><a href="#使用-check-and-set-操作实现乐观锁" class="headerlink" title="使用 check-and-set 操作实现乐观锁"></a>使用 check-and-set 操作实现乐观锁</h3><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p>
<p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回空多条批量回复（null multi-bulk reply）来表示事务已经失败。</p>
<p>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。</p>
<p>首先我们可能会这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val &#x3D; GET mykey</span><br><span class="line">val &#x3D; val + 1</span><br><span class="line">SET mykey $val</span><br></pre></td></tr></table></figure>
<p>上面的这个实现在只有一个客户端的时候可以执行得很好。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。</p>
<p>举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。</p>
<p>有了 WATCH ， 我们就可以轻松地解决这类问题了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line"></span><br><span class="line">val &#x3D; GET mykey</span><br><span class="line">val &#x3D; val + 1</span><br><span class="line"></span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>
<p>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。</p>
<p>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p>
<h3 id="了解-WATCH"><a href="#了解-WATCH" class="headerlink" title="了解 WATCH"></a>了解 WATCH</h3><p>WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。</p>
<p>如果你使用 WATCH 监视了一个带过期时间的键， 那么即使这个键过期了， 事务仍然可以正常执行， 关于这方面的详细情况，请看这个帖子： <a target="_blank" rel="noopener" href="http://code.google.com/p/redis/issues/detail?id=270">http://code.google.com/p/redis/issues/detail?id=270</a></p>
<p>WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。</p>
<p>用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：</p>
<p>redis&gt; WATCH key1 key2 key3<br>OK<br>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。</p>
<p>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</p>
<p>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</p>
<h3 id="使用-WATCH-实现-ZPOP"><a href="#使用-WATCH-实现-ZPOP" class="headerlink" title="使用 WATCH 实现 ZPOP"></a>使用 WATCH 实现 ZPOP</h3><p>WATCH 可以用于创建 Redis 没有内置的原子操作。</p>
<p>举个例子， 以下代码实现了原创的 ZPOP 命令， 它可以原子地弹出有序集合中分值（score）最小的元素：</p>
<p>WATCH zset<br>element = ZRANGE zset 0 0<br>MULTI<br>    ZREM zset element<br>EXEC<br>程序只要重复执行这段代码， 直到 EXEC 的返回值不是空多条回复（null multi-bulk reply）即可。</p>
<h3 id="Redis-脚本和事务"><a href="#Redis-脚本和事务" class="headerlink" title="Redis 脚本和事务"></a>Redis 脚本和事务</h3><p>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。</p>
<p>因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。</p>
<p>不过我们并不打算在短时间内就移除事务功能， 因为事务提供了一种即使不使用脚本， 也可以避免竞争条件的方法， 而且事务本身的实现并不复杂。</p>
<p>不过在不远的将来， 可能所有用户都会只使用脚本来实现事务也说不定。 如果真的发生这种情况的话， 那么我们将废弃并最终移除事务功能。</p>
<blockquote>
<p>译者：黄健宏<br>原文：<a target="_blank" rel="noopener" href="http://redisdoc.com/topic/transaction.html">http://redisdoc.com/topic/transaction.html</a><br>本文档翻译自： <a target="_blank" rel="noopener" href="http://redis.io/topics/transactions">http://redis.io/topics/transactions</a></p>
</blockquote>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 事物</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做好监控微服务调⽤?</title>
    <url>/2021/06/16/service-06-16-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%9B%91%E6%8E%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E2%BD%A4/</url>
    <content><![CDATA[<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/%E5%9B%BE%E6%80%AA%E5%85%BD_17f35bc65eed401b374b1b5fcf552d44_83179.png" style="zoom:90%;" />

<h6 id="监控对象"><a href="#监控对象" class="headerlink" title="监控对象"></a>监控对象</h6><ul>
<li><p>⽤户端监控。通常是指业务直接对⽤户提供的功能的监控</p>
</li>
<li><p>接口监控。通常是指业务提供的功能所依赖的接口的监控</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>资源监控。通常是指某个接⼝依赖的资源的监控。比如该接口使用的redis 缓存，对redis 的监控就是资源的</p>
<p>监控</p>
</li>
<li><p>基础监控。通常是指对服务器本身的健康状况的监控。主要包括CPU利⽤率、内存使⽤量、I/O读写量、⽹卡</p>
<p>带宽等</p>
</li>
</ul>
<h6 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h6><ul>
<li><p>请求量。请求量监控分为两个维度，⼀个是实时请求量QPS，⼀个是统计请求量PV。QPS（Queries Per</p>
<p>Second） 即每秒查询次数来衡量，它反映了服务调⽤的实时变化情况。统计请求量⼀般⽤PV（Page View）</p>
<p>即⼀段时间内⽤户的访 问量来衡量，⽐如⼀天的PV代表了服务⼀天的请求量，通常⽤来统计报表。</p>
</li>
<li><p>响应时间。⼤多数情况下，可以⽤⼀段时间内所有调⽤的平均耗时来反映请求的响应时间。可以把响应时间划</p>
<p>分为多个区间，⽐如0～10ms、10ms～50ms、50ms～ 100ms、100ms～500ms、500ms以上这五个区</p>
<p>间。除此之外，还可以从P90、P95、P99、P999⻆度来监控请求的响应时间，⽐如P99 = 500ms，意思是</p>
<p>99%的请求响 应时间在500ms以内，它代表了请求的服务质量，即SLA。</p>
</li>
<li><p>错误率。错误率的监控通常⽤⼀段时间内调⽤失败的次数占调⽤总次数的⽐率来衡量，⽐如对于接⼝的错误率</p>
<p>⼀般⽤接⼝ 返回错误码为503的⽐率来表示。</p>
</li>
</ul>
<h6 id="监控维度"><a href="#监控维度" class="headerlink" title="监控维度"></a>监控维度</h6><ul>
<li><p>全局维度。从整体⻆度监控对象的的请求量、平均耗时以及错误率，全局维度的监控⼀般是为了让你对监控对象的调⽤情 况有个整体了解。</p>
</li>
<li><p> 分机房维度。</p>
</li>
<li><p> 时间维度。同⼀个监控对象，在每天的同⼀时刻各种指标通常也不会⼀样</p>
</li>
<li><p>核⼼维度。业务上⼀般会依据重要性程度对监控对象进⾏分级，最简单的是分成核⼼业务和⾮核⼼业务。</p>
<p>核⼼业务和⾮核⼼业务在部署上必须隔离，分开监控，这样才能对核⼼业务做重点保障。</p>
</li>
</ul>
<h6 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h6><blockquote>
<p>主要包括四个环节：数据采集、数据传输、数据处理和数据展示</p>
</blockquote>
<ul>
<li><p>数据采集</p>
<p>通常有两种数据收集⽅式：</p>
<ul>
<li><p><strong>服务主动上报</strong>，这种处理⽅式通过在业务代码或者服务框架⾥加⼊数据收集代码逻辑，在每⼀次服务</p>
<p>调⽤完成后，主动上报服务的调⽤信息。</p>
</li>
<li><p><strong>代理收集</strong>，这种处理⽅式通过服务调⽤后把调⽤的详细信息记录到本地⽇志⽂件中，然后再通过代理去解</p>
<p>析本地⽇志⽂ 件，然后再上报服务的调⽤信息。</p>
</li>
</ul>
</li>
<li><p>数据传输</p>
<ul>
<li><p><strong>UDP传输</strong>，这种处理⽅式是数据处理单元提供服务器的请求地址，数据采集后通过UDP协议与服务器建⽴</p>
<p>连接，然后把数 据发送过去。</p>
</li>
<li><p><strong>Kafka传输</strong>，这种处理⽅式是数据采集后发送到指定的Topic，然后数据处理单元再订阅对应的Topic，就</p>
<p>可以从Kafka消息队列中读取到对应的数据。</p>
<img src="https://cdn.smalltechnologyjun.com//image-20210615200330740.png" alt="image-20210615200330740" style="zoom: 80%;" /></li>
</ul>
</li>
<li><p>数据处理</p>
<p>数据聚合两个维度：接口维度和机器维度</p>
<p>聚合后的数据持久化： 索引数据库(es) 或者 时序数据库influxDB</p>
</li>
<li><p>数据展示</p>
<p>数据展示有多种⽅式，⽐如曲线图、饼状图、格⼦图展示</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>微服务治理</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第22篇：整合elk，搭建实时日志平台</title>
    <url>/2017/05/05/springboot-2017-05-05-sprinboot25-elk/</url>
    <content><![CDATA[<p>这篇文章主要介绍springboot整合elk.</p>
<span id="more"></span>

<h2 id="elk-简介"><a href="#elk-简介" class="headerlink" title="elk 简介"></a>elk 简介</h2><ul>
<li><p>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</p>
</li>
<li><p>Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。</p>
</li>
<li><p>Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。</p>
</li>
</ul>
<h2 id="elk下载安装"><a href="#elk下载安装" class="headerlink" title="elk下载安装"></a>elk下载安装</h2><p>elk下载地址：<a target="_blank" rel="noopener" href="https://www.elastic.co/downloads/">https://www.elastic.co/downloads/</a></p>
<p>建议在 linux上运行，elk在windows上支持得不好，另外需要jdk1.8 的支持，需要提前安装好jdk.</p>
<p>下载完之后： 安装，以logstash为栗子：</p>
<blockquote>
<p>cd /usr/local/</p>
<p>mkdir logstash</p>
<p>tar -zxvf logstash-5.3.2.tar.gz</p>
<p>mv logstash-5.3.2 /usr/local/logstash</p>
</blockquote>
<h2 id="配置、启动-Elasticsearch"><a href="#配置、启动-Elasticsearch" class="headerlink" title="配置、启动 Elasticsearch"></a>配置、启动 Elasticsearch</h2><p>打开Elasticsearch的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure>
<p>修改配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">network.host&#x3D;localhost</span><br><span class="line">network.port&#x3D;9200</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它默认就是这个配置，没有特殊要求，在本地不需要修改。</p>
<p>启动Elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;elasticsearch</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动成功，访问localhost:9200,网页显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;56IrTCM&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;e4ja7vS2TIKI1BsggEAa6Q&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;5.2.2&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;f9d9b74&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2017-02-24T17:26:45.835Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;6.4.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置、启动-logstash"><a href="#配置、启动-logstash" class="headerlink" title="配置、启动 logstash"></a>配置、启动 logstash</h2><p>在 logstash的主目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim config&#x2F;log4j_to_es.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改 log4j_to_es.conf 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  log4j &#123;</span><br><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span><br><span class="line">    host &#x3D;&gt; &quot;localhost&quot;</span><br><span class="line">    port &#x3D;&gt; 4560</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  #Only matched data are send to output.</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">    action &#x3D;&gt; &quot;index&quot;          #The operation on ES</span><br><span class="line">    hosts  &#x3D;&gt; &quot;localhost:9200&quot;   #ElasticSearch host, can be array.</span><br><span class="line">    index  &#x3D;&gt; &quot;applog&quot;         #The index to write data to.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改完配置后启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;logstash -f config&#x2F;log4j_to_es.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>终端显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-77bf8e6fba787399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720" alt="image.png"></p>
<p>访问localhost:9600</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;host&quot;:&quot;Pc-20130412.local&quot;,&quot;version&quot;:&quot;5.3.2&quot;,&quot;http_address&quot;:&quot;127.0.0.1:9600&quot;,&quot;id&quot;:&quot;e6bb985c-c688-49a4-</span><br><span class="line">a55b-4d362bb4136f&quot;,&quot;name&quot;:&quot;Pc-20130412.local&quot;,&quot;build_date&quot;:</span><br><span class="line">&quot;2017-04-24T16:32:22Z&quot;,&quot;build_sha&quot;:&quot;242159a5eea55fe213fe5c8</span><br><span class="line">52d36455e24252c82&quot;,&quot;build_snapshot&quot;:false&#125;</span><br></pre></td></tr></table></figure>

<p>证明logstash启动成功。</p>
<h2 id="配置、启动kibana"><a href="#配置、启动kibana" class="headerlink" title="配置、启动kibana"></a>配置、启动kibana</h2><p>到kibana的安装目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;kibana </span><br></pre></td></tr></table></figure>

<p>默认配置即可。</p>
<p>访问localhost:5601，网页显示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-6524e596d53ec119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720" alt="image.png"></p>
<p>证明启动成功。</p>
<h2 id="创建springboot工程"><a href="#创建springboot工程" class="headerlink" title="创建springboot工程"></a>创建springboot工程</h2><p>起步依赖如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;exclusions&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;&#x2F;exclusion&gt;</span><br><span class="line">			&lt;&#x2F;exclusions&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.3.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>log4j的配置，／src/resources/log4j.properties如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">log4j.rootLogger&#x3D;INFO,console</span><br><span class="line"></span><br><span class="line"># for package com.demo.elk, log would be sent to socket appender.</span><br><span class="line">log4j.logger.com.forezp&#x3D;DEBUG, socket</span><br><span class="line"></span><br><span class="line"># appender socket</span><br><span class="line">log4j.appender.socket&#x3D;org.apache.log4j.net.SocketAppender</span><br><span class="line">log4j.appender.socket.Port&#x3D;4560</span><br><span class="line">log4j.appender.socket.RemoteHost&#x3D;localhost</span><br><span class="line">log4j.appender.socket.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.socket.layout.ConversionPattern&#x3D;%d [%-5p] [%l] %m%n</span><br><span class="line">log4j.appender.socket.ReconnectionDelay&#x3D;10000</span><br><span class="line"></span><br><span class="line"># appender console</span><br><span class="line">log4j.appender.console&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.target&#x3D;System.out</span><br><span class="line">log4j.appender.console.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern&#x3D;%d [%-5p] [%l] %m%n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印log测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringbootElkApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void contextLoads() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Logger logger &#x3D; Logger.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		for(int i&#x3D;0;i&lt;100;i++) &#123;</span><br><span class="line">			logger.info(&quot;输出info  &quot;);</span><br><span class="line">			logger.debug(&quot;输出debug+skkkw嗡嗡嗡kw&quot;);</span><br><span class="line">			logger.error(&quot;输出error  嗡嗡嗡我&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在kibana-实时监控日志"><a href="#在kibana-实时监控日志" class="headerlink" title="在kibana 实时监控日志"></a>在kibana 实时监控日志</h2><p>打开localhost:5601:</p>
<p>Management=&gt;index pattrns=&gt;add new:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-14a8c8e08d971647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>点击discovery:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-1f43ebd237e8543e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://my.oschina.net/itblog/blog/547250">https://my.oschina.net/itblog/blog/547250</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot非官方教程 | 终章：文章汇总</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-all/</url>
    <content><![CDATA[<h1 id="SpringBoot非官方教程-终章：文章汇总"><a href="#SpringBoot非官方教程-终章：文章汇总" class="headerlink" title="SpringBoot非官方教程 | 终章：文章汇总"></a>SpringBoot非官方教程 | 终章：文章汇总</h1><p> springboot非官方教程，可能最接近于官方的一个教程，大多数案例都来自于官方文档，为了更好的理解，加入了个人的改造。</p>
<p>码云下载：<a target="_blank" rel="noopener" href="https://git.oschina.net/forezp/SpringBootLearning">https://git.oschina.net/forezp/SpringBootLearning</a></p>
<p> 源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a>,谢谢支持，记得star哦。</p>
 <span id="more"></span>
<p>欢迎关注：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">SpringCloud 系列教程</a></p>
<h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341651">SpringBoot非官方教程 | 第一篇：构建第一个SpringBoot工程</a></p>
<h2 id="配置篇"><a href="#配置篇" class="headerlink" title="配置篇"></a>配置篇</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70437576"> SpringBoot非官方教程 | 第二篇：Spring Boot配置文件详解</a></p>
<h2 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70477821">SpringBoot非官方教程 | 第三篇：SpringBoot用JdbcTemplates访问Mysql</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70545038">SpringBoot非官方教程 |  第四篇：SpringBoot 整合JPA</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70662983">SpringBoot非官方教程 | 第五篇：springboot整合 beatlsql</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70768477">SpringBoot非官方教程 | 第六篇：springboot整合mybatis</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70833629">SpringBoot非官方教程 | 第七篇：springboot开启声明式事务</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70941577">SpringBoot非官方教程 | 第八篇：springboot整合mongodb</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70991675"> SpringBoot非官方教程 | 第九篇： springboot整合Redis</a></p>
<h2 id="构架文档篇"><a href="#构架文档篇" class="headerlink" title="构架文档篇"></a>构架文档篇</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023510">SpringBoot非官方教程 | 第十篇： 用spring Restdocs创建API文档</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023536"> SpringBoot非官方教程 | 第十一篇：springboot集成swagger2，构建优雅的Restful API</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023579">SpringBoot非官方教程 | 第十二篇：springboot集成apidoc</a></p>
<h2 id="缓存篇"><a href="#缓存篇" class="headerlink" title="缓存篇"></a>缓存篇</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023614">SpringBoot非官方教程 | 第十三篇：springboot集成spring cache</a></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023652">SpringBoot非官方教程 | 第十四篇：在springboot中用redis实现消息队列</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023692"> SpringBoot非官方教程 | 第十五篇：Springboot整合RabbitMQ</a></p>
<h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023724">SpringBoot非官方教程 | 第十六篇：用restTemplate消费服务</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023752">SpringBoot非官方教程 | 第十七篇：上传文件</a></p>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023783">SpringBoot非官方教程 | 第十八篇： 定时任务（Scheduling Tasks）</a></p>
<h2 id="表单相关"><a href="#表单相关" class="headerlink" title="表单相关"></a>表单相关</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023817">SpringBoot非官方教程 | 第十九篇： 验证表单信息</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023868">SpringBoot非官方教程 | 第二十篇： 处理表单提交</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71024024"> SpringBoot非官方教程 | 第二十一篇： springboot集成JMS</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71024153">SpringBoot非官方教程 | 第二十二篇： 创建含有多module的springboot工程</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71024169"> SpringBoot非官方教程 | 第二十三篇： 异步方法</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71024219"> SpringBoot非官方教程 | 第二十四篇： springboot整合docker</a></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/61472783"> SpringBoot非官方教程 | 第二十五篇： 2小时学会springboot</a></p>
<h2 id="未完结"><a href="#未完结" class="headerlink" title="未完结"></a>未完结</h2><ul>
<li>待续。。。</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第23篇：异步方法</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-ansy/</url>
    <content><![CDATA[<p>这篇文章主要介绍在springboot 使用异步方法，去请求github api.</p>
<span id="more"></span>


<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>在pom文件引入相关依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>创建一个接收数据的实体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@JsonIgnoreProperties(ignoreUnknown&#x3D;true)</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String blog;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBlog() &#123;</span><br><span class="line">        return blog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBlog(String blog) &#123;</span><br><span class="line">        this.blog &#x3D; blog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User [name&#x3D;&quot; + name + &quot;, blog&#x3D;&quot; + blog + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个请求的　githib的service:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class GitHubLookupService &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(GitHubLookupService.class);</span><br><span class="line"></span><br><span class="line">    private final RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public GitHubLookupService(RestTemplateBuilder restTemplateBuilder) &#123;</span><br><span class="line">        this.restTemplate &#x3D; restTemplateBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public Future&lt;User&gt; findUser(String user) throws InterruptedException &#123;</span><br><span class="line">        logger.info(&quot;Looking up &quot; + user);</span><br><span class="line">        String url &#x3D; String.format(&quot;https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;%s&quot;, user);</span><br><span class="line">        User results &#x3D; restTemplate.getForObject(url, User.class);</span><br><span class="line">        &#x2F;&#x2F; Artificial delay of 1s for demonstration purposes</span><br><span class="line">        Thread.sleep(1000L);</span><br><span class="line">        return new AsyncResult&lt;&gt;(results);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过，RestTemplate去请求，另外加上类@Async 表明是一个异步任务。</p>
<p>开启异步任务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAsync</span><br><span class="line">public class Application extends AsyncConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Executor getAsyncExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor &#x3D; new ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(2);</span><br><span class="line">        executor.setMaxPoolSize(2);</span><br><span class="line">        executor.setQueueCapacity(500);</span><br><span class="line">        executor.setThreadNamePrefix(&quot;GithubLookup-&quot;);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        return executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>通过@EnableAsync开启异步任务；并且配置AsyncConfigurerSupport，比如最大的线程池为2.</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AppRunner implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(AppRunner.class);</span><br><span class="line"></span><br><span class="line">    private final GitHubLookupService gitHubLookupService;</span><br><span class="line"></span><br><span class="line">    public AppRunner(GitHubLookupService gitHubLookupService) &#123;</span><br><span class="line">        this.gitHubLookupService &#x3D; gitHubLookupService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; Start the clock</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Kick of multiple, asynchronous lookups</span><br><span class="line">        Future&lt;User&gt; page1 &#x3D; gitHubLookupService.findUser(&quot;PivotalSoftware&quot;);</span><br><span class="line">        Future&lt;User&gt; page2 &#x3D; gitHubLookupService.findUser(&quot;CloudFoundry&quot;);</span><br><span class="line">        Future&lt;User&gt; page3 &#x3D; gitHubLookupService.findUser(&quot;Spring-Projects&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Wait until they are all done</span><br><span class="line">        while (!(page1.isDone() &amp;&amp; page2.isDone() &amp;&amp; page3.isDone())) &#123;</span><br><span class="line">            Thread.sleep(10); &#x2F;&#x2F;10-millisecond pause between each check</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Print results, including elapsed time</span><br><span class="line">        logger.info(&quot;Elapsed time: &quot; + (System.currentTimeMillis() - start));</span><br><span class="line">        logger.info(&quot;--&gt; &quot; + page1.get());</span><br><span class="line">        logger.info(&quot;--&gt; &quot; + page2.get());</span><br><span class="line">        logger.info(&quot;--&gt; &quot; + page3.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动程序，控制台会打印：</p>
<blockquote>
<p>2017-04-30 13:11:10.351  INFO 1511 — [ GithubLookup-1] com.forezp.service.GitHubLookupService   : Looking up PivotalSoftware<br>2017-04-30 13:11:10.351  INFO 1511 — [ GithubLookup-2] com.forezp.service.GitHubLookupService   : Looking up CloudFoundry<br>2017-04-30 13:11:13.144  INFO 1511 — [ GithubLookup-2] com.forezp.service.GitHubLookupService   : Looking up Spring-Projects</p>
</blockquote>
<p>耗时：3908</p>
<p>分析：可以卡的前面2个方法分别在GithubLookup-1 和GithubLookup-2执行，第三个在GithubLookup-2执行，注意因为在配置线程池的时候最大线程为2.如果你把线程池的个数为3的时候，耗时减少。</p>
<p>如果去掉@Async，你会发现，执行这三个方法都在main线程中执行。耗时总结，如下：</p>
<blockquote>
<p>2017-04-30 13:13:00.934  INFO 1527 — [           main] com.forezp.service.GitHubLookupService   : Looking up PivotalSoftware<br>2017-04-30 13:13:03.571  INFO 1527 — [           main] com.forezp.service.GitHubLookupService   : Looking up CloudFoundry<br>2017-04-30 13:13:04.865  INFO 1527 — [           main] com.forezp.service.GitHubLookupService   : Looking up Spring-Projects</p>
</blockquote>
<p>耗时：5261</p>
<p>通过这一个小的栗子，你应该对异步任务有了一定的了解。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/async-method/">https://spring.io/guides/gs/async-method/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第12篇：apidoc</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-apidoc/</url>
    <content><![CDATA[<p>首先声明下，apidoc是基于注释来生成文档的，它不基于任何框架，而且支持大多数编程语言，为了springboot系列的完整性，所以标了个题。</p>
<span id="more"></span>

<h2 id="一、apidoc简介"><a href="#一、apidoc简介" class="headerlink" title="一、apidoc简介"></a>一、apidoc简介</h2><p>apidoc通过在你代码的注释来生成api文档的。它对代码没有侵入性，只需要你写好相关的注释即可，并且它仅通过写简单的配置就可以生成高颜值的api接口页面。它基于node.js，所以你需要安装node.js环境。node.js安装，<a target="_blank" rel="noopener" href="http://www.runoob.com/nodejs/nodejs-install-setup.html">点击这里</a>。这里就不介绍。</p>
<h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><p>安装完node.js安装api.doc,它的项目源码：<a target="_blank" rel="noopener" href="https://github.com/apidoc/apidoc">https://github.com/apidoc/apidoc</a> 。</p>
<p>通过命令安装：</p>
<blockquote>
<p>npm install apidoc -g</p>
</blockquote>
<h2 id="三、注释怎么写"><a href="#三、注释怎么写" class="headerlink" title="三、注释怎么写"></a>三、注释怎么写</h2><ul>
<li>@api</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@api &#123;method&#125; path [title]</span><br><span class="line"></span><br><span class="line">method：请求方法，</span><br><span class="line">path：请求路径 </span><br><span class="line">title(可选)：标题</span><br></pre></td></tr></table></figure>

<ul>
<li>@apiDescription </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@apiDescription text</span><br><span class="line">text说明</span><br></pre></td></tr></table></figure>
<ul>
<li>@apiError</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@apiError [(group)] [&#123;type&#125;] field [description]</span><br><span class="line"></span><br><span class="line">（group）（可选）：参数将以这个名称分组，不设置的话，默认是Error 4xx </span><br><span class="line">&#123;type&#125;（可选）：返回值类型，例如：&#123;Boolean&#125;, &#123;Number&#125;, &#123;String&#125;, &#123;Object&#125;, &#123;String[]&#125; </span><br><span class="line">field：返回值字段名称 </span><br><span class="line">descriptionoptional（可选）：返回值字段说明</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>@apiGroup</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@apiGroup name</span><br><span class="line">name：组名称，也是导航的标题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多注释，参见官方文档：<a target="_blank" rel="noopener" href="http://apidocjs.com/#params">http://apidocjs.com/#params</a></p>
<h2 id="四、写给栗子"><a href="#四、写给栗子" class="headerlink" title="四、写给栗子"></a>四、写给栗子</h2><h3 id="首先写配置文件"><a href="#首先写配置文件" class="headerlink" title="首先写配置文件"></a>首先写配置文件</h3><p>在项目的主目录新建一个apidoc.json文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;example&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A basic apiDoc example&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更多配置参考：<a target="_blank" rel="noopener" href="http://apidocjs.com/#configuration">http://apidocjs.com/#configuration</a></p>
<h3 id="写个注释"><a href="#写个注释" class="headerlink" title="写个注释:"></a>写个注释:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @api &#123;POST&#125; &#x2F;register 注册用户</span><br><span class="line"> * @apiGroup Users</span><br><span class="line"> * @apiVersion 0.0.1</span><br><span class="line"> * @apiDescription 用于注册用户</span><br><span class="line"> * @apiParam &#123;String&#125; account 用户账户名</span><br><span class="line"> * @apiParam &#123;String&#125; password 密码</span><br><span class="line"> * @apiParam &#123;String&#125; mobile 手机号</span><br><span class="line"> * @apiParam &#123;int&#125; vip &#x3D; 0  是否注册Vip身份 0 普通用户 1 Vip用户</span><br><span class="line"> * @apiParam &#123;String&#125; [recommend] 邀请码</span><br><span class="line"> * @apiParamExample &#123;json&#125; 请求样例：</span><br><span class="line"> *                ?account&#x3D;sodlinken&amp;password&#x3D;11223344&amp;mobile&#x3D;13739554137&amp;vip&#x3D;0&amp;recommend&#x3D;</span><br><span class="line"> * @apiSuccess (200) &#123;String&#125; msg 信息</span><br><span class="line"> * @apiSuccess (200) &#123;int&#125; code 0 代表无错误 1代表有错误</span><br><span class="line"> * @apiSuccessExample &#123;json&#125; 返回样例:</span><br><span class="line"> *                &#123;&quot;code&quot;:&quot;0&quot;,&quot;msg&quot;:&quot;注册成功&quot;&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="用apidoc命令生成文档界面"><a href="#用apidoc命令生成文档界面" class="headerlink" title="用apidoc命令生成文档界面"></a>用apidoc命令生成文档界面</h3><p>先cd到工程的外层目录，并在外层目建个输出文档的目录，我建的是docapi。</p>
<p>输命令：</p>
<blockquote>
<p>apidoc -i chapter4/ -o apidoc/ </p>
</blockquote>
<p>-i 输入目录 -o 输出目录</p>
<p>chapter4是我的工程名。</p>
<p>可以看到在apidoc目录生成了很多文件:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-76fd0f3c5ac1d190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>打开index.html,可以看到文档页面:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0319025291e1417a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ图片20170417175251.png"></p>
<h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/apidoc/apidoc">apidoc</a></p>
<p><a target="_blank" rel="noopener" href="http://apidocjs.com/">apidocjs.com</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/soslinken/article/details/50468896">使用apidoc 生成Restful web Api文档</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第20篇：表单提交</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-form/</url>
    <content><![CDATA[<p>这篇文件主要介绍通过springboot 去创建和提交一个表单。</p>
<span id="more"></span>


<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>涉及了 web，加上spring-boot-starter-web和spring-boot-starter-thymeleaf的起步依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建实体"><a href="#创建实体" class="headerlink" title="创建实体"></a>创建实体</h2><p>代码清单如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Greeting &#123;</span><br><span class="line"></span><br><span class="line">    private long id;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(long id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class GreetingController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;greeting&quot;)</span><br><span class="line">    public String greetingForm(Model model) &#123;</span><br><span class="line">        model.addAttribute(&quot;greeting&quot;, new Greeting());</span><br><span class="line">        return &quot;greeting&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;greeting&quot;)</span><br><span class="line">    public String greetingSubmit(@ModelAttribute Greeting greeting) &#123;</span><br><span class="line">        return &quot;result&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="页面展示层"><a href="#页面展示层" class="headerlink" title="页面展示层"></a>页面展示层</h2><p>src/main/resources/templates/greeting.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Handling Form Submission<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/greeting&#125;&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;greeting&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Id: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;id&#125;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Message: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;content&#125;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Reset&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>src/main/resources/templates/result.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Handling Form Submission<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Result<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;id: &#x27; + $&#123;greeting.id&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;content: &#x27; + $&#123;greeting.content&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/greeting&quot;</span>&gt;</span>Submit another message<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动工程，访问ttp://localhost:8080/greeting:</p>
<p><img src="https://spring.io/guides/gs/handling-form-submission/images/form.png"></p>
<p>点击submit:</p>
<p><img src="https://spring.io/guides/gs/handling-form-submission/images/result.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/handling-form-submission/">https://spring.io/guides/gs/handling-form-submission/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第6篇：整合mybatis</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-mybatis/</url>
    <content><![CDATA[<p>本文主要讲解如何在springboot下整合mybatis，并访问数据库。由于mybatis这个框架太过于流行，所以我就不讲解了。</p>
<span id="more"></span>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>在pom文件引入mybatis-spring-boot-starter的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mybatis-spring-boot-starter&lt;artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.3.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>引入数据库连接依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.0.29&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="引入数据源"><a href="#引入数据源" class="headerlink" title="引入数据源"></a>引入数据源</h2><p>application.properties配置文件中引入数据源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;123456</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>

<p>这样，springboot就可以访问数据了。</p>
<h2 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h2><p>建表语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- create table &#96;account&#96;</span><br><span class="line"># DROP TABLE &#96;account&#96; IF EXISTS</span><br><span class="line">CREATE TABLE &#96;account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(20) NOT NULL,</span><br><span class="line">  &#96;money&#96; double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;1&#39;, &#39;aaa&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;2&#39;, &#39;bbb&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;3&#39;, &#39;ccc&#39;, &#39;1000&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p> 这篇文篇通过注解的形式实现。</p>
<h3 id="创建实体："><a href="#创建实体：" class="headerlink" title="创建实体："></a>创建实体：</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">   private int id ;</span><br><span class="line">   private String name ;</span><br><span class="line">   private double money;</span><br><span class="line">   </span><br><span class="line"> setter...</span><br><span class="line"> getter...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface AccountMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into account(name, money) values(#&#123;name&#125;, #&#123;money&#125;)&quot;)</span><br><span class="line">    int add(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) double money);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update account set name &#x3D; #&#123;name&#125;, money &#x3D; #&#123;money&#125; where id &#x3D; #&#123;id&#125;&quot;)</span><br><span class="line">    int update(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) double money, @Param(&quot;id&quot;) int  id);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from account where id &#x3D; #&#123;id&#125;&quot;)</span><br><span class="line">    int delete(int id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select id, name as name, money as money from account where id &#x3D; #&#123;id&#125;&quot;)</span><br><span class="line">    Account findAccount(@Param(&quot;id&quot;) int id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select id, name as name, money as money from account&quot;)</span><br><span class="line">    List&lt;Account&gt; findAccountList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    public int add(String name, double money) &#123;</span><br><span class="line">        return accountMapper.add(name, money);</span><br><span class="line">    &#125;</span><br><span class="line">    public int update(String name, double money, int id) &#123;</span><br><span class="line">        return accountMapper.update(name, money, id);</span><br><span class="line">    &#125;</span><br><span class="line">    public int delete(int id) &#123;</span><br><span class="line">        return accountMapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">    public Account findAccount(int id) &#123;</span><br><span class="line">        return accountMapper.findAccount(id);</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Account&gt; findAccountList() &#123;</span><br><span class="line">        return accountMapper.findAccountList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="controller层，构建restful-API"><a href="#controller层，构建restful-API" class="headerlink" title="controller层，构建restful API"></a>controller层，构建restful API</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.forezp.web;</span><br><span class="line"></span><br><span class="line">import com.forezp.entity.Account;</span><br><span class="line">import com.forezp.service.AccountService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;20.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    AccountService accountService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;list&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public List&lt;Account&gt; getAccounts() &#123;</span><br><span class="line">        return accountService.findAccountList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public Account getAccountById(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return accountService.findAccount(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.PUT)</span><br><span class="line">    public String updateAccount(@PathVariable(&quot;id&quot;) int id, @RequestParam(value &#x3D; &quot;name&quot;, required &#x3D; true) String name,</span><br><span class="line">                                @RequestParam(value &#x3D; &quot;money&quot;, required &#x3D; true) double money) &#123;</span><br><span class="line">        int t&#x3D; accountService.update(name,money,id);</span><br><span class="line">        if(t&#x3D;&#x3D;1) &#123;</span><br><span class="line">            return &quot;success&quot;;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.DELETE)</span><br><span class="line">    public String delete(@PathVariable(value &#x3D; &quot;id&quot;)int id) &#123;</span><br><span class="line">        int t&#x3D; accountService.delete(id);</span><br><span class="line">        if(t&#x3D;&#x3D;1) &#123;</span><br><span class="line">            return &quot;success&quot;;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">    public String postAccount(@RequestParam(value &#x3D; &quot;name&quot;) String name,</span><br><span class="line">                              @RequestParam(value &#x3D; &quot;money&quot;) double money) &#123;</span><br><span class="line"></span><br><span class="line">       int t&#x3D; accountService.add(name,money);</span><br><span class="line">       if(t&#x3D;&#x3D;1) &#123;</span><br><span class="line">           return &quot;success&quot;;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           return &quot;fail&quot;;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过postman测试通过。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#properties">mybatis</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.720ui.com/2016/springboot_02_data_mybatis/">MyBatis整合</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第11篇：swagger2</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-swagger2/</url>
    <content><![CDATA[<p>swagger,中文“拽”的意思。它是一个功能强大的api框架，它的集成非常简单，不仅提供了在线文档的查阅，而且还提供了在线文档的测试。另外swagger很容易构建restful风格的api，简单优雅帅气，正如它的名字。</p>
<span id="more"></span>

<p>一、引入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.6.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.6.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二、写配置类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2 &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.forezp.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;springboot利用swagger构建api文档&quot;)</span><br><span class="line">                .description(&quot;简单优雅的restfun风格，http:&#x2F;&#x2F;blog.csdn.net&#x2F;forezp&quot;)</span><br><span class="line">                .termsOfServiceUrl(&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;forezp&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过@Configuration注解，表明它是一个配置类，@EnableSwagger2开启swagger2。apiINfo()配置一些基本的信息。apis()指定扫描的包会生成文档。</p>
<p>三、写生产文档的注解</p>
<p>swagger通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息的等等。</p>
<ul>
<li>@Api：修饰整个类，描述Controller的作用</li>
<li>@ApiOperation：描述一个类的一个方法，或者说一个接口</li>
<li>@ApiParam：单个参数描述</li>
<li>@ApiModel：用对象来接收参数</li>
<li>@ApiProperty：用对象接收参数时，描述对象的一个字段</li>
<li>@ApiResponse：HTTP响应其中1个描述</li>
<li>@ApiResponses：HTTP响应整体描述</li>
<li>@ApiIgnore：使用该注解忽略这个API </li>
<li>@ApiError ：发生错误返回的信息</li>
<li>@ApiParamImplicitL：一个请求参数</li>
<li>@ApiParamsImplicit 多个请求参数</li>
</ul>
<p>现在通过一个栗子来说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.forezp.controller;</span><br><span class="line"></span><br><span class="line">import com.forezp.entity.Book;</span><br><span class="line">import io.swagger.annotations.ApiImplicitParam;</span><br><span class="line">import io.swagger.annotations.ApiImplicitParams;</span><br><span class="line">import io.swagger.annotations.ApiOperation;</span><br><span class="line">import org.springframework.ui.ModelMap;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">import springfox.documentation.annotations.ApiIgnore;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用户创建某本图书	POST	&#x2F;books&#x2F;</span><br><span class="line"> * 用户修改对某本图书	PUT	&#x2F;books&#x2F;:id&#x2F;</span><br><span class="line"> * 用户删除对某本图书	DELETE	&#x2F;books&#x2F;:id&#x2F;</span><br><span class="line"> * 用户获取所有的图书 GET &#x2F;books</span><br><span class="line"> *  用户获取某一图书  GET &#x2F;Books&#x2F;:id</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;17.</span><br><span class="line"> * 官方文档：http:&#x2F;&#x2F;swagger.io&#x2F;docs&#x2F;specification&#x2F;api-host-and-base-path&#x2F;</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;books&quot;)</span><br><span class="line">public class BookContrller &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Long, Book&gt; books &#x3D; Collections.synchronizedMap(new HashMap&lt;Long, Book&gt;());</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value&#x3D;&quot;获取图书列表&quot;, notes&#x3D;&quot;获取图书列表&quot;)</span><br><span class="line">    @RequestMapping(value&#x3D;&#123;&quot;&quot;&#125;, method&#x3D; RequestMethod.GET)</span><br><span class="line">    public List&lt;Book&gt; getBook() &#123;</span><br><span class="line">        List&lt;Book&gt; book &#x3D; new ArrayList&lt;&gt;(books.values());</span><br><span class="line">        return book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value&#x3D;&quot;创建图书&quot;, notes&#x3D;&quot;创建图书&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;book&quot;, value &#x3D; &quot;图书详细实体&quot;, required &#x3D; true, dataType &#x3D; &quot;Book&quot;)</span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&quot;, method&#x3D;RequestMethod.POST)</span><br><span class="line">    public String postBook(@RequestBody Book book) &#123;</span><br><span class="line">        books.put(book.getId(), book);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @ApiOperation(value&#x3D;&quot;获图书细信息&quot;, notes&#x3D;&quot;根据url的id来获取详细信息&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;ID&quot;, required &#x3D; true, dataType &#x3D; &quot;Long&quot;,paramType &#x3D; &quot;path&quot;)</span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&#x2F;&#123;id&#125;&quot;, method&#x3D;RequestMethod.GET)</span><br><span class="line">    public Book getBook(@PathVariable Long id) &#123;</span><br><span class="line">        return books.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value&#x3D;&quot;更新信息&quot;, notes&#x3D;&quot;根据url的id来指定更新图书信息&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;图书ID&quot;, required &#x3D; true, dataType &#x3D; &quot;Long&quot;,paramType &#x3D; &quot;path&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;book&quot;, value &#x3D; &quot;图书实体book&quot;, required &#x3D; true, dataType &#x3D; &quot;Book&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&#x2F;&#123;id&#125;&quot;, method&#x3D; RequestMethod.PUT)</span><br><span class="line">    public String putUser(@PathVariable Long id, @RequestBody Book book) &#123;</span><br><span class="line">        Book book1 &#x3D; books.get(id);</span><br><span class="line">        book1.setName(book.getName());</span><br><span class="line">        book1.setPrice(book.getPrice());</span><br><span class="line">        books.put(id, book1);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @ApiOperation(value&#x3D;&quot;删除图书&quot;, notes&#x3D;&quot;根据url的id来指定删除图书&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;图书ID&quot;, required &#x3D; true, dataType &#x3D; &quot;Long&quot;,paramType &#x3D; &quot;path&quot;)</span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&#x2F;&#123;id&#125;&quot;, method&#x3D;RequestMethod.DELETE)</span><br><span class="line">    public String deleteUser(@PathVariable Long id) &#123;</span><br><span class="line">        books.remove(id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiIgnore&#x2F;&#x2F;使用该注解忽略这个API</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public String  jsonTest() &#123;</span><br><span class="line">        return &quot; hi you!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过相关注解，就可以让swagger2生成相应的文档。如果你不需要某接口生成文档，只需要在加@ApiIgnore注解即可。需要说明的是，如果请求参数在url上，@ApiImplicitParam 上加paramType = “path” 。</p>
<p>启动工程，访问：<a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，就看到swagger-ui:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-62a6df7cc78d4027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>整个集成过程非常简单，但是我看了相关的资料，swagger没有做安全方面的防护，可能需要我们自己做相关的工作。</p>
<h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p><a target="_blank" rel="noopener" href="http://swagger.io/docs/">swagger.io</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.didispace.com/springbootswagger2/">Spring Boot中使用Swagger2构建强大的RESTful API文档</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第9篇：声明式事务</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-tracstion/</url>
    <content><![CDATA[<p>springboot开启事务很简单，只需要一个注解@Transactional 就可以了。因为在springboot中已经默认对jpa、jdbc、mybatis开启了事事务，引入它们依赖的时候，事物就默认开启。当然，如果你需要用其他的orm，比如beatlsql，就需要自己配置相关的事物管理器。</p>
<span id="more"></span>

<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>以上一篇文章的代码为例子，即springboot整合mybatis，上一篇文章是基于注解来实现mybatis的数据访问层，这篇文章基于xml的来实现，并开启声明式事务。</p>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><p>在pom文件中引入mybatis启动依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.3.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>引入mysql 依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.0.29&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="初始化数据库脚本"><a href="#初始化数据库脚本" class="headerlink" title="初始化数据库脚本"></a>初始化数据库脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- create table &#96;account&#96;</span><br><span class="line"># DROP TABLE &#96;account&#96; IF EXISTS</span><br><span class="line">CREATE TABLE &#96;account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(20) NOT NULL,</span><br><span class="line">  &#96;money&#96; double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;1&#39;, &#39;aaa&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;2&#39;, &#39;bbb&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;3&#39;, &#39;ccc&#39;, &#39;1000&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;123456</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">mybatis.mapper-locations&#x3D;classpath*:mybatis&#x2F;*Mapper.xml</span><br><span class="line">mybatis.type-aliases-package&#x3D;com.forezp.entity</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过配置mybatis.mapper-locations来指明mapper的xml文件存放位置，我是放在resources/mybatis文件下的。mybatis.type-aliases-package来指明和数据库映射的实体的所在包。</p>
<p>经过以上步骤，springboot就可以通过mybatis访问数据库来。</p>
<h2 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Account &#123;</span><br><span class="line">    private int id ;</span><br><span class="line">    private String name ;</span><br><span class="line">    private double money;</span><br><span class="line">    </span><br><span class="line">    getter..</span><br><span class="line">    setter..</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据访问dao-层"><a href="#数据访问dao-层" class="headerlink" title="数据访问dao 层"></a>数据访问dao 层</h2><p>接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AccountMapper2 &#123;</span><br><span class="line">   int update( @Param(&quot;money&quot;) double money, @Param(&quot;id&quot;) int  id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mapper:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.forezp.dao.AccountMapper2&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;update id&#x3D;&quot;update&quot;&gt;</span><br><span class="line">        UPDATE account set money&#x3D;#&#123;money&#125; WHERE id&#x3D;#&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;update&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountService2 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    AccountMapper2 accountMapper2;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void transfer() throws RuntimeException&#123;</span><br><span class="line">        accountMapper2.update(90,1);&#x2F;&#x2F;用户1减10块 用户2加10块</span><br><span class="line">        int i&#x3D;1&#x2F;0;</span><br><span class="line">        accountMapper2.update(110,2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>@Transactional，声明事务，并设计一个转账方法，用户1减10块，用户2加10块。在用户1减10 ，之后，抛出异常，即用户2加10块钱不能执行，当加注解@Transactional之后，两个人的钱都没有增减。当不加@Transactional，用户1减了10，用户2没有增加，即没有操作用户2 的数据。可见@Transactional注解开启了事物。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>springboot 开启事物很简单，只需要加一行注解就可以了，前提你用的是jdbctemplate, jpa, mybatis，这种常见的orm。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/managing-transactions/">managing-transactions/</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第1篇：构建springboot工程</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot1/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> spring boot 它的设计目的就是为例简化开发，开启了各种自动装配，你不想写各种配置文件，引入相关的依赖就能迅速搭建起一个web工程。它采用的是建立生产就绪的应用程序观点，优先于配置的惯例。</p>
 <span id="more"></span>

<p>可能你有很多理由不放弃SSM,SSH，但是当你一旦使用了springboot ,你会觉得一切变得简单了，配置变的简单了、编码变的简单了，部署变的简单了，感觉自己健步如飞，开发速度大大提高了。就好比，当你用了IDEA，你会觉得再也回不到Eclipse时代一样。另，本系列教程全部用的IDEA作为开发工具。</p>
<h2 id="建构工程"><a href="#建构工程" class="headerlink" title="建构工程"></a>建构工程</h2><p>你需要：</p>
<ul>
<li>15分钟</li>
<li>jdk 1.8或以上</li>
<li>maven 3.0+</li>
<li>Idea</li>
</ul>
<p>打开Idea-&gt; new Project -&gt;Spring Initializr -&gt;填写group、artifact -&gt;钩上web(开启web功能）-&gt;点下一步就行了。</p>
<h2 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h2><p>创建完工程，工程的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- src</span><br><span class="line">	-main</span><br><span class="line">		-java</span><br><span class="line">			-package</span><br><span class="line">				-SpringbootApplication</span><br><span class="line">		-resouces</span><br><span class="line">			- statics</span><br><span class="line">			- templates</span><br><span class="line">			- application.yml</span><br><span class="line">	-test</span><br><span class="line">- pom</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>pom文件为基本的依赖管理文件</li>
<li>resouces 资源文件<ul>
<li>statics 静态资源</li>
<li>templates 模板资源</li>
<li>application.yml 配置文件</li>
</ul>
</li>
<li>SpringbootApplication程序的入口。</li>
</ul>
<p>pom.xml的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springboot-first-application&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;springboot-first-application&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中spring-boot-starter-web不仅包含spring-boot-starter,还自动开启了web功能。</p>
<h2 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h2><p>说了这么多，你可能还体会不到，举个栗子，比如你引入了Thymeleaf的依赖，spring boot 就会自动帮你引入SpringTemplateEngine，当你引入了自己的SpringTemplateEngine，spring boot就不会帮你引入。它让你专注于你的自己的业务开发，而不是各种配置。</p>
<p>再举个栗子,建个controller：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Greetings from Spring Boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动SpringbootFirstApplication的main方法，打开浏览器localhost:8080,浏览器显示：</p>
<blockquote>
<p>Greetings from Spring Boot!</p>
</blockquote>
<h4 id="神奇之处："><a href="#神奇之处：" class="headerlink" title="神奇之处："></a>神奇之处：</h4><ul>
<li>你没有做任何的web.xml配置。</li>
<li>你没有做任何的sping mvc的配置; springboot为你做了。</li>
<li>你没有配置tomcat ;springboot内嵌tomcat.</li>
</ul>
<h4 id="启动springboot-方式"><a href="#启动springboot-方式" class="headerlink" title="启动springboot 方式"></a>启动springboot 方式</h4><p>cd到项目主目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean  </span><br><span class="line">mvn package  编译项目的jar</span><br></pre></td></tr></table></figure>

<ul>
<li>mvn spring-boot: run  启动</li>
<li>cd 到target目录，java -jar  项目.jar</li>
</ul>
<h2 id="来看看springboot在启动的时候为我们注入了哪些bean"><a href="#来看看springboot在启动的时候为我们注入了哪些bean" class="headerlink" title="来看看springboot在启动的时候为我们注入了哪些bean"></a>来看看springboot在启动的时候为我们注入了哪些bean</h2><p>在程序入口加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootFirstApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringbootFirstApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public CommandLineRunner commandLineRunner(ApplicationContext ctx) &#123;</span><br><span class="line">		return args -&gt; &#123;</span><br><span class="line"></span><br><span class="line">			System.out.println(&quot;Let&#39;s inspect the beans provided by Spring Boot:&quot;);</span><br><span class="line"></span><br><span class="line">			String[] beanNames &#x3D; ctx.getBeanDefinitionNames();</span><br><span class="line">			Arrays.sort(beanNames);</span><br><span class="line">			for (String beanName : beanNames) &#123;</span><br><span class="line">				System.out.println(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<blockquote>
<p>Let’s inspect the beans provided by Spring Boot:<br>basicErrorController<br>beanNameHandlerMapping<br>beanNameViewResolver<br>characterEncodingFilter<br>commandLineRunner<br>conventionErrorViewResolver<br>defaultServletHandlerMapping<br>defaultViewResolver<br>dispatcherServlet<br>dispatcherServletRegistration<br>duplicateServerPropertiesDetector<br>embeddedServletContainerCustomizerBeanPostProcessor<br>error<br>errorAttributes<br>errorPageCustomizer<br>errorPageRegistrarBeanPostProcessor</p>
</blockquote>
<blockquote>
<p>….<br> ….</p>
</blockquote>
<p> 在程序启动的时候，springboot自动诸如注入了40-50个bean.</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>通过@RunWith() @SpringBootTest开启注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(webEnvironment &#x3D; SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line">public class HelloControllerIT &#123;</span><br><span class="line"></span><br><span class="line">    @LocalServerPort</span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    private URL base;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TestRestTemplate template;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws Exception &#123;</span><br><span class="line">        this.base &#x3D; new URL(&quot;http:&#x2F;&#x2F;localhost:&quot; + port + &quot;&#x2F;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getHello() throws Exception &#123;</span><br><span class="line">        ResponseEntity&lt;String&gt; response &#x3D; template.getForEntity(base.toString(),</span><br><span class="line">                String.class);</span><br><span class="line">        assertThat(response.getBody(), equalTo(&quot;Greetings from Spring Boot!&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 运行它会先开启sprigboot工程，然后再测试，测试通过 ^.^</p>
<p> 源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>市面上有很多springboot的书，有很多springboot的博客，为什么我还要写这样一个系列？到目前为止，我没有看过一本springboot的书，因为还没来得及看，看的都是官方指南，当然也参考了很多的博客，他们都写的非常的棒！在看官方指南和博客的时候，发现他们有很多不同之处，所以我打算写一个来源于官方，通过自己理解加整合写一个系列，所以取名叫《springboot 非官方教程》。我相信我写的可能跟其他人的写的会不太一样。另外，最主要的原因还是提高自己，怀着一个乐于分享的心，将自己的理解分享给更多需要的人。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/spring-boot/">Building an Application with Spring Boot</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 终章：文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章: 文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第10篇：restdoc</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot10-springrestdocs/</url>
    <content><![CDATA[<p>这篇文章将带你了解如何用spring官方推荐的restdoc去生成api文档。本文创建一个简单的springboot工程，将http接口通过Api文档暴露出来。只需要通过 JUnit单元测试和Spring的MockMVC就可以生成文档。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>你需要15min</li>
<li>Jdk 1.8</li>
<li>maven 3.0+</li>
<li>idea</li>
</ul>
<h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p>引入依赖，其pom文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.restdocs&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-restdocs-mockmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>通过@SpringBootApplication,开启springboot</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在springboot通常创建一个controller:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HomeController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public Map&lt;String, Object&gt; greeting() &#123;</span><br><span class="line">        return Collections.singletonMap(&quot;message&quot;, &quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动工程，访问localhost:8080，浏览器显示：</p>
<blockquote>
<p>{“message”:”Hello World”}</p>
</blockquote>
<p>证明接口已经写好了，但是如何通过restdoc生存api文档呢</p>
<h2 id="Restdoc-通过单元测试生成api文档"><a href="#Restdoc-通过单元测试生成api文档" class="headerlink" title="Restdoc,通过单元测试生成api文档"></a>Restdoc,通过单元测试生成api文档</h2><p>restdocs是通过单元测试生存snippets文件，然后snippets根据插件生成htm文档的。</p>
<p>建一个单元测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@WebMvcTest(HomeController.class)</span><br><span class="line">@AutoConfigureRestDocs(outputDir &#x3D; &quot;target&#x2F;snippets&quot;)</span><br><span class="line">public class WebLayerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void shouldReturnDefaultMessage() throws Exception &#123;</span><br><span class="line">        this.mockMvc.perform(get(&quot;&#x2F;&quot;)).andDo(print()).andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(containsString(&quot;Hello World&quot;)))</span><br><span class="line">                .andDo(document(&quot;home&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，@ AutoConfigureRestDocs注解开启了生成snippets文件，并指定了存放位置。</p>
<p>启动单元测试，测试通过，你会发现在target文件下生成了一个snippets文件夹，其目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">└── target</span><br><span class="line">    └── snippets</span><br><span class="line">        └── home</span><br><span class="line">            └── httpie-request.adoc</span><br><span class="line">            └── curl-request.adoc</span><br><span class="line">            └── http-request.adoc</span><br><span class="line">            └── http-response.adoc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下，snippets是Asciidoctor格式的文件，包括request和reponse，另外其他两种httpie和curl两种流行的命令行的http请求模式。</p>
<p>到目前为止，只生成了Snippets文件，需要用Snippets文件生成文档。</p>
<h4 id="怎么用Snippets"><a href="#怎么用Snippets" class="headerlink" title="怎么用Snippets"></a>怎么用Snippets</h4><p>创建一个新文件src/main/asciidoc/index.adoc ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D; 用 Spring REST Docs 构建文档</span><br><span class="line"></span><br><span class="line">This is an example output for a service running at http:&#x2F;&#x2F;localhost:8080:</span><br><span class="line"></span><br><span class="line">.request</span><br><span class="line">include::&#123;snippets&#125;&#x2F;home&#x2F;http-request.adoc[]</span><br><span class="line"></span><br><span class="line">.response</span><br><span class="line">include::&#123;snippets&#125;&#x2F;home&#x2F;http-response.adoc[]</span><br><span class="line"></span><br><span class="line">这个例子非常简单，通过单元测试和一些简单的配置就能够得到api文档了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>adoc的书写格式，参考:<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-restdocs/docs/current/reference/html5/">http://docs.spring.io/spring-restdocs/docs/current/reference/html5/</a>，这里不多讲解。</p>
<p>需要使用asciidoctor-maven-plugin插件，在其pom文件加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.asciidoctor&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;asciidoctor-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;generate-docs&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;phase&gt;prepare-package&lt;&#x2F;phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;process-asciidoc&lt;&#x2F;goal&gt;</span><br><span class="line">            &lt;&#x2F;goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;sourceDocumentName&gt;index.adoc&lt;&#x2F;sourceDocumentName&gt;</span><br><span class="line">                &lt;backend&gt;html&lt;&#x2F;backend&gt;</span><br><span class="line">                &lt;attributes&gt;</span><br><span class="line">                    &lt;snippets&gt;$&#123;project.build.directory&#125;&#x2F;snippets&lt;&#x2F;snippets&gt;</span><br><span class="line">                &lt;&#x2F;attributes&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;execution&gt;</span><br><span class="line">    &lt;&#x2F;executions&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时只需要通过mvnw package命令就可以生成文档了。<br>在/target/generated-docs下有个index.html，打开这个html,显示如下，界面还算简洁：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-33d12bf68b964711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过单元测试，生存adoc文件，再用adoc文件生存html，只需要简单的几步就可以生成一个api文档的html文件，这个html文件你可以通网站发布出去。整个过程很简单，对代码无任何影响。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/testing-restdocs/">restdocs</a></p>
<p><a target="_blank" rel="noopener" href="http://docs.spring.io/spring-restdocs/docs/current/reference/html5/">http://docs.spring.io/spring-restdocs/docs/current/reference/html5/</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第16篇：ResrTemplate</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot11-restTemplate/</url>
    <content><![CDATA[<p>这篇文章主要介绍怎么用消费一个 Restful的web服务。我将用restTemplate去消费一个服务： <a target="_blank" rel="noopener" href="http://gturnquist-quoters.cfapps.io/api/random">http://gturnquist-quoters.cfapps.io/api/random</a>.</p>
<span id="more"></span>

<h2 id="构架工程"><a href="#构架工程" class="headerlink" title="构架工程"></a>构架工程</h2><p>创建一个springboot工程，去消费RESTFUL的服务。这个服务是 http:///gturnquist-quoters.cfapps.io/api/random ，它会随机返回Json字符串。<br>在Spring项目中，它提供了一个非常简便的类，叫RestTemplate，它可以很简便的消费服务。</p>
<h2 id="消费服务"><a href="#消费服务" class="headerlink" title="消费服务"></a>消费服务</h2><p>通过RestTemplate消费服务，需要先context中注册一个RestTemplate bean。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">	public RestTemplate restTemplate(RestTemplateBuilder builder) &#123;</span><br><span class="line">		return builder.build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public CommandLineRunner run(RestTemplate restTemplate) throws Exception &#123;</span><br><span class="line">		return args -&gt; &#123;</span><br><span class="line">			String quote &#x3D; restTemplate.getForObject(</span><br><span class="line">					&quot;http:&#x2F;&#x2F;gturnquist-quoters.cfapps.io&#x2F;api&#x2F;random&quot;, String.class);</span><br><span class="line">			log.info(quote.toString());</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，控制台打印：</p>
<blockquote>
<p>{<br>    “type”: “success”,<br>    “value”: {<br>        “id”: 6,<br>        “quote”: “It embraces convention over configuration, providing an experience on par with frameworks that excel at early stage development, such as Ruby on Rails.”<br>    }<br>}</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/consuming-rest/">https://spring.io/guides/gs/consuming-rest/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第13篇：spring cache</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot13-springcache/</url>
    <content><![CDATA[<p>本文介绍如何在springboot中使用默认的spring cache，</p>
<span id="more"></span>

<h2 id="声明式缓存"><a href="#声明式缓存" class="headerlink" title="声明式缓存"></a>声明式缓存</h2><p>Spring 定义 CacheManager 和 Cache 接口用来统一不同的缓存技术。例如 JCache、 EhCache、 Hazelcast、 Guava、 Redis 等。在使用 Spring 集成 Cache 的时候，我们需要注册实现的 CacheManager 的 Bean。</p>
<p>Spring Boot 为我们自动配置了 JcacheCacheConfiguration、 EhCacheCacheConfiguration、HazelcastCacheConfiguration、GuavaCacheConfiguration、RedisCacheConfiguration、SimpleCacheConfiguration 等。</p>
<h2 id="默认使用-ConcurrenMapCacheManager"><a href="#默认使用-ConcurrenMapCacheManager" class="headerlink" title="默认使用 ConcurrenMapCacheManager"></a>默认使用 ConcurrenMapCacheManager</h2><p>在我们不使用其他第三方缓存依赖的时候，springboot自动采用ConcurrenMapCacheManager作为缓存管理器。</p>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><p>在pom文件引入spring-boot-starter-cache环境依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-cache&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建一个book数据访问层"><a href="#创建一个book数据访问层" class="headerlink" title="创建一个book数据访问层"></a>创建一个book数据访问层</h2><h3 id="先创建一个实体类"><a href="#先创建一个实体类" class="headerlink" title="先创建一个实体类"></a>先创建一个实体类</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Book &#123;</span><br><span class="line"></span><br><span class="line">   private String isbn;</span><br><span class="line">   private String title;</span><br><span class="line"></span><br><span class="line">   public Book(String isbn, String title) &#123;</span><br><span class="line">       this.isbn &#x3D; isbn;</span><br><span class="line">       this.title &#x3D; title;</span><br><span class="line">   &#125;</span><br><span class="line"> ....getter</span><br><span class="line"> ....setter  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="创建一个数据访问接口"><a href="#创建一个数据访问接口" class="headerlink" title="创建一个数据访问接口"></a>创建一个数据访问接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface BookRepository &#123;</span><br><span class="line"></span><br><span class="line">    Book getByIsbn(String isbn);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个你可以写一个很复杂的数据查询操作，比如操作mysql、nosql等等。为了演示这个栗子，我只做了一下线程的延迟操作，当作是查询数据库的时间。</p>
<p>实现接口类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SimpleBookRepository implements BookRepository &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    </span><br><span class="line">    public Book getByIsbn(String isbn) &#123;</span><br><span class="line">        simulateSlowService();</span><br><span class="line">        return new Book(isbn, &quot;Some book&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Don&#39;t do this at home</span><br><span class="line">    private void simulateSlowService() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            long time &#x3D; 3000L;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AppRunner implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(AppRunner.class);</span><br><span class="line"></span><br><span class="line">    private final BookRepository bookRepository;</span><br><span class="line"></span><br><span class="line">    public AppRunner(BookRepository bookRepository) &#123;</span><br><span class="line">        this.bookRepository &#x3D; bookRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        logger.info(&quot;.... Fetching books&quot;);</span><br><span class="line">        logger.info(&quot;isbn-1234 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-1234&quot;));</span><br><span class="line">        logger.info(&quot;isbn-4567 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-4567&quot;));</span><br><span class="line">        logger.info(&quot;isbn-1234 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-1234&quot;));</span><br><span class="line">        logger.info(&quot;isbn-4567 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-4567&quot;));</span><br><span class="line">        logger.info(&quot;isbn-1234 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-1234&quot;));</span><br><span class="line">        logger.info(&quot;isbn-1234 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-1234&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动程序，你会发现程序在控制台依次打印了：</p>
<blockquote>
<p>2014-06-05 12:15:35.783  … : …. Fetching books</p>
<p>2014-06-05 12:15:40.783  … : isbn-1234 –&gt; &gt;Book{isbn=’isbn-1234’, title=’Some book’}</p>
</blockquote>
<p>2014-06-05 12:15:43.784  … : isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}</p>
<blockquote>
</blockquote>
<p>2014-06-05 12:15:46.786  … : isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}</p>
<p>你会发现程序依次3s打印一行日志。这时还没开启缓存技术。</p>
<h2 id="开启缓存技术"><a href="#开启缓存技术" class="headerlink" title="开启缓存技术"></a>开启缓存技术</h2><p>在程序的入口中加入@ EnableCaching开启缓存技术：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableCaching</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要缓存的地方加入@Cacheable注解，比如在getByIsbn（）方法上加入@Cacheable(“books”)，这个方法就开启了缓存策略，当缓存有这个数据的时候，会直接返回数据，不会等待去查询数据库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SimpleBookRepository implements BookRepository &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Cacheable(&quot;books&quot;)</span><br><span class="line">    public Book getByIsbn(String isbn) &#123;</span><br><span class="line">        simulateSlowService();</span><br><span class="line">        return new Book(isbn, &quot;Some book&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Don&#39;t do this at home</span><br><span class="line">    private void simulateSlowService() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            long time &#x3D; 3000L;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时再启动程序，你会发现程序打印：</p>
<blockquote>
<p>isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}<br>2017-04-23 18:17:09.479  INFO 8054 — [           main] forezp.AppRunner                         : isbn-4567 –&gt;Book{isbn=’isbn-4567’, title=’Some book’}<br>2017-04-23 18:17:09.480  INFO 8054 — [           main] forezp.AppRunner                         : isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}<br>2017-04-23 18:17:09.480  INFO 8054 — [           main] forezp.AppRunner                         : isbn-4567 –&gt;Book{isbn=’isbn-4567’, title=’Some book’}<br>2017-04-23 18:17:09.481  INFO 8054 — [           main] forezp.AppRunner                         : isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}<br>2017-04-23 18:17:09.481  INFO 8054 — [           main] forezp.AppRunner                         : isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}</p>
</blockquote>
<p>只有打印前面2个数据，程序等了3s，之后的数据瞬间打印在控制台上了，这说明缓存起了作用。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/caching/">caching</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.720ui.com/2017/springboot_02_data_cache_concurrenmapcache/">Spring Boot 揭秘与实战（二） 数据缓存篇 - 快速入门</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第14篇：Redis消息队列</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot14-redis-mq%E5%88%97/</url>
    <content><![CDATA[<p>这篇文章主要讲述如何在springboot中用reids实现消息队列。</p>
<span id="more"></span>

<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><ul>
<li>安装redis,可参考我的另一篇文章，<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/61471712">5分钟带你入门Redis</a>。</li>
<li>java 1.8</li>
<li>maven 3.0</li>
<li>idea</li>
</ul>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><p>创建一个新的springboot工程，在其pom文件,加入spring-boot-starter-data-redis依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建一个消息接收者"><a href="#创建一个消息接收者" class="headerlink" title="创建一个消息接收者"></a>创建一个消息接收者</h2><p>REcevier类，它是一个普通的类，需要注入到springboot中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Receiver &#123;</span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(Receiver.class);</span><br><span class="line"></span><br><span class="line">    private CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public Receiver(CountDownLatch latch) &#123;</span><br><span class="line">        this.latch &#x3D; latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void receiveMessage(String message) &#123;</span><br><span class="line">        LOGGER.info(&quot;Received &lt;&quot; + message + &quot;&gt;&quot;);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注入消息接收者"><a href="#注入消息接收者" class="headerlink" title="注入消息接收者"></a>注入消息接收者</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">	Receiver receiver(CountDownLatch latch) &#123;</span><br><span class="line">		return new Receiver(latch);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	CountDownLatch latch() &#123;</span><br><span class="line">		return new CountDownLatch(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	StringRedisTemplate template(RedisConnectionFactory connectionFactory) &#123;</span><br><span class="line">		return new StringRedisTemplate(connectionFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注入消息监听容器"><a href="#注入消息监听容器" class="headerlink" title="注入消息监听容器"></a>注入消息监听容器</h2><p>在spring data redis中，利用redis发送一条消息和接受一条消息，需要三样东西：</p>
<ul>
<li>一个连接工厂 </li>
<li>一个消息监听容器</li>
<li>Redis template</li>
</ul>
<p>上述1、3步已经完成，所以只需注入消息监听容器即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">	RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,</span><br><span class="line">											MessageListenerAdapter listenerAdapter) &#123;</span><br><span class="line"></span><br><span class="line">		RedisMessageListenerContainer container &#x3D; new RedisMessageListenerContainer();</span><br><span class="line">		container.setConnectionFactory(connectionFactory);</span><br><span class="line">		container.addMessageListener(listenerAdapter, new PatternTopic(&quot;chat&quot;));</span><br><span class="line"></span><br><span class="line">		return container;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	MessageListenerAdapter listenerAdapter(Receiver receiver) &#123;</span><br><span class="line">		return new MessageListenerAdapter(receiver, &quot;receiveMessage&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在springboot入口的main方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		ApplicationContext ctx &#x3D;  SpringApplication.run(SpringbootRedisApplication.class, args);</span><br><span class="line"></span><br><span class="line">		StringRedisTemplate template &#x3D; ctx.getBean(StringRedisTemplate.class);</span><br><span class="line">		CountDownLatch latch &#x3D; ctx.getBean(CountDownLatch.class);</span><br><span class="line"></span><br><span class="line">		LOGGER.info(&quot;Sending message...&quot;);</span><br><span class="line">		template.convertAndSend(&quot;chat&quot;, &quot;Hello from Redis!&quot;);</span><br><span class="line"></span><br><span class="line">		latch.await();</span><br><span class="line"></span><br><span class="line">		System.exit(0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先用redisTemplate发送一条消息，接收者接收到后，打印出来。启动springboot程序，控制台打印：</p>
<blockquote>
<p>2017-04-20 17:25:15.536  INFO 39148 — [           main] com.forezp.SpringbootRedisApplication    : Sending message…<br>      2017-04-20 17:25:15.544  INFO 39148 — [    container-2] com.forezp.message.Receiver              : 》Received &lt;Hello from Redis!&gt;</p>
</blockquote>
<p>测试通过，接收者确实接收到了发送者的消息。</p>
<h2 id="源码下载："><a href="#源码下载：" class="headerlink" title="源码下载："></a>源码下载：</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/messaging-redis/">messaging-redis</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第17篇：上传文件</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot14-upload/</url>
    <content><![CDATA[<p>这篇文章主要介绍，如何在springboot工程作为服务器，去接收通过http 上传的multi-file的文件。</p>
<span id="more"></span>


<h2 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h2><p>为例创建一个springmvc工程你需要spring-boot-starter-thymeleaf和 spring-boot-starter-web的起步依赖。为例能够上传文件在服务器，你需要在web.xml中加入<multipart-config>标签做相关的配置，但在sringboot 工程中，它已经为你自动做了，所以不需要你做任何的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建文件上传controller"><a href="#创建文件上传controller" class="headerlink" title="创建文件上传controller"></a>创建文件上传controller</h2><p>直接贴代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line"></span><br><span class="line">    private final StorageService storageService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public FileUploadController(StorageService storageService) &#123;</span><br><span class="line">        this.storageService &#x3D; storageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String listUploadedFiles(Model model) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;files&quot;, storageService</span><br><span class="line">                .loadAll()</span><br><span class="line">                .map(path -&gt;</span><br><span class="line">                        MvcUriComponentsBuilder</span><br><span class="line">                                .fromMethodName(FileUploadController.class, &quot;serveFile&quot;, path.getFileName().toString())</span><br><span class="line">                                .build().toString())</span><br><span class="line">                .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">        return &quot;uploadForm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;files&#x2F;&#123;filename:.+&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ResponseEntity&lt;Resource&gt; serveFile(@PathVariable String filename) &#123;</span><br><span class="line"></span><br><span class="line">        Resource file &#x3D; storageService.loadAsResource(filename);</span><br><span class="line">        return ResponseEntity</span><br><span class="line">                .ok()</span><br><span class="line">                .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename&#x3D;\&quot;&quot;+file.getFilename()+&quot;\&quot;&quot;)</span><br><span class="line">                .body(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file,</span><br><span class="line">                                   RedirectAttributes redirectAttributes) &#123;</span><br><span class="line"></span><br><span class="line">        storageService.store(file);</span><br><span class="line">        redirectAttributes.addFlashAttribute(&quot;message&quot;,</span><br><span class="line">                &quot;You successfully uploaded &quot; + file.getOriginalFilename() + &quot;!&quot;);</span><br><span class="line"></span><br><span class="line">        return &quot;redirect:&#x2F;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(StorageFileNotFoundException.class)</span><br><span class="line">    public ResponseEntity handleStorageFileNotFound(StorageFileNotFoundException exc) &#123;</span><br><span class="line">        return ResponseEntity.notFound().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个类通过@Controller注解，表明自己上一个Spring mvc的c。每个方法通过<br>@GetMapping 或者@PostMapping注解表明自己的 http方法。</p>
<ul>
<li>GET / 获取已经上传的文件列表</li>
<li>GET /files/{filename}  下载已经存在于服务器的文件</li>
<li>POST / 上传文件给服务器</li>
</ul>
<h2 id="创建一个简单的-html模板"><a href="#创建一个简单的-html模板" class="headerlink" title="创建一个简单的 html模板"></a>创建一个简单的 html模板</h2><p>为了展示上传文件的过程，我们做一个界面：<br>在src/main/resources/templates/uploadForm.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">	&lt;div th:if&#x3D;&quot;$&#123;message&#125;&quot;&gt;</span><br><span class="line">		&lt;h2 th:text&#x3D;&quot;$&#123;message&#125;&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;form method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; action&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">			&lt;table&gt;</span><br><span class="line">				&lt;tr&gt;&lt;td&gt;File to upload:&lt;&#x2F;td&gt;&lt;td&gt;&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; &#x2F;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">				&lt;tr&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Upload&quot; &#x2F;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">			&lt;&#x2F;table&gt;</span><br><span class="line">		&lt;&#x2F;form&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;ul&gt;</span><br><span class="line">			&lt;li th:each&#x3D;&quot;file : $&#123;files&#125;&quot;&gt;</span><br><span class="line">				&lt;a th:href&#x3D;&quot;$&#123;file&#125;&quot; th:text&#x3D;&quot;$&#123;file&#125;&quot; &#x2F;&gt;</span><br><span class="line">			&lt;&#x2F;li&gt;</span><br><span class="line">		&lt;&#x2F;ul&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="上传文件大小限制"><a href="#上传文件大小限制" class="headerlink" title="上传文件大小限制"></a>上传文件大小限制</h2><p>如果需要限制上传文件的大小也很简单，只需要在springboot 工程的src/main/resources/application.properties 加入以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.http.multipart.max-file-size&#x3D;128KB</span><br><span class="line">spring.http.multipart.max-request-size&#x3D;128KB</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试情况如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-5f398faeb076e37e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/uploading-files/">https://spring.io/guides/gs/uploading-files/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第15篇：Rabbitmq</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot15-rabbitmq/</url>
    <content><![CDATA[<p>这篇文章带你了解怎么整合RabbitMQ服务器，并且通过它怎么去发送和接收消息。我将构建一个springboot工程，通过RabbitTemplate去通过MessageListenerAdapter去订阅一个POJO类型的消息。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>15min</li>
<li>IDEA</li>
<li>maven 3.0</li>
</ul>
<p>在开始构建项目之前，机器需要安装rabbitmq，你可以去官网下载，<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a> ，如果你是用的Mac（程序员都应该用mac吧），你可以这样下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install rabbitmq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装完成后开启服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq-server</span><br></pre></td></tr></table></figure>

<p>开启服务器成功，你可以看到以下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            RabbitMQ 3.1.3. Copyright (C) 2007-2013 VMware, Inc.</span><br><span class="line">##  ##      Licensed under the MPL.  See http:&#x2F;&#x2F;www.rabbitmq.com&#x2F;</span><br><span class="line">##  ##</span><br><span class="line">##########  Logs: &#x2F;usr&#x2F;local&#x2F;var&#x2F;log&#x2F;rabbitmq&#x2F;rabbit@localhost.log</span><br><span class="line">######  ##        &#x2F;usr&#x2F;local&#x2F;var&#x2F;log&#x2F;rabbitmq&#x2F;rabbit@localhost-sasl.log</span><br><span class="line">##########</span><br><span class="line">            Starting broker... completed with 6 plugins.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h2><p>构架一个SpringBoot工程，其pom文件依赖加上spring-boot-starter-amqp的起步依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建消息接收者"><a href="#创建消息接收者" class="headerlink" title="创建消息接收者"></a>创建消息接收者</h2><p>在任何的消息队列程序中，你需要创建一个消息接收者，用于响应发送的消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class Receiver &#123;</span><br><span class="line"></span><br><span class="line">    private CountDownLatch latch &#x3D; new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">    public void receiveMessage(String message) &#123;</span><br><span class="line">        System.out.println(&quot;Received &lt;&quot; + message + &quot;&gt;&quot;);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CountDownLatch getLatch() &#123;</span><br><span class="line">        return latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消息接收者是一个简单的POJO类，它定义了一个方法去接收消息，当你注册它去接收消息，你可以给它取任何的名字。其中，它有CountDownLatch这样的一个类，它是用于告诉发送者消息已经收到了，你不需要在应用程序中具体实现它，只需要latch.countDown()就行了。</p>
<h2 id="创建消息监听，并发送一条消息"><a href="#创建消息监听，并发送一条消息" class="headerlink" title="创建消息监听，并发送一条消息"></a>创建消息监听，并发送一条消息</h2><p>在spring程序中，RabbitTemplate提供了发送消息和接收消息的所有方法。你只需简单的配置下就行了：</p>
<ul>
<li>需要一个消息监听容器</li>
<li>声明一个quene,一个exchange,并且绑定它们</li>
<li>一个组件去发送消息</li>
</ul>
<p>代码清单如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.forezp;</span><br><span class="line"></span><br><span class="line">import com.forezp.message.Receiver;</span><br><span class="line">import org.springframework.amqp.core.Binding;</span><br><span class="line">import org.springframework.amqp.core.BindingBuilder;</span><br><span class="line">import org.springframework.amqp.core.Queue;</span><br><span class="line">import org.springframework.amqp.core.TopicExchange;</span><br><span class="line">import org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br><span class="line">import org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;</span><br><span class="line">import org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootRabbitmqApplication &#123;</span><br><span class="line"></span><br><span class="line">	 final static String queueName &#x3D; &quot;spring-boot&quot;;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	Queue queue() &#123;</span><br><span class="line">		return new Queue(queueName, false);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	TopicExchange exchange() &#123;</span><br><span class="line">		return new TopicExchange(&quot;spring-boot-exchange&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	Binding binding(Queue queue, TopicExchange exchange) &#123;</span><br><span class="line">		return BindingBuilder.bind(queue).to(exchange).with(queueName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	SimpleMessageListenerContainer container(ConnectionFactory connectionFactory,</span><br><span class="line">											 MessageListenerAdapter listenerAdapter) &#123;</span><br><span class="line">		SimpleMessageListenerContainer container &#x3D; new SimpleMessageListenerContainer();</span><br><span class="line">		container.setConnectionFactory(connectionFactory);</span><br><span class="line">		container.setQueueNames(queueName);</span><br><span class="line">		container.setMessageListener(listenerAdapter);</span><br><span class="line">		return container;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	MessageListenerAdapter listenerAdapter(Receiver receiver) &#123;</span><br><span class="line">		return new MessageListenerAdapter(receiver, &quot;receiveMessage&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringbootRabbitmqApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个测试方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class Runner implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    private final RabbitTemplate rabbitTemplate;</span><br><span class="line">    private final Receiver receiver;</span><br><span class="line">    private final ConfigurableApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public Runner(Receiver receiver, RabbitTemplate rabbitTemplate,</span><br><span class="line">            ConfigurableApplicationContext context) &#123;</span><br><span class="line">        this.receiver &#x3D; receiver;</span><br><span class="line">        this.rabbitTemplate &#x3D; rabbitTemplate;</span><br><span class="line">        this.context &#x3D; context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Sending message...&quot;);</span><br><span class="line">        rabbitTemplate.convertAndSend(Application.queueName, &quot;Hello from RabbitMQ!&quot;);</span><br><span class="line">        receiver.getLatch().await(10000, TimeUnit.MILLISECONDS);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动程序，你会发现控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sending message...</span><br><span class="line">Received &lt;Hello from RabbitMQ!&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>恭喜！你刚才已经学会了如何通过spring raabitmq去构建一个消息发送和订阅的程序。 这仅仅是一个好的开始，你可以通过spring-rabbitmq做更多的事，<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-amqp/reference/html/_introduction.html#quick-tour">点击这里</a>。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/messaging-rabbitmq/">https://spring.io/guides/gs/messaging-rabbitmq/</a></p>
<h2 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h2><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第18篇：定时任务</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot18-scheduling/</url>
    <content><![CDATA[<p>这篇文章将介绍怎么通过spring去做调度任务。</p>
<span id="more"></span>

<h2 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h2><p>创建一个Springboot工程，在它的程序入口加上@EnableScheduling,开启调度任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class SpringbootSchedulingTasksApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringbootSchedulingTasksApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h2><p>创建一个定时任务，每过5s在控制台打印当前时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ScheduledTasks &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger log &#x3D; LoggerFactory.getLogger(ScheduledTasks.class);</span><br><span class="line"></span><br><span class="line">    private static final SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    @Scheduled(fixedRate &#x3D; 5000)</span><br><span class="line">    public void reportCurrentTime() &#123;</span><br><span class="line">        log.info(&quot;The time is now &#123;&#125;&quot;, dateFormat.format(new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在方法上加@Scheduled注解，表明该方法是一个调度任务。</p>
<ul>
<li>@Scheduled(fixedRate = 5000) ：上一次开始执行时间点之后5秒再执行</li>
<li>@Scheduled(fixedDelay = 5000) ：上一次执行完毕时间点之后5秒再执行</li>
<li>@Scheduled(initialDelay=1000, fixedRate=5000) ：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次</li>
<li>@Scheduled(cron=”  /5   “) ：通过cron表达式定义规则，什么是cro表达式，自行搜索引擎。</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动springboot工程，控制台没过5s就打印出了当前的时间。</p>
<blockquote>
<p>2017-04-29 17:39:37.672  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:37<br>2017-04-29 17:39:42.671  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:42<br>2017-04-29 17:39:47.672  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:47<br>2017-04-29 17:39:52.675  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:52</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在springboot创建定时任务比较简单，只需2步：</p>
<ul>
<li>1.在程序的入口加上@EnableScheduling注解。</li>
<li>2.在定时方法上加@Scheduled注解。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/scheduling-tasks/">https://spring.io/guides/gs/scheduling-tasks/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第19篇：验证表单信息</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot19/</url>
    <content><![CDATA[<p>这篇文篇主要简述如何在springboot中验证表单信息。在springmvc工程中，需要检查表单信息，表单信息验证主要通过注解的形式。</p>
<span id="more"></span>

<h2 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h2><p>创建一个springboot工程，由于用到了 web 、thymeleaf、validator、el，引入相应的起步依赖和依赖，代码清单如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependencies&gt; </span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.hibernate&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;hibernate-validator&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;tomcat-embed-el&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建一个PresonForm的Object类"><a href="#创建一个PresonForm的Object类" class="headerlink" title="创建一个PresonForm的Object类"></a>创建一个PresonForm的Object类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.forezp.entity;</span><br><span class="line"></span><br><span class="line">import javax.validation.constraints.Min;</span><br><span class="line">import javax.validation.constraints.NotNull;</span><br><span class="line">import javax.validation.constraints.Size;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;19.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PersonForm &#123;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    @Size(min&#x3D;2, max&#x3D;30)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    @Min(18)</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person(Name: &quot; + this.name + &quot;, Age: &quot; + this.age + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个实体类，在2个属性:name,age.它们各自有验证的注解：</p>
<ul>
<li>@Size(min=2, max=30) name的长度为2-30个字符</li>
<li>@NotNull 不为空</li>
<li>@Min(18)age不能小于18</li>
</ul>
<h2 id="创建-web-Controller"><a href="#创建-web-Controller" class="headerlink" title="创建 web Controller"></a>创建 web Controller</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class WebController extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        registry.addViewController(&quot;&#x2F;results&quot;).setViewName(&quot;results&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String showForm(PersonForm personForm) &#123;</span><br><span class="line">        return &quot;form&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String checkPersonInfo(@Valid PersonForm personForm, BindingResult bindingResult) &#123;</span><br><span class="line"></span><br><span class="line">        if (bindingResult.hasErrors()) &#123;</span><br><span class="line">            return &quot;form&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;redirect:&#x2F;results&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建form表单"><a href="#创建form表单" class="headerlink" title="创建form表单"></a>创建form表单</h2><p>src/main/resources/templates/form.html:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form action&#x3D;&quot;#&quot; th:action&#x3D;&quot;@&#123;&#x2F;&#125;&quot; th:object&#x3D;&quot;$&#123;personForm&#125;&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">            &lt;table&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;Name:&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; th:field&#x3D;&quot;*&#123;name&#125;&quot; &#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td th:if&#x3D;&quot;$&#123;#fields.hasErrors(&#39;name&#39;)&#125;&quot; th:errors&#x3D;&quot;*&#123;name&#125;&quot;&gt;Name Error&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;Age:&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; th:field&#x3D;&quot;*&#123;age&#125;&quot; &#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td th:if&#x3D;&quot;$&#123;#fields.hasErrors(&#39;age&#39;)&#125;&quot; th:errors&#x3D;&quot;*&#123;age&#125;&quot;&gt;Age Error&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;&lt;button type&#x3D;&quot;submit&quot;&gt;Submit&lt;&#x2F;button&gt;&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">            &lt;&#x2F;table&gt;</span><br><span class="line">        &lt;&#x2F;form&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="注册成功的页面"><a href="#注册成功的页面" class="headerlink" title="注册成功的页面"></a>注册成功的页面</h2><p>src/main/resources/templates/results.html:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">html&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		Congratulations! You are old enough to sign up for this site.</span><br><span class="line">	&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>启动工程，访问<a target="_blank" rel="noopener" href="http://localhost:8080/%EF%BC%9A">http://localhost:8080/：</a></p>
<p><img src="https://spring.io/guides/gs/validating-form-input/images/valid-01.png"></p>
<p>如果你输入A和15，点击 submit:</p>
<p><img src="https://spring.io/guides/gs/validating-form-input/images/valid-02.png"></p>
<p><img src="https://spring.io/guides/gs/validating-form-input/images/valid-03.png"></p>
<p>如果name 输入N, age为空：</p>
<p><img src="https://spring.io/guides/gs/validating-form-input/images/valid-04.png"></p>
<p>如果输入：forezp. 18</p>
<p><img src="https://spring.io/guides/gs/validating-form-input/images/valid-05.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/validating-form-input/">https://spring.io/guides/gs/validating-form-input/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第2篇：配置文件详解</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot2-config-file/</url>
    <content><![CDATA[<p>springboot采纳了建立生产就绪Spring应用程序的观点。 Spring Boot优先于配置的惯例，旨在让您尽快启动和运行。在一般情况下，我们不需要做太多的配置就能够让spring boot正常运行。在一些特殊的情况下，我们需要做修改一些配置，或者需要有自己的配置属性。</p>
<span id="more"></span>

<h2 id="一、自定义属性"><a href="#一、自定义属性" class="headerlink" title="一、自定义属性"></a>一、自定义属性</h2><p>当我们创建一个springboot项目的时候，系统默认会为我们在src/main/java/resources目录下创建一个application.properties。个人习惯，我会将application.properties改为application.yml文件，两种文件格式都支持。</p>
<p>在application.yml自定义一组属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my:</span><br><span class="line"> name: forezp</span><br><span class="line"> age: 12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你需要读取配置文件的值只需要加@Value(“${属性名}”)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class MiyaController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;my.name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @Value(&quot;$&#123;my.age&#125;&quot;)</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;miya&quot;)</span><br><span class="line">    public String miya()&#123;</span><br><span class="line">        return name+&quot;:&quot;+age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动工程，访问：localhost:8080/miya,浏览器显示：</p>
<blockquote>
<p>forezp:12</p>
</blockquote>
<h2 id="二、将配置文件的属性赋给实体类"><a href="#二、将配置文件的属性赋给实体类" class="headerlink" title="二、将配置文件的属性赋给实体类"></a>二、将配置文件的属性赋给实体类</h2><p>当我们有很多配置属性的时候，这时我们会把这些属性作为字段来创建一个javabean，并将属性值赋予给他们,比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my:</span><br><span class="line"> name: forezp</span><br><span class="line"> age: 12</span><br><span class="line"> number:  $&#123;random.int&#125;</span><br><span class="line"> uuid : $&#123;random.uuid&#125;</span><br><span class="line"> max: $&#123;random.int(10)&#125;</span><br><span class="line"> value: $&#123;random.value&#125;</span><br><span class="line"> greeting: hi,i&#39;m  $&#123;my.name&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中配置文件中用到了${random} ，它可以用来生成各种不同类型的随机值。</p>
<p>怎么讲这些属性赋于给一个javabean 呢，首先创建一个javabean ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;my&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class ConfigBean &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int number;</span><br><span class="line">    private String uuid;</span><br><span class="line">    private int max;</span><br><span class="line">    private String value;</span><br><span class="line">    private String greeting;</span><br><span class="line">    </span><br><span class="line">    省略了getter setter....</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要加个注解@ConfigurationProperties，并加上它的prrfix。另外@Component可加可不加。另外spring-boot-configuration-processor依赖可加可不加，具体原因不详。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外需要在应用类或者application类，加EnableConfigurationProperties注解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@EnableConfigurationProperties(&#123;ConfigBean.class&#125;)</span><br><span class="line">public class LucyController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    ConfigBean configBean;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;lucy&quot;)</span><br><span class="line">    public String miya()&#123;</span><br><span class="line">        return configBean.getGreeting()+&quot; &gt;&gt;&gt;&gt;&quot;+configBean.getName()+&quot; &gt;&gt;&gt;&gt;&quot;+ configBean.getUuid()+&quot; &gt;&gt;&gt;&gt;&quot;+configBean.getMax();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动工程，访问localhost:8080/lucy,我们会发现配置文件信息读到了。</p>
<h2 id="三、自定义配置文件"><a href="#三、自定义配置文件" class="headerlink" title="三、自定义配置文件"></a>三、自定义配置文件</h2><p>上面介绍的是我们都把配置文件写到application.yml中。有时我们不愿意把配置都写到application配置文件中，这时需要我们自定义配置文件，比如test.properties:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.forezp.name&#x3D;forezp</span><br><span class="line">com.forezp.age&#x3D;12</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>怎么将这个配置文件信息赋予给一个javabean呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(value &#x3D; &quot;classpath:test.properties&quot;)</span><br><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;com.forezp&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在最新版本的springboot，需要加这三个注解。@Configuration<br>@PropertySource(value = “classpath:test.properties”)<br>@ConfigurationProperties(prefix = “com.forezp”);在1.4版本需要<br>PropertySource加上location。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@EnableConfigurationProperties(&#123;ConfigBean.class,User.class&#125;)</span><br><span class="line">public class LucyController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    ConfigBean configBean;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;lucy&quot;)</span><br><span class="line">    public String miya()&#123;</span><br><span class="line">        return configBean.getGreeting()+&quot; &gt;&gt;&gt;&gt;&quot;+configBean.getName()+&quot; &gt;&gt;&gt;&gt;&quot;+ configBean.getUuid()+&quot; &gt;&gt;&gt;&gt;&quot;+configBean.getMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    User user;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;)</span><br><span class="line">    public String user()&#123;</span><br><span class="line">        return user.getName()+user.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动工程，打开localhost:8080/user;浏览器会显示：</p>
<blockquote>
<p>forezp12</p>
</blockquote>
<h2 id="四、多个环境配置文件"><a href="#四、多个环境配置文件" class="headerlink" title="四、多个环境配置文件"></a>四、多个环境配置文件</h2><p>在现实的开发环境中，我们需要不同的配置环境；格式为application-{profile}.properties，其中{profile}对应你的环境标识，比如：</p>
<ul>
<li>application-test.properties：测试环境</li>
<li>application-dev.properties：开发环境</li>
<li>application-prod.properties：生产环境</li>
</ul>
<p>怎么使用？只需要我们在application.yml中加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> profiles:</span><br><span class="line">   active: dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 其中application-dev.yml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line"> port: 8082</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  启动工程，发现程序的端口不再是8080,而是8082。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p>  <a target="_blank" rel="noopener" href="https://www.gitbook.com/book/qbgbook/spring-boot-reference-guide-zh/details">spring-boot-reference-guide-zh</a></p>
<p>  <a target="_blank" rel="noopener" href="http://tengj.top/2017/02/28/springboot2/">pring Boot干货系列：（二）配置文件解析</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.didispace.com/springbootproperties/">Spring Boot属性配置文件详解</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第24篇：整合docker</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot24-docker/</url>
    <content><![CDATA[<p>这篇文篇介绍，怎么为 springboot程序构建一个docker镜像。docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<span id="more"></span>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>环境：</p>
<ul>
<li>linux环境或mac,不要用windows</li>
<li>jdk 8</li>
<li>maven 3.0</li>
<li>docker</li>
</ul>
<p>对docker一无所知的看<a target="_blank" rel="noopener" href="http://www.runoob.com/docker/docker-tutorial.html">docker教程</a>。</p>
<h2 id="创建一个springboot工程"><a href="#创建一个springboot工程" class="headerlink" title="创建一个springboot工程"></a>创建一个springboot工程</h2><p>引入web的起步依赖，创建一个 Controler:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line">public class SpringbootWithDockerApplication &#123;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">	public String home() &#123;</span><br><span class="line">		return &quot;Hello Docker World&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringbootWithDockerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将springboot工程容器化"><a href="#将springboot工程容器化" class="headerlink" title="将springboot工程容器化"></a>将springboot工程容器化</h2><p>Docker有一个简单的<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">dockerfile</a>文件作为指定镜像的图层。让我们先创建一个 dockerFile文件：</p>
<p>src/main/docker/Dockerfile:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM frolvlad&#x2F;alpine-oraclejdk8:slim</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD springboot-with-docker-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">RUN sh -c &#39;touch &#x2F;app.jar&#39;</span><br><span class="line">ENV JAVA_OPTS&#x3D;&quot;&quot;</span><br><span class="line">ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom -jar &#x2F;app.jar&quot; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们通过maven 构建docker镜像。</p>
<p>在maven的pom目录，加上docker镜像构建的插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">   &lt;docker.image.prefix&gt;springio&lt;&#x2F;docker.image.prefix&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.4.11&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;imageName&gt;</span><br><span class="line">                &lt;dockerDirectory&gt;src&#x2F;main&#x2F;docker&lt;&#x2F;dockerDirectory&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;&#x2F;&lt;&#x2F;targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;&#x2F;directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;include&gt;</span><br><span class="line">                    &lt;&#x2F;resource&gt;</span><br><span class="line">                &lt;&#x2F;resources&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：${docker.image.prefix} 为你在 docker官方仓库的用户名，如果你不需要上传镜像，随便填。</p>
<p>通过maven 命令：</p>
<p>第一步：mvn clean</p>
<p>第二步： mvn package docker:bulid ,如下：</p>
<blockquote>
<p>Step 2/6 : VOLUME /tmp<br> —&gt; Running in a98be3878053<br> —&gt; 8286e98b54c5<br>Removing intermediate container a98be3878053<br>Step 3/6 : ADD springboot-with-docker-0.0.1-SNAPSHOT.jar app.jar<br> —&gt; c6ce13e50bbd<br>Removing intermediate container a303a3058869<br>Step 4/6 : RUN sh -c ‘touch /app.jar’<br> —&gt; Running in cf231afe700e<br> —&gt; 9a0ec8936c00<br>Removing intermediate container cf231afe700e<br>Step 5/6 : ENV JAVA_OPTS “”<br> —&gt; Running in e192597fc881<br> —&gt; 2cb0d73bbdb0<br>Removing intermediate container e192597fc881<br>Step 6/6 : ENTRYPOINT sh -c java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar<br> —&gt; Running in ab85f53fcdd8<br> —&gt; 60fdb5c61692<br>Removing intermediate container ab85f53fcdd8<br>Successfully built 60fdb5c61692<br>[INFO] Built forezp/springboot-with-docker<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 01:45 min<br>[INFO] Finished at: 2017-04-19T05:37:44-07:00<br>[INFO] Final Memory: 19M/48M<br>[INFO] ————————————————————————</p>
</blockquote>
<p>镜像构建成功。查看镜像：</p>
<blockquote>
<p>docker images</p>
</blockquote>
<p>显示：</p>
<blockquote>
<p>forezp/springboot-with-docker   latest              60fdb5c61692        About a minute ago   195 MB</p>
</blockquote>
<p>启动镜像：</p>
<blockquote>
<p>$ docker run -p 8080:8080 -t forezp/springboot-with-docker</p>
</blockquote>
<p>打开浏览器访问  localhost:8080;浏览器显示：Hello Docker World。<br>说明docker 的springboot工程已部署。</p>
<p>停止镜像：</p>
<blockquote>
<p>docker stop 60fdb5c61692</p>
</blockquote>
<p>删除镜像：</p>
<blockquote>
<p>docker rm 60fdb5c61692</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/)</a>)</p>
<p><a target="_blank" rel="noopener" href="http://www.runoob.com/docker/docker-tutorial.html">http://www.runoob.com/docker/docker-tutorial.html</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第25篇：2小时学会spring boot</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot25-2hour/</url>
    <content><![CDATA[<h3 id="一-什么是spring-boot"><a href="#一-什么是spring-boot" class="headerlink" title="一.什么是spring boot"></a>一.什么是spring boot</h3><blockquote>
<p>Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible.</p>
<p>  摘自官网</p>
<p>翻译：采纳了建立生产就绪Spring应用程序的观点。 Spring Boot优先于配置的惯例，旨在让您尽快启动和运行。</p>
</blockquote>
<span id="more"></span>


<p>spring boot 致力于简洁，让开发者写更少的配置，程序能够更快的运行和启动。它是下一代javaweb框架，并且它是spring cloud（微服务）的基础。</p>
<h3 id="二、搭建第一个sping-boot-程序"><a href="#二、搭建第一个sping-boot-程序" class="headerlink" title="二、搭建第一个sping  boot 程序"></a>二、搭建第一个sping  boot 程序</h3><p>可以在start.spring.io上建项目，也可以用idea构建。本案列采用idea.</p>
<p>具体步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new prpject -&gt; spring initializr -&gt;&#123;name :firstspringboot , type: mavenproject,packaging:jar ,..&#125;  -&gt;&#123;spring version :1.5.2  web: web &#125; -&gt; ....</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用创建成功后，会生成相应的目录和文件。</p>
<p>其中有一个Application类,它是程序的入口:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class FirstspringbootApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(FirstspringbootApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在resources文件下下又一个application.yml文件，它是程序的配置文件。默认为空，写点配置 ,程序的端口为8080,context-path为  /springboot：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">  context-path: &#x2F;springboot</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写一个HelloController：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController     &#x2F;&#x2F;等同于同时加上了@Controller和@ResponseBody</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;访问&#x2F;hello或者&#x2F;hi任何一个地址，都会返回一样的结果</span><br><span class="line">    @RequestMapping(value &#x3D; &#123;&quot;&#x2F;hello&quot;,&quot;&#x2F;hi&quot;&#125;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public String say()&#123;</span><br><span class="line">        return &quot;hi you!!!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行 Application的main(),呈现会启动，由于springboot自动内置了servlet容器，所以不需要类似传统的方式，先部署到容器再启动容器。只需要运行main()即可，这时打开浏览器输入网址：localhost:8080/springboot/hi  ，就可以在浏览器上看到: <em>hi you!!!</em></p>
<h3 id="三-属性配置"><a href="#三-属性配置" class="headerlink" title="三.属性配置"></a>三.属性配置</h3><p>在appliction.yml文件添加属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">  context-path: &#x2F;springboot</span><br><span class="line"></span><br><span class="line">girl:</span><br><span class="line">  name: B</span><br><span class="line">  age: 18</span><br><span class="line">  content: content:$&#123;name&#125;,age:$&#123;age&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>在java文件中，获取name属性，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;name&#125;&quot;)</span><br><span class="line"> private String name;</span><br></pre></td></tr></table></figure>

<p>也可以通过ConfigurationProperties注解，将属性注入到bean中，通过Component注解将bean注解到spring容器中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix&#x3D;&quot;girl&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class GirlProperties &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外可以通过配置文件制定不同环境的配置文，具体见源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="四-通过jpa方式操作数据库"><a href="#四-通过jpa方式操作数据库" class="headerlink" title="四.通过jpa方式操作数据库"></a>四.通过jpa方式操作数据库</h3><p>导入jar ，在pom.xml中添加依赖:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在appilication.yml中添加数据库配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod</span><br><span class="line">    </span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbgirl?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;characterSetResults&#x3D;utf8</span><br><span class="line">    username: root</span><br><span class="line">    password: 123</span><br><span class="line"></span><br><span class="line">  jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: create</span><br><span class="line">    show-sql: true</span><br></pre></td></tr></table></figure>

<p>这些都是数据库常见的一些配置没什么可说的，其中ddl_auto: create 代表在数据库创建表，update 代表更新，首次启动需要create ,如果你想通过hibernate 注解的方式创建数据库的表的话，之后需要改为 update.</p>
<p>创建一个实体girl，这是基于hibernate的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Girl &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String cupSize;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public Girl() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCupSize() &#123;</span><br><span class="line">        return cupSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCupSize(String cupSize) &#123;</span><br><span class="line">        this.cupSize &#x3D; cupSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建Dao接口, springboot 将接口类会自动注解到spring容器中，不需要我吗做任何配置，只需要继承JpaRepository 即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;其中第二个参数为Id的类型</span><br><span class="line">public interface GirlRep extends JpaRepository&lt;Girl,Integer&gt;&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>创建一个GirlController，写一个获取所有girl的api和添加girl的api ，自己跑一下就可以了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class GirlController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private GirlRep girlRep;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询所有女生列表</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;girls&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public List&lt;Girl&gt; getGirlList()&#123;</span><br><span class="line">        return girlRep.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加一个女生</span><br><span class="line">     * @param cupSize</span><br><span class="line">     * @param age</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;girls&quot;,method &#x3D; RequestMethod.POST)</span><br><span class="line">    public Girl addGirl(@RequestParam(&quot;cupSize&quot;) String cupSize,</span><br><span class="line">                        @RequestParam(&quot;age&quot;) Integer age)&#123;</span><br><span class="line">        Girl girl &#x3D; new Girl();</span><br><span class="line">        girl.setAge(age);</span><br><span class="line">        girl.setCupSize(cupSize);</span><br><span class="line">        return girlRep.save(girl);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>

<p>如果需要事务的话，在service层加@Transaction注解即可。已经凌晨了，我要睡了.</p>
<p>源码；<a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9778235">http://download.csdn.net/detail/forezp/9778235</a></p>
<p>关注我的专栏《史上最简单的 SpringCloud 教程 》<a target="_blank" rel="noopener" href="http://blog.csdn.net/column/details/15197.html">http://blog.csdn.net/column/details/15197.html</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第3篇：JDBCTemplate</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot3-JdbcTemplates-Mysql/</url>
    <content><![CDATA[<p>本文介绍springboot通过jdbc访问关系型mysql,通过spring的JdbcTemplate去访问。</p>
<span id="more"></span>


<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>jdk 1.8</li>
<li>maven 3.0</li>
<li>idea</li>
<li>mysql</li>
</ul>
<p>初始化mysql:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- create table &#96;account&#96;</span><br><span class="line">DROP TABLE &#96;account&#96; IF EXISTS</span><br><span class="line">CREATE TABLE &#96;account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(20) NOT NULL,</span><br><span class="line">  &#96;money&#96; double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;1&#39;, &#39;aaa&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;2&#39;, &#39;bbb&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;3&#39;, &#39;ccc&#39;, &#39;1000&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><h3 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h3><p>在pom文件引入spring-boot-starter-jdbc的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>引入mysql连接类和连接池：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.0.29&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开启web:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置相关文件"><a href="#配置相关文件" class="headerlink" title="配置相关文件"></a>配置相关文件</h3><p>在application.properties文件配置mysql的驱动类，数据库地址，数据库账号、密码信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;123456</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过引入这些依赖和配置一些基本信息，springboot就可以访问数据库类。</p>
<h2 id="具体编码"><a href="#具体编码" class="headerlink" title="具体编码"></a>具体编码</h2><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">    private int id ;</span><br><span class="line">    private String name ;</span><br><span class="line">    private double money;</span><br><span class="line"></span><br><span class="line">....省略了getter. setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountDAO &#123;</span><br><span class="line">    int add(Account account);</span><br><span class="line"></span><br><span class="line">    int update(Account account);</span><br><span class="line"></span><br><span class="line">    int delete(int id);</span><br><span class="line"></span><br><span class="line">    Account findAccountById(int id);</span><br><span class="line"></span><br><span class="line">    List&lt;Account&gt; findAccountList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体的实现类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.forezp.dao.impl;</span><br><span class="line"></span><br><span class="line">import com.forezp.dao.IAccountDAO;</span><br><span class="line">import com.forezp.entity.Account;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;20.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Repository</span><br><span class="line">public class AccountDaoImpl implements IAccountDAO &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    @Override</span><br><span class="line">    public int add(Account account) &#123;</span><br><span class="line">        return jdbcTemplate.update(&quot;insert into account(name, money) values(?, ?)&quot;,</span><br><span class="line">              account.getName(),account.getMoney());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int update(Account account) &#123;</span><br><span class="line">        return jdbcTemplate.update(&quot;UPDATE  account SET NAME&#x3D;? ,money&#x3D;? WHERE id&#x3D;?&quot;,</span><br><span class="line">                account.getName(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int delete(int id) &#123;</span><br><span class="line">        return jdbcTemplate.update(&quot;DELETE from TABLE account where id&#x3D;?&quot;,id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Account findAccountById(int id) &#123;</span><br><span class="line">        List&lt;Account&gt; list &#x3D; jdbcTemplate.query(&quot;select * from account where id &#x3D; ?&quot;, new Object[]&#123;id&#125;, new BeanPropertyRowMapper(Account.class));</span><br><span class="line">        if(list!&#x3D;null &amp;&amp; list.size()&gt;0)&#123;</span><br><span class="line">            Account account &#x3D; list.get(0);</span><br><span class="line">            return account;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Account&gt; findAccountList() &#123;</span><br><span class="line">        List&lt;Account&gt; list &#x3D; jdbcTemplate.query(&quot;select * from account&quot;, new Object[]&#123;&#125;, new BeanPropertyRowMapper(Account.class));</span><br><span class="line">        if(list!&#x3D;null &amp;&amp; list.size()&gt;0)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int add(Account account);</span><br><span class="line"></span><br><span class="line">    int update(Account account);</span><br><span class="line"></span><br><span class="line">    int delete(int id);</span><br><span class="line"></span><br><span class="line">    Account findAccountById(int id);</span><br><span class="line"></span><br><span class="line">    List&lt;Account&gt; findAccountList();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体实现类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountService implements IAccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    IAccountDAO accountDAO;</span><br><span class="line">    @Override</span><br><span class="line">    public int add(Account account) &#123;</span><br><span class="line">        return accountDAO.add(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int update(Account account) &#123;</span><br><span class="line">        return accountDAO.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int delete(int id) &#123;</span><br><span class="line">        return accountDAO.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Account findAccountById(int id) &#123;</span><br><span class="line">        return accountDAO.findAccountById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Account&gt; findAccountList() &#123;</span><br><span class="line">        return accountDAO.findAccountList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构建一组restful-api来展示"><a href="#构建一组restful-api来展示" class="headerlink" title="构建一组restful api来展示"></a>构建一组restful api来展示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.forezp.web;</span><br><span class="line"></span><br><span class="line">import com.forezp.entity.Account;</span><br><span class="line">import com.forezp.service.IAccountService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;20.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    IAccountService accountService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;list&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public  List&lt;Account&gt; getAccounts()&#123;</span><br><span class="line">       return accountService.findAccountList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public  Account getAccountById(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">        return accountService.findAccountById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;,method &#x3D; RequestMethod.PUT)</span><br><span class="line">    public  String updateAccount(@PathVariable(&quot;id&quot;)int id , @RequestParam(value &#x3D; &quot;name&quot;,required &#x3D; true)String name,</span><br><span class="line">    @RequestParam(value &#x3D; &quot;money&quot; ,required &#x3D; true)double money)&#123;</span><br><span class="line">        Account account&#x3D;new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        account.setId(id);</span><br><span class="line">        int t&#x3D;accountService.update(account);</span><br><span class="line">        if(t&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return account.toString();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&quot;,method &#x3D; RequestMethod.POST)</span><br><span class="line">    public  String postAccount( @RequestParam(value &#x3D; &quot;name&quot;)String name,</span><br><span class="line">                                 @RequestParam(value &#x3D; &quot;money&quot; )double money)&#123;</span><br><span class="line">        Account account&#x3D;new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        int t&#x3D; accountService.add(account);</span><br><span class="line">        if(t&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return account.toString();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以通过postman来测试，具体的我已经全部测试通过，没有任何问题。注意restful构建api的风格。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/relational-data-access/">relational-data-access</a></p>
<h2 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h2><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第4篇：JPA</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot4-jpaJ/</url>
    <content><![CDATA[<p>JPA全称Java Persistence API.JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p>
<p>JPA 的目标之一是制定一个可以由很多供应商实现的API，并且开发人员可以编码来实现该API，而不是使用私有供应商特有的API。</p>
<span id="more"></span>

<p>JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个，应该说无人能出其右。从功能上来说，JPA就是Hibernate功能的一个子集。</p>
<h2 id="添加相关依赖"><a href="#添加相关依赖" class="headerlink" title="添加相关依赖"></a>添加相关依赖</h2><p>添加spring-boot-starter-jdbc依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-jpa</span><br><span class="line">			&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>添加mysql连接类和连接池类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置数据源，在application-properties文件配置："><a href="#配置数据源，在application-properties文件配置：" class="headerlink" title="配置数据源，在application.properties文件配置："></a>配置数据源，在application.properties文件配置：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;characterSetResults&#x3D;utf8</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line"></span><br><span class="line">  jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update  # 第一次简表create  后面用update</span><br><span class="line">    show-sql: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，如果通过jpa在数据库中建表，将jpa.hibernate,ddl-auto改为create，建完表之后，要改为update,要不然每次重启工程会删除表并新建。</p>
<h2 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h2><p>通过@Entity 表明是一个映射的实体类，  @Id表明id， @GeneratedValue 字段自动生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Account &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private int id ;</span><br><span class="line">    private String name ;</span><br><span class="line">    private double money;</span><br><span class="line"></span><br><span class="line">...  省略getter setter</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h2><p>数据访问层，通过编写一个继承自 JpaRepository 的接口就能完成数据访问,其中包含了几本的单表查询的方法，非常的方便。值得注意的是，这个Account 对象名，而不是具体的表名，另外Interger是主键的类型，一般为Integer或者Long</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AccountDao  extends JpaRepository&lt;Account,Integer&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Web层"><a href="#Web层" class="headerlink" title="Web层"></a>Web层</h2><p>在这个栗子中我简略了service层的书写，在实际开发中，不可省略。新写一个controller，写几个restful api来测试数据的访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;list&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public List&lt;Account&gt; getAccounts() &#123;</span><br><span class="line">        return accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public Account getAccountById(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return accountDao.findOne(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.PUT)</span><br><span class="line">    public String updateAccount(@PathVariable(&quot;id&quot;) int id, @RequestParam(value &#x3D; &quot;name&quot;, required &#x3D; true) String name,</span><br><span class="line">                                @RequestParam(value &#x3D; &quot;money&quot;, required &#x3D; true) double money) &#123;</span><br><span class="line">        Account account &#x3D; new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        account.setId(id);</span><br><span class="line">        Account account1 &#x3D; accountDao.saveAndFlush(account);</span><br><span class="line"></span><br><span class="line">        return account1.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">    public String postAccount(@RequestParam(value &#x3D; &quot;name&quot;) String name,</span><br><span class="line">                              @RequestParam(value &#x3D; &quot;money&quot;) double money) &#123;</span><br><span class="line">        Account account &#x3D; new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        Account account1 &#x3D; accountDao.save(account);</span><br><span class="line">        return account1.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过postman请求测试，代码已经全部通过测试。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/accessing-data-jpa/">accessing-data-jpa</a></p>
<h2 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h2><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第5篇：beatsql</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot5-beatlsql/</url>
    <content><![CDATA[<p>BeetSql是一个全功能DAO工具， 同时具有Hibernate 优点 &amp; Mybatis优点功能，适用于承认以SQL为中心，同时又需求工具能自动能生成大量常用的SQL的应用。</p>
<span id="more"></span>


<h2 id="beatlsql-优点"><a href="#beatlsql-优点" class="headerlink" title="beatlsql 优点"></a>beatlsql 优点</h2><ul>
<li><p>开发效率</p>
<ul>
<li>无需注解，自动使用大量内置SQL，轻易完成增删改查功能，节省50%的开发工作量</li>
<li>数据模型支持Pojo，也支持Map/List这种快速模型，也支持混合模型</li>
<li>SQL 模板基于Beetl实现，更容易写和调试，以及扩展</li>
</ul>
</li>
<li><p>维护性</p>
<ul>
<li>SQL 以更简洁的方式，Markdown方式集中管理，同时方便程序开发和数据库SQL调试。</li>
<li>可以自动将sql文件映射为dao接口类</li>
<li>灵活直观的支持支持一对一，一对多，多对多关系映射而不引入复杂的OR Mapping概念和技术。</li>
<li>具备Interceptor功能，可以调试，性能诊断SQL，以及扩展其他功能</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>内置支持主从数据库支持的开源工具</li>
<li>支持跨数据库平台，开发者所需工作减少到最小，目前跨数据库支持mysql,postgres,oracle,sqlserver,h2,sqllite,DB2.</li>
</ul>
</li>
</ul>
<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.ibeetl&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;beetl&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.3.2&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.ibeetl&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;beetlsql&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.3.1&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;5.0.5&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>这几个依赖都是必须的。</p>
<h2 id="整合阶段"><a href="#整合阶段" class="headerlink" title="整合阶段"></a>整合阶段</h2><p>由于springboot没有对 beatlsql的快速启动装配，所以需要我自己导入相关的bean，包括数据源，包扫描，事物管理器等。</p>
<p>在application加入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean(initMethod &#x3D; &quot;init&quot;, name &#x3D; &quot;beetlConfig&quot;)</span><br><span class="line">	public BeetlGroupUtilConfiguration getBeetlGroupUtilConfiguration() &#123;</span><br><span class="line">		BeetlGroupUtilConfiguration beetlGroupUtilConfiguration &#x3D; new BeetlGroupUtilConfiguration();</span><br><span class="line">		ResourcePatternResolver patternResolver &#x3D; ResourcePatternUtils.getResourcePatternResolver(new DefaultResourceLoader());</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; WebAppResourceLoader 配置root路径是关键</span><br><span class="line">			WebAppResourceLoader webAppResourceLoader &#x3D; new WebAppResourceLoader(patternResolver.getResource(&quot;classpath:&#x2F;templates&quot;).getFile().getPath());</span><br><span class="line">			beetlGroupUtilConfiguration.setResourceLoader(webAppResourceLoader);</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;读取配置文件信息</span><br><span class="line">		return beetlGroupUtilConfiguration;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean(name &#x3D; &quot;beetlViewResolver&quot;)</span><br><span class="line">	public BeetlSpringViewResolver getBeetlSpringViewResolver(@Qualifier(&quot;beetlConfig&quot;) BeetlGroupUtilConfiguration beetlGroupUtilConfiguration) &#123;</span><br><span class="line">		BeetlSpringViewResolver beetlSpringViewResolver &#x3D; new BeetlSpringViewResolver();</span><br><span class="line">		beetlSpringViewResolver.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br><span class="line">		beetlSpringViewResolver.setOrder(0);</span><br><span class="line">		beetlSpringViewResolver.setConfig(beetlGroupUtilConfiguration);</span><br><span class="line">		return beetlSpringViewResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;配置包扫描</span><br><span class="line">	@Bean(name &#x3D; &quot;beetlSqlScannerConfigurer&quot;)</span><br><span class="line">	public BeetlSqlScannerConfigurer getBeetlSqlScannerConfigurer() &#123;</span><br><span class="line">		BeetlSqlScannerConfigurer conf &#x3D; new BeetlSqlScannerConfigurer();</span><br><span class="line">		conf.setBasePackage(&quot;com.forezp.dao&quot;);</span><br><span class="line">		conf.setDaoSuffix(&quot;Dao&quot;);</span><br><span class="line">		conf.setSqlManagerFactoryBeanName(&quot;sqlManagerFactoryBean&quot;);</span><br><span class="line">		return conf;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean(name &#x3D; &quot;sqlManagerFactoryBean&quot;)</span><br><span class="line">	@Primary</span><br><span class="line">	public SqlManagerFactoryBean getSqlManagerFactoryBean(@Qualifier(&quot;datasource&quot;) DataSource datasource) &#123;</span><br><span class="line">		SqlManagerFactoryBean factory &#x3D; new SqlManagerFactoryBean();</span><br><span class="line"></span><br><span class="line">		BeetlSqlDataSource source &#x3D; new BeetlSqlDataSource();</span><br><span class="line">		source.setMasterSource(datasource);</span><br><span class="line">		factory.setCs(source);</span><br><span class="line">		factory.setDbStyle(new MySqlStyle());</span><br><span class="line">		factory.setInterceptors(new Interceptor[]&#123;new DebugInterceptor()&#125;);</span><br><span class="line">		factory.setNc(new UnderlinedNameConversion());&#x2F;&#x2F;开启驼峰</span><br><span class="line">		factory.setSqlLoader(new ClasspathLoader(&quot;&#x2F;sql&quot;));&#x2F;&#x2F;sql文件路径</span><br><span class="line">		return factory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;配置数据库</span><br><span class="line">	@Bean(name &#x3D; &quot;datasource&quot;)</span><br><span class="line">	public DataSource getDataSource() &#123;</span><br><span class="line">		return DataSourceBuilder.create().url(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test&quot;).username(&quot;root&quot;).password(&quot;123456&quot;).build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;开启事务</span><br><span class="line">	@Bean(name &#x3D; &quot;txManager&quot;)</span><br><span class="line">	public DataSourceTransactionManager getDataSourceTransactionManager(@Qualifier(&quot;datasource&quot;) DataSource datasource) &#123;</span><br><span class="line">		DataSourceTransactionManager dsm &#x3D; new DataSourceTransactionManager();</span><br><span class="line">		dsm.setDataSource(datasource);</span><br><span class="line">		return dsm;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在resouces包下，加META_INF文件夹，文件夹中加入spring-devtools.properties:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">restart.include.beetl&#x3D;&#x2F;beetl-2.3.2.jar</span><br><span class="line">restart.include.beetlsql&#x3D;&#x2F;beetlsql-2.3.1.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在templates下加一个index.btl文件。</p>
<p>加入jar和配置beatlsql的这些bean，以及resources这些配置之后，springboot就能够访问到数据库类。</p>
<h2 id="举个restful的栗子"><a href="#举个restful的栗子" class="headerlink" title="举个restful的栗子"></a>举个restful的栗子</h2><h3 id="初始化数据库的表"><a href="#初始化数据库的表" class="headerlink" title="初始化数据库的表"></a>初始化数据库的表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># DROP TABLE &#96;account&#96; IF EXISTS</span><br><span class="line">CREATE TABLE &#96;account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(20) NOT NULL,</span><br><span class="line">  &#96;money&#96; double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;1&#39;, &#39;aaa&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;2&#39;, &#39;bbb&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;3&#39;, &#39;ccc&#39;, &#39;1000&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">    private int id ;</span><br><span class="line">    private String name ;</span><br><span class="line">    private double money;</span><br><span class="line"></span><br><span class="line">    getter...</span><br><span class="line">    </span><br><span class="line">    setter...</span><br><span class="line">    </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure>

<h3 id="数据访问dao层"><a href="#数据访问dao层" class="headerlink" title="数据访问dao层"></a>数据访问dao层</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AccountDao extends BaseMapper&lt;Account&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @SqlStatement(params &#x3D; &quot;name&quot;)</span><br><span class="line">    Account selectAccountByName(String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接口继承BaseMapper，就能获取单表查询的一些性质，当你需要自定义sql的时候，只需要在resouses/sql/account.md文件下书写文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">selectAccountByName</span><br><span class="line">&#x3D;&#x3D;&#x3D;</span><br><span class="line">*根据name获account</span><br><span class="line"></span><br><span class="line">    select * from account where name&#x3D; #name#</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>其中“=== ”上面是唯一标识，对应于接口的方法名，“* ”后面是注释，在下面就是自定义的sql语句，具体的见官方文档。</p>
<h3 id="web层"><a href="#web层" class="headerlink" title="web层"></a>web层</h3><p>这里省略了service层，实际开发补上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;list&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public  List&lt;Account&gt; getAccounts()&#123;</span><br><span class="line">       return accountDao.all();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public  Account getAccountById(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">        return accountDao.unique(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public  Account getAccountById(@RequestParam(&quot;name&quot;) String name)&#123;</span><br><span class="line">        return accountDao.selectAccountByName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;,method &#x3D; RequestMethod.PUT)</span><br><span class="line">    public  String updateAccount(@PathVariable(&quot;id&quot;)int id , @RequestParam(value &#x3D; &quot;name&quot;,required &#x3D; true)String name,</span><br><span class="line">    @RequestParam(value &#x3D; &quot;money&quot; ,required &#x3D; true)double money)&#123;</span><br><span class="line">        Account account&#x3D;new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        account.setId(id);</span><br><span class="line">        int t&#x3D;accountDao.updateById(account);</span><br><span class="line">        if(t&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return account.toString();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&quot;,method &#x3D; RequestMethod.POST)</span><br><span class="line">    public  String postAccount( @RequestParam(value &#x3D; &quot;name&quot;)String name,</span><br><span class="line">                                 @RequestParam(value &#x3D; &quot;money&quot; )double money) &#123;</span><br><span class="line">        Account account &#x3D; new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        KeyHolder t &#x3D; accountDao.insertReturnKey(account);</span><br><span class="line">        if (t.getInt() &gt; 0) &#123;</span><br><span class="line">            return account.toString();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过postman 测试，代码已全部通过。</p>
<p>个人使用感受，使用bealsql做了一些项目的试验，但是没有真正用于真正的生产环境，用起来非常的爽。但是springboot没有提供自动装配的直接支持，需要自己注解bean。另外使用这个orm的人不太多，有木有坑不知道，在我使用的过程中没有遇到什么问题。另外它的中文文档比较友好。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://www.ibeetl.com/guide/#beetlsql">BeetlSQL2.8中文文档</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第8篇：整合mongodb</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot8-mongodb/</url>
    <content><![CDATA[<p>这篇文章主要介绍springboot如何整合mongodb。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/mongodb/mongodb-window-install.html">安装 MongoDB</a></li>
<li>jdk 1.8</li>
<li>maven 3.0</li>
<li>idea</li>
</ul>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><p>在pom文件引入spring-boot-starter-data-mongodb依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>##数据源配置</p>
<p>如果mongodb端口是默认端口，并且没有设置密码，可不配置，sprinboot会开启默认的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.data.mongodb.uri&#x3D;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;springboot-db</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mongodb设置了密码，这样配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.data.mongodb.uri&#x3D;mongodb:&#x2F;&#x2F;name:pass@localhost:27017&#x2F;dbname</span><br></pre></td></tr></table></figure>

<h2 id="定义一个简单的实体"><a href="#定义一个简单的实体" class="headerlink" title="定义一个简单的实体"></a>定义一个简单的实体</h2><p>mongodb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.forezp.entity;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.annotation.Id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Customer &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    public String id;</span><br><span class="line"></span><br><span class="line">    public String firstName;</span><br><span class="line">    public String lastName;</span><br><span class="line"></span><br><span class="line">    public Customer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Customer(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName &#x3D; firstName;</span><br><span class="line">        this.lastName &#x3D; lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(</span><br><span class="line">                &quot;Customer[id&#x3D;%s, firstName&#x3D;&#39;%s&#39;, lastName&#x3D;&#39;%s&#39;]&quot;,</span><br><span class="line">                id, firstName, lastName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="数据操作dao层"><a href="#数据操作dao层" class="headerlink" title="数据操作dao层"></a>数据操作dao层</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface CustomerRepository extends MongoRepository&lt;Customer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Customer findByFirstName(String firstName);</span><br><span class="line">    public List&lt;Customer&gt; findByLastName(String lastName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写一个接口，继承MongoRepository，这个接口有了几本的CURD的功能。如果你想自定义一些查询，比如根据firstName来查询，获取根据lastName来查询，只需要定义一个方法即可。注意firstName严格按照存入的mongodb的字段对应。在典型的java的应用程序，写这样一个接口的方法，需要自己实现，但是在springboot中，你只需要按照格式写一个接口名和对应的参数就可以了，因为springboot已经帮你实现了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootMongodbApplication  implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private CustomerRepository repository;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringbootMongodbApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run(String... args) throws Exception &#123;</span><br><span class="line">		repository.deleteAll();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; save a couple of customers</span><br><span class="line">		repository.save(new Customer(&quot;Alice&quot;, &quot;Smith&quot;));</span><br><span class="line">		repository.save(new Customer(&quot;Bob&quot;, &quot;Smith&quot;));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; fetch all customers</span><br><span class="line">		System.out.println(&quot;Customers found with findAll():&quot;);</span><br><span class="line">		System.out.println(&quot;-------------------------------&quot;);</span><br><span class="line">		for (Customer customer : repository.findAll()) &#123;</span><br><span class="line">			System.out.println(customer);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; fetch an individual customer</span><br><span class="line">		System.out.println(&quot;Customer found with findByFirstName(&#39;Alice&#39;):&quot;);</span><br><span class="line">		System.out.println(&quot;--------------------------------&quot;);</span><br><span class="line">		System.out.println(repository.findByFirstName(&quot;Alice&quot;));</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;Customers found with findByLastName(&#39;Smith&#39;):&quot;);</span><br><span class="line">		System.out.println(&quot;--------------------------------&quot;);</span><br><span class="line">		for (Customer customer : repository.findByLastName(&quot;Smith&quot;)) &#123;</span><br><span class="line">			System.out.println(customer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>在springboot的应用程序，加入测试代码。启动程序，控制台打印了：</p>
<blockquote>
<p>Customers found with findAll():<br>     ——————————-<br>     Customer[id=58f880f589ffb696b8a6077e, firstName=’Alice’, lastName=’Smith’]<br>     Customer[id=58f880f589ffb696b8a6077f, firstName=’Bob’, lastName=’Smith’]<br>     Customer found with findByFirstName(‘Alice’):<br>     ——————————–<br>     Customer[id=58f880f589ffb696b8a6077e, firstName=’Alice’, lastName=’Smith’]<br>     Customers found with findByLastName(‘Smith’):<br>     ——————————–<br>     Customer[id=58f880f589ffb696b8a6077e, firstName=’Alice’, lastName=’Smith’]<br>     Customer[id=58f880f589ffb696b8a6077f, firstName=’Bob’, lastName=’Smith’]</p>
</blockquote>
<p>测试通过。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/accessing-data-mongodb/">accessing-data-mongodb</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第9篇：整合Redis</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot9-redis/</url>
    <content><![CDATA[<p>这篇文章主要介绍springboot整合redis，至于没有接触过redis的同学可以看下这篇文章：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/61471712">5分钟带你入门Redis</a>。</p>
<span id="more"></span> 

<h2 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h2><p>在pom文件中添加redis依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.redis.host&#x3D;localhost</span><br><span class="line">spring.redis.port&#x3D;6379</span><br><span class="line">#spring.redis.password&#x3D;</span><br><span class="line">spring.redis.database&#x3D;1</span><br><span class="line">spring.redis.pool.max-active&#x3D;8</span><br><span class="line">spring.redis.pool.max-wait&#x3D;-1</span><br><span class="line">spring.redis.pool.max-idle&#x3D;500</span><br><span class="line">spring.redis.pool.min-idle&#x3D;0</span><br><span class="line">spring.redis.timeout&#x3D;0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 如果你的redis有密码，配置下即可。经过上述两步的操作，你可以访问redis数据了。</p>
<h2 id="数据访问层dao"><a href="#数据访问层dao" class="headerlink" title="数据访问层dao"></a>数据访问层dao</h2><p>通过redisTemplate来访问redis.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class RedisDao &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    public  void setKey(String key,String value)&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops &#x3D; template.opsForValue();</span><br><span class="line">        ops.set(key,value,1, TimeUnit.MINUTES);&#x2F;&#x2F;1分钟过期</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue(String key)&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops &#x3D; this.template.opsForValue();</span><br><span class="line">        return ops.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringbootRedisApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">	public static Logger logger&#x3D; LoggerFactory.getLogger(SpringbootRedisApplicationTests.class);</span><br><span class="line">	@Test</span><br><span class="line">	public void contextLoads() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	RedisDao redisDao;</span><br><span class="line">	@Test</span><br><span class="line">	public void testRedis()&#123;</span><br><span class="line">		redisDao.setKey(&quot;name&quot;,&quot;forezp&quot;);</span><br><span class="line">		redisDao.setKey(&quot;age&quot;,&quot;11&quot;);</span><br><span class="line">		logger.info(redisDao.getValue(&quot;name&quot;));</span><br><span class="line">		logger.info(redisDao.getValue(&quot;age&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动单元测试，你发现控制台打印了：</p>
<blockquote>
<p>forezp</p>
<p>11</p>
</blockquote>
<p>单元测试通过；</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/messaging-redis/">messaging-redis</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第22篇：多Module工程</title>
    <url>/2017/05/05/springboot-2017-05-05-springbot22-modules/</url>
    <content><![CDATA[<p>这篇文章主要介绍如何在springboot中如何创建含有多个module的工程，栗子中含有两个 module，一个作为libarary. 工程，另外一个是主工程，调用libary .其中libary jar有一个服务，main工程调用这个服务。</p>
<span id="more"></span>

<h2 id="创建根工程"><a href="#创建根工程" class="headerlink" title="创建根工程"></a>创建根工程</h2><p>创建一个maven 工程,其pom文件为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springboot-multi-module&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</span><br><span class="line">	&lt;name&gt;springboot-multi-module&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是packaging标签为pom 属性。</p>
<h2 id="创建libary工程"><a href="#创建libary工程" class="headerlink" title="创建libary工程"></a>创建libary工程</h2><p>libary工程为maven工程，其pom文件的packaging标签为jar 属性。创建一个service组件,它读取配置文件的 service.message属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(&quot;service&quot;)</span><br><span class="line">public class ServiceProperties &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * A message for the service.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message &#x3D; message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提供一个对外暴露的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(ServiceProperties.class)</span><br><span class="line">public class ServiceConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Service service(ServiceProperties properties) &#123;</span><br><span class="line">        return new Service(properties.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="创建一个springbot工程"><a href="#创建一个springbot工程" class="headerlink" title="创建一个springbot工程"></a>创建一个springbot工程</h2><p>引入相应的依赖,创建一个web服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@Import(ServiceConfiguration.class)</span><br><span class="line">@RestController</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">    private final Service service;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public DemoApplication(Service service) &#123;</span><br><span class="line">        this.service &#x3D; service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String home() &#123;</span><br><span class="line">        return service.message();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在配置文件application.properties中加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service.message&#x3D;Hello World</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>打开浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8080/;%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8080/;浏览器显示：</a></p>
<blockquote>
<p>Hello World</p>
</blockquote>
<p>说明确实引用了libary中的方法。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/multi-module/">https://spring.io/guides/gs/multi-module/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第1篇：Eureka</title>
    <url>/2017/06/01/springcloud-2017-06-01-sc01-eureka/</url>
    <content><![CDATA[<p>__</p>
<h3 id="一、spring-cloud简介"><a href="#一、spring-cloud简介" class="headerlink" title="一、spring cloud简介"></a>一、spring cloud简介</h3><p>spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。另外说明spring cloud是基于springboot的，所以需要开发中对springboot有一定的了解，如果不了解的话可以看这篇文章：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/61472783">2小时学会springboot</a>。另外对于“微服务架构” 不了解的话，可以通过搜索引擎搜索“微服务架构”了解下。</p>
<span id="more"></span>

<h3 id="二、创建服务注册中心"><a href="#二、创建服务注册中心" class="headerlink" title="二、创建服务注册中心"></a>二、创建服务注册中心</h3><p>在这里，我们需要用的的组件上Spring Cloud Netflix的Eureka ,eureka是一个服务注册和发现模块。</p>
<p><strong>2.1 首先创建一个maven主工程。</strong></p>
<p>**2.2 然后创建2个model工程:**一个model工程作为服务注册中心，即Eureka Server,另一个作为Eureka Client。</p>
<p>下面以创建server为例子，详细说明创建过程：</p>
<p>右键工程-&gt;创建model-&gt; 选择spring initialir 如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-de33b84a79858106.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>下一步-&gt;选择cloud discovery-&gt;eureka server ,然后一直下一步就行了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-3addb73d569a58e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>创建完后的工程的pom.xml文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;eurekaserver&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;eurekaserver&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;!--eureka server --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- spring boot test--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2.3  启动一个服务注册中心</strong>，只需要一个注解@EnableEurekaServer，这个注解需要在springboot工程的启动application类上加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@EnableEurekaServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class EurekaserverApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(EurekaserverApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**2.4 **eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。eureka server的配置文件appication.yml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    fetchRegistry: false</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<p>通过eureka.client.registerWithEureka：false和fetchRegistry：false来表明自己是一个eureka server.</p>
<p><strong>2.5</strong> eureka server 是有界面的，启动工程,打开浏览器访问：<br><a target="_blank" rel="noopener" href="http://localhost:8761/">http://localhost:8761</a> ,界面如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-8c954deeb3a3a01c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<blockquote>
<p>No application available 没有服务被发现 ……^_^<br>因为没有注册服务当然不可能有服务被发现了。</p>
</blockquote>
<h3 id="三、创建一个服务提供者-eureka-client"><a href="#三、创建一个服务提供者-eureka-client" class="headerlink" title="三、创建一个服务提供者 (eureka client)"></a>三、创建一个服务提供者 (eureka client)</h3><p>当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。</p>
<p>创建过程同server类似,创建完pom.xml如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;service-hi&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;service-hi&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过注解@EnableEurekaClient 表明自己是一个eurekaclient.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@RestController</span><br><span class="line">public class ServiceHiApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceHiApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">	String port;</span><br><span class="line">	@RequestMapping(&quot;&#x2F;hi&quot;)</span><br><span class="line">	public String home(@RequestParam String name) &#123;</span><br><span class="line">		return &quot;hi &quot;+name+&quot;,i am from port:&quot; +port;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仅仅@EnableEurekaClient是不够的，还需要在配置文件中注明自己的服务注册中心的地址，application.yml配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">  port: 8762</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-hi</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要指明spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name 。<br>启动工程，打开<a target="_blank" rel="noopener" href="http://localhost:8761/">http://localhost:8761</a> ，即eureka server 的网址：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-d830f93f1e56f6a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>你会发现一个服务已经注册在服务中了，服务名为SERVICE-HI ,端口为7862</p>
<p>这时打开 <a target="_blank" rel="noopener" href="http://localhost:8762/hi?name=forezp">http://localhost:8762/hi?name=forezp</a> ，你会在浏览器上看到 :</p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter1">https://github.com/forezp/SpringCloudLearning/tree/master/chapter1</a></p>
<h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-eureka-server">springcloud eureka server 官方文档</a></p>
<p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_service_discovery_eureka_clients">springcloud eureka client 官方文档</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第2篇：Ribbon</title>
    <url>/2017/06/02/springcloud-2017-06-02-sc02-rest-ribbon/</url>
    <content><![CDATA[<p>在上一篇文章，讲了服务的注册和发现。在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest。</p>
<span id="more"></span>

<h3 id="一、ribbon简介"><a href="#一、ribbon简介" class="headerlink" title="一、ribbon简介"></a>一、ribbon简介</h3><blockquote>
<p>Ribbon is a client side load balancer which gives you a lot of control over the behaviour of HTTP and TCP clients. Feign already uses Ribbon, so if you are using @FeignClient then this section also applies.</p>
<p>  —–摘自官网</p>
</blockquote>
<p>ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon。</p>
<p>ribbon 已经默认实现了这些配置bean：</p>
<ul>
<li><p>IClientConfig ribbonClientConfig: DefaultClientConfigImpl</p>
</li>
<li><p>IRule ribbonRule: ZoneAvoidanceRule</p>
</li>
<li><p>IPing ribbonPing: NoOpPing</p>
</li>
<li><p>ServerList<Server> ribbonServerList: ConfigurationBasedServerList</p>
</li>
<li><p>ServerListFilter<Server> ribbonServerListFilter: ZonePreferenceServerListFilter</p>
</li>
<li><p>ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</p>
</li>
</ul>
<h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><p>这一篇文章基于上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762；将service-hi的配置文件的端口改为8763,并启动，这时你会发现：service-hi在eureka-server注册了2个实例，这就相当于一个小的集群。访问localhost:8761如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-862f68c48735d126.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="三、建一个服务消费者"><a href="#三、建一个服务消费者" class="headerlink" title="三、建一个服务消费者"></a>三、建一个服务消费者</h4><p>重新新建一个spring-boot工程，取名为：service-ribbon;<br>在它的pom.xml文件分别引入起步依赖spring-cloud-starter-eureka、spring-cloud-starter-ribbon、spring-boot-starter-web，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;service-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;service-ribbon&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在工程的配置文件指定服务的注册中心地址为<a target="_blank" rel="noopener" href="http://localhost:8761/eureka/%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%90%8D%E7%A7%B0%E4%B8%BA">http://localhost:8761/eureka/，程序名称为</a> service-ribbon，程序端口为8764。配置文件application.yml如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">  port: 8764</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-ribbon</span><br></pre></td></tr></table></figure>

<p>在工程的启动类中,通过@EnableDiscoveryClient向服务中心注册；并且向程序的ioc注入一个bean: restTemplate;并通过@LoadBalanced注解表明这个restRemplate开启负载均衡的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class ServiceRibbonApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceRibbonApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@LoadBalanced</span><br><span class="line">	RestTemplate restTemplate() &#123;</span><br><span class="line">		return new RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写一个测试类HelloService，通过之前注入ioc容器的restTemplate来消费service-hi服务的“/hi”接口，在这里我们直接用的程序名替代了具体的url地址，在ribbon中它会根据服务名来选择具体的服务实例，根据服务实例在请求的时候会用具体的url替换掉服务名，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public String hiService(String name) &#123;</span><br><span class="line">        return restTemplate.getForObject(&quot;http:&#x2F;&#x2F;SERVICE-HI&#x2F;hi?name&#x3D;&quot;+name,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写一个controller，在controller中用调用HelloService 的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;6.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">public class HelloControler &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    HelloService helloService;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;)</span><br><span class="line">    public String hi(@RequestParam String name)&#123;</span><br><span class="line">        return helloService.hiService(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在浏览器上多次访问<a target="_blank" rel="noopener" href="http://localhost:8764/hi?name=forezp%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%A4%E6%9B%BF%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8764/hi?name=forezp，浏览器交替显示：</a></p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
<p>hi forezp,i am from port:8763</p>
</blockquote>
<p>这说明当我们通过调用restTemplate.getForObject(“<a target="_blank" rel="noopener" href="http://service-hi/hi?name=&quot;+name,String.class)%E6%96%B9%E6%B3%95%E6%97%B6%EF%BC%8C%E5%B7%B2%E7%BB%8F%E5%81%9A%E4%BA%86%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%8C%E8%AE%BF%E9%97%AE%E4%BA%86%E4%B8%8D%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E3%80%82">http://SERVICE-HI/hi?name=&quot;+name,String.class)方法时，已经做了负载均衡，访问了不同的端口的服务实例。</a></p>
<h3 id="四、此时的架构"><a href="#四、此时的架构" class="headerlink" title="四、此时的架构"></a>四、此时的架构</h3><p><img src="http://upload-images.jianshu.io/upload_images/2279594-9f10b702188a129d.png" alt="此时架构图.png"></p>
<ul>
<li>一个服务注册中心，eureka server,端口为8761</li>
<li>service-hi工程跑了两个实例，端口分别为8762,8763，分别向服务注册中心注册</li>
<li>sercvice-ribbon端口为8764,向服务注册中心注册</li>
<li>当sercvice-ribbon通过restTemplate调用service-hi的hi接口时，因为用ribbon进行了负载均衡，会轮流的调用service-hi：8762和8763 两个端口的hi接口；</li>
</ul>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter2">https://github.com/forezp/SpringCloudLearning/tree/master/chapter2</a></p>
<h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p>本文参考了以下：</p>
<p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-ribbon">spring-cloud-ribbon</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/liaokailin/article/details/51469834">springcloud ribbon with eureka</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.didispace.com/springcloud2/">服务消费者</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第3篇：feign</title>
    <url>/2017/06/03/springcloud-2017-06-03-sc03-feign/</url>
    <content><![CDATA[<p>上一篇文章，讲述了如何通过RestTemplate+Ribbon去消费服务，这篇文章主要讲述如何通过Feign去消费服务。</p>
<span id="more"></span>

<h3 id="一、Feign简介"><a href="#一、Feign简介" class="headerlink" title="一、Feign简介"></a>一、Feign简介</h3><p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p>
<p>简而言之：</p>
<ul>
<li>Feign 采用的是基于接口的注解</li>
<li>Feign 整合了ribbon</li>
</ul>
<h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><p>继续用上一节的工程， 启动eureka-server，端口为8761; 启动service-hi 两次，端口分别为8762 、8773.</p>
<h3 id="三、创建一个feign的服务"><a href="#三、创建一个feign的服务" class="headerlink" title="三、创建一个feign的服务"></a>三、创建一个feign的服务</h3><p>新建一个spring-boot工程，取名为serice-feign，在它的pom文件引入Feign的起步依赖spring-cloud-starter-feign、Eureka的起步依赖spring-cloud-starter-eureka、Web的起步依赖spring-boot-starter-web，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;service-feign&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;service-feign&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-feign&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为<a target="_blank" rel="noopener" href="http://localhost:8761/eureka/">http://localhost:8761/eureka/</a> ，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">  port: 8765</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-feign</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在程序的启动类ServiceFeignApplication ，加上@EnableFeignClients注解开启Feign的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class ServiceFeignApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceFeignApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务。比如在代码中调用了service-hi服务的“/hi”接口，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;6.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@FeignClient(value &#x3D; &quot;service-hi&quot;)</span><br><span class="line">public interface SchedualServiceHi &#123;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    String sayHiFromClientOne(@RequestParam(value &#x3D; &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Web层的controller层，对外暴露一个”/hi”的API接口，通过上面定义的Feign客户端SchedualServiceHi 来消费服务。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HiController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    SchedualServiceHi schedualServiceHi;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public String sayHi(@RequestParam String name)&#123;</span><br><span class="line">        return schedualServiceHi.sayHiFromClientOne(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动程序，多次访问<a target="_blank" rel="noopener" href="http://localhost:8765/hi?name=forezp,%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%A4%E6%9B%BF%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8765/hi?name=forezp,浏览器交替显示：</a></p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
<p>hi forezp,i am from port:8763</p>
</blockquote>
<p>Feign源码解析：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/73480304">http://blog.csdn.net/forezp/article/details/73480304</a></p>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter3">https://github.com/forezp/SpringCloudLearning/tree/master/chapter3</a></p>
<h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-feign">spring-cloud-feign</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud feign</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第4篇：Hystrix</title>
    <url>/2017/06/04/springcloud-2017-06-04-sc04-hystrix/</url>
    <content><![CDATA[<p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p>
<p>为了解决这个问题，业界提出了断路器模型。</p>
<span id="more"></span>

<h3 id="一、断路器简介"><a href="#一、断路器简介" class="headerlink" title="一、断路器简介"></a>一、断路器简介</h3><blockquote>
<p>Netflix has created a library called Hystrix that implements the circuit breaker pattern. In a microservice architecture it is common to have multiple layers of service calls.</p>
<p>. —-摘自官网 </p>
</blockquote>
<p>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-08d8d524c312c27d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="HystrixGraph.png"></p>
<p>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-8dcb1f208d62046f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="HystrixFallback.png"></p>
<p>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。</p>
<h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><p>这篇文章基于上一篇文章的工程，首先启动上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762。</p>
<h3 id="三、在ribbon使用断路器"><a href="#三、在ribbon使用断路器" class="headerlink" title="三、在ribbon使用断路器"></a>三、在ribbon使用断路器</h3><p>改造serice-ribbon 工程的代码，首先在pox.xml文件中加入spring-cloud-starter-hystrix的起步依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在程序的启动类ServiceRibbonApplication 加@EnableHystrix注解开启Hystrix：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableHystrix</span><br><span class="line">public class ServiceRibbonApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceRibbonApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@LoadBalanced</span><br><span class="line">	RestTemplate restTemplate() &#123;</span><br><span class="line">		return new RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串，字符串为”hi,”+name+”,sorry,error!”，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @HystrixCommand(fallbackMethod &#x3D; &quot;hiError&quot;)</span><br><span class="line">    public String hiService(String name) &#123;</span><br><span class="line">        return restTemplate.getForObject(&quot;http:&#x2F;&#x2F;SERVICE-HI&#x2F;hi?name&#x3D;&quot;+name,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String hiError(String name) &#123;</span><br><span class="line">        return &quot;hi,&quot;+name+&quot;,sorry,error!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动：service-ribbon 工程，当我们访问<a target="_blank" rel="noopener" href="http://localhost:8764/hi?name=forezp,%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8764/hi?name=forezp,浏览器显示：</a></p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>此时关闭 service-hi 工程，当我们再访问<a target="_blank" rel="noopener" href="http://localhost:8764/hi?name=forezp%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8764/hi?name=forezp，浏览器会显示：</a></p>
<blockquote>
<p>hi ,forezp,orry,error!</p>
</blockquote>
<p>这就说明当 service-hi 工程不可用的时候，service-ribbon调用 service-hi的API接口时，会执行快速失败，直接返回一组字符串，而不是等待响应超时，这很好的控制了容器的线程阻塞。</p>
<h3 id="四、Feign中使用断路器"><a href="#四、Feign中使用断路器" class="headerlink" title="四、Feign中使用断路器"></a>四、Feign中使用断路器</h3><p>Feign是自带断路器的，在D版本的Spring Cloud中，它没有默认打开。需要在配置文件中配置打开它，在配置文件加以下代码：</p>
<blockquote>
<p>feign.hystrix.enabled=true</p>
</blockquote>
<p>基于service-feign工程进行改造，只需要在FeignClient的SchedualServiceHi接口的注解中加上fallback的指定类就行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FeignClient(value &#x3D; &quot;service-hi&quot;,fallback &#x3D; SchedualServiceHiHystric.class)</span><br><span class="line">public interface SchedualServiceHi &#123;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    String sayHiFromClientOne(@RequestParam(value &#x3D; &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SchedualServiceHiHystric需要实现SchedualServiceHi 接口，并注入到Ioc容器中，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SchedualServiceHiHystric implements SchedualServiceHi &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String sayHiFromClientOne(String name) &#123;</span><br><span class="line">        return &quot;sorry &quot;+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动四servcie-feign工程，浏览器打开<a target="_blank" rel="noopener" href="http://localhost:8765/hi?name=forezp,%E6%B3%A8%E6%84%8F%E6%AD%A4%E6%97%B6service-hi%E5%B7%A5%E7%A8%8B%E6%B2%A1%E6%9C%89%E5%90%AF%E5%8A%A8%EF%BC%8C%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8765/hi?name=forezp,注意此时service-hi工程没有启动，网页显示：</a></p>
<blockquote>
<p>sorry forezp</p>
</blockquote>
<p>打开service-hi工程，再次访问，浏览器显示：</p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>这证明断路器起到作用了。</p>
<p>五、Hystrix Dashboard (断路器：Hystrix 仪表盘)</p>
<p>基于service-ribbon 改造，Feign的改造和这一样。</p>
<p>首选在pom.xml引入spring-cloud-starter-hystrix-dashboard的起步依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在主程序启动类中加入@EnableHystrixDashboard注解，开启hystrixDashboard：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableHystrix</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">public class ServiceRibbonApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceRibbonApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@LoadBalanced</span><br><span class="line">	RestTemplate restTemplate() &#123;</span><br><span class="line">		return new RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开浏览器：访问<a target="_blank" rel="noopener" href="http://localhost:8764/hystrix,%E7%95%8C%E9%9D%A2%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8764/hystrix,界面如下：</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-64f5fa9d0d96ee21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>点击monitor stream，进入下一个界面，访问：<a target="_blank" rel="noopener" href="http://localhost:8764/hi?name=forezp">http://localhost:8764/hi?name=forezp</a></p>
<p>此时会出现监控界面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-755cd7ce5c066649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter4">https://github.com/forezp/SpringCloudLearning/tree/master/chapter4</a></p>
<h3 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_clients">circuit_breaker_hystrix</a></p>
<p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-feign-hystrix">feign-hystrix</a></p>
<p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_dashboard">hystrix_dashboard</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第5篇：Zuul</title>
    <url>/2017/06/05/springcloud-2017-06-05-sc05-zuul/</url>
    <content><![CDATA[<p>在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统。一个简答的微服务系统如下图：</p>
<span id="more"></span>

<p><img src="http://upload-images.jianshu.io/upload_images/2279594-6b7c148110ebc56e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Azure (1).png"><br><strong>注意：A服务和B服务是可以相互调用的，作图的时候忘记了。并且配置服务也是注册到服务注册中心的。</strong></p>
<p>在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理（下一篇文章讲述），配置服务的配置文件放在git仓库，方便开发人员随时改配置。</p>
<h3 id="一、Zuul简介"><a href="#一、Zuul简介" class="headerlink" title="一、Zuul简介"></a>一、Zuul简介</h3><p>Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。</p>
<p>zuul有以下功能：</p>
<ul>
<li>Authentication</li>
<li>Insights</li>
<li>Stress Testing</li>
<li>Canary Testing</li>
<li>Dynamic Routing</li>
<li>Service Migration</li>
<li>Load Shedding</li>
<li>Security</li>
<li>Static Response handling</li>
<li>Active/Active traffic management</li>
</ul>
<h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><p>继续使用上一节的工程。在原有的工程上，创建一个新的工程。</p>
<h3 id="三、创建service-zuul工程"><a href="#三、创建service-zuul工程" class="headerlink" title="三、创建service-zuul工程"></a>三、创建service-zuul工程</h3><p>其pom.xml文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;service-zuul&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;service-zuul&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-zuul&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其入口applicaton类加上注解@EnableZuulProxy，开启zuul的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableZuulProxy</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ServiceZuulApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceZuulApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加上配置文件application.yml加上以下的配置代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">  port: 8769</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-zuul</span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    api-a:</span><br><span class="line">      path: &#x2F;api-a&#x2F;**</span><br><span class="line">      serviceId: service-ribbon</span><br><span class="line">    api-b:</span><br><span class="line">      path: &#x2F;api-b&#x2F;**</span><br><span class="line">      serviceId: service-feign</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先指定服务注册中心的地址为<a target="_blank" rel="noopener" href="http://localhost:8761/eureka/%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%B8%BA8769%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%90%8D%E4%B8%BAservice-zuul%EF%BC%9B%E4%BB%A5/api-a/">http://localhost:8761/eureka/，服务的端口为8769，服务名为service-zuul；以/api-a/</a> 开头的请求都转发给service-ribbon服务；以/api-b/开头的请求都转发给service-feign服务；</p>
<p>依次运行这五个工程;打开浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8769/api-a/hi?name=forezp">http://localhost:8769/api-a/hi?name=forezp</a> ;浏览器显示：</p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>打开浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8769/api-b/hi?name=forezp">http://localhost:8769/api-b/hi?name=forezp</a> ;浏览器显示：</p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>这说明zuul起到了路由的作用</p>
<h3 id="四、服务过滤"><a href="#四、服务过滤" class="headerlink" title="四、服务过滤"></a>四、服务过滤</h3><p>zuul不仅只是路由，并且还能过滤，做一些安全验证。继续改造工程；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyFilter extends ZuulFilter&#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(MyFilter.class);</span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return &quot;pre&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() &#123;</span><br><span class="line">        RequestContext ctx &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request &#x3D; ctx.getRequest();</span><br><span class="line">        log.info(String.format(&quot;%s &gt;&gt;&gt; %s&quot;, request.getMethod(), request.getRequestURL().toString()));</span><br><span class="line">        Object accessToken &#x3D; request.getParameter(&quot;token&quot;);</span><br><span class="line">        if(accessToken &#x3D;&#x3D; null) &#123;</span><br><span class="line">            log.warn(&quot;token is empty&quot;);</span><br><span class="line">            ctx.setSendZuulResponse(false);</span><br><span class="line">            ctx.setResponseStatusCode(401);</span><br><span class="line">            try &#123;</span><br><span class="line">                ctx.getResponse().getWriter().write(&quot;token is empty&quot;);</span><br><span class="line">            &#125;catch (Exception e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;ok&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：<ul>
<li>pre：路由之前</li>
<li>routing：路由之时</li>
<li>post： 路由之后</li>
<li>error：发送错误调用</li>
</ul>
</li>
<li>filterOrder：过滤的顺序</li>
<li>shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。</li>
<li>run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</li>
</ul>
<p>这时访问：<a target="_blank" rel="noopener" href="http://localhost:8769/api-a/hi?name=forezp">http://localhost:8769/api-a/hi?name=forezp</a> ；网页显示：</p>
<blockquote>
<p>token is empty</p>
</blockquote>
<p>访问 <a target="_blank" rel="noopener" href="http://localhost:8769/api-a/hi?name=forezp&amp;token=22">http://localhost:8769/api-a/hi?name=forezp&amp;token=22</a> ；<br>网页显示：</p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter5">https://github.com/forezp/SpringCloudLearning/tree/master/chapter5</a></p>
<h3 id="五、参考资料："><a href="#五、参考资料：" class="headerlink" title="五、参考资料："></a>五、参考资料：</h3><p> <a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_router_and_filter_zuul">router_and_filter_zuul</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第6篇：config</title>
    <url>/2017/06/06/springcloud-2017-06-06-sc06-config/</url>
    <content><![CDATA[<p>在上一篇文章讲述zuul的时候，已经提到过，使用配置服务来保存各个服务的配置文件。它就是Spring Cloud Config。</p>
<span id="more"></span>

<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p>
<h3 id="二、构建Config-Server"><a href="#二、构建Config-Server" class="headerlink" title="二、构建Config Server"></a>二、构建Config Server</h3><p>创建一个spring-boot项目，取名为config-server,其pom.xml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;config-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;config-server&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-config-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Camden.SR6&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在程序的入口Application类加上@EnableConfigServer注解开启配置服务器的功能，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableConfigServer</span><br><span class="line">public class ConfigServerApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要在程序的配置文件application.properties文件配置以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name&#x3D;config-server</span><br><span class="line">server.port&#x3D;8888</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring.cloud.config.server.git.uri&#x3D;https:&#x2F;&#x2F;github.com&#x2F;forezp&#x2F;SpringcloudConfig&#x2F;</span><br><span class="line">spring.cloud.config.server.git.searchPaths&#x3D;respo</span><br><span class="line">spring.cloud.config.label&#x3D;master</span><br><span class="line">spring.cloud.config.server.git.username&#x3D;your username</span><br><span class="line">spring.cloud.config.server.git.password&#x3D;your password</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>spring.cloud.config.server.git.uri：配置git仓库地址</li>
<li>spring.cloud.config.server.git.searchPaths：配置仓库路径</li>
<li>spring.cloud.config.label：配置仓库的分支</li>
<li>spring.cloud.config.server.git.username：访问git仓库的用户名</li>
<li>spring.cloud.config.server.git.password：访问git仓库的用户密码</li>
</ul>
<p>如果Git仓库为公开仓库，可以不填写用户名和密码，如果是私有仓库需要填写，本例子是公开仓库，放心使用。</p>
<p>远程仓库<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringcloudConfig/">https://github.com/forezp/SpringcloudConfig/</a> 中有个文件config-client-dev.properties文件中有一个属性：</p>
<blockquote>
<p>foo = foo version 3</p>
</blockquote>
<p>启动程序：访问<a target="_blank" rel="noopener" href="http://localhost:8888/foo/dev">http://localhost:8888/foo/dev</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;foo&quot;,&quot;profiles&quot;:[&quot;dev&quot;],&quot;label&quot;:&quot;master&quot;,</span><br><span class="line">&quot;version&quot;:&quot;792ffc77c03f4b138d28e89b576900ac5e01a44b&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>证明配置服务中心可以从远程程序获取配置信息。</p>
<p>http请求地址和资源文件映射如下:</p>
<ul>
<li>/{application}/{profile}[/{label}]</li>
<li>/{application}-{profile}.yml</li>
<li>/{label}/{application}-{profile}.yml</li>
<li>/{application}-{profile}.properties</li>
<li>/{label}/{application}-{profile}.properties</li>
</ul>
<h3 id="三、构建一个config-client"><a href="#三、构建一个config-client" class="headerlink" title="三、构建一个config client"></a>三、构建一个config client</h3><p>重新创建一个springboot项目，取名为config-client,其pom文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;config-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;config-client&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name&#x3D;config-client</span><br><span class="line">spring.cloud.config.label&#x3D;master</span><br><span class="line">spring.cloud.config.profile&#x3D;dev</span><br><span class="line">spring.cloud.config.uri&#x3D; http:&#x2F;&#x2F;localhost:8888&#x2F;</span><br><span class="line">server.port&#x3D;8881</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>spring.cloud.config.label 指明远程仓库的分支</li>
<li>spring.cloud.config.profile <ul>
<li>dev开发环境配置文件</li>
<li>test测试环境</li>
<li>pro正式环境</li>
</ul>
</li>
<li>spring.cloud.config.uri= <a target="_blank" rel="noopener" href="http://localhost:8888/">http://localhost:8888/</a> 指明配置服务中心的网址。</li>
</ul>
<p>程序的入口类，写一个API接口“／hi”，返回从配置中心读取的foo变量的值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line">public class ConfigClientApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ConfigClientApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;$&#123;foo&#125;&quot;)</span><br><span class="line">	String foo;</span><br><span class="line">	@RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;)</span><br><span class="line">	public String hi()&#123;</span><br><span class="line">		return foo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开网址访问：<a target="_blank" rel="noopener" href="http://localhost:8881/hi%EF%BC%8C%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8881/hi，网页显示：</a></p>
<blockquote>
<p>foo version 3</p>
</blockquote>
<p>这就说明，config-client从config-server获取了foo的属性，而config-server是从git仓库读取的,如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-40ecbed6d38573d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Azure (2).png"></p>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter6">https://github.com/forezp/SpringCloudLearning/tree/master/chapter6</a></p>
<h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_spring_cloud_config">spring_cloud_config</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud config</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第7篇：高可用的分布式配置中心</title>
    <url>/2017/06/07/springcloud-2017-06-07-sc07-config/</url>
    <content><![CDATA[<p>上一篇文章讲述了一个服务如何从配置中心读取文件，配置中心如何从远程git读取配置文件，当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用，架构图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-babe706075d72c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Azure (3).png"></p>
<span id="more"></span>

<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><p>继续使用上一篇文章的工程，创建一个eureka-server工程，用作服务注册中心。</p>
<p>在其pom.xml文件引入Eureka的起步依赖spring-cloud-starter-eureka-server，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;eureka-server&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在配置文件application.yml上，指定服务端口为8889，加上作为服务注册中心的基本配置，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8889</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    fetchRegistry: false</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<p>入口类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableEurekaServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class EurekaServerApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、改造config-server"><a href="#二、改造config-server" class="headerlink" title="二、改造config-server"></a>二、改造config-server</h3><p>在其pom.xml文件加上EurekaClient的起步依赖spring-cloud-starter-eureka，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-config-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置文件application.yml，指定服务注册地址为<a target="_blank" rel="noopener" href="http://localhost:8889/eureka/%EF%BC%8C%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E5%90%8C%E4%B8%8A%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E5%AE%8C%E6%95%B4%E7%9A%84%E9%85%8D%E7%BD%AE%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8889/eureka/，其他配置同上一篇文章，完整的配置如下：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name&#x3D;config-server</span><br><span class="line">server.port&#x3D;8888</span><br><span class="line"></span><br><span class="line">spring.cloud.config.server.git.uri&#x3D;https:&#x2F;&#x2F;github.com&#x2F;forezp&#x2F;SpringcloudConfig&#x2F;</span><br><span class="line">spring.cloud.config.server.git.searchPaths&#x3D;respo</span><br><span class="line">spring.cloud.config.label&#x3D;master</span><br><span class="line">spring.cloud.config.server.git.username&#x3D; your username</span><br><span class="line">spring.cloud.config.server.git.password&#x3D; your password</span><br><span class="line">eureka.client.serviceUrl.defaultZone&#x3D;http:&#x2F;&#x2F;localhost:8889&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>
<p>最后需要在程序的启动类Application加上@EnableEureka的注解。</p>
<h3 id="三、改造config-client"><a href="#三、改造config-client" class="headerlink" title="三、改造config-client"></a>三、改造config-client</h3><p>将其注册微到服务注册中心，作为Eureka客户端，需要pom文件加上起步依赖spring-cloud-starter-eureka，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件bootstrap.properties，注意是bootstrap。加上服务注册地址为<a target="_blank" rel="noopener" href="http://localhost:8889/eureka/">http://localhost:8889/eureka/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name&#x3D;config-client</span><br><span class="line">spring.cloud.config.label&#x3D;master</span><br><span class="line">spring.cloud.config.profile&#x3D;dev</span><br><span class="line">#spring.cloud.config.uri&#x3D; http:&#x2F;&#x2F;localhost:8888&#x2F;</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone&#x3D;http:&#x2F;&#x2F;localhost:8889&#x2F;eureka&#x2F;</span><br><span class="line">spring.cloud.config.discovery.enabled&#x3D;true</span><br><span class="line">spring.cloud.config.discovery.serviceId&#x3D;config-server</span><br><span class="line">server.port&#x3D;8881</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>spring.cloud.config.discovery.enabled 是从配置中心读取文件。</li>
<li>spring.cloud.config.discovery.serviceId 配置中心的servieId，即服务名。</li>
</ul>
<p>这时发现，在读取配置文件不再写ip地址，而是服务名，这时如果配置服务部署多份，通过负载均衡，从而高可用。</p>
<p>依次启动eureka-servr,config-server,config-client<br>访问网址：<a target="_blank" rel="noopener" href="http://localhost:8889/">http://localhost:8889/</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-1639fdb713faa405.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>访问<a target="_blank" rel="noopener" href="http://localhost:8881/hi%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8881/hi，浏览器显示：</a></p>
<blockquote>
<p>foo version 3</p>
</blockquote>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter7">https://github.com/forezp/SpringCloudLearning/tree/master/chapter7</a></p>
<h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_spring_cloud_config">spring_cloud_config</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud config</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第8篇：Spring Cloud Bus</title>
    <url>/2017/06/08/springcloud-2017-06-08-sc08-bus/</url>
    <content><![CDATA[<p>Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。本文要讲述的是用Spring Cloud Bus实现通知微服务架构的配置文件的更改。</p>
<span id="more"></span>

<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><p>本文还是基于上一篇文章来实现。按照官方文档，我们只需要在配置文件中配置 spring-cloud-starter-bus-amqp ；这就是说我们需要装rabbitMq，点击<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/">rabbitmq</a>下载。至于怎么使用 rabbitmq，搜索引擎下。</p>
<h3 id="二、改造config-client"><a href="#二、改造config-client" class="headerlink" title="二、改造config-client"></a>二、改造config-client</h3><p>在pom文件加上起步依赖spring-cloud-starter-bus-amqp，完整的配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;config-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;config-client&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.retry&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-retry&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在配置文件application.properties中加上RabbitMq的配置，包括RabbitMq的地址、端口，用户名、密码，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">spring.rabbitmq.host&#x3D;localhost</span><br><span class="line">spring.rabbitmq.port&#x3D;5672</span><br><span class="line"># spring.rabbitmq.username&#x3D;</span><br><span class="line"># spring.rabbitmq.password&#x3D;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果rabbitmq有用户名密码，输入即可。</p>
<p>依次启动eureka-server、confg-cserver,启动两个config-client，端口为：8881、8882。</p>
<p>访问<a target="_blank" rel="noopener" href="http://localhost:8881/hi">http://localhost:8881/hi</a>  或者<a target="_blank" rel="noopener" href="http://localhost:8882/hi">http://localhost:8882/hi</a> 浏览器显示：</p>
<blockquote>
<p>foo version 3</p>
</blockquote>
<p>这时我们去<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringcloudConfig/blob/master/respo/config-client-dev.properties">代码仓库</a>将foo的值改为“foo version 4”，即改变配置文件foo的值。如果是传统的做法，需要重启服务，才能达到配置文件的更新。此时，我们只需要发送post请求：<a target="_blank" rel="noopener" href="http://localhost:8881/bus/refresh%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0config-client%E4%BC%9A%E9%87%8D%E7%8E%B0%E8%82%9A%E8%84%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">http://localhost:8881/bus/refresh，你会发现config-client会重现肚脐配置文件</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-c1fe748f1d25af70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>重新读取配置文件：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-57874b46c40c9916.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>这时我们再访问<a target="_blank" rel="noopener" href="http://localhost:8881/hi">http://localhost:8881/hi</a>  或者<a target="_blank" rel="noopener" href="http://localhost:8882/hi">http://localhost:8882/hi</a> 浏览器显示：</p>
<blockquote>
<p>foo version 4</p>
</blockquote>
<p>另外，/bus/refresh接口可以指定服务，即使用”destination”参数，比如 “/bus/refresh?destination=customers:**” 即刷新服务名为customers的所有服务，不管ip。</p>
<h3 id="三、分析"><a href="#三、分析" class="headerlink" title="三、分析"></a>三、分析</h3><p>此时的架构图：<br><img src="http://upload-images.jianshu.io/upload_images/2279594-9a119d83cf90069f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>当git文件更改的时候，通过pc端用post 向端口为8882的config-client发送请求/bus/refresh／；此时8882端口会发送一个消息，由消息总线向其他服务传递，从而使整个微服务集群都达到更新配置文件。</p>
<h3 id="四、其他扩展（可忽视）"><a href="#四、其他扩展（可忽视）" class="headerlink" title="四、其他扩展（可忽视）"></a>四、其他扩展（可忽视）</h3><p>可以用作自定义的Message Broker,只需要spring-cloud-starter-bus-amqp, 然后再配置文件写上配置即可，同上。</p>
<p>Tracing Bus Events：<br>需要设置：spring.cloud.bus.trace.enabled=true，如果那样做的话，那么Spring Boot TraceRepository（如果存在）将显示每个服务实例发送的所有事件和所有的ack,比如：（来自官网）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2015-11-26T10:24:44.411+0000&quot;,</span><br><span class="line">  &quot;info&quot;: &#123;</span><br><span class="line">    &quot;signal&quot;: &quot;spring.cloud.bus.ack&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;RefreshRemoteApplicationEvent&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;c4d374b7-58ea-4928-a312-31984def293b&quot;,</span><br><span class="line">    &quot;origin&quot;: &quot;stores:8081&quot;,</span><br><span class="line">    &quot;destination&quot;: &quot;*:**&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2015-11-26T10:24:41.864+0000&quot;,</span><br><span class="line">  &quot;info&quot;: &#123;</span><br><span class="line">    &quot;signal&quot;: &quot;spring.cloud.bus.sent&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;RefreshRemoteApplicationEvent&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;c4d374b7-58ea-4928-a312-31984def293b&quot;,</span><br><span class="line">    &quot;origin&quot;: &quot;customers:9000&quot;,</span><br><span class="line">    &quot;destination&quot;: &quot;*:**&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2015-11-26T10:24:41.862+0000&quot;,</span><br><span class="line">  &quot;info&quot;: &#123;</span><br><span class="line">    &quot;signal&quot;: &quot;spring.cloud.bus.ack&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;RefreshRemoteApplicationEvent&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;c4d374b7-58ea-4928-a312-31984def293b&quot;,</span><br><span class="line">    &quot;origin&quot;: &quot;customers:9000&quot;,</span><br><span class="line">    &quot;destination&quot;: &quot;*:**&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter8">https://github.com/forezp/SpringCloudLearning/tree/master/chapter8</a></p>
<h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_spring_cloud_bus">spring_cloud_bus</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud SpringCloudBus</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第9篇：Sleuth</title>
    <url>/2017/06/08/springcloud-2017-06-09-sc09-sleuth/</url>
    <content><![CDATA[<p>这篇文章主要讲述服务追踪组件zipkin，Spring Cloud Sleuth集成了zipkin组件。</p>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><blockquote>
<p>Add sleuth to the classpath of a Spring Boot application (see below for Maven and Gradle examples), and you will see the correlation data being collected in logs, as long as you are logging requests.</p>
<p>——  <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-sleuth">摘自官网</a></p>
</blockquote>
<p>Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。</p>
<span id="more"></span>

<h3 id="二、服务追踪分析"><a href="#二、服务追踪分析" class="headerlink" title="二、服务追踪分析"></a>二、服务追踪分析</h3><p>微服务架构上通过业务来划分服务的，通过REST调用，对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-dd72907e82f89fd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-4b7d1b6abe595390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<h3 id="三、术语"><a href="#三、术语" class="headerlink" title="三、术语"></a>三、术语</h3><ul>
<li>Span：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址)<br>span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。</li>
<li>Trace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。</li>
<li>Annotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束<ul>
<li>cs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始</li>
<li>sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟</li>
<li>ss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间</li>
<li>cr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间<br>将Span和Trace在一个系统中使用Zipkin注解的过程图形化：</li>
</ul>
</li>
</ul>
<p>将Span和Trace在一个系统中使用Zipkin注解的过程图形化：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-4b865f2a2c271def.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="Paste_Image.png"></p>
<h3 id="四、构建工程"><a href="#四、构建工程" class="headerlink" title="四、构建工程"></a>四、构建工程</h3><p>基本知识讲解完毕，下面我们来实战，本文的案例主要有三个工程组成:一个server-zipkin,它的主要作用使用ZipkinServer 的功能，收集调用数据，并展示；一个service-hi,对外暴露hi接口；一个service-miya,对外暴露miya接口；这两个service可以相互调用；并且只有调用了，server-zipkin才会收集数据的，这就是为什么叫服务追踪了。</p>
<h4 id="4-1-构建server-zipkin"><a href="#4-1-构建server-zipkin" class="headerlink" title="4.1 构建server-zipkin"></a>4.1 构建server-zipkin</h4><p>建一个spring-boot工程取名为server-zipkin，在其pom引入依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;io.zipkin.java&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;zipkin-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;io.zipkin.java&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;zipkin-autoconfigure-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Camden.SR6&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>在其程序入口类, 加上注解@EnableZipkinServer，开启ZipkinServer的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableZipkinServer</span><br><span class="line">public class ServerZipkinApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServerZipkinApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在配置文件application.yml指定服务端口为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port&#x3D;9411</span><br></pre></td></tr></table></figure>
<h4 id="4-2-创建service-hi"><a href="#4-2-创建service-hi" class="headerlink" title="4.2 创建service-hi"></a>4.2 创建service-hi</h4><p> 在其pom引入起步依赖spring-cloud-starter-zipkin，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;!--compile(&#39;org.springframework.cloud:spring-cloud-starter-zipkin&#39;)--&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-zipkin&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其配置文件application.yml指定zipkin server的地址，头通过配置“spring.zipkin.base-url”指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server.port&#x3D;8988</span><br><span class="line">spring.zipkin.base-url&#x3D;http:&#x2F;&#x2F;localhost:9411</span><br><span class="line">spring.application.name&#x3D;service-hi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过引入spring-cloud-starter-zipkin依赖和设置spring.zipkin.base-url就可以了。</p>
<p>对外暴露接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line">public class ServiceHiApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceHiApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static final Logger LOG &#x3D; Logger.getLogger(ServiceHiApplication.class.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public RestTemplate getRestTemplate()&#123;</span><br><span class="line">		return new RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;&#x2F;hi&quot;)</span><br><span class="line">	public String callHome()&#123;</span><br><span class="line">		LOG.log(Level.INFO, &quot;calling trace service-hi  &quot;);</span><br><span class="line">		return restTemplate.getForObject(&quot;http:&#x2F;&#x2F;localhost:8989&#x2F;miya&quot;, String.class);</span><br><span class="line">	&#125;</span><br><span class="line">	@RequestMapping(&quot;&#x2F;info&quot;)</span><br><span class="line">	public String info()&#123;</span><br><span class="line">		LOG.log(Level.INFO, &quot;calling trace service-hi &quot;);</span><br><span class="line"></span><br><span class="line">		return &quot;i&#39;m service-hi&quot;;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public AlwaysSampler defaultSampler()&#123;</span><br><span class="line">		return new AlwaysSampler();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-3-创建service-miya"><a href="#4-3-创建service-miya" class="headerlink" title="4.3 创建service-miya"></a>4.3 创建service-miya</h4><p>创建过程痛service-hi，引入相同的依赖，配置下spring.zipkin.base-url。</p>
<p>对外暴露接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line">public class ServiceMiyaApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceMiyaApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static final Logger LOG &#x3D; Logger.getLogger(ServiceMiyaApplication.class.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;&#x2F;hi&quot;)</span><br><span class="line">	public String home()&#123;</span><br><span class="line">		LOG.log(Level.INFO, &quot;hi is being called&quot;);</span><br><span class="line">		return &quot;hi i&#39;m miya!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;&#x2F;miya&quot;)</span><br><span class="line">	public String info()&#123;</span><br><span class="line">		LOG.log(Level.INFO, &quot;info is being called&quot;);</span><br><span class="line">		return restTemplate.getForObject(&quot;http:&#x2F;&#x2F;localhost:8988&#x2F;info&quot;,String.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public RestTemplate getRestTemplate()&#123;</span><br><span class="line">		return new RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-4-启动工程，演示追踪"><a href="#4-4-启动工程，演示追踪" class="headerlink" title="4.4 启动工程，演示追踪"></a>4.4 启动工程，演示追踪</h4><p>依次启动上面的三个工程，打开浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:9411/%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%A5%E4%B8%8B%E7%95%8C%E9%9D%A2%EF%BC%9A">http://localhost:9411/，会出现以下界面：</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-d5461a49188ec624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>访问：<a target="_blank" rel="noopener" href="http://localhost:8989/miya%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%87%BA%E7%8E%B0%EF%BC%9A">http://localhost:8989/miya，浏览器出现：</a></p>
<blockquote>
<p>i’m service-hi</p>
</blockquote>
<p>再打开<a target="_blank" rel="noopener" href="http://localhost:9411/%E7%9A%84%E7%95%8C%E9%9D%A2%EF%BC%8C%E7%82%B9%E5%87%BBDependencies,%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%EF%BC%9A">http://localhost:9411/的界面，点击Dependencies,可以发现服务的依赖关系：</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-48cfbe426b23b7a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>点击find traces,可以看到具体服务相互调用的数据：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-3fe448b513ad867b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter9">https://github.com/forezp/SpringCloudLearning/tree/master/chapter9</a></p>
<h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-sleuth">spring-cloud-sleuth</a></p>
<p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/60165">利用Zipkin对Spring Cloud应用进行服务追踪分析</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/u010257992/article/details/52474639"> Spring Cloud Sleuth使用简介</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud sleuth</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第10篇：高可用的服务注册中心</title>
    <url>/2017/06/01/springcloud-2017-06-10-sc-ha-eureka/</url>
    <content><![CDATA[<p>文章 <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a> 介绍了服务注册与发现，其中服务注册中心Eureka Server，是一个实例，当成千上万个服务向它注册的时候，它的负载是非常高的，这在生产环境上是不太合适的，这篇文章主要介绍怎么将Eureka Server集群化。</p>
<span id="more"></span>

<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><blockquote>
<p>Eureka can be made even more resilient and available by running multiple instances and asking them to register with each other. In fact, this is the default behaviour, so all you need to do to make it work is add a valid serviceUrl to a peer, e.g.</p>
<p> 摘自官网</p>
</blockquote>
<p>Eureka通过运行多个实例，使其更具有高可用性。事实上，这是它默认的熟性，你需要做的就是给对等的实例一个合法的关联serviceurl。</p>
<p>这篇文章我们基于<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter1">第一篇文章的工程</a>，来做修改。</p>
<h3 id="二、改造工作"><a href="#二、改造工作" class="headerlink" title="二、改造工作"></a>二、改造工作</h3><p>在eureka-server工程中resources文件夹下，创建配置文件application-peer1.yml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: peer1</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer1</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;peer2:8769&#x2F;eureka&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>并且创建另外一个配置文件application-peer2.yml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8769</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: peer2</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer2</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;peer1:8761&#x2F;eureka&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时eureka-server就已经改造完毕。</p>
<blockquote>
<p>ou could use this configuration to test the peer awareness on a single host (there’s not much value in doing that in production) by manipulating /etc/hosts to resolve the host names.</p>
</blockquote>
<p>按照官方文档的指示，需要改变etc/hosts，linux系统通过vim /etc/hosts ,加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1 peer1</span><br><span class="line">127.0.0.1 peer2</span><br></pre></td></tr></table></figure>
<p> windows电脑，在c:/windows/systems/drivers/etc/hosts 修改。</p>
<p>这时需要改造下service-hi:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;peer1:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">  port: 8762</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-hi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三、启动工程"><a href="#三、启动工程" class="headerlink" title="三、启动工程"></a>三、启动工程</h3><p>启动eureka-server：</p>
<blockquote>
<p>java -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=peer1</p>
</blockquote>
<p>java -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=peer2</p>
<blockquote>
</blockquote>
<p>启动service-hi:</p>
<blockquote>
<p>java -jar service-hi-0.0.1-SNAPSHOT.jar</p>
</blockquote>
<p>访问：localhost:8761,如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-659c68e405bd70bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="Paste_Image.png"></p>
<p>你会发现注册了service-hi，并且有个peer2节点，同理访问localhost:8769你会发现有个peer1节点。</p>
<p>client只向8761注册，但是你打开8769，你也会发现，8769也有 client的注册信息。</p>
<p>个人感受：这是通过看官方文档的写的demo ，但是需要手动改host是不是不符合Spring Cloud 的高上大？</p>
<blockquote>
<h3 id="Prefer-IP-Address"><a href="#Prefer-IP-Address" class="headerlink" title="Prefer IP Address"></a>Prefer IP Address</h3><p>In some cases, it is preferable for Eureka to advertise the IP Adresses of services rather than the hostname. Set eureka.instance.preferIpAddress to true and when the application registers with eureka, it will use its IP Address rather than its hostname.</p>
<p>摘自官网</p>
</blockquote>
<p>eureka.instance.preferIpAddress=true是通过设置ip让eureka让其他服务注册它。也许能通过去改变去通过改变host的方式。</p>
<p>此时的架构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-a052854a3084fdd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="有点丑e.png"></p>
<p>Eureka-eserver peer1 8761,Eureka-eserver peer2 8769相互感应，当有服务注册时，两个Eureka-eserver是对等的，它们都存有相同的信息，这就是通过服务器的冗余来增加可靠性，当有一台服务器宕机了，服务并不会终止，因为另一台服务存有相同的数据。</p>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter10">https://github.com/forezp/SpringCloudLearning/tree/master/chapter10</a></p>
<h3 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_high_availability_zones_and_regions">high_availability_zones</a></p>
<h3 id="相关文章推荐："><a href="#相关文章推荐：" class="headerlink" title="相关文章推荐："></a>相关文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第11篇：docker部署springcloud工程</title>
    <url>/2017/06/11/springcloud-2017-06-11-sc11-docker/</url>
    <content><![CDATA[<h2 id="一、docker简介"><a href="#一、docker简介" class="headerlink" title="一、docker简介"></a>一、docker简介</h2><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 </p>
<span id="more"></span>

<p>Docker通常用于如下场景：</p>
<ul>
<li>web应用的自动化打包和发布；</li>
<li>自动化测试和持续集成、发布；</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用；</li>
<li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li>
</ul>
<p>Docker 的优点</p>
<ul>
<li><p>1、简化程序：<br>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的    任务，在Docker容器的处理下，只需要数秒就能完成。</p>
</li>
<li><p>2、避免选择恐惧症：<br>如果你有选择恐惧症，还是资深患者。Docker 帮你    打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</p>
</li>
<li><p>3、节省开支：<br>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p>
</li>
</ul>
<p>上面文字参考了相关文章；另，关于docker 的安装和基本的使用见<a target="_blank" rel="noopener" href="http://www.runoob.com/docker/docker-tutorial.html">相关教程</a>。</p>
<h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><p>环境条件：</p>
<ul>
<li>linux系统，不建议windows</li>
<li>docker最新版本</li>
<li>jdk 1.8</li>
<li>maven3.0</li>
</ul>
<p>本文采用的工程来自第一篇文章的工程，采用maven的方式去构建项目，并采用docker-maven-plugin去构建docker镜像。</p>
<h2 id="三、改造工程、构建镜像"><a href="#三、改造工程、构建镜像" class="headerlink" title="三、改造工程、构建镜像"></a>三、改造工程、构建镜像</h2><h5 id="改造eureka-server工程"><a href="#改造eureka-server工程" class="headerlink" title="改造eureka-server工程"></a>改造eureka-server工程</h5><p>在pom文件加上插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">			&lt;!-- tag::plugin[] --&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;docker-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;0.4.3&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;configuration&gt;</span><br><span class="line">					&lt;imageName&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;imageName&gt;</span><br><span class="line">					&lt;dockerDirectory&gt;src&#x2F;main&#x2F;docker&lt;&#x2F;dockerDirectory&gt;</span><br><span class="line">					&lt;resources&gt;</span><br><span class="line">						&lt;resource&gt;</span><br><span class="line">							&lt;targetPath&gt;&#x2F;&lt;&#x2F;targetPath&gt;</span><br><span class="line">							&lt;directory&gt;$&#123;project.build.directory&#125;&lt;&#x2F;directory&gt;</span><br><span class="line">							&lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;include&gt;</span><br><span class="line">						&lt;&#x2F;resource&gt;</span><br><span class="line">					&lt;&#x2F;resources&gt;</span><br><span class="line">				&lt;&#x2F;configuration&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">			&lt;!-- end::plugin[] --&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。</p>
<ul>
<li>imageName指定了镜像的名字，本例为 forep/eureka-server</li>
<li>dockerDirectory指定 Dockerfile 的位置</li>
<li>resources是指那些需要和 Dockerfile 放在一起，在构建镜像时使用的文件，一般应用 jar 包需要纳入。</li>
</ul>
<p>修改下配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    fetchRegistry: false</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="编写dockerfile文件："><a href="#编写dockerfile文件：" class="headerlink" title="编写dockerfile文件："></a>编写dockerfile文件：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM frolvlad&#x2F;alpine-oraclejdk8:slim</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD eureka-server-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">#RUN bash -c &#39;touch &#x2F;app.jar&#39;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br><span class="line">EXPOSE 8761</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="docker-file编写指令："><a href="#docker-file编写指令：" class="headerlink" title="docker file编写指令："></a>docker file编写指令：</h4><ul>
<li>FROM</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">FROM &lt;image&gt; &lt;digest&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>FROM指令必须指定且需要在Dockerfile其他指令的前面，指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。后续的指令都依赖于该指令指定的image。当在同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令。</p>
<ul>
<li>VOLUME</li>
</ul>
<p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;&#x2F;data&quot;]</span><br></pre></td></tr></table></figure>
<p>使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用，也可以共享给其他容器。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。</p>
<ul>
<li>ADD</li>
</ul>
<p>从src目录复制文件到容器的dest。其中src可以是Dockerfile所在目录的相对路径，也可以是一个URL，还可以是一个压缩包</p>
<ul>
<li>ENTRYPOINT</li>
</ul>
<p>指定Docker容器启动时执行的命令，可以多次设置，但是只有最后一个有效。</p>
<ul>
<li>EXPOSE</li>
</ul>
<p>为Docker容器设置对外的端口号。在启动时，可以使用-p选项或者-P选项。</p>
<h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>执行构建docker镜像maven命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn package docker:build</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="http://upload-images.jianshu.io/upload_images/2279594-7b307969f9b753f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>构建eureka-server镜像成功。</p>
<h4 id="同理构建service-hi镜像"><a href="#同理构建service-hi镜像" class="headerlink" title="同理构建service-hi镜像"></a>同理构建service-hi镜像</h4><ul>
<li>pom文件导入同eurek-server</li>
<li>修改下配置文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka-server:8761&#x2F;eureka&#x2F; # 这个需要改为eureka-server</span><br><span class="line">server:</span><br><span class="line">  port: 8763</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-hi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里说下：defaultZone发现服务的host改为镜像名。</p>
<ul>
<li><p>dockefile 编写同eureka-server</p>
</li>
<li><p>构建镜像：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn package docker:build</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/2279594-6e3a82c7216fbc7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>这时我们运行docke的eureka-server 和service-hi镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 8761: 8761 -t forezp&#x2F;eureka-server</span><br><span class="line">docker run -p 8763: 8763 -t forezp&#x2F;service-hi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问localhost:8761</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-9199ffddc0bde596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h2 id="四、采用docker-compose启动镜像"><a href="#四、采用docker-compose启动镜像" class="headerlink" title="四、采用docker-compose启动镜像"></a>四、采用docker-compose启动镜像</h2><p>Compose 是一个用于定义和运行多容器的Docker应用的工具。使用Compose，你可以在一个配置文件（yaml格式）中配置你应用的服务，然后使用一个命令，即可创建并启动配置中引用的所有服务。下面我们进入Compose的实战吧。</p>
<p>采用docker-compose的方式编排镜像，启动镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  eureka-server:</span><br><span class="line">    image: forezp&#x2F;eureka-server</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 8761:8761</span><br><span class="line"></span><br><span class="line">  service-hi:</span><br><span class="line">    image: forezp&#x2F;service-hi</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 8763:8763</span><br></pre></td></tr></table></figure>


<p>输入命令： docker-compose up</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-a500c3ed7a4513ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>发现2个镜像按照指定的顺序启动了。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter11">https://github.com/forezp/SpringCloudLearning/tree/master/chapter11</a></p>
<h2 id="五、采用docker-compose编排并启动镜像"><a href="#五、采用docker-compose编排并启动镜像" class="headerlink" title="五、采用docker-compose编排并启动镜像"></a>五、采用docker-compose编排并启动镜像</h2><p>docker-compose也可以构建镜像，现在我们采用docker-compose的方式构建镜像。</p>
<p>现在以eureka-server为例：<br>将Dockerfile移到eureka-server的主目录，改写ADD的相对路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FROM frolvlad&#x2F;alpine-oraclejdk8:slim</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD .&#x2F;target&#x2F;eureka-server-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">#RUN bash -c &#39;touch &#x2F;app.jar&#39;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br><span class="line">EXPOSE 8761</span><br></pre></td></tr></table></figure>
<p>同理修改service-hi目录；</p>
<p>编写构建镜像docker-compose-dev文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  eureka-server:</span><br><span class="line">    build: eureka-server</span><br><span class="line">    ports:</span><br><span class="line">      - 8761:8761</span><br><span class="line"></span><br><span class="line">  service-hi:</span><br><span class="line">    build: service-hi</span><br><span class="line">    ports:</span><br><span class="line">      - 8763:8763</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令构建镜像并启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose.yml -f docker-compose-dev.yml up </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/2279594-994f016ca3bd2bcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter11-2">https://github.com/forezp/SpringCloudLearning/tree/master/chapter11-2</a></p>
<h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p><a target="_blank" rel="noopener" href="http://www.runoob.com/docker/docker-tutorial.html">docker教程</a></p>
<p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/47344">用 Docker 构建、运行、发布一个 Spring Boot 应用</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/docker/compose">docker-compose</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud docker</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第12篇：Hystrix Dashboard</title>
    <url>/2017/06/12/springcloud-2017-06-12-sc12-hystix-dashboard/</url>
    <content><![CDATA[<p>在我的第四篇文章<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69934399">断路器</a>讲述了如何使用断路器，并简单的介绍了下Hystrix Dashboard组件，这篇文章更加详细的介绍Hystrix Dashboard。</p>
<span id="more"></span>

<h2 id="一、Hystrix-Dashboard简介"><a href="#一、Hystrix-Dashboard简介" class="headerlink" title="一、Hystrix Dashboard简介"></a>一、Hystrix Dashboard简介</h2><p>在微服务架构中为例保证程序的可用性，防止程序出错导致网络阻塞，出现了断路器模型。断路器的状况反应了一个程序的可用性和健壮性，它是一个重要指标。Hystrix Dashboard是作为断路器状态的一个组件，提供了数据监控和友好的图形化界面。</p>
<h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><p>本文的的工程栗子，来源于<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">第一篇文章</a>的栗子，在它的基础上进行改造。</p>
<h2 id="三、开始改造service-hi"><a href="#三、开始改造service-hi" class="headerlink" title="三、开始改造service-hi"></a>三、开始改造service-hi</h2><p>在pom的工程文件引入相应的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>其中，这三个依赖是必须的，缺一不可。</p>
<p>在程序的入口ServiceHiApplication类，加上@EnableHystrix注解开启断路器，这个是必须的，并且需要在程序中声明断路点HystrixCommand；加上@EnableHystrixDashboard注解，开启HystrixDashboard</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@RestController</span><br><span class="line">@EnableHystrix</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">public class ServiceHiApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceHiApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">	String port;</span><br><span class="line">	@RequestMapping(&quot;&#x2F;hi&quot;)</span><br><span class="line">	@HystrixCommand(fallbackMethod &#x3D; &quot;hiError&quot;)</span><br><span class="line">	public String home(@RequestParam String name) &#123;</span><br><span class="line">		return &quot;hi &quot;+name+&quot;,i am from port:&quot; +port;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String hiError(String name) &#123;</span><br><span class="line">		return &quot;hi,&quot;+name+&quot;,sorry,error!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行程序： 依次开启eureka-server 和service-hi.</p>
<h2 id="四、Hystrix-Dashboard图形展示"><a href="#四、Hystrix-Dashboard图形展示" class="headerlink" title="四、Hystrix Dashboard图形展示"></a>四、Hystrix Dashboard图形展示</h2><p>打开<a target="_blank" rel="noopener" href="http://localhost:8762/hystrix.stream%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%B8%80%E4%BA%9B%E5%85%B7%E4%BD%93%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A">http://localhost:8762/hystrix.stream，可以看到一些具体的数据：</a></p>
<p><img src="http://img.blog.csdn.net/20170416111909110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>打开locahost:8762/hystrix 可以看见以下界面：</p>
<p><img src="http://img.blog.csdn.net/20170416110739541?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在界面依次输入：locahost:8762/hystrix.stream 、2000 、miya<br>；点确定。</p>
<p>在另一个窗口输入： <a target="_blank" rel="noopener" href="http://localhost:8762/hi?name=forezp">http://localhost:8762/hi?name=forezp</a></p>
<p>重新刷新hystrix.stream网页，你会看到良好的图形化界面：</p>
<p><img src="http://img.blog.csdn.net/20170416111243262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter12">https://github.com/forezp/SpringCloudLearning/tree/master/chapter12</a></p>
<h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/tree/master/hystrix-dashboard">hystrix-dashboard</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud HystrixDashboard</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第13篇：Turbine</title>
    <url>/2017/06/13/springcloud-2017-06-13-sc13-turbine/</url>
    <content><![CDATA[<p>上一篇文章讲述了如何利用Hystrix Dashboard去监控断路器的Hystrix command。当我们有很多个服务的时候，这就需要聚合所以服务的Hystrix Dashboard的数据了。这就需要用到Spring Cloud的另一个组件了，即Hystrix Turbine。</p>
<span id="more"></span>

<h2 id="一、Hystrix-Turbine简介"><a href="#一、Hystrix-Turbine简介" class="headerlink" title="一、Hystrix Turbine简介"></a>一、Hystrix Turbine简介</h2><p>看单个的Hystrix Dashboard的数据并没有什么多大的价值，要想看这个系统的Hystrix Dashboard数据就需要用到Hystrix Turbine。Hystrix Turbine将每个服务Hystrix Dashboard数据进行了整合。Hystrix Turbine的使用非常简单，只需要引入相应的依赖和加上注解和配置就可以了。</p>
<h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><p>本文使用的工程为上一篇文章的工程，在此基础上进行改造。因为我们需要多个服务的Dashboard，所以需要再建一个服务，取名为service-lucy，它的基本配置同service-hi，具体见<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter13">源码</a>,在这里就不详细说明。</p>
<h2 id="三、创建service-turbine"><a href="#三、创建service-turbine" class="headerlink" title="三、创建service-turbine"></a>三、创建service-turbine</h2><p>引入相应的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-turbine&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-netflix-turbine&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其入口类ServiceTurbineApplication加上注解@EnableTurbine，开启turbine，@EnableTurbine注解包含了@EnableDiscoveryClient注解，即开启了注册服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableTurbine</span><br><span class="line">public class ServiceTurbineApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">			new SpringApplicationBuilder(ServiceTurbineApplication.class).web(true).run(args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置文件application.yml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application.name: service-turbine</span><br><span class="line">server:</span><br><span class="line">  port: 8769</span><br><span class="line">security.basic.enabled: false</span><br><span class="line">turbine:</span><br><span class="line">  aggregator:</span><br><span class="line">    clusterConfig: default   # 指定聚合哪些集群，多个使用&quot;,&quot;分割，默认为default。可使用http:&#x2F;&#x2F;...&#x2F;turbine.stream?cluster&#x3D;&#123;clusterConfig之一&#125;访问</span><br><span class="line">  appConfig: service-hi,service-lucy  ### 配置Eureka中的serviceId列表，表明监控哪些服务</span><br><span class="line">  clusterNameExpression: new String(&quot;default&quot;)</span><br><span class="line">  # 1. clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称</span><br><span class="line">  # 2. 当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default</span><br><span class="line">  # 3. 当clusterNameExpression: metadata[&#39;cluster&#39;]时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">      </span><br><span class="line">     </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置文件注解写的很清楚。</p>
<h2 id="四、Turbine演示"><a href="#四、Turbine演示" class="headerlink" title="四、Turbine演示"></a>四、Turbine演示</h2><p>依次开启eureka-server、service-hi、service-lucy、service-turbine工程。</p>
<p>打开浏览器输入：<a target="_blank" rel="noopener" href="http://localhost:8769/turbine.stream,%E7%95%8C%E9%9D%A2%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8769/turbine.stream,界面如下：</a></p>
<p><img src="http://img.blog.csdn.net/20170416135735474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>依次请求：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8762/hi?name=forezp">http://localhost:8762/hi?name=forezp</a> </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8763/hi?name=forezp">http://localhost:8763/hi?name=forezp</a></p>
<p>打开:<a target="_blank" rel="noopener" href="http://localhost:8763/hystrix,%E8%BE%93%E5%85%A5%E7%9B%91%E6%8E%A7%E6%B5%81http://localhost:8769/turbine.stream">http://localhost:8763/hystrix,输入监控流http://localhost:8769/turbine.stream</a></p>
<p><img src="http://img.blog.csdn.net/20170416140029540?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>点击monitor stream 进入页面：</p>
<p><img src="http://img.blog.csdn.net/20170416140256754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以看到这个页面聚合了2个service的hystrix dashbord数据。</p>
<p>源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter13">https://github.com/forezp/SpringCloudLearning/tree/master/chapter13</a></p>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_dashboard">hystrix_dashboard</a></p>
<p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_turbine">turbine</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Turbine</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第14篇：Consule</title>
    <url>/2017/06/14/springcloud-2017-06-14-sc14-consul/</url>
    <content><![CDATA[<p>这篇文章主要介绍 spring cloud consul 组件，它是一个提供服务发现和配置的工具。consul具有分布式、高可用、高扩展性。</p>
<span id="more"></span>

<h2 id="一、consul-简介"><a href="#一、consul-简介" class="headerlink" title="一、consul 简介"></a>一、consul 简介</h2><p>consul 具有以下性质：</p>
<ul>
<li>服务发现：consul通过http 方式注册服务，并且服务与服务之间相互感应。</li>
<li>服务健康监测</li>
<li>key/value 存储</li>
<li>多数据中心</li>
</ul>
<p>consul可运行在mac windows linux 等机器上。</p>
<h2 id="二、consul安装"><a href="#二、consul安装" class="headerlink" title="二、consul安装"></a>二、consul安装</h2><p>linux</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir -p $GOPATH&#x2F;src&#x2F;github.com&#x2F;hashicorp &amp;&amp; cd $!</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;hashicorp&#x2F;consul.git</span><br><span class="line">$ cd consul</span><br><span class="line">$ make bootstrap</span><br><span class="line">$ make bootstrap</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>windows下安装：<br>见<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70188595">consul怎么在windows下安装</a></p>
<h2 id="三、构建工程"><a href="#三、构建工程" class="headerlink" title="三、构建工程"></a>三、构建工程</h2><p>构建一个consul-miya的springboot工程，导入依赖pring-cloud-starter-consul-discovery，其依赖文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;consul-miya&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;consul-miya&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其入口文件ConsulMiyaApplication加入注解@EnableDiscoveryClient，开启服务发现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@RestController</span><br><span class="line">public class ConsulMiyaApplication &#123;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;&#x2F;hi&quot;)</span><br><span class="line">	public String home() &#123;</span><br><span class="line">		return &quot;hi ,i&#39;m miya&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new SpringApplicationBuilder(ConsulMiyaApplication.class).web(true).run(args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其配置文件application.yml指定consul服务的端口为8500：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: 8500</span><br><span class="line">      discovery:</span><br><span class="line">        healthCheckPath: $&#123;management.contextPath&#125;&#x2F;health</span><br><span class="line">        healthCheckInterval: 15s</span><br><span class="line">        instance-id: consul-miya</span><br><span class="line">  application:</span><br><span class="line">    name: consul-miya</span><br><span class="line">server:</span><br><span class="line">  port: 8502</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动工程，访问localhost:8500,可以发现consul-miya被注册了。</p>
<p>源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter14">https://github.com/forezp/SpringCloudLearning/tree/master/chapter14</a></p>
<h4 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h4><p><a target="_blank" rel="noopener" href="https://github.com/HashiCorp/consul">HashiCorp/consul</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-consul/blob/master/docs/src/main/asciidoc/spring-cloud-consul.adoc#install-consul">Spring Cloud Consul</a></p>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/docs/upgrading.html">consul.io</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Consule</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT简介</title>
    <url>/2017/05/07/tools-2017-05-04-consul-windows-install/</url>
    <content><![CDATA[<p>去官网下载：<a target="_blank" rel="noopener" href="https://www.consul.io/downloads.html">https://www.consul.io/downloads.html</a><br>解压：<br><img src="http://upload-images.jianshu.io/upload_images/2279594-24b004549def507f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<span id="more"></span>

<p>设置环境变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">计算机  右键  属性 高级属性设置环境变量设置</span><br><span class="line"></span><br><span class="line">在path下加上：E:\programfiles\consul；</span><br></pre></td></tr></table></figure>
<p>cmd启动：</p>
<blockquote>
<p>consul agent -dev</p>
</blockquote>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-6379a5174dafb3f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"><br>可以看到启动成功。</p>
<p>打开网址：<a target="_blank" rel="noopener" href="http://localhost:8500/">http://localhost:8500</a>  ，可以看到界面，相关服务发现的界面。</p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>consule</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Tutorial: IoC Container</title>
    <url>/2021/06/10/spring-06-10-springIoc/</url>
    <content><![CDATA[<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/%E5%9B%BE%E6%80%AA%E5%85%BD_7d43390b66abdbb57cd5a8b2c6ef0169_30946.png" style="zoom:90%;" />

<h4 id="什么是IOC？"><a href="#什么是IOC？" class="headerlink" title="什么是IOC？"></a><strong>什么是IOC？</strong></h4><p>通俗理解就是 POJO 原本是自己需要然后new出来，现在是IOC 容器则是 你告诉我你需要什么，我们直接给你，让别人为你服务！</p>
<p><strong>现实生活</strong>： 1.你出门之前需要穿衣服，之前则是需要自己找对应的衣服，现在则反转成你的妻子把这些衣服找好给你穿上。</p>
<span id="more"></span>

<p>当然为你服务的前提是知道你的需求：</p>
<ul>
<li><p> 第一类似于你是酒吧常客，服务员立马知道你的需求 – 构造函数初始化 ，优点则是对象构造完成之后 对象就已经就绪可以用了</p>
</li>
<li><p> 第二类似于你到酒吧大喊我需要啤酒，服务员知道你的需求 – 对象set/get 方法 对象构造完成之后也不可以立马使用，但是比较解耦，类似于我告诉对应的需求，你来服务我，而不是见到我就无脑服务我</p>
</li>
</ul>
<p>IOC 可以很好的做到解耦，正常来说 我明确我需要什么，具体服务实现你提供给我即可。</p>
<h4 id="看看spring-里的Ioc-容器："><a href="#看看spring-里的Ioc-容器：" class="headerlink" title="看看spring 里的Ioc 容器："></a>看看spring 里的Ioc 容器：</h4><h5 id="beanFactory-amp-ApplicationContext"><a href="#beanFactory-amp-ApplicationContext" class="headerlink" title="beanFactory &amp;  ApplicationContext"></a>beanFactory &amp;  ApplicationContext</h5><p><img src="https://i.loli.net/2021/05/27/fYeCTJqAKmWi1Sz.png" alt="image-20210527161111966"></p>
<p><img src="https://i.loli.net/2021/05/27/N6eX1cO4mdLufng.png" alt="image-20210527160746029"></p>
<p><strong>defaultListableBeanFactory</strong> 是一个比较通用的<strong>beanFactory</strong> ，不仅实现了 beanFactory 的getBean等方法，也实现了</p>
<p><strong>beanDefinitionRegistry</strong>的注册管理的功能。beanDefinitionRegistry 就像图书馆的书架一样，beanFactory 则是整个图书馆，</p>
<p>书架上的书则是beanDefinition 。</p>
<p><img src="https://i.loli.net/2021/05/27/vXPYDwZec9lLBt7.png" alt="image-20210527161035328"></p>
<h5 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h5><p>外部配置 xml / properties –&gt; beanDefinitionReader —&gt;beanDefinition —&gt; 将beanDefinition 注册到beanDefinitionRegister，完成</p>
<p>bean的注册和加载 ，从而进行bean的获取。</p>
<p><img src="https://i.loli.net/2021/05/27/VXAExpJmFtdLszO.png" alt="image-20210527164639931"></p>
<p>Ioc 容器 就是在了解你的需求之后 去满足你的需求，而不需要你自己去实现自己的需求。</p>
<p>spring 里的容器则是beanFactory  比较简单只有getBean ，高级一点的则有applicationContext ，里面不仅是getBean</p>
<h5 id="beanFactory-amp-factoryBean"><a href="#beanFactory-amp-factoryBean" class="headerlink" title="beanFactory &amp; factoryBean"></a>beanFactory &amp; factoryBean</h5><p><img src="https://i.loli.net/2021/05/28/yV5xhaAOqISwb8U.png" alt="image-20210528103240843"></p>
<h5 id="容器的整个历程"><a href="#容器的整个历程" class="headerlink" title="容器的整个历程"></a>容器的整个历程</h5><ul>
<li>概览：</li>
</ul>
<p><img src="https://i.loli.net/2021/05/28/jTKN3G4xWy8mibM.png" alt="image-20210528150114956"></p>
<p><strong>容器启动阶段</strong>： BeanDefinitionReader 加载解析 xml 配置信息 成beanDefinition ，并且注册到beanDefinitionRegister。</p>
<p><img src="https://i.loli.net/2021/05/28/Lw1x4iqgyKvH7NX.png" alt="image-20210528150321558"></p>
<p><strong>容器实例化阶段</strong>： getBean 尝试获取对象，如果获取不到，则根据对应注册的beanDefinition 进行实例化返回</p>
<p><strong>ps</strong>：总的来说 第一阶段像装配生产线，酒吧服务知道你的需求，第二阶段则是进行真正的生产，酒吧服务员满足你的需求。</p>
<h5 id="BeanFactoryPostprocessor"><a href="#BeanFactoryPostprocessor" class="headerlink" title="BeanFactoryPostprocessor"></a>BeanFactoryPostprocessor</h5><p><strong>BeanFactoryPostprocessor</strong> 会插手容器启动阶段，可以修改已经加载的beanDefinition信息，常见的如:PropertyPlaceholderConfigurer 和 PropertyOverrideConfigurer.</p>
<ul>
<li><strong>PropertyOverrideConfigurer</strong>:</li>
</ul>
<p><img src="https://i.loli.net/2021/05/28/wZYQyU29e7XMNvm.png" alt="image-20210528165746359"></p>
<ul>
<li><strong>overrideConfig</strong>.properties: 规则 –&gt; beanname+属性</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">testFactoryBeanCore.name</span>=<span class="string">&quot;ckj&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>结果</strong> ：</li>
</ul>
<p><img src="https://i.loli.net/2021/05/28/AfmV5U674OD9qQy.png" alt="image-20210528170019059"></p>
<h5 id="bean-的生命历程"><a href="#bean-的生命历程" class="headerlink" title="bean 的生命历程"></a>bean 的生命历程</h5><p>经过第一阶段的 启动过程 之后，有了bean的 beanDefinitions，进入实例化阶段，这个阶段实在getBean 时 才进行触发。</p>
<p><img src="https://i.loli.net/2021/05/28/9Z4G7NA6mrcUEHO.png" alt="image-20210528172119044"></p>
<h5 id="beanFactoryPostprocessor-amp-beanPostprocessor"><a href="#beanFactoryPostprocessor-amp-beanPostprocessor" class="headerlink" title="beanFactoryPostprocessor &amp; beanPostprocessor"></a>beanFactoryPostprocessor &amp; beanPostprocessor</h5><p>BeanPostProcessor是存在于对象实例化阶段作用于bean，而BeanFactoryPostProcessor则是存在于容器启动阶段，作用于beanFactory 。</p>
<h5 id="自定义beanPostProcessor"><a href="#自定义beanPostProcessor" class="headerlink" title="自定义beanPostProcessor"></a>自定义beanPostProcessor</h5><p><strong>beanPostProcessor：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> TestBeanPostProcessorCore) &#123;</span><br><span class="line">            ((TestBeanPostProcessorCore) bean).setAge(<span class="number">100</span>);</span><br><span class="line">            ((TestBeanPostProcessorCore) bean).setName(<span class="string">&quot;ckj&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;=== this custom bean :&#123;&#125;&quot;</span>, JSON.toJSONString(bean));</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanPostProcessorCore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">05</span>-<span class="number">31</span> <span class="number">16</span>:<span class="number">50</span>:<span class="number">19.522</span>  INFO <span class="number">12652</span> --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line"><span class="number">2021</span>-<span class="number">05</span>-<span class="number">31</span> <span class="number">16</span>:<span class="number">50</span>:<span class="number">19.522</span>  INFO <span class="number">12652</span> --- [           main] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in <span class="number">1641</span> ms</span><br><span class="line"><span class="number">2021</span>-<span class="number">05</span>-<span class="number">31</span> <span class="number">16</span>:<span class="number">50</span>:<span class="number">19.708</span>  INFO <span class="number">12652</span> --- [           main] c.c.base.spring.CustomBeanPostProcessor  : === <span class="keyword">this</span> custom bean :&#123;<span class="string">&quot;age&quot;</span>:<span class="number">100</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;ckj&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
</search>
