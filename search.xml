<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Discord如何存储数万亿条消息</title>
    <url>/2023/04/01/discord/</url>
    <content><![CDATA[<p>Discord是一款专为社群设计的免费网络实时通话软件与数字发行平台，主要针对游戏玩家、教育人士、朋友及商业人士，用户之间可以在软体的聊天频道通过消息、图片、视频和音频进行交流。这款软件可以在Microsoft Windows、macOS、Android、iOS、Linux和网页上运行。</p>
<p>下面的图展示了Discord消息存储的演变历程：</p>
<p><img src="https://res.craft.do/user/full/8cf3a6c7-2a00-8ee8-0195-0eb38fda2eeb/5915084F-1F12-445D-B6F4-BE12D63C75AE_2/y6PCZxe8EwmpdNacqIRuPwKScgJthxcgJyg1eKOEYdsz/67b3962d-becb-4fba-a9ae-115692dfa6e1_3576x3033.jpeg" alt="67b3962d-becb-4fba-a9ae-115692dfa6e1_3576x3033.jpeg"></p>
<span id="more"></span>

<p>MongoDB ➡️ Cassandra ➡️ ScyllaDB</p>
<p>2015年，Discord的第一个版本建立在一个单独的MongoDB副本之上。到了2015年11月左右，MongoDB存储了1亿条消息，但是RAM已经无法再容纳数据和索引了。此时延迟变得不可预测。因此，需要将消息存储转移到另一个数据库。最终选择了Cassandra。</p>
<p>2017年，Discord有12个Cassandra节点，并存储了数十亿条消息。</p>
<p>到2022年初，它已经有177个节点，并存储了数万亿条消息。此时，延迟变得不可预测，并且维护操作的成本变得太高。</p>
<p>问题的原因有以下几点：</p>
<ul>
<li>Cassandra使用LSM树作为内部数据结构。读操作比写操作更昂贵。在具有数百个用户的服务器上可能有很多并发读取，从而导致热点问题。</li>
<li>维护集群（如压缩SSTables）会影响性能。</li>
<li>垃圾回收暂停会导致显著的延迟峰值。</li>
</ul>
<p>ScyllaDB是一个兼容Cassandra的数据库，用C++编写。Discord重新设计了其架构，具有单片API、用Rust编写的数据服务和基于ScyllaDB的存储。</p>
<p>在ScyllaDB中，p99读取延迟为15毫秒，而Cassandra中为40-125毫秒。p99写入延迟为5毫秒，而Cassandra中为5-70毫秒。</p>
<p>ScyllaDB是一个快速、可扩展和高可用的分布式数据库，适用于大规模数据处理和高吞吐量应用程序。它已被广泛应用于云计算、物联网、金融服务、在线广告和游戏等领域，被视为具有很高性价比的数据库解决方案。</p>
<p>以下是一个使用 Java 驱动程序连接 ScyllaDB 并执行查询的示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.datastax.driver.core.*;</span><br><span class="line"></span><br><span class="line">public class ScyllaDBExample &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; Connect to the cluster and keyspace</span><br><span class="line">    Cluster cluster &#x3D; Cluster.builder().addContactPoint(&quot;127.0.0.1&quot;).build();</span><br><span class="line">    Session session &#x3D; cluster.connect(&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Execute a simple query</span><br><span class="line">    ResultSet results &#x3D; session.execute(&quot;SELECT * FROM users&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Print the results</span><br><span class="line">    for (Row row : results) &#123;</span><br><span class="line">      System.out.format(&quot;%d %s %s\n&quot;, row.getInt(&quot;id&quot;), row.getString(&quot;name&quot;), row.getString(&quot;email&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Close the session and cluster</span><br><span class="line">    session.close();</span><br><span class="line">    cluster.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子使用 DataStax Java 驱动程序连接 ScyllaDB 并执行一个简单的查询来获取所有用户的记录。它打印查询结果，然后关闭会话和集群。</p>
<p>要运行这个示例，你需要将 DataStax Java 驱动程序添加到你的 Java 项目中。可以通过 Maven 或 Gradle 添加以下依赖项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.datastax.cassandra&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cassandra-driver-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.14.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了默认的本地节点 IP 地址 127.0.0.1，也可以使用 ScyllaDB 集群中的其他节点 IP 地址。在实际应用中，建议使用连接池和预处理语句来提高性能。</p>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="http://scylladb.com/product/technology/shard-per-core-architecture/">scylladb.com/product/technology/shard-per-core-architecture/</a></p>
<p><a target="_blank" rel="noopener" href="http://discord.com/blog/how-discord-stores-trillions-of-messages">discord.com/blog/how-discord-stores-trillions-of-messages</a></p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是gRPC？有什么优点？</title>
    <url>/2023/04/01/grpc/</url>
    <content><![CDATA[<p>RPC（远程过程调用）被称为“远程”，是因为它可以在微服务架构下将服务部署在不同的服务器上时，在远程服务之间进行通信。从用户的角度来看，它就像是一个本地函数调用。</p>
<p>下面的图表说明了gRPC的整体数据流程。</p>
<p><img src="https://res.craft.do/user/full/8cf3a6c7-2a00-8ee8-0195-0eb38fda2eeb/5610CB5D-8792-4108-B0B9-D1582C6C9B59_2/bOxnEzyEycV4MsFrPOFkkGcHzgT4O1YNv1fHHOJTy6kz/b98afdcd-b567-4c90-9f47-5358df0adda6_1280x1619.jpeg" alt="b98afdcd-b567-4c90-9f47-5358df0adda6_1280x1619.jpeg"></p>
<span id="more"></span>

<p>第1步：客户端发出REST调用。请求正文通常以JSON格式呈现。</p>
<p>第2-4步：订单服务（gRPC客户端）接收REST调用，对其进行转换，并向付款服务发出RPC调用。gPRC将客户端存根编码为二进制格式并将其发送到底层传输层。</p>
<p>第5步：gRPC通过HTTP2将数据包通过网络发送。由于二进制编码和网络优化，gRPC的速度比JSON快5倍。</p>
<p>第6-8步：付款服务（gRPC服务器）接收来自网络的数据包，对其进行解码并调用服务器应用程序。</p>
<p>第9-11步：结果从服务器应用程序返回，并被编码并发送到传输层。</p>
<p>第12-14步：订单服务接收数据包，对其进行解码，并将结果发送到客户端应用程序。</p>
<p>在使用gRPC时，需要定义protobuf消息和服务定义。protobuf消息是通信中传输的数据类型，而服务定义则描述了如何使用这些消息来实现RPC方法。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面是一个使用gRPC实现简单加法功能的代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package calculator;</span><br><span class="line"></span><br><span class="line">service Calculator &#123;</span><br><span class="line">  rpc Add (AddRequest) returns (AddResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddRequest &#123;</span><br><span class="line">  int32 a &#x3D; 1;</span><br><span class="line">  int32 b &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddResponse &#123;</span><br><span class="line">  int32 result &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了一个名为<code>Calculator</code>的服务，该服务具有一个名为<code>Add</code>的RPC方法。此方法将一个请求消息<code>AddRequest</code>作为输入，并返回一个响应消息<code>AddResponse</code>。</p>
<p><code>AddRequest</code>和<code>AddResponse</code>是protobuf消息。它们都具有简单的整数字段。<code>AddRequest</code>包含两个整数字段a和b，表示要相加的两个数字。<code>AddResponse</code>包含一个整数字段result，表示加法的结果。</p>
<p>现在，我们需要在客户端和服务器上实现这个服务。在开始实现客户端代码之前，需要先引入gRPC依赖库。可以通过在Maven或Gradle中添加以下依赖项来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Maven</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-netty-shaded&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.42.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Gradle</span><br><span class="line">implementation &#39;io.grpc:grpc-netty-shaded:1.42.0&#39;</span><br></pre></td></tr></table></figure>

<p>接下来，我们可以编写一个简单的Java客户端程序来调用我们之前定义的加法服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import io.grpc.ManagedChannel;</span><br><span class="line">import io.grpc.ManagedChannelBuilder;</span><br><span class="line">import io.grpc.StatusRuntimeException;</span><br><span class="line">import com.example.grpc.AddRequest;</span><br><span class="line">import com.example.grpc.AddResponse;</span><br><span class="line">import com.example.grpc.MathServiceGrpc;</span><br><span class="line"></span><br><span class="line">public class MathClient &#123;</span><br><span class="line">    private final ManagedChannel channel;</span><br><span class="line">    private final MathServiceGrpc.MathServiceBlockingStub blockingStub;</span><br><span class="line"></span><br><span class="line">    public MathClient(String host, int port) &#123;</span><br><span class="line">        channel &#x3D; ManagedChannelBuilder.forAddress(host, port)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        blockingStub &#x3D; MathServiceGrpc.newBlockingStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutdown() throws InterruptedException &#123;</span><br><span class="line">        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(int a, int b) &#123;</span><br><span class="line">        AddRequest request &#x3D; AddRequest.newBuilder()</span><br><span class="line">                .setA(a)</span><br><span class="line">                .setB(b)</span><br><span class="line">                .build();</span><br><span class="line">        AddResponse response;</span><br><span class="line">        try &#123;</span><br><span class="line">            response &#x3D; blockingStub.add(request);</span><br><span class="line">        &#125; catch (StatusRuntimeException e) &#123;</span><br><span class="line">            System.err.println(&quot;RPC failed: &quot; + e.getStatus());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Result: &quot; + response.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MathClient client &#x3D; new MathClient(&quot;localhost&quot;, 50051);</span><br><span class="line">        try &#123;</span><br><span class="line">            client.add(1, 2);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            client.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此代码中，我们首先创建了一个<code>ManagedChannel</code>实例，该实例连接到我们的服务器。然后，我们使用这个<code>ManagedChannel</code>实例创建一个新的<code>MathServiceGrpc.MathServiceBlockingStub</code>实例，该实例是通过gRPC自动生成的，可以用来调用我们定义的加法方法。</p>
<p>在<code>add</code>方法中，我们首先构建一个<code>AddRequest</code>实例，该实例包含了我们需要相加的两个整数。然后，我们使用我们之前创建的<code>MathServiceGrpc.MathServiceBlockingStub</code>实例调用<code>add</code>方法，并传递这个<code>AddRequest</code>实例作为参数。最后，我们将结果打印出来。</p>
<p>在<code>main</code>方法中，我们创建一个新的<code>MathClient</code>实例，并使用它来调用<code>add</code>方法。最后，我们在<code>finally</code>块中关闭了<code>MathClient</code>实例。</p>
<p>这个Java客户端代码可以通过以下命令来编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ javac MathClient.java</span><br></pre></td></tr></table></figure>

<p>然后，我们可以使用以下命令来运行它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java MathClient</span><br></pre></td></tr></table></figure>

<p>运行这个程序后，将输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result: 3</span><br></pre></td></tr></table></figure>

<p>这表明我们的加法服务已经成功地在客户端和服务器之间通信了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>gRPC可以实现简单的RPC方法，在客户端和服务器之间成功地进行通信。</li>
<li>protobuf消息和服务定义使得定义和使用RPC方法更容易。</li>
<li>gRPC提供高效的网络传输和编码，从而提高了通信速度和可靠性。</li>
<li>gRPC为开发人员提供了轻松构建分布式系统的强大工具。</li>
<li>在微服务架构下，gRPC使服务之间的通信更加容易和高效。</li>
<li>在实际开发中需要注意潜在的问题，例如网络延迟和数据大小限制，需要仔细设计服务接口和消息类型，以确保通信的稳定性和可靠性。</li>
<li>gRPC是值得尝试的分布式系统开发工具，提供高效的RPC通信和易于使用的接口定义。</li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>android realm</title>
    <url>/2015/05/05/android-2015-05-05-Android-Realm/</url>
    <content><![CDATA[<p>Realm is a mobile database that runs directly inside phones, tablets or wearables. This repository holds the source code for the Java version of Realm, which currently runs only on Android.</p>
<span id="more"></span>

<p>Realm是一个移动端的数据库，它可以在手机、平板。穿戴设备上运行。这个仓库的代码是一个Java版本的代码，目前只用在安卓端。</p>
<p>摘自：<a target="_blank" rel="noopener" href="https://github.com/realm/realm-java">https://github.com/realm/realm-java</a></p>
<p>导入JAR</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &#39;io.realm:realm-android:0.87.0&#39;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在Application 中配置，不配置也可以，就是默认的哦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyApplication extends Application &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        initRealm();</span><br><span class="line">    &#125;</span><br><span class="line">    private void initRealm()&#123;</span><br><span class="line">        RealmConfiguration configuration &#x3D; new RealmConfiguration</span><br><span class="line">                .Builder(this)</span><br><span class="line">                .name(&quot;test.realm&quot;)</span><br><span class="line">                .deleteRealmIfMigrationNeeded()</span><br><span class="line">                .schemaVersion(7).migration(new RealmMigration() &#123;</span><br><span class="line"></span><br><span class="line">                    @Override</span><br><span class="line">                    public void migrate(DynamicRealm realm, long oldVersion, long newVersion) &#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;).build();</span><br><span class="line"></span><br><span class="line">        Realm.setDefaultConfiguration(configuration);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建实体类，需集成RealmObject</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User  extends RealmObject&#123;</span><br><span class="line">    @PrimaryKey</span><br><span class="line">    private String id;</span><br><span class="line">    private String userName;</span><br><span class="line">    private String mobile;</span><br><span class="line"></span><br><span class="line">    public String getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(String id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getUserName() &#123;</span><br><span class="line">        return userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setUserName(String userName) &#123;</span><br><span class="line">        this.userName &#x3D; userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMobile() &#123;</span><br><span class="line">        return mobile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMobile(String mobile) &#123;</span><br><span class="line">        this.mobile &#x3D; mobile;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在Activity中初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Realm myRealm ;</span><br><span class="line"> myRealm&#x3D; Realm.getInstance(this);</span><br></pre></td></tr></table></figure>

<p>添加数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Realm开始处理事物  方式1：</span><br><span class="line">      myRealm.beginTransaction();</span><br><span class="line">      User user &#x3D; myRealm.createObject(User.class);</span><br><span class="line">      user.setId(&quot;445115&quot;);</span><br><span class="line">      user.setMobile(&quot;44545&quot;);</span><br><span class="line">      user.setUserName(&quot;hha&quot;);</span><br><span class="line">      myRealm.commitTransaction();</span><br><span class="line">      &#x2F;&#x2F;方式2：</span><br><span class="line">User user2&#x3D;new User();</span><br><span class="line">      user2.setId(&quot;1123&quot;);</span><br><span class="line">      user2.setUserName(&quot;sss&quot;);</span><br><span class="line">      user2.setMobile(&quot;445&quot;);</span><br><span class="line">      myRealm.beginTransaction();</span><br><span class="line">      User userCopy2 &#x3D; myRealm.copyToRealm(user2);</span><br><span class="line">      myRealm.commitTransaction();</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查找数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RealmResults&lt;User&gt; listUser &#x3D; myRealm.where(User.class).findAll();</span><br><span class="line"></span><br><span class="line">       StringBuilder stringBuilder&#x3D;new StringBuilder();</span><br><span class="line"></span><br><span class="line">       for(User u:listUser) &#123;</span><br><span class="line">           stringBuilder.append(u.getUserName()+&quot;--------****--------- &quot;);</span><br><span class="line">           Log.d(&quot;results1&quot;,u.getUserName());</span><br><span class="line">       &#125;</span><br><span class="line">       tv.setText(stringBuilder.toString());</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/forezp/RealmJavaTest">源码下载</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">csdn博客</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android js 互调</title>
    <url>/2015/05/05/android-2015-05-05-Javascript-android-react/</url>
    <content><![CDATA[<p>最近在做原生和js端的互调的功能，自己改了个demo，给大家讲解下。</p>
<span id="more"></span>

<p>先上js代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;方法调用基本流程测试&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;div id&#x3D;&quot;helloweb&quot;&gt; </span><br><span class="line">	&lt;div id&#x3D;&quot;echoInfo&quot;&gt;如果有数据返回，会显示在这儿&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line">	&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">	</span><br><span class="line">	function funFromjs()&#123;</span><br><span class="line">    	document.getElementById(&quot;helloweb&quot;).innerHTML&#x3D;&quot;HelloWebView,i&#39;m from js&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">		function echoInfo( container, obj )&#123;</span><br><span class="line">			var domContainer &#x3D; document.getElementById(&#39;echoInfo&#39;);</span><br><span class="line">			domContainer.innerHTML &#x3D; JSON.stringify( obj );</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F;function windowCallback( str )&#123;</span><br><span class="line">			&#x2F;&#x2F;echoInfo( &#39;echoInfo&#39;, str );</span><br><span class="line">		&#x2F;&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">		 window.windowCallback &#x3D; function( str )&#123;</span><br><span class="line">		 	echoInfo( &#39;echoInfo&#39;, str );</span><br><span class="line">		 &#125;;</span><br><span class="line"></span><br><span class="line">		var MfsJSBridge &#x3D; MfsJSBridge || undefined;</span><br><span class="line">		if( undefined !&#x3D; MfsJSBridge )&#123;</span><br><span class="line"></span><br><span class="line">			&#x2F;&#x2F;看这里</span><br><span class="line">			var params &#x3D; &#123;</span><br><span class="line">				id : 1,</span><br><span class="line">				name : &#39;测试&#39;</span><br><span class="line">			&#125;;</span><br><span class="line"></span><br><span class="line">			var strParams &#x3D; JSON.stringify( params );</span><br><span class="line"></span><br><span class="line">			MfsJSBridge.invoke( &#39;testFunc&#39;, strParams, &#39;windowCallback&#39;);</span><br><span class="line"></span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			alert(&#39;未定义MfsJSBridge&#39;);</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>android webview 设置可用javascript</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置编码</span></span><br><span class="line"> mWebView.getSettings().setDefaultTextEncodingName(<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line"> <span class="comment">//支持js</span></span><br><span class="line">mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>
<p>android 调js</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mBtn1.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">              mWebView.loadUrl(<span class="string">&quot;javascript:funFromjs()&quot;</span>);<span class="comment">//其中funFromjs()为js的方法</span></span><br><span class="line">              Toast.makeText(mContext, <span class="string">&quot;调用javascript:funFromjs()&quot;</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>js调原生，原生响应时间并回调数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mWebView.addJavascriptInterface(<span class="keyword">new</span> Object()&#123;</span><br><span class="line">       	<span class="comment">//注意4.4以后加注解，位置在这个方法名上面，鉴于很多这个的例子，瞎、、写注解位置，并需要下                        //载积分写了这个</span></span><br><span class="line">        <span class="meta">@JavascriptInterface</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(String name ,String t,String callback)</span> </span>&#123;</span><br><span class="line">           	<span class="keyword">if</span>(name.equals(<span class="string">&quot;testFunc&quot;</span>))&#123; </span><br><span class="line">           	<span class="comment">//其中t 为js带过来的数据          </span></span><br><span class="line">           		Toast.makeText(mContext, t,Toast.LENGTH_LONG).show();</span><br><span class="line">           		</span><br><span class="line">           		String strJson = <span class="string">&quot;&#123;\&quot;code\&quot;:122, \&quot;msg\&quot;:\&quot;1231\&quot;, \&quot;data\&quot;:null&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">           		<span class="comment">//回调数据给js 其中callback 为android 掉js 的方法名称。</span></span><br><span class="line">           		mWebView.loadUrl(<span class="string">&quot;javascript:&quot;</span>+ callback +<span class="string">&quot;(&#x27;&quot;</span> + strJson + <span class="string">&quot;&#x27;)&quot;</span>);</span><br><span class="line">           	&#125;</span><br><span class="line">             <span class="comment">//  Toast.makeText(mContext, name, Toast.LENGTH_LONG).show();</span></span><br><span class="line">               </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,<span class="string">&quot;MfsJSBridge&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>代码比较简单，最主要的是 @JavascriptInterface注解的位置大家注意下。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9555368">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android design新控件</title>
    <url>/2015/05/05/android-2015-05-05-android-design/</url>
    <content><![CDATA[<p> 最近在研究android   开发的新控件，包括drawer layout ,NavigationView,CoordinatorLayout,AppBarLayout,Toolbar,TabLayout,SwipeRefreshLayout,Recyclerview等。</p>
<span id="more"></span>

<p>先上效果图：</p>
<p><img src="http://img.blog.csdn.net/20160710200140616" width = "300"  alt="图片名称" align=center />     <img src="http://img.blog.csdn.net/20160710200214538" width = "300"  alt="图片名称" align=center /><br><img src="http://img.blog.csdn.net/20160710200253055" width = "300"  alt="图片名称" align=center />   <img src="http://img.blog.csdn.net/20160710200353322" width = "300"  alt="图片名称" align=center /></p>
<p>主界面上drawlayou 和NavigationView形成抽屉效果，布局文件如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;android.support.v4.widget.DrawerLayout</span><br><span class="line">    xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:app=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span><br><span class="line">    android:id=<span class="string">&quot;@+id/id_drawerlayout&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    &gt;</span><br><span class="line">    &lt;include layout=<span class="string">&quot;@layout/home_content&quot;</span>/&gt;</span><br><span class="line">    &lt;android.support.design.widget.NavigationView</span><br><span class="line">        android:id=<span class="string">&quot;@+id/id_navigationview&quot;</span></span><br><span class="line">        app:itemTextColor=<span class="string">&quot;@color/selector_nav_menu_textcolor&quot;</span></span><br><span class="line">        android:layout_gravity=<span class="string">&quot;left&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;match_parent&quot;</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/android.support.design.widget.NavigationView&gt;</span><br><span class="line"></span><br><span class="line">&lt;/android.support.v4.widget.DrawerLayout&gt;</span><br></pre></td></tr></table></figure>
<p>java代码：抽屉部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drawerLayout &#x3D; (DrawerLayout)findViewById(R.id.id_drawerlayout);</span><br><span class="line">navigationView &#x3D; (NavigationView)findViewById(R.id.id_navigationview);</span><br><span class="line"> ActionBarDrawerToggle mActionBarDrawerToggle &#x3D;</span><br><span class="line">                new ActionBarDrawerToggle(this, drawerLayout, toolbar, R.string.open, R.string.close);</span><br><span class="line">        mActionBarDrawerToggle.syncState();</span><br><span class="line">        drawerLayout.setDrawerListener(mActionBarDrawerToggle);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;给NavigationView填充顶部区域，也可在xml中使用app:headerLayout&#x3D;&quot;@layout&#x2F;header_nav&quot;来设置</span><br><span class="line">        navigationView.inflateHeaderView(R.layout.header_nav);</span><br><span class="line">        View headerView &#x3D; navigationView.getHeaderView(0);</span><br><span class="line"></span><br><span class="line">        CircleImageView circleImageView &#x3D; (CircleImageView)headerView.findViewById(R.id.id_circleview);</span><br><span class="line">        Glide.with(this).load(&quot;http:&#x2F;&#x2F;pic1.nipic.com&#x2F;2008-10-30&#x2F;200810309416546_2.jpg&quot;).into(circleImageView);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;给NavigationView填充Menu菜单，也可在xml中使用app:menu&#x3D;&quot;@menu&#x2F;menu_nav&quot;来设置</span><br><span class="line">        navigationView.inflateMenu(R.menu.menu_nav);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以给navigationview 设置点击事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mNav.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123;</span><br><span class="line">            @Override public boolean onNavigationItemSelected(MenuItem menuItem) &#123;</span><br><span class="line"></span><br><span class="line">                String msgString &#x3D; &quot;&quot;;</span><br><span class="line"></span><br><span class="line">                switch (menuItem.getItemId()) &#123;</span><br><span class="line">                    case R.id.nav_menu_home:</span><br><span class="line">                        msgString &#x3D; (String) menuItem.getTitle();</span><br><span class="line">                        break;</span><br><span class="line">                    case R.id.nav_menu_categories:</span><br><span class="line">                        msgString &#x3D; (String) menuItem.getTitle();</span><br><span class="line">                        break;</span><br><span class="line">                    case R.id.nav_menu_feedback:</span><br><span class="line">                        msgString &#x3D; (String) menuItem.getTitle();</span><br><span class="line">                        break;</span><br><span class="line">                    case R.id.nav_menu_setting:</span><br><span class="line">                        msgString &#x3D; (String) menuItem.getTitle();</span><br><span class="line">                        break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                &#x2F;&#x2F; Menu item点击后选中，并关闭Drawerlayout</span><br><span class="line">                menuItem.setChecked(true);</span><br><span class="line">                drawerLayout.closeDrawers();</span><br><span class="line"></span><br><span class="line">                Toast.makeText(HomeActivity.this,msgString,Toast.LENGTH_SHORT).show();</span><br><span class="line">               </span><br><span class="line">                return true;</span><br></pre></td></tr></table></figure>
<p>draw layout  和navigation view 组合可以写成非常好的抽屉效果，避免了第三方库，用原生的感觉非常棒。<br>－－－－－－－－－－抽屉部分结束－－－－－－－－－－－<br><br></br><br><br></br></p>
<p>tab layout 和view pager 实现联动效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 初始化ViewPager的适配器，并设置给它</span><br><span class="line">       mViewPagerAdapter &#x3D; new MyViewPagerAdapter(getSupportFragmentManager(), mTitles, mFragments);</span><br><span class="line">       viewPager.setAdapter(mViewPagerAdapter);</span><br><span class="line">       &#x2F;&#x2F; 设置ViewPager最大缓存的页面个数</span><br><span class="line">       viewPager.setOffscreenPageLimit(5);</span><br><span class="line">       &#x2F;&#x2F; 给ViewPager添加页面动态监听器（为了让Toolbar中的Title可以变化相应的Tab的标题）</span><br><span class="line">       viewPager.addOnPageChangeListener(this);</span><br><span class="line"></span><br><span class="line">       tabLayout.setTabMode(MODE_SCROLLABLE);</span><br><span class="line">       &#x2F;&#x2F; 将TabLayout和ViewPager进行关联，让两者联动起来</span><br><span class="line">       tabLayout.setupWithViewPager(viewPager);</span><br><span class="line">       &#x2F;&#x2F; 设置Tablayout的Tab显示ViewPager的适配器中的getPageTitle函数获取到的标题</span><br><span class="line">       tabLayout.setTabsFromPagerAdapter(mViewPagerAdapter);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>RefreshLayout 实现下拉刷新效果:<br>布局文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">       xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">       android:id&#x3D;&quot;@+id&#x2F;id_swiperefreshlayout&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">       app:layout_behavior&#x3D;&quot;@string&#x2F;appbar_scrolling_view_behavior&quot;</span><br><span class="line">       &gt;</span><br><span class="line"></span><br><span class="line">       &lt;!--</span><br><span class="line">               使用RecyclerView需要在build.gradle中添加</span><br><span class="line">              compile &#39;com.android.support:recyclerview-v7:23.3.0&#39;</span><br><span class="line">       --&gt;</span><br><span class="line">       &lt;android.support.v7.widget.RecyclerView</span><br><span class="line">           android:id&#x3D;&quot;@+id&#x2F;id_recyclerview&quot;</span><br><span class="line">           android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">           android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">           android:foregroundGravity&#x3D;&quot;center&quot;</span><br><span class="line">           &#x2F;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;android.support.v4.widget.SwipeRefreshLayout&gt;</span><br></pre></td></tr></table></figure>
<p>在fragment 实现下拉刷新接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DemoFragment extends Fragment implements SwipeRefreshLayout.OnRefreshListener&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>mSwipeRefreshLayout实现下拉是的颜色变化，和设置监听事件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mSwipeRefreshLayout.setColorSchemeResources(R.color.main_blue_light, R.color.main_blue_dark);</span><br><span class="line"> mSwipeRefreshLayout.setOnRefreshListener(this);</span><br></pre></td></tr></table></figure>
<p>下拉刷新刷新数据的接口实现的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onRefresh() &#123;</span><br><span class="line"></span><br><span class="line">        new Handler().postDelayed(new Runnable() &#123;</span><br><span class="line">            @Override public void run() &#123;</span><br><span class="line">               mSwipeRefreshLayout.setRefreshing(false);&#x2F;&#x2F;关闭下拉动画</span><br><span class="line"></span><br><span class="line">                           </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, 1000);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>－－－－－－－－－下拉刷新结束－－－－－－－－－－</p>
<p>RecyclerView可以实现listview （横行和纵向）.gridview（横行和纵向） ,瀑布流的效果。<br>我讲解一下最简单的效果：listview的效果：<br>直接上代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mLayoutManager &#x3D;new LinearLayoutManager(getActivity(), LinearLayoutManager.VERTICAL, false);</span><br><span class="line">mRecyclerViewAdapter &#x3D; new DemoRecyclerViewAdapter(getActivity());</span><br><span class="line">mRecyclerViewAdapter.setOnItemClickListener(this);</span><br><span class="line">            mRecyclerView.setAdapter(mRecyclerViewAdapter);</span><br><span class="line">            mRecyclerViewAdapter.setList(list);</span><br><span class="line">            mRecyclerView.setLayoutManager(mLayoutManager);</span><br><span class="line">            mRecyclerViewAdapter.notifyDataSetChanged();                        </span><br></pre></td></tr></table></figure>
<p>其中adapter 的写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class DemoRecyclerViewAdapter extends RecyclerView.Adapter&lt;DemoRecyclerViewHolder&gt; &#123;</span><br><span class="line">    private Context context;</span><br><span class="line">    private ArrayList&lt;ImageBean&gt; list;</span><br><span class="line">  </span><br><span class="line">    public DemoRecyclerViewAdapter(Context mContext) &#123;</span><br><span class="line">        this.context &#x3D; mContext;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public DemoRecyclerViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">        View mView&#x3D; LayoutInflater.from(context).inflate(R.layout.item_demo_adapter,parent,false);</span><br><span class="line">        DemoRecyclerViewHolder recyclerViewHolder&#x3D;new DemoRecyclerViewHolder(mView);</span><br><span class="line">        return recyclerViewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onBindViewHolder(final DemoRecyclerViewHolder holder, final int position) &#123;</span><br><span class="line">        if(mOnItemClickListener!&#x3D;null)&#123;</span><br><span class="line">            holder.itemView.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void onClick(View v) &#123;</span><br><span class="line">                    mOnItemClickListener.onItemClick(holder.itemView,position);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public boolean onLongClick(View v) &#123;</span><br><span class="line">                    mOnItemClickListener.onItemLongClick(holder.itemView, position);</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        holder.textView.setText(list.get(position).getName());</span><br><span class="line">        Glide.with(context).load(list.get(position).getImg()).into(holder.imageView);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getItemCount() &#123;</span><br><span class="line">        return list.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>adapter的写法根之前BaseAdapter 很类似，需要特别注意的是:<br>加载布局文件的方法一定是这个，要不然会出现match_parent 失效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">View mView&#x3D; LayoutInflater.from(context).inflate(R.layout.item_demo_adapter,parent,false);</span><br></pre></td></tr></table></figure>
<p>还有一些其他的控件如cardview 比较简单就不说了，toolbar的用法会在下次给出好的例子。</p>
<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9571175">源码下载</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android轮播图</title>
    <url>/2015/05/05/android-2015-05-05-android-galaeery/</url>
    <content><![CDATA[<p> 最近做项目，自己封装了一个图片轮播的组件，主要的思想就采用ViewPager和ScrollGater实现，图片加载用的Imageloader，也可以换其他的，比如Glide.具体封装的组件件源码，这里只说下用法，首先上布局文件。</p>
<span id="more"></span>
<img src="http://img.blog.csdn.net/20160708091623612" width = "300"  alt="图片名称" align=center />

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;LinearLayout xmlns:android=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="line">    xmlns:tools=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="line">    android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:layout_height=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">    android:orientation=<span class="string">&quot;vertical&quot;</span></span><br><span class="line">    tools:context=<span class="string">&quot;.MainActivity&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:id=<span class="string">&quot;@+id/root&quot;</span></span><br><span class="line">        android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">        android:layout_height=<span class="string">&quot;180dp&quot;</span></span><br><span class="line">        android:orientation=<span class="string">&quot;vertical&quot;</span> &gt;</span><br><span class="line"></span><br><span class="line">        &lt;com.example.shuffviewdemo.ShufflingView</span><br><span class="line">            android:id=<span class="string">&quot;@+id/shuffling_view&quot;</span></span><br><span class="line">            android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">            android:layout_height=<span class="string">&quot;wrap_content&quot;</span> &gt;</span><br><span class="line">        &lt;/com.example.shuffviewdemo.ShufflingView&gt;</span><br><span class="line">    &lt;/LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">&lt;/LinearLayout&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 初始化ShufflingView,设置des可见，轮播的指示器在底部。设置点击事件监听。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">mShufflingView = (ShufflingView) findViewById(R.id.shuffling_view);</span><br><span class="line">		mShufflingView.setContentDesVisibility(View.VISIBLE);</span><br><span class="line">		mShufflingView.setDotGravity(Gravity.BOTTOM);</span><br><span class="line">		mShufflingView.setOnItemClickListener(mOnShufflingItemClickListener);</span><br><span class="line">		bannerList = <span class="keyword">new</span> ArrayList&lt;ShufflingItemBean&gt;();</span><br><span class="line">		loadShuffingViewData();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>设置shufflingView 的beans接收的是一个arraylist对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">ShufflingItemBean shufflingItemBean=<span class="keyword">new</span> ShufflingItemBean();</span><br><span class="line">		shufflingItemBean.setImg(<span class="string">&quot;http://img3.imgtn.bdimg.com/it/u=4227020988,3565099621&amp;fm=21&amp;gp=0.jpg&quot;</span>);</span><br><span class="line">		shufflingItemBean.setUrl(<span class="string">&quot;www.baidu.com&quot;</span>);<span class="comment">//点击跳转到webview</span></span><br><span class="line">		bannerList.add(shufflingItemBean);</span><br><span class="line">		bannerList.add(shufflingItemBean);</span><br><span class="line">		bannerList.add(shufflingItemBean);</span><br><span class="line">		mShufflingView.updateDatas(bannerList);</span><br></pre></td></tr></table></figure>

<p>shufflingView 的监听，具体的跳转和类型，根据需求组件设置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">actionFromType</span><span class="params">(Context context, ShufflingItemBean item)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;-1&quot;</span>)) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;1&quot;</span>)) &#123;<span class="comment">// 交易贴</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;2&quot;</span>)) &#123;<span class="comment">// 外部链接</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;3&quot;</span>)) &#123;<span class="comment">// 资讯贴</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;4&quot;</span>)) &#123;<span class="comment">// 应援贴</span></span><br><span class="line"></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (item.getType().equals(<span class="string">&quot;5&quot;</span>)) &#123;<span class="comment">//</span></span><br><span class="line">			<span class="comment">//Intent intent = new Intent(context, WebViewActivity.class);</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">//intent.putExtra(&quot;url&quot;,</span></span><br><span class="line">			<span class="comment">//item.getUrl());</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			<span class="comment">//intent.putExtra(&quot;type&quot;, 1);</span></span><br><span class="line">			<span class="comment">//context.startActivity(intent);</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">// 其他</span></span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9570165">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android 动画</title>
    <url>/2015/05/05/android-2015-05-05-android-gif/</url>
    <content><![CDATA[<p>ObjectAnimator继承自ValueAnimator的，底层的动画实现机制也是基于ValueAnimator来完成的，因此ValueAnimator仍然是整个属性动画当中最核心的一个类。那么既然是继承关系，说明ValueAnimator中可以使用的方法在ObjectAnimator中也是可以正常使用的，它们的用法也非常类似.</p>
<span id="more"></span>

<p>1.旋转控件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(textView, &quot;rotation&quot;, 0f, 360f);</span><br><span class="line">               animator.setDuration(5000);</span><br><span class="line">               animator.start();</span><br></pre></td></tr></table></figure>

<p>2.平移控件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float curTranslationX &#x3D; textView.getTranslationX();</span><br><span class="line">                ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(textView, &quot;translationX&quot;, curTranslationX, -500f, curTranslationX);</span><br><span class="line">                animator.setDuration(5000);</span><br><span class="line">                animator.start();</span><br></pre></td></tr></table></figure>
<p>3.放大缩小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(textView, &quot;scaleY&quot;, 1f, 3f, 1f);</span><br><span class="line">               animator.setDuration(3000);</span><br><span class="line">               animator.start();</span><br></pre></td></tr></table></figure>

<p>4.透明  控件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator animator &#x3D; ObjectAnimator.ofFloat(textView, &quot;alpha&quot;, 1f, 0f,1f);</span><br><span class="line">              animator.setDuration(3000);</span><br><span class="line">              animator.start();</span><br></pre></td></tr></table></figure>
<p>用法确实比较简单。<br>5.组合动画<br>实现组合动画功能主要需要借助AnimatorSet这个类，这个类提供了一个play()方法，如果我们向这个方法中传入一个Animator对象(ValueAnimator或ObjectAnimator)将会返回一个AnimatorSet.Builder的实例，AnimatorSet.Builder中包括以下四个方法：<br>after(Animator anim)   将现有动画插入到传入的动画之后执行<br>after(long delay)   将现有动画延迟指定毫秒后执行<br>before(Animator anim)   将现有动画插入到传入的动画之前执行<br>with(Animator anim)   将现有动画和传入的动画同时执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectAnimator moveIn &#x3D; ObjectAnimator.ofFloat(textView, &quot;translationX&quot;, -500f, 0f);</span><br><span class="line">               ObjectAnimator rotate &#x3D; ObjectAnimator.ofFloat(textView, &quot;rotation&quot;, 0f, 360f);</span><br><span class="line">               ObjectAnimator fadeInOut &#x3D; ObjectAnimator.ofFloat(textView, &quot;alpha&quot;, 1f, 0f, 1f);</span><br><span class="line">               AnimatorSet animSet &#x3D; new AnimatorSet();</span><br><span class="line">               AnimatorSet.Builder builder&#x3D;animSet.play(rotate);</span><br><span class="line">               builder.with(fadeInOut).after(moveIn);</span><br><span class="line">               animSet.setDuration(5000);</span><br><span class="line">               animSet.start();</span><br></pre></td></tr></table></figure>

<p>布局实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line"></span><br><span class="line">&lt;set xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:ordering&#x3D;&quot;sequentially&quot; &gt;</span><br><span class="line"></span><br><span class="line">    &lt;objectAnimator</span><br><span class="line">        android:duration&#x3D;&quot;2000&quot;</span><br><span class="line">        android:propertyName&#x3D;&quot;translationX&quot;</span><br><span class="line">        android:valueFrom&#x3D;&quot;-500&quot;</span><br><span class="line">        android:valueTo&#x3D;&quot;0&quot;</span><br><span class="line">        android:valueType&#x3D;&quot;floatType&quot; &gt;</span><br><span class="line">    &lt;&#x2F;objectAnimator&gt;</span><br><span class="line"></span><br><span class="line">    &lt;set android:ordering&#x3D;&quot;together&quot; &gt;</span><br><span class="line">        &lt;objectAnimator</span><br><span class="line">            android:duration&#x3D;&quot;3000&quot;</span><br><span class="line">            android:propertyName&#x3D;&quot;rotation&quot;</span><br><span class="line">            android:valueFrom&#x3D;&quot;0&quot;</span><br><span class="line">            android:valueTo&#x3D;&quot;360&quot;</span><br><span class="line">            android:valueType&#x3D;&quot;floatType&quot; &gt;</span><br><span class="line">        &lt;&#x2F;objectAnimator&gt;</span><br><span class="line"></span><br><span class="line">        &lt;set android:ordering&#x3D;&quot;sequentially&quot; &gt;</span><br><span class="line">            &lt;objectAnimator</span><br><span class="line">                android:duration&#x3D;&quot;1500&quot;</span><br><span class="line">                android:propertyName&#x3D;&quot;alpha&quot;</span><br><span class="line">                android:valueFrom&#x3D;&quot;1&quot;</span><br><span class="line">                android:valueTo&#x3D;&quot;0&quot;</span><br><span class="line">                android:valueType&#x3D;&quot;floatType&quot; &gt;</span><br><span class="line">            &lt;&#x2F;objectAnimator&gt;</span><br><span class="line">            &lt;objectAnimator</span><br><span class="line">                android:duration&#x3D;&quot;1500&quot;</span><br><span class="line">                android:propertyName&#x3D;&quot;alpha&quot;</span><br><span class="line">                android:valueFrom&#x3D;&quot;0&quot;</span><br><span class="line">                android:valueTo&#x3D;&quot;1&quot;</span><br><span class="line">                android:valueType&#x3D;&quot;floatType&quot; &gt;</span><br><span class="line">            &lt;&#x2F;objectAnimator&gt;</span><br><span class="line">        &lt;&#x2F;set&gt;</span><br><span class="line">    &lt;&#x2F;set&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;set&gt;</span><br></pre></td></tr></table></figure>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Animator animator &#x3D; AnimatorInflater.loadAnimator(MainActivity.this, R.animator.setanim);</span><br><span class="line">                animator.setTarget(textView);</span><br><span class="line">                animator.start();</span><br></pre></td></tr></table></figure>
<p>调用AnimatorInflater的loadAnimator来将XML动画文件加载进来，然后再调用setTarget()方法将这个动画设置到某一个对象上面，最后再调用start()方法启动动画就可以了，就是这么简单。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9587802">源码下载</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">csdn博客</a></p>
<p> 本文参考了 郭神的博客：<a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog/article/details/43536355">http://blog.csdn.net/guolin_blog/article/details/43536355</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android最新学习资料收集</title>
    <url>/2015/05/05/android-2015-05-05-android-materials/</url>
    <content><![CDATA[<p>收集这份资料的灵感来源于我的浏览器收藏夹快爆了，后来在github 上也看到了很优秀的开源库的收集资料，非常的好，但是太过于多，也不够新，所以决定自己来做一个。原始的markdowm文件已经放到github上，欢迎<a target="_blank" rel="noopener" href="https://github.com/forezp/AndroidMaterialLatest">下载和star</a> 。这份资料我会不断的完善，也欢迎一些经验丰富的开发者可以一起来完善，直接<a target="_blank" rel="noopener" href="https://github.com/forezp/AndroidMaterialLatest/pulls">pull request</a> 或者<a target="_blank" rel="noopener" href="https://github.com/forezp/AndroidMaterialLatest/issues">issue</a>，我会定期筛选合并，有一些好的建议和意见随时<a href="#%E8%81%94%E7%B3%BB%E6%88%91">联系我</a>，欢迎转载，谢谢收藏。</p>
<span id="more"></span>

<h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><a href="#%E5%AE%89%E5%8D%93%E6%B5%81%E8%A1%8C%E6%A1%86%E6%9E%B6%E6%8E%A8%E8%8D%90">安卓流行框架</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E7%BD%91%E7%AB%99">常用网站</a></li>
<li><a href="#%E5%8D%9A%E5%AE%A2%E6%8E%A8%E8%8D%90">博客推荐</a></li>
<li><a href="#%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E6%8E%A8%E8%8D%90">微信公众号推荐</a></li>
<li><a href="#%E4%B9%A6%E7%B1%8D%E6%8E%A8%E8%8D%90">书籍推荐</a></li>
<li><a href="#RxJava%E7%B3%BB%E5%88%97">RxJava系列</a></li>
<li><a href="#retrofi%E7%B3%BB%E5%88%97">retrofi系列</a></li>
<li><a href="#MVP%E7%B3%BB%E5%88%97">MVP系列</a></li>
<li><a href="#MaterialDesign%E7%B3%BB%E5%88%97">MaterialDesign系列</a></li>
<li><a href="#MVP-retrofit-rxjava-materialDesign%E7%B3%BB%E5%88%97">MVP-retrofit-rxjava-materialDesign系列</a></li>
<li><a href="#Kotlin%E7%B3%BB%E5%88%97">Kotlin系列</a></li>
<li><a href="#%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0">开源项目学习</a></li>
<li><a href="#%E5%BC%80%E6%BA%90%E5%BA%93%E6%94%B6%E9%9B%86">开源库收集</a></li>
<li><a href="#Android%E5%BC%80%E5%8F%91%E8%80%85%E6%9D%82%E5%BF%97%E5%91%A8%E5%88%8A">Android开发者杂志周刊</a></li>
<li><a href="#%E5%B7%A5%E5%85%B7">工具</a></li>
<li><a href="#%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83">开发环境</a></li>
<li><a href="#%E7%B4%A0%E6%9D%90">素材</a></li>
<li><a href="#%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F">设计模式</a></li>
<li><a href="#%E6%96%87%E6%A1%A3">文档</a></li>
<li><a href="#%E6%84%9F%E8%B0%A2">感谢</a></li>
<li><a href="#%E8%81%94%E7%B3%BB%E6%88%91">联系我</a></li>
</ul>
<p>=========================================================</p>
<h2 id="安卓流行框架"><a href="#安卓流行框架" class="headerlink" title="安卓流行框架"></a>安卓流行框架</h2><table>
<thead>
<tr>
<th>分类</th>
<th>框架名称</th>
<th>推荐理由</th>
</tr>
</thead>
<tbody><tr>
<td>缓存</td>
<td><a target="_blank" rel="noopener" href="https://github.com/JakeWharton/DiskLruCache">DiskLruCache</a></td>
<td>DiskLruCache ，JakeWharton开源，缓存神器</td>
</tr>
<tr>
<td>图片加载</td>
<td><a target="_blank" rel="noopener" href="https://github.com/bumptech/glide">Glide</a></td>
<td>可播放gif，谷歌推荐的图片加载</td>
</tr>
<tr>
<td>图片加载</td>
<td><a target="_blank" rel="noopener" href="https://github.com/facebook/fresco">Fresco</a></td>
<td>可播放gif，流畅性最好的加载框架，Facebook 出品</td>
</tr>
<tr>
<td>图片加载</td>
<td><a target="_blank" rel="noopener" href="https://github.com/square/picasso">Picasso</a></td>
<td>squre inc.开源的图片加载框架。</td>
</tr>
<tr>
<td>图片处理</td>
<td><a target="_blank" rel="noopener" href="https://github.com/wasabeef/picasso-transformations">Picasso—transformations</a></td>
<td>图片处理框架。</td>
</tr>
<tr>
<td>图片处理</td>
<td><a target="_blank" rel="noopener" href="https://github.com/wasabeef/glide-transformations">Glide—transformations</a></td>
<td>图片处理框架。</td>
</tr>
<tr>
<td>网络请求</td>
<td><a target="_blank" rel="noopener" href="https://github.com/square/okhttp">Okhttp</a></td>
<td>非常强大的一个网络请求框架。</td>
</tr>
<tr>
<td>网络请求</td>
<td><a target="_blank" rel="noopener" href="https://github.com/square/retrofit">Retrofit</a></td>
<td>基于okhttp ,squire出品，必属精品。。</td>
</tr>
<tr>
<td>网络请求</td>
<td><a target="_blank" rel="noopener" href="https://github.com/mcxiaoke/android-volley">volley</a></td>
<td>谷歌之前出品的网络框架。</td>
</tr>
<tr>
<td>数据解析</td>
<td><a target="_blank" rel="noopener" href="https://github.com/google/gson">Gson</a></td>
<td>非常好用的JSOn解析。</td>
</tr>
<tr>
<td>数据解析</td>
<td><a target="_blank" rel="noopener" href="https://github.com/FasterXML/jackson">jackson</a></td>
<td>这个也不错。</td>
</tr>
<tr>
<td>数据库</td>
<td><a target="_blank" rel="noopener" href="https://github.com/greenrobot/greenDAO">greendao</a></td>
<td>一个轻量、效率快的数据库。</td>
</tr>
<tr>
<td>数据库</td>
<td><a target="_blank" rel="noopener" href="https://github.com/realm/realm-java">realm</a></td>
<td>好用，替代sqlite。</td>
</tr>
<tr>
<td>数据库</td>
<td><a target="_blank" rel="noopener" href="https://github.com/satyan/sugar">Sugar</a></td>
<td>另外一个好用的数据库，个人推荐GreenDao。</td>
</tr>
<tr>
<td>依赖注入</td>
<td><a target="_blank" rel="noopener" href="https://github.com/JakeWharton/butterknife">ButterKnife</a></td>
<td>注解，让你的代码整洁，配合ButterKnife Zelezny，一键生成注解。</td>
</tr>
<tr>
<td>图表</td>
<td><a target="_blank" rel="noopener" href="https://github.com/diogobernardino/WilliamChart">WilliamChart</a></td>
<td>强大的图标库。</td>
</tr>
<tr>
<td>图表</td>
<td><a target="_blank" rel="noopener" href="https://github.com/PhilJay/MPAndroidChart">MPAndroidChart</a></td>
<td>强大的图标库。</td>
</tr>
<tr>
<td>事件总线</td>
<td><a target="_blank" rel="noopener" href="https://github.com/greenrobot/EventBus">EventBus</a></td>
<td>一个简单移动的事件总线。</td>
</tr>
<tr>
<td>事件总线</td>
<td><a target="_blank" rel="noopener" href="https://github.com/square/otto">otto</a></td>
<td>另一个简单移动的事件总线。</td>
</tr>
<tr>
<td>响应式</td>
<td><a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxJava">RXjava</a></td>
<td>响应式编程 ，功能强大，值得学习。</td>
</tr>
<tr>
<td>响应式</td>
<td><a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxAndroid">RXAndroid</a></td>
<td>响应式编程 ，功能强大，值得学习。。</td>
</tr>
<tr>
<td>响应式</td>
<td><a target="_blank" rel="noopener" href="https://github.com/JakeWharton/RxBinding">RXBinding</a></td>
<td>响应式编程 ，功能强大，值得学习。。</td>
</tr>
<tr>
<td>Log</td>
<td><a target="_blank" rel="noopener" href="https://github.com/orhanobut/logger">logger</a></td>
<td>一个logger框架。</td>
</tr>
<tr>
<td>Log</td>
<td><a target="_blank" rel="noopener" href="https://github.com/spf13/hugo">Hugo</a></td>
<td>一个logger框架。</td>
</tr>
<tr>
<td>Log</td>
<td><a target="_blank" rel="noopener" href="https://github.com/JakeWharton/timber">Timber</a></td>
<td>一个logger框架。</td>
</tr>
<tr>
<td>测试框架</td>
<td><a target="_blank" rel="noopener" href="https://github.com/mockito/mockito">mockito</a></td>
<td>一个强大的用于 Java 开发的模拟测试框架。</td>
</tr>
<tr>
<td>测试框架</td>
<td><a target="_blank" rel="noopener" href="https://github.com/RobotiumTech/robotium">robotium</a></td>
<td>是一款国外的Android自动化测试框架。</td>
</tr>
<tr>
<td>调试框架</td>
<td><a target="_blank" rel="noopener" href="https://github.com/facebook/stetho">stetho</a></td>
<td>facebook的Android调试工具Stetho。</td>
</tr>
<tr>
<td>性能优化</td>
<td><a target="_blank" rel="noopener" href="https://github.com/square/leakcanary">leakcanary</a></td>
<td>一个检查内存泄露的插件，非常的强大。</td>
</tr>
</tbody></table>
<h2 id="常用网站"><a href="#常用网站" class="headerlink" title="常用网站"></a>常用网站</h2><table>
<thead>
<tr>
<th>网站名称</th>
<th>推荐理由</th>
</tr>
</thead>
<tbody><tr>
<td><a href="google.com">Google</a></td>
<td>google搜索，让信息传遍世界</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.github.com/">Github</a></td>
<td>面向世界的代码托管平台，在GitHub，你可以十分轻易地找到海量的开源代码</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://stackoverflow.com/">StackOverFlow</a></td>
<td>一个与程序相关的IT技术问答网站</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://segmentfault.com/t/android">SegmentFault</a></td>
<td>中文的开发者社区及媒体,中国的StackOverFlow</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.oschina.net/">开源中国</a></td>
<td>开源中国社区</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://developer.android.com/">安卓开发社区</a></td>
<td>安卓官网</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://gold.xitu.io/">掘金</a></td>
<td>掘金，号称中国质量最高的技术分享社区</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.csdn.net/">csdn</a></td>
<td>CSDN，全球最大的中文IT技术社区</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.csdn.net/">泡在网上的日子</a></td>
<td>泡在网上的日子，一个正对移动开发的技术分享论坛。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://gank.io/">干货集中营</a></td>
<td>干货集中营，每日分享。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="博客推荐"><a href="#博客推荐" class="headerlink" title="博客推荐"></a>博客推荐</h2><table>
<thead>
<tr>
<th>博客地址</th>
<th>博主信息</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://android-developers.blogspot.com/">Android Developers Blog</a></td>
<td>Android官网博客 ，有Android 的最新资讯，要翻墙。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/guolin_blog">郭霖</a></td>
<td>博主郭霖是大神, 人人都称”郭神”, 是第一行代码的作者, 博主在 CSDN 上所写的文章都非常值得学习</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/lmj623565791/">张鸿洋</a></td>
<td>张鴻洋是 CSDN 博客专家, “洋神”, 他的每一篇博客都很值得大家去学习</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.daimajia.com/">代码家</a></td>
<td>Android 大神, 博主收集了很多 Android 开源库, 博主自己也做了很多开源库, 非常值得学习，另外是<a href="gank.io">gank.io</a>的组织者。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.trinea.cn/">Trinea</a></td>
<td>目前在滴滴负责 Android 客户端技术, 他是开源库项目收集达人, 你想要的开源库<a target="_blank" rel="noopener" href="https://github.com/Trinea">上面</a>都有,并且有源码解析，大家可以去关注一下, <a target="_blank" rel="noopener" href="http://p.codekk.com/">地址</a> .</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/xyz_lmn">张兴业</a></td>
<td>张兴业同样也是 CSDN 博客专家</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/lzyzsd/">大头鬼</a></td>
<td>hi大头鬼hi 是阿里巴巴集团的一名 Android 工程师, 写了一系列RXJava 资料。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://over140.cnblogs.com/">农民伯伯</a></td>
<td>资深博客写手，他的博客非常值得一看。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/singwhatiwanna">任玉刚</a></td>
<td>《安卓开发艺术探索》作者。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/Luoshengyang">罗升阳</a></td>
<td>CSDN博客专家，《安卓系统源代码情景分析》。</td>
</tr>
</tbody></table>
<h2 id="微信公众号推荐"><a href="#微信公众号推荐" class="headerlink" title="微信公众号推荐"></a>微信公众号推荐</h2><table>
<thead>
<tr>
<th>微信公众号ID</th>
<th>博主信息</th>
</tr>
</thead>
<tbody><tr>
<td>guolin_blog</td>
<td>郭霖的公众号，有每日推荐文章，《第一行代码》作者。</td>
</tr>
<tr>
<td>hongyangAndroid</td>
<td>张鸿洋的公众号。有每日推荐文字，Csdn博客专家。</td>
</tr>
<tr>
<td>AndroidDeveloper</td>
<td>他是上海薄荷科技开发主管, 他的博客分享了他从编程白痴到自学 Android 一路走过的经验, 写了一篇 <a target="_blank" rel="noopener" href="http://stormzhang.com/android/2014/07/07/learn-android-from-rookie/">Android学习之路</a> 帮助了无数人, 里面还有很多好的文章非常适合新手入门,</td>
</tr>
</tbody></table>
<h2 id="书籍推荐"><a href="#书籍推荐" class="headerlink" title="书籍推荐"></a>书籍推荐</h2><table>
<thead>
<tr>
<th>书籍名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/25942191/">第一行代码</a></td>
<td>郭霖大杰作，适合新人</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/25762168/">Java核心技术 卷I</a></td>
<td>java入门书籍</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/3360807/">Effective Java</a></td>
<td>进阶书</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/10484692/">Java并发编程</a></td>
<td>Java并发编程</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26274206/">给大忙人看的Java8</a></td>
<td>给大忙人看的Java8</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1723199/">Thinking In Java 中文版</a></td>
<td>学习Java 语言必备书籍</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/26599539/">Android群英传</a></td>
<td>本书作者 @Tomcat 的猫。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://product.china-pub.com/4806147">Android开发艺术探索</a></td>
<td>由任玉刚所著.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/24722612/">深入理解Java虚拟机</a></td>
<td>不是很难 ，需要看看</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/4889838/">鸟哥的Linux私房菜</a></td>
<td>太经典。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/25863515/">图解Http</a></td>
<td>让你很快上手http。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2243615/">Head First设计模式</a></td>
<td>Head First设计模式</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/5387402/">程序员修炼之道</a></td>
<td>程序员修炼之道</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://iissnan.com/progit/html/zh/ch1_0.html">Git权威指南中文手册</a></td>
<td>Git权威指南中文手册</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/1139426/">数据结构与算法基础</a></td>
<td>数据结构和算法的书，比较全</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://book.douban.com/subject/2228378/">JavaScript权威指南</a></td>
<td>JavaScript权威指南，学习js一本书差不多了</td>
</tr>
</tbody></table>
<h2 id="RxJava系列"><a href="#RxJava系列" class="headerlink" title="RxJava系列"></a>RxJava系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://mcxiaoke.gitbooks.io/rxdocs/content/">ReactiveX/RxJava文档中文版</a></td>
<td>大神们在百忙之中翻译的文档，感谢开源。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://reactivex.io/RxJava/javadoc/">ReactiveX/RxJava官方API</a></td>
<td>ReactiveX/RxJava官方API</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://gank.io/post/560e15be2dca930e00da1083">给 Android 开发者的 RxJava 详解</a></td>
<td>给 Android 开发者的 RxJava 详解 ,作者：扔物线</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/lzyzsd/article/details/41833541/">深入浅出RxJava</a></td>
<td>大头鬼写的Rxjava 系列</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.apkbus.com/forum.php?mod=viewthread&tid=257703&extra=page=1&filter=author&orderby=dateline&_dsign=43e9b95f">老罗Rxjava视频</a></td>
<td>老罗Rxjava视频</td>
</tr>
</tbody></table>
<h2 id="retrofi系列"><a href="#retrofi系列" class="headerlink" title="retrofi系列"></a>retrofi系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://square.github.io/retrofit/">官方文档</a></td>
<td>squire出品，必属精品。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0915/3460.html">Retrofit 2.0：有史以来最大的改进</a></td>
<td>泡在网上的日子，翻译。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://blog.csdn.net/ljd2038/article/details/51046512">Retrofit2.0使用详解</a></td>
<td>讲解了基本的使用方法</td>
</tr>
</tbody></table>
<h2 id="MVP系列"><a href="#MVP系列" class="headerlink" title="MVP系列"></a>MVP系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0227/2503.html">Android中的MVP</a></td>
<td>泡在网上的日子翻译。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/googlesamples/android-architecture">google写的列子</a></td>
<td>google写的MvP例子。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/android10/Android-CleanArchitecture">Android-CleanArchitecture</a></td>
<td>一个适合新人的MVP例子</td>
</tr>
</tbody></table>
<h2 id="MaterialDesign系列"><a href="#MaterialDesign系列" class="headerlink" title="MaterialDesign系列"></a>MaterialDesign系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
</table>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.google.com/design/spec/material-design/introduction.html">Material Design 教程</a> |  google官方提高的materail design 指导。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/1sters/material_design_zh_2">Material Design 教程(中文版)</a> |  翻译的中文文档。</li>
<li><a target="_blank" rel="noopener" href="https://github.com/navasmdc/MaterialDesignLibrary">Material Design Android Library </a>(Material Design 开源库) |  一些非常优秀的material design 开源库。</li>
</ul>
<h2 id="MVP-retrofit-rxjava-materialDesign系列"><a href="#MVP-retrofit-rxjava-materialDesign系列" class="headerlink" title="MVP-retrofit-rxjava-materialDesign系列"></a>MVP-retrofit-rxjava-materialDesign系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/forezp/banya">瓣呀</a></td>
<td><a target="_blank" rel="noopener" href="https://github.com/forezp/banya">瓣呀，一个基于豆瓣API仿网易音乐的开源项目（本人写的，欢迎star）</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/Freelander/Elephant">大象</a></td>
<td>一个第三放PHPHUB客户端</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/8c3898eed1bb">开发资料</a></td>
<td>开发 Material Design+RxJava+Retrofit+MVP App 参考资料</td>
</tr>
</tbody></table>
<h2 id="Kotlin系列"><a href="#Kotlin系列" class="headerlink" title="Kotlin系列"></a>Kotlin系列</h2><table>
<thead>
<tr>
<th>名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://www.weibo.com/ttarticle/p/show?id=2309403942933815527259">kotlin 介绍</a></td>
<td>kotlin 介绍</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://kotlinlang.org/">kotlin 官网</a></td>
<td>kotlin 官网，最新的资讯。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/25289041">kotlin,网友对其评价</a></td>
<td>网友对其评价 ，很中肯。本人已经在学习，觉得如果熟练，开发速度大大提高，代码可读性也提高。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h2 id="开源项目学习"><a href="#开源项目学习" class="headerlink" title="开源项目学习"></a>开源项目学习</h2><table>
<thead>
<tr>
<th>项目名称</th>
<th>项目简介</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/google/iosched">Google I/O 2014</a></td>
<td>Google I/O Android App 使用了当时最新推出的 Material Design 设计</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/googlesamples/android-UniversalMusicPlayer">Google play music</a></td>
<td>一个跨多个平台音乐播放器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/pockethub/PocketHub">github客户端</a></td>
<td>开源者 github 团队, 支持项目的 lssues 和 Gists 并集成了新闻 feed 以便及时获取来自组织好友和资料库的更新信息, 还提供了一个用于快速访问你创建,监控以及发布 issue 面板, 可查看并将问题加到收藏夹</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/MiCode/Notes">MIUI 便签</a></td>
<td>MiCode 便签是小米便签的社区开源版, 由 MIUI 团队(ww.miui.com)发起并贡献第一批代码, 遵循 NOTICE 文件所描述的开源协议</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://git.oschina.net/oschina/android-app">oschina</a></td>
<td>开源中国社区 Android 客户端, 此开源的是 v1 版本, v2 版本将在 2015 年年中开源</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/zxing/zxing">ZXing</a></td>
<td>二维码扫描工具,市场上许多应用的二维码扫描工具都是从这个修改得到的</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/drakeet/Meizhi">Meizhi</a></td>
<td>开发者是许晓峰(Drakeet), 该 app 是数据来自代码家干货网站 <a target="_blank" rel="noopener" href="http://gank.io/">gank.io</a>, 有很多开发者都纷纷为这网站做客户端 app, 因为代码家大神开放该网站的 Api, 更重要的是该网站每天除了有干货还有漂亮妹子看呢, 该 App 使用到的技术有 RxJava + Retrofit, 代码结构非常清晰, 值得一看的开源 App.</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/Curzibn/Luban">鲁班</a></td>
<td>Android图片压缩工具，仿微信朋友圈压缩策略,一个优秀的压缩图片框架</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/izzyleung/ZhihuDailyPurify">ZhihuDailyPurify </a></td>
<td>知乎日报·净化</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/forezp/banya">瓣呀</a></td>
<td><a target="_blank" rel="noopener" href="https://github.com/forezp/banya">瓣呀，一个基于豆瓣API仿网易音乐的开源项目（本人写的，欢迎star）</a></td>
</tr>
</tbody></table>
<h2 id="开源库收集"><a href="#开源库收集" class="headerlink" title="开源库收集"></a>开源库收集</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/wasabeef/awesome-android-ui">awesome-android-ui</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/wasabeef/awesome-android-libraries">awesome-android-libraries</a></li>
<li><a target="_blank" rel="noopener" href="http://www.jcodecraeer.com/plus/list.php?tid=31">泡在网上的日子</a></li>
<li><a target="_blank" rel="noopener" href="http://alamkanak.github.io/android-libraries-and-resources/">Android Libraries and Resources </a></li>
<li><a target="_blank" rel="noopener" href="http://android-arsenal.com/">Android Arsenal </a>(一个专门收集 android 开源库的网站, 网站经常更新)</li>
<li><a target="_blank" rel="noopener" href="https://github.com/Trinea/android-open-project">Android 开源项目汇总 </a>(Trinea 大神收集的)</li>
<li><a target="_blank" rel="noopener" href="http://codekk.com/open-source-project-analysis">Android 开源项目源码分析 </a>(在懂得使用这些开源项目同时, 也应该了解当中的原理)</li>
<li><a target="_blank" rel="noopener" href="http://www.apkbus.com/forum-417-1.html">安卓巴士</a></li>
</ul>
<h2 id="Android开发者杂志周刊"><a href="#Android开发者杂志周刊" class="headerlink" title="Android开发者杂志周刊"></a>Android开发者杂志周刊</h2><table>
<thead>
<tr>
<th>周刊名</th>
<th>周刊简介</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://gank.io/">干货集中营</a></td>
<td>由 <a target="_blank" rel="noopener" href="http://blog.daimajia.com/">代码家</a> 维护更新, 分享内容有漂亮妹子, Android 干货, iOS 干货, App, 技术以外推荐, 还有休息视频</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://androidweekly.net/">Android Weekly</a></td>
<td>Android Weekly 是由Android 团队的成员和国外知名的 Android 开发者维护, 分享的都是干货。</td>
</tr>
</tbody></table>
<h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><table>
<thead>
<tr>
<th>工具名称</th>
<th>推荐理由</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="https://github.com/getlantern/lantern">蓝灯</a></td>
<td>Lantern ，免费翻墙神器</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.bejson.com/">bejson</a></td>
<td>Json查看，Json生成实体</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://tool.lu/sql/">sql</a></td>
<td>sql语句验证</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://www.iconfont.cn/">矢量图</a></td>
<td>阿里巴巴的矢量图库</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://labs.rampinteractive.co.uk/android_dp_px_calculator/">dp px 转换</a></td>
<td>阿里巴巴的矢量图库</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://translate.google.cn/">谷歌翻译</a></td>
<td>谷歌翻译</td>
</tr>
</tbody></table>
<h2 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h2><table>
<thead>
<tr>
<th>环境/工具</th>
<th>简述</th>
</tr>
</thead>
<tbody><tr>
<td><a target="_blank" rel="noopener" href="http://www.androiddevtools.cn/">AndroidDevTools</a></td>
<td>一个收集整理Android开发所需的Android SDK、开发中用到的工具、Android开发教程、Android设计规范，免费的设计素材的网站,很齐全，有它够用了。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://developer.android.com/sdk/index.html">Android Studio</a></td>
<td>安卓官方开发工具，基于IDEA , 比Eclipse好太多，没有用的同学赶紧转吧。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://www.genymotion.com/#!/download">Genymotion</a></td>
<td>安卓模拟器。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/skylot/jadx">jadx</a></td>
<td>Android 反编译神器, 不同于常见的 <a target="_blank" rel="noopener" href="https://github.com/pxb1988/dex2jar">dex2jar</a></td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/ligi/GradleDependenciesHelperPlugin">GradleDependenciesHelperPlugin</a></td>
<td>Gradle 依赖自动补全插件</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/square/leakcanary">LeakCanary</a></td>
<td>Square开源的一个非常有用的工具,检测出内存泄的问题</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/avast/android-butterknife-zelezny">ButterKnife Zelezny</a></td>
<td>ButterKnife 生成器, 使用起来非常简单方便, 为你简写了很多代码。</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/nicoulaj/idea-markdown">idea-markdown</a></td>
<td>在 AS 中编写 Markdown 文件, 可以直接预览网页显示效果</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="http://facebook.github.io/stetho/">Stetho</a></td>
<td>Stetho 是 Facebook 出品的一个强大的 Android 调试工具,使用该工具你可以在 Chrome Developer Tools 查看 App 的布局</td>
</tr>
<tr>
<td><a target="_blank" rel="noopener" href="https://github.com/zzz40500/GsonFormat">GsonFormat</a></td>
<td>现在大多数服务端 api 都以 json 数据格式返回, 而客户端需要根据 api 接口生成相应的实体类, 这个插件把这个过程自动化了</td>
</tr>
</tbody></table>
<h2 id="素材"><a href="#素材" class="headerlink" title="素材"></a>素材</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.iconfont.cn/">阿里巴巴矢量图</a></li>
<li><a target="_blank" rel="noopener" href="http://www.materialup.com/">Material Design设计模板与素材</a></li>
<li><a target="_blank" rel="noopener" href="https://iconstore.co/">Icon Store</a></li>
<li><a target="_blank" rel="noopener" href="https://design.google.com/icons/">Material icons</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/gztchan/awesome-design/">awesome-design</a></li>
</ul>
<h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/iluwatar/java-design-patterns#model-view-presenter">java-design-patterns</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/HackathonHackers/programming-ebooks/blob/master/Java/Effective%20Java%20%282nd%20Edition%29.pdf">Effective Java</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/zhangerqing/article/details/8194653">Java之美[从菜鸟到高手演变]之设计模式</a></li>
</ul>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.fresco-cn.org/">Fresco文档</a></li>
<li><a target="_blank" rel="noopener" href="http://mrfu.me/2016/02/27/Glide_Getting_Started/">Glide 中文非官方文档</a></li>
<li><a target="_blank" rel="noopener" href="http://developer.android.com/reference/android/package-summary.html">Android 官方 API 文档</a>(网站需要翻墙)</li>
<li><a target="_blank" rel="noopener" href="http://hukai.me/android-training-course-in-chinese/index.html">Android 官方培训课程中文版</a>(Google Android 官方培训课程翻译的中文版)</li>
</ul>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul>
<li>感谢这么多伟大的开源者，感谢这么多伟大的开源公司，因为开源，世界变得更加美好。</li>
</ul>
<h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我"></a>联系我</h2><ul>
<li>Email:<a href="mailto:&#49;&#50;&#52;&#55;&#x34;&#x36;&#x34;&#48;&#54;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;">&#49;&#50;&#52;&#55;&#x34;&#x36;&#x34;&#48;&#54;&#64;&#x71;&#113;&#46;&#x63;&#x6f;&#x6d;</a> </li>
<li>GitHub: <a target="_blank" rel="noopener" href="https://github.com/forezp">Forezp</a></li>
<li>Blog : <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">csdn blog</a></li>
<li>原文件: <a target="_blank" rel="noopener" href="https://github.com/forezp/AndroidMaterialLatest/issues">AndroidMaterialLatest</a></li>
</ul>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android MVP</title>
    <url>/2015/05/05/android-2015-05-05-android-mvp/</url>
    <content><![CDATA[<p>##Mvp模式简介</p>
<p>衍生于MVC 模式，降低了耦合性，避免了View(Activity/Fragment)承担了所有的责任，<br>分担了UI层的职责。<br></p>
<span id="more"></span>

<p>在MVP模式里通常包含4个要素：</p>
<ul>
<li>View:负责绘制UI元素、与用户进行交互(在Android中体现为Activity);</li>
<li>View interface:需要View实现的接口，View通过View interface与Presenter进行交互，降低耦合，方便进行单元测试;</li>
<li>Model:负责存储、检索、操纵数据(有时也实现一个Model interface用来降低耦合);</li>
<li>Presenter:作为View与Model交互的中间纽带，处理与用户交互的负责逻辑。</li>
</ul>
<h2 id="为什么要使用-MVP模式"><a href="#为什么要使用-MVP模式" class="headerlink" title="为什么要使用 MVP模式"></a>为什么要使用 MVP模式</h2><p> 在Android开发中，Activity并不是一个标准的MVC模式中的Controller，它的首要职责是加载应用的布局和初始化用户界面，<br> 并接受并处理来自用户的操作请求，进而作出响应。随着界面及其逻辑的复杂度不断提升，Activity类的 职责不断增加，<br> 以致变得庞大臃肿。当我们将其中复杂的逻辑处理移至另外的一个类（Presneter）中时，Activity其实就是MVP模式中 View，<br> 它负责UI元素的初始化，建立UI元素与Presenter的关联（Listener之类），同时自己也会处理一些简单的逻辑（复杂的逻辑交由<br> Presenter处理）.<br></p>
<p> 在实际的开发过程中,往往需求和界面是不确定的，随着开发的不断推进，原来的很多界面基本修改得面目全非，这是许多开发者面临<br> 的一个非常头疼的问题，MVP在一定程度上了解决了这个问题。</p>
<p> ##MVP 实战<br> （0）UserBean</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class User &#123;</span><br><span class="line">    </span><br><span class="line">    private int  id;</span><br><span class="line">    private String name ;</span><br><span class="line">    private String mobile ;</span><br><span class="line">    private String password;</span><br><span class="line">    public int getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setId(int id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getMobile() &#123;</span><br><span class="line">        return mobile;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setMobile(String mobile) &#123;</span><br><span class="line">        this.mobile &#x3D; mobile;</span><br><span class="line">    &#125;</span><br><span class="line">    public String getPassword() &#123;</span><br><span class="line">        return password;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setPassword(String password) &#123;</span><br><span class="line">        this.password &#x3D; password;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User [id&#x3D;&quot; + id + &quot;, name&#x3D;&quot; + name + &quot;, mobile&#x3D;&quot; + mobile + &quot;, password&#x3D;&quot; + password + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> （1）IUserModel 用户登录model接口 <br><br> 需要实现其接口，一般是读取网络数据，并存在JavaBean 中，并对javabean 有set和get的读写权限。<br> <br><br> 一般为了需要一个Listerner 来监听网络请求读写数据的情况。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public interface IUserModel &#123;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F; 用户登录接口</span><br><span class="line">    public void login(String phone, String passwdMd5, final LoginHandler handler);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> （2）IUserLoginView  用户登录view 接口<br><br>    根据需求，VIEw 需要对Model的bean数据进行操作，当登录成功，返回登录人信息情况。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserLoginView</span> <span class="keyword">extends</span> <span class="title">IUserView</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserLoginSuccess</span><span class="params">(User user)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onUserLoginError</span><span class="params">(String msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> (3)IUserModel监听类</p>
<p>  Model联网成功后，根据返回情况进行监听，它也起到了传递数据的作用，它将Model的数据传递给<br>  Presenter ，从而Presenter 来讲数据传递给view</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface LoginHandler extends NetworkHandler &#123;</span><br><span class="line">    public void onLoginSuccess(User user);       &#x2F;&#x2F; 登录成功</span><br><span class="line"></span><br><span class="line">    public void onLoginError(String msg);         &#x2F;&#x2F; 登录失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> (4)UserPresenter</p>
<p> 连接model 层和 view层，处理model和view进行交互。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserPresenter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG=<span class="string">&quot;UserPresenter&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> IUserModel mUser;      </span><br><span class="line">    <span class="keyword">private</span> IUserView mView;       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建用户模型的主导器</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> view 如果不需要进行界面展示则View传入null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserPresenter</span><span class="params">(<span class="meta">@Nullable</span> IUserView view)</span> </span>&#123;</span><br><span class="line">        mUser = UserModel.getInstance();</span><br><span class="line">        mView = view;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String mobile,String password)</span></span>&#123;</span><br><span class="line">        mUser.login(mobile, password, <span class="keyword">new</span> LoginHandler() &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onlinkError</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(mView!=<span class="keyword">null</span>&amp;&amp;mView <span class="keyword">instanceof</span> IUserLoginView)</span><br><span class="line">                 ( (IUserLoginView) mView).onUserLoginError(msg);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoginSuccess</span><span class="params">(User u)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (mView != <span class="keyword">null</span> &amp;&amp; mView <span class="keyword">instanceof</span> IUserLoginView)</span><br><span class="line">                    ((IUserLoginView) mView).onUserLoginSuccess(u);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoginError</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">               <span class="keyword">if</span>(mView!=<span class="keyword">null</span>&amp;&amp;mView <span class="keyword">instanceof</span> IUserLoginView)</span><br><span class="line">                   ((IUserLoginView)mView).onUserLoginError(msg);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（5）View 实现层<br></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends Activity implements IUserLoginView&#123;</span><br><span class="line">    </span><br><span class="line">    @ViewInject(id&#x3D;R.id.btn_login,click&#x3D;&quot;login&quot;) Button btn_login;</span><br><span class="line">    @ViewInject(id&#x3D;R.id.et_login_name)EditText et_login_name;</span><br><span class="line">    @ViewInject(id&#x3D;R.id.et_login_password) EditText et_login_password;</span><br><span class="line">    private Context mContext;</span><br><span class="line">    private UserPresenter userPresenter;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        FinalActivity.initInjectedView(this);</span><br><span class="line">        mContext&#x3D;this;</span><br><span class="line">        userPresenter&#x3D;new UserPresenter(this);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void login(View v)&#123;</span><br><span class="line">        String mobile&#x3D;et_login_name.getText().toString();</span><br><span class="line">        String password&#x3D;et_login_password.getText().toString();</span><br><span class="line">        String md5Pwd&#x3D;MD5(password);</span><br><span class="line">        userPresenter.login(mobile, md5Pwd);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    public void onUserLoginSuccess(User user) &#123;</span><br><span class="line">        </span><br><span class="line">        Toast.makeText(mContext, &quot;&quot;+user.toString(), Toast.LENGTH_SHORT).show();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public void onUserLoginError(String msg) &#123;</span><br><span class="line">        Toast.makeText(mContext, msg, Toast.LENGTH_SHORT).show();</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">    </span><br><span class="line">    public final static String MD5(String plain) &#123;  </span><br><span class="line">        try &#123;</span><br><span class="line">            MessageDigest md5 &#x3D; MessageDigest.getInstance(&quot;MD5&quot;);</span><br><span class="line">            md5.update(plain.getBytes(&quot;UTF-8&quot;));</span><br><span class="line">            byte[] m &#x3D; md5.digest();</span><br><span class="line">            StringBuilder hex &#x3D; new StringBuilder(m.length * 2);</span><br><span class="line">            for (byte b : m) &#123;</span><br><span class="line">                if ((b &amp; 0xFF) &lt; 0x10) hex.append(&quot;0&quot;);</span><br><span class="line">                hex.append(Integer.toHexString(b &amp; 0xFF));</span><br><span class="line">            &#125;</span><br><span class="line">            return hex.toString();</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写<br>更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9556104">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android图片圆角实现方式</title>
    <url>/2015/05/05/android-2015-05-05-android-round-pic/</url>
    <content><![CDATA[<p>android 圆角图片的实现形式，包括用第三方、也有系统的。比如makeramen:roundedimageview，系统的cardview ， glide .fresco 。</p>
<span id="more"></span>

<p><img src="http://img.blog.csdn.net/20160819134250608" alt="这里写图片描述"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &#39;com.android.support:appcompat-v7:24.0.0&#39;</span><br><span class="line">   compile &#39;com.makeramen:roundedimageview:2.2.1&#39;</span><br><span class="line">   compile &#39;com.android.support:cardview-v7:24.0.0&#39;</span><br><span class="line">   compile &#39;com.github.bumptech.glide:glide:3.7.0&#39;</span><br><span class="line">   compile &#39;com.facebook.fresco:fresco:0.12.0&#39;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;android.support.v7.widget.CardView</span><br><span class="line">    xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:app&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res-auto&quot;</span><br><span class="line">    android:id&#x3D;&quot;@+id&#x2F;id_cardview&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">    android:layout_gravity&#x3D;&quot;center_horizontal&quot;</span><br><span class="line">    app:cardBackgroundColor&#x3D;&quot;@color&#x2F;bg_light_gray&quot;</span><br><span class="line">    app:cardCornerRadius&#x3D;&quot;3dp&quot;</span><br><span class="line">    app:cardUseCompatPadding&#x3D;&quot;false&quot;</span><br><span class="line">    app:cardPreventCornerOverlap&#x3D;&quot;true&quot;</span><br><span class="line"></span><br><span class="line">    &gt;</span><br><span class="line">    &lt;ImageView</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;iv_subject&quot;</span><br><span class="line">        android:gravity&#x3D;&quot;center&quot;</span><br><span class="line">        android:scaleType&#x3D;&quot;centerCrop&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;200dp&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:paddingLeft&#x3D;&quot;5dp&quot;</span><br><span class="line">        android:paddingBottom&#x3D;&quot;5dp&quot;</span><br><span class="line">        android:background&#x3D;&quot;@drawable&#x2F;bg_biaoti&quot;</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;tv_subject&quot;</span><br><span class="line">        android:gravity&#x3D;&quot;center_vertical&quot;</span><br><span class="line">        android:text&#x3D;&quot;&quot;</span><br><span class="line">        android:ellipsize&#x3D;&quot;end&quot;</span><br><span class="line">        android:singleLine&#x3D;&quot;true&quot;</span><br><span class="line">        android:textSize&#x3D;&quot;13sp&quot;</span><br><span class="line">        android:textColor&#x3D;&quot;@color&#x2F;white&quot;</span><br><span class="line">        android:layout_gravity&#x3D;&quot;bottom&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;android.support.v7.widget.CardView&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">iv_round&#x3D;(RoundedImageView) findViewById(R.id.iv_round);</span><br><span class="line">Glide.with(this).load(url).into(iv_round);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iv_cardview&#x3D;(ImageView)findViewById(R.id.iv_cardview);</span><br><span class="line">  Glide.with(this).load(url).into(iv_cardview);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iv_fresco&#x3D;(SimpleDraweeView)findViewById(R.id.iv_fresco);</span><br><span class="line">     Glide.with(this).load(url).into(iv_round);</span><br><span class="line">     Glide.with(this).load(url).into(iv_cardview);</span><br><span class="line">     Uri uri &#x3D; Uri.parse(url);</span><br><span class="line">     iv_fresco.setImageURI(uri);</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package roundimageview.forezp.com.roundimageview;</span><br><span class="line"></span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.res.Resources;</span><br><span class="line">import android.graphics.Bitmap;</span><br><span class="line">import android.graphics.BitmapShader;</span><br><span class="line">import android.graphics.Canvas;</span><br><span class="line">import android.graphics.Paint;</span><br><span class="line">import android.graphics.RectF;</span><br><span class="line"></span><br><span class="line">import com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;</span><br><span class="line">import com.bumptech.glide.load.resource.bitmap.BitmapTransformation;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by Administrator on 2016&#x2F;8&#x2F;19 0019.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class  GlideRoundTransform extends BitmapTransformation &#123;</span><br><span class="line"></span><br><span class="line">    private static float radius &#x3D; 0f;</span><br><span class="line"></span><br><span class="line">    public GlideRoundTransform(Context context) &#123;</span><br><span class="line">        this(context, 4);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public GlideRoundTransform(Context context, int dp) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        this.radius &#x3D; Resources.getSystem().getDisplayMetrics().density * dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) &#123;</span><br><span class="line">        return roundCrop(pool, toTransform);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static Bitmap roundCrop(BitmapPool pool, Bitmap source) &#123;</span><br><span class="line">        if (source &#x3D;&#x3D; null) return null;</span><br><span class="line"></span><br><span class="line">        Bitmap result &#x3D; pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">        if (result &#x3D;&#x3D; null) &#123;</span><br><span class="line">            result &#x3D; Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Canvas canvas &#x3D; new Canvas(result);</span><br><span class="line">        Paint paint &#x3D; new Paint();</span><br><span class="line">        paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));</span><br><span class="line">        paint.setAntiAlias(true);</span><br><span class="line">        RectF rectF &#x3D; new RectF(0f, 0f, source.getWidth(), source.getHeight());</span><br><span class="line">        canvas.drawRoundRect(rectF, radius, radius, paint);</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override public String getId() &#123;</span><br><span class="line">        return getClass().getName() + Math.round(radius);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Glide.with(this).load(url).transform(new GlideRoundTransform(this,6)).into(iv_glide);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android学习路线图</title>
    <url>/2015/05/05/android-2015-05-05-android-study-way/</url>
    <content><![CDATA[<p>jixiaohua发了一篇一个老鸟也发了一份他给公司内部小伙伴整理的路线图。另一份 Android 开发学习路线图。可惜不是MarkDown格式的，所以jixiaohua直接上传的截图，在jixiaohua的呼吁下，我花了些时间，把这篇大牛的推荐清单编辑成了Markdown格式，方便大家浏览，学习。</p>
<span id="more"></span>

<p>有一些链接可能还不是特别准确，因为我只能根据图片上的书或者资源的名字去Google可能的书籍，所以链接上有什么不对的，欢迎大家评论指出，我会及时更正。请参考原文：另一份 Android 开发学习路线图 帮助修改。谢谢。</p>
<p>基础工具部分： 中文手册，我猜测是Maven中文手册，可是我并没有找到这样的资源，欢迎知道的朋友告诉我；<br>Android部分有 『第三方库集合』，我没能找到资源地址；<br>书籍我大多是给的豆瓣链接，如果觉得不合适可以替换一下；<br>关于Markdown表格</p>
<p>本来我一开始整理了一份表格版本的, 用 Mou 写的，表格内的换行用<br/>标签处理的，但是在DiyCode上来发的时候，发现Markdown表格内部不支持<br/>标签换行，所以就只能整理成平铺的文档格式。Markdown对于表格的支持不是很强大。</p>
<p>程序设计</p>
<p>一、java</p>
<p>（a）基本语法(如继承、异常、引用、泛型等)</p>
<p>Java核心技术 卷I（适合入门）<br>进阶<br>Effective Java中文版（如何写好的Java代码）<br>Java解惑 （介绍烂Java代码是什么样的）<br>（b）多线程、并发</p>
<p>Java并发编程实战 （系统全面的介绍了Java的并发，如何设计支持并发的数据结构）<br>（c）Java 7</p>
<p>Java程序员修炼之道 （详细的介绍Java 7 的新特性）<br>（d）Java 8</p>
<p>写给大忙人看的Java SE 8<br>函数式编程思维<br>（e）Java虚拟机</p>
<p>深入理解Java虚拟机 （并不是那么难，Java程序员都该看看）<br>（f）性能优化</p>
<p>Java性能优化权威指南 （后面的章节好像用处不大，前面有些部分还是值得看）<br>二、算法与数据结构</p>
<p>算法时间复杂度、空间复杂度的基本认知<br>熟悉常用数据结构：链表、队列、散列表、树等；<br>递归、分支等基本思想；<br>常用算法应用：排序、查找、比较等<br>数据结构与算法分析 （涵盖面比较全、示例是Java语言）<br>算法设计与分析基础 （实用主义的典型、偏算法设计）<br>编程珠玑 （实践型算法数据）<br>三、操作系统</p>
<p>对Linux/OS的基本认知<br>Linux的常用命令<br>鸟哥的Linux私房菜<br>Linux内核设计与实现(原书第3版) （很精炼的语言描述清楚了内核算法）<br>四、网络</p>
<p>Http/Https<br>TCP/IP<br>图解HTTP<br>图解TCP/IP<br>进阶<br>TCP/IP详解<br>五、Android</p>
<p>四大组件（服务、广播、ContentProvider、页面容器）<br>基础UI组件（ListView、ViewPager）<br>异步任务机制（AsyncTask、Handler、线程池）<br>布局优化（层级、绘制、碎片化处理）<br>图片加载（Bitmap、缓冲区）<br>UniversalMusicePlayer (通过学习一个音乐播放器的代码能很快了解四大组件)<br>Android Training官方课程<br>Android一些重要知识点解析整理<br>Android UI/UX库（各类常用组件及扩展组件的集合）<br>Picasso 、 Glide （两个图片加载库）<br>The Google I/O 2015 Android App (Google大会官方的App，适合学习各类实现)<br>Android开发技术前线 （定期翻译、发布国内外Android优质的技术、开源库、软件架构设计、测试等文章）<br>进阶<br>第三方库集合 （列举了常见的各方向第三方库）<br>软件工程</p>
<p>一、基础工具</p>
<p>IDE、Git、Maven<br>AndroidStudio<br>Git权威指南中文手册<br>二、软件质量</p>
<p>代码整洁<br>码质量<br>码重构<br>编写可读代码的艺术 （来自Google工程师，专注于代码可读性）<br>代码整洁之道（使用面向对象+敏捷开发原则编写清晰可维护的代码）<br>重构-改善既有代码的设计 （学习改善已有代码）<br>重构手册 （改善代码的实际操作）<br>三、设计模式</p>
<p>23种常见设计模式<br>大话设计模式<br>Head First设计模式(两本入门级的设计模式书籍)<br>进阶<br>设计模式-可复用面向对象软件的基础（设计模式在实际中的应用）<br>四、敏捷开发</p>
<p>解析极限编程<br>敏捷开发的艺术<br>进阶<br>敏捷软件开发-原则、模式与实践<br>五、专业开发</p>
<p>序员职业素养<br>更高效、更实效<br>程序员的是职业素养<br>程序员修炼之道-从小工到专家<br>六、思考人生</p>
<p>黑客与画家 (硅谷创业之父Paul Craham 的文集，主要介绍黑客及优秀程序员的爱好和动机)</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>拍照、选择相片</title>
    <url>/2015/05/05/android-2015-05-05-android-pic/</url>
    <content><![CDATA[<p>最近做项目需要用到拍照和选择相册照片，并显示出来imageview 上，然后压缩上传到服务器中，这本是一个非常常见的功能，但对于图片的处理确实一个技术活，稍微不注意会出现oom，图片压缩也要处理的刚刚好，不能浪费用户的流量，也不能过分的压缩使图片失真，这真的不简单，好在开源中国的安卓端app以开源，本人特意从开源中国整理了这个demo，分享给大家。</p>
<span id="more"></span>

<p>进入相册选择照片：注意6.0之后要申请运行时权限，即api23。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intent intent;</span><br><span class="line">       <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">19</span>) &#123;</span><br><span class="line">           intent = <span class="keyword">new</span> Intent();</span><br><span class="line">           intent.setAction(Intent.ACTION_GET_CONTENT);</span><br><span class="line">           intent.setType(<span class="string">&quot;image/*&quot;</span>);</span><br><span class="line">           startActivityForResult(Intent.createChooser(intent, <span class="string">&quot;选择图片&quot;</span>), ImageUtils.REQUEST_CODE_GETIMAGE_BYSDCARD);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           intent = <span class="keyword">new</span> Intent(Intent.ACTION_PICK, MediaStore.Images.Media.EXTERNAL_CONTENT_URI);</span><br><span class="line">           intent.setType(<span class="string">&quot;image/*&quot;</span>);</span><br><span class="line">           startActivityForResult(Intent.createChooser(intent, <span class="string">&quot;选择图片&quot;</span>), ImageUtils.REQUEST_CODE_GETIMAGE_BYSDCARD);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>或者拍照：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void toCamera() &#123;</span><br><span class="line">      &#x2F;&#x2F; 判断是否挂载了SD卡</span><br><span class="line">      String savePath &#x3D; &quot;&quot;;</span><br><span class="line">      String storageState &#x3D; Environment.getExternalStorageState();</span><br><span class="line">      if (storageState.equals(Environment.MEDIA_MOUNTED)) &#123;</span><br><span class="line">          savePath &#x3D; Environment.getExternalStorageDirectory()</span><br><span class="line">                  .getAbsolutePath() + &quot;&#x2F;oschina&#x2F;Camera&#x2F;&quot;;</span><br><span class="line">          File savedir &#x3D; new File(savePath);</span><br><span class="line">          if (!savedir.exists()) &#123;</span><br><span class="line">              savedir.mkdirs();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 没有挂载SD卡，无法保存文件</span><br><span class="line">      if (TextUtils.isEmpty(savePath)) &#123;</span><br><span class="line">         &#x2F;&#x2F; AppContext.showToastShort(&quot;无法保存照片，请检查SD卡是否挂载&quot;);</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      String timeStamp &#x3D; new SimpleDateFormat(&quot;yyyyMMddHHmmss&quot;).format(new Date());</span><br><span class="line">      String fileName &#x3D; timeStamp + &quot;.jpg&quot;;&#x2F;&#x2F; 照片命名</span><br><span class="line">      File out &#x3D; new File(savePath, fileName);</span><br><span class="line">      Uri uri &#x3D; Uri.fromFile(out);</span><br><span class="line">      &#x2F;&#x2F;tweet.setImageFilePath(savePath + fileName); &#x2F;&#x2F; 该照片的绝对路径</span><br><span class="line">      mPhotoPath&#x3D;savePath + fileName;</span><br><span class="line">      Intent intent &#x3D; new Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">      intent.putExtra(MediaStore.EXTRA_OUTPUT, uri);</span><br><span class="line">      startActivityForResult(intent, ImageUtils.REQUEST_CODE_GETIMAGE_BYCAMERA);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在onActivity获取图片信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123;</span><br><span class="line">       super.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">       if (resultCode !&#x3D; Activity.RESULT_OK)</span><br><span class="line">           return;</span><br><span class="line">       if (requestCode &#x3D;&#x3D; ImageUtils.REQUEST_CODE_GETIMAGE_BYSDCARD) &#123;</span><br><span class="line">           if (data &#x3D;&#x3D; null)</span><br><span class="line">               return;</span><br><span class="line">           Uri selectedImageUri &#x3D; data.getData();</span><br><span class="line">           if (selectedImageUri !&#x3D; null) &#123;</span><br><span class="line">               String path &#x3D; ImageUtils.getImagePath(selectedImageUri, this);</span><br><span class="line">               setImageFromPath(path);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else if (requestCode &#x3D;&#x3D; ImageUtils.REQUEST_CODE_GETIMAGE_BYCAMERA) &#123;</span><br><span class="line">           &#x2F;&#x2F;setImageFromPath(tweet.getImageFilePath());</span><br><span class="line">           setImageFromPath(mPhotoPath);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过返回的uri获取图片路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 通过Uri获取文件路径</span><br><span class="line">    * 支持图片媒体,文件等</span><br><span class="line">    * &lt;p&#x2F;&gt;</span><br><span class="line">    * Author qiujuer@live.cn</span><br><span class="line">    *</span><br><span class="line">    * @param uri     Uri</span><br><span class="line">    * @param context Context</span><br><span class="line">    * @return 文件路径</span><br><span class="line">    *&#x2F;</span><br><span class="line">   @SuppressLint(&#123;&quot;NewApi&quot;, &quot;Recycle&quot;&#125;)</span><br><span class="line">   public static String getImagePath(Uri uri, Context context) &#123;</span><br><span class="line">       String selection &#x3D; null;</span><br><span class="line">       String[] selectionArgs &#x3D; null;</span><br><span class="line">       &#x2F;&#x2F; Uri is different in versions after KITKAT (Android 4.4), we need to</span><br><span class="line">       if (Build.VERSION.SDK_INT &gt;&#x3D; 19 &amp;&amp; DocumentsContract.isDocumentUri(context.getApplicationContext(), uri)) &#123;</span><br><span class="line">           String authority &#x3D; uri.getAuthority();</span><br><span class="line">           if (&quot;com.android.externalstorage.documents&quot;.equals(authority)) &#123;</span><br><span class="line">               &#x2F;&#x2F; isExternalStorageDocument</span><br><span class="line">               final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">               final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">               return Environment.getExternalStorageDirectory() + &quot;&#x2F;&quot; + split[1];</span><br><span class="line">           &#125; else if (&quot;com.android.providers.downloads.documents&quot;.equals(authority)) &#123;</span><br><span class="line">               &#x2F;&#x2F; isDownloadsDocument</span><br><span class="line">               final String id &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">               uri &#x3D; ContentUris.withAppendedId(</span><br><span class="line">                       Uri.parse(&quot;content:&#x2F;&#x2F;downloads&#x2F;public_downloads&quot;), Long.valueOf(id));</span><br><span class="line">           &#125; else if (&quot;com.android.providers.media.documents&quot;.equals(authority)) &#123;</span><br><span class="line">               &#x2F;&#x2F; isMediaDocument</span><br><span class="line">               final String docId &#x3D; DocumentsContract.getDocumentId(uri);</span><br><span class="line">               final String[] split &#x3D; docId.split(&quot;:&quot;);</span><br><span class="line">               final String type &#x3D; split[0];</span><br><span class="line">               if (&quot;image&quot;.equals(type)) &#123;</span><br><span class="line">                   uri &#x3D; MediaStore.Images.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">               &#125; else if (&quot;video&quot;.equals(type)) &#123;</span><br><span class="line">                   uri &#x3D; MediaStore.Video.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">               &#125; else if (&quot;audio&quot;.equals(type)) &#123;</span><br><span class="line">                   uri &#x3D; MediaStore.Audio.Media.EXTERNAL_CONTENT_URI;</span><br><span class="line">               &#125;</span><br><span class="line">               selection &#x3D; &quot;_id&#x3D;?&quot;;</span><br><span class="line">               selectionArgs &#x3D; new String[]&#123;</span><br><span class="line">                       split[1]</span><br><span class="line">               &#125;;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if (&quot;content&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">           String[] projection &#x3D; &#123;MediaStore.Images.Media.DATA&#125;;</span><br><span class="line">           Cursor cursor &#x3D; null;</span><br><span class="line">           try &#123;</span><br><span class="line">               cursor &#x3D; context.getContentResolver()</span><br><span class="line">                       .query(uri, projection, selection, selectionArgs, null);</span><br><span class="line">               if (cursor !&#x3D; null) &#123;</span><br><span class="line">                   int column_index &#x3D; cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DATA);</span><br><span class="line">                   if (cursor.moveToFirst()) &#123;</span><br><span class="line">                       return cursor.getString(column_index);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; catch (Exception e) &#123;</span><br><span class="line">               e.fillInStackTrace();</span><br><span class="line">           &#125; finally &#123;</span><br><span class="line">               if (cursor !&#x3D; null)</span><br><span class="line">                   cursor.close();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; else if (&quot;file&quot;.equalsIgnoreCase(uri.getScheme())) &#123;</span><br><span class="line">           return uri.getPath();</span><br><span class="line">       &#125;</span><br><span class="line">       return null;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>根据图片地址去获取bitmap这时需要自己传入图片的大小即高度和宽度，根据自己的需求去传。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bitmap bitmap &#x3D; BitmapCreate.bitmapFromStream(new FileInputStream(path), 512, 512);</span><br></pre></td></tr></table></figure>
<p>图片压缩</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">   * 获取一个指定大小的bitmap&lt;br&gt;</span><br><span class="line">   * 实际调用的方法是bitmapFromByteArray(data, 0, data.length, w, h);</span><br><span class="line">   *</span><br><span class="line">   * @param is        从输入流中读取Bitmap</span><br><span class="line">   * @param reqWidth  目标宽度</span><br><span class="line">   * @param reqHeight 目标高度</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static Bitmap bitmapFromStream(InputStream is, int reqWidth,</span><br><span class="line">                                        int reqHeight) &#123;</span><br><span class="line">      if (reqHeight &#x3D;&#x3D; 0 || reqWidth &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              return BitmapFactory.decodeStream(is);</span><br><span class="line">          &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      byte[] data &#x3D; FileUtils.input2byte(is);</span><br><span class="line">      return bitmapFromByteArray(data, 0, data.length, reqWidth, reqHeight);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 获取一个指定大小的bitmap</span><br><span class="line">   *</span><br><span class="line">   * @param data      Bitmap的byte数组</span><br><span class="line">   * @param offset    image从byte数组创建的起始位置</span><br><span class="line">   * @param length    the number of bytes, 从offset处开始的长度</span><br><span class="line">   * @param reqWidth  目标宽度</span><br><span class="line">   * @param reqHeight 目标高度</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static Bitmap bitmapFromByteArray(byte[] data, int offset,</span><br><span class="line">                                           int length, int reqWidth, int reqHeight) &#123;</span><br><span class="line">      if (reqHeight &#x3D;&#x3D; 0 || reqWidth &#x3D;&#x3D; 0) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              return BitmapFactory.decodeByteArray(data, offset, length);</span><br><span class="line">          &#125; catch (OutOfMemoryError e) &#123;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      BitmapFactory.Options options &#x3D; new BitmapFactory.Options();</span><br><span class="line">      options.inJustDecodeBounds &#x3D; true;</span><br><span class="line">      options.inPurgeable &#x3D; true;</span><br><span class="line">      BitmapFactory.decodeByteArray(data, offset, length, options);</span><br><span class="line">      options &#x3D; calculateInSampleSize(options, reqWidth, reqHeight);</span><br><span class="line">      return BitmapFactory.decodeByteArray(data, offset, length, options);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 图片压缩处理（使用Options的方法）</span><br><span class="line">   * &lt;br&gt;</span><br><span class="line">   * &lt;b&gt;说明&lt;&#x2F;b&gt; 使用方法：</span><br><span class="line">   * 首先你要将Options的inJustDecodeBounds属性设置为true，BitmapFactory.decode一次图片 。</span><br><span class="line">   * 然后将Options连同期望的宽度和高度一起传递到到本方法中。</span><br><span class="line">   * 之后再使用本方法的返回值做参数调用BitmapFactory.decode创建图片。</span><br><span class="line">   * &lt;br&gt;</span><br><span class="line">   * &lt;b&gt;说明&lt;&#x2F;b&gt; BitmapFactory创建bitmap会尝试为已经构建的bitmap分配内存</span><br><span class="line">   * ，这时就会很容易导致OOM出现。为此每一种创建方法都提供了一个可选的Options参数</span><br><span class="line">   * ，将这个参数的inJustDecodeBounds属性设置为true就可以让解析方法禁止为bitmap分配内存</span><br><span class="line">   * ，返回值也不再是一个Bitmap对象， 而是null。虽然Bitmap是null了，但是Options的outWidth、</span><br><span class="line">   * outHeight和outMimeType属性都会被赋值。</span><br><span class="line">   *</span><br><span class="line">   * @param reqWidth  目标宽度,这里的宽高只是阀值，实际显示的图片将小于等于这个值</span><br><span class="line">   * @param reqHeight 目标高度,这里的宽高只是阀值，实际显示的图片将小于等于这个值</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static BitmapFactory.Options calculateInSampleSize(</span><br><span class="line">          final BitmapFactory.Options options, final int reqWidth,</span><br><span class="line">          final int reqHeight) &#123;</span><br><span class="line">      &#x2F;&#x2F; 源图片的高度和宽度</span><br><span class="line">      final int height &#x3D; options.outHeight;</span><br><span class="line">      final int width &#x3D; options.outWidth;</span><br><span class="line">      int inSampleSize &#x3D; 1;</span><br><span class="line">      if (height &gt; reqHeight || width &gt; reqWidth) &#123;</span><br><span class="line">          &#x2F;&#x2F; 计算出实际宽高和目标宽高的比率</span><br><span class="line">          final int heightRatio &#x3D; Math.round((float) height</span><br><span class="line">                  &#x2F; (float) reqHeight);</span><br><span class="line">          final int widthRatio &#x3D; Math.round((float) width &#x2F; (float) reqWidth);</span><br><span class="line">          &#x2F;&#x2F; 选择宽和高中最小的比率作为inSampleSize的值，这样可以保证最终图片的宽和高</span><br><span class="line">          &#x2F;&#x2F; 一定都会大于等于目标的宽和高。</span><br><span class="line">          inSampleSize &#x3D; heightRatio &lt; widthRatio ? heightRatio : widthRatio;</span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F; 设置压缩比例</span><br><span class="line">      options.inSampleSize &#x3D; inSampleSize;</span><br><span class="line">      options.inJustDecodeBounds &#x3D; false;</span><br><span class="line">      return options;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>将压缩后的bitmap存在sdcard中，待会儿要上传到服务器中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * 图片写入文件</span><br><span class="line">   *</span><br><span class="line">   * @param bitmap</span><br><span class="line">   *            图片</span><br><span class="line">   * @param filePath</span><br><span class="line">   *            文件路径</span><br><span class="line">   * @return 是否写入成功</span><br><span class="line">   *&#x2F;</span><br><span class="line">  public static boolean bitmapToFile(Bitmap bitmap, String filePath) &#123;</span><br><span class="line">      boolean isSuccess &#x3D; false;</span><br><span class="line">      if (bitmap &#x3D;&#x3D; null) &#123;</span><br><span class="line">          return isSuccess;</span><br><span class="line">      &#125;</span><br><span class="line">      File file &#x3D; new File(filePath.substring(0,</span><br><span class="line">              filePath.lastIndexOf(File.separator)));</span><br><span class="line">      if (!file.exists()) &#123;</span><br><span class="line">          file.mkdirs();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      OutputStream out &#x3D; null;</span><br><span class="line">      try &#123;</span><br><span class="line">          out &#x3D; new BufferedOutputStream(new FileOutputStream(filePath),</span><br><span class="line">                  8 * 1024);</span><br><span class="line">          isSuccess &#x3D; bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);</span><br><span class="line">      &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">      &#125; finally &#123;</span><br><span class="line">          closeIO(out);</span><br><span class="line">      &#125;</span><br><span class="line">      return isSuccess;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>将压缩后的bitmap 根据需求进一步缩放，显示在imageview上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * 放大缩小图片</span><br><span class="line">    *</span><br><span class="line">    * @param bitmap</span><br><span class="line">    * @param w</span><br><span class="line">    * @param h</span><br><span class="line">    * @return</span><br><span class="line">    *&#x2F;</span><br><span class="line">   public static Bitmap zoomBitmap(Bitmap bitmap, int w, int h) &#123;</span><br><span class="line">       Bitmap newbmp &#x3D; null;</span><br><span class="line">       if (bitmap !&#x3D; null) &#123;</span><br><span class="line">           int width &#x3D; bitmap.getWidth();</span><br><span class="line">           int height &#x3D; bitmap.getHeight();</span><br><span class="line">           Matrix matrix &#x3D; new Matrix();</span><br><span class="line">           float scaleWidht &#x3D; ((float) w &#x2F; width);</span><br><span class="line">           float scaleHeight &#x3D; ((float) h &#x2F; height);</span><br><span class="line">           matrix.postScale(scaleWidht, scaleHeight);</span><br><span class="line">           newbmp &#x3D; Bitmap.createBitmap(bitmap, 0, 0, width, height, matrix,</span><br><span class="line">                   true);</span><br><span class="line">       &#125;</span><br><span class="line">       return newbmp;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在拍照的过程中，有的机型照片会倒转，这是需要处理一下即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">     * 读取图片属性：旋转的角度</span><br><span class="line">     * @param path 图片绝对路径</span><br><span class="line">     * @return degree旋转的角度</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static int readPictureDegree(String path) &#123;</span><br><span class="line">        int degree  &#x3D; 0;</span><br><span class="line">        try &#123;</span><br><span class="line">            ExifInterface exifInterface &#x3D; new ExifInterface(path);</span><br><span class="line">            int orientation &#x3D; exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL);</span><br><span class="line">            switch (orientation) &#123;</span><br><span class="line">                case ExifInterface.ORIENTATION_ROTATE_90:</span><br><span class="line">                    degree &#x3D; 90;</span><br><span class="line">                    break;</span><br><span class="line">                case ExifInterface.ORIENTATION_ROTATE_180:</span><br><span class="line">                    degree &#x3D; 180;</span><br><span class="line">                    break;</span><br><span class="line">                case ExifInterface.ORIENTATION_ROTATE_270:</span><br><span class="line">                    degree &#x3D; 270;</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return degree;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 旋转图片</span><br><span class="line">     * @param angle</span><br><span class="line">     * @param bitmap</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Bitmap rotaingImageView(int angle , Bitmap bitmap) &#123;</span><br><span class="line">        &#x2F;&#x2F;旋转图片 动作</span><br><span class="line">        Matrix matrix &#x3D; new Matrix();</span><br><span class="line">        matrix.postRotate(angle);</span><br><span class="line">        System.out.println(&quot;angle2&#x3D;&quot; + angle);</span><br><span class="line">        &#x2F;&#x2F; 创建新的图片</span><br><span class="line">        Bitmap resizedBitmap &#x3D; Bitmap.createBitmap(bitmap, 0, 0,</span><br><span class="line">                bitmap.getWidth(), bitmap.getHeight(), matrix, true);</span><br><span class="line">        return resizedBitmap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这些代码百分之七八十来自开源中国。感谢原作者。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/forezp/SelectPicAndCamera">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>省市区三级联动</title>
    <url>/2015/05/05/android-2015-05-05-android-ssq-sjliand/</url>
    <content><![CDATA[<p>最近项目，需要用到三级联动，在网上找了一些例子，进行了修改，实现，提炼出来了给大家分享<br>实现思路是在三个wheelview 进行联动。选择了省，马上就关联到市和区，选择了市 ，马上就可以关联到区。</p>
<span id="more"></span>

<p>效果图：</p>
<img src="http://img.blog.csdn.net/20160616165630865" width = "300"  alt="图片名称" align=center />
首先建了三个Model 用于存数据
存省 和市的list 和区的
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProvinceInfoModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;CityInfoModel&gt; cityList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProvinceInfoModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProvinceInfoModel</span><span class="params">(String name, List&lt;CityInfoModel&gt; cityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.cityList = cityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;CityInfoModel&gt; <span class="title">getCityList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCityList</span><span class="params">(List&lt;CityInfoModel&gt; cityList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cityList = cityList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;ProvinceInfoModel [name=&quot;</span> + name + <span class="string">&quot;, cityList=&quot;</span> + cityList + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
存市和其对应的区list
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CityInfoModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;DistrictInfoModel&gt; districtList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CityInfoModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CityInfoModel</span><span class="params">(String name, List&lt;DistrictInfoModel&gt; districtList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.districtList = districtList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;DistrictInfoModel&gt; <span class="title">getDistrictList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> districtList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDistrictList</span><span class="params">(List&lt;DistrictInfoModel&gt; districtList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.districtList = districtList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;CityInfoModel [name=&quot;</span> + name + <span class="string">&quot;, districtList=&quot;</span> + districtList</span><br><span class="line">                + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
区的modeL
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DistrictInfoModel</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String zipcode;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistrictInfoModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DistrictInfoModel</span><span class="params">(String name, String zipcode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.zipcode = zipcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getZipcode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> zipcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setZipcode</span><span class="params">(String zipcode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.zipcode = zipcode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;DistrictInfoModel [name=&quot;</span> + name + <span class="string">&quot;, zipcode=&quot;</span> + zipcode + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
数据存储在xml中，在assets目录下，详情见源代码，代码太多了。

<p>用的sax解析xml并得到数据存储在内存中</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddrXmlParser</span> <span class="keyword">extends</span> <span class="title">DefaultHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;ProvinceInfoModel&gt; provinceList = <span class="keyword">new</span> ArrayList&lt;ProvinceInfoModel&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> java.util.<span class="function">List&lt;ProvinceInfoModel&gt; <span class="title">getDataList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> provinceList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startDocument</span><span class="params">()</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ProvinceInfoModel provinceModel = <span class="keyword">new</span> ProvinceInfoModel();</span><br><span class="line">    CityInfoModel cityModel = <span class="keyword">new</span> CityInfoModel();</span><br><span class="line">    DistrictInfoModel districtModel = <span class="keyword">new</span> DistrictInfoModel();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startElement</span><span class="params">(String uri, String localName, String qName,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Attributes attributes)</span> <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qName.equals(<span class="string">&quot;province&quot;</span>)) &#123;</span><br><span class="line">            provinceModel = <span class="keyword">new</span> ProvinceInfoModel();</span><br><span class="line">            provinceModel.setName(attributes.getValue(<span class="number">0</span>));</span><br><span class="line">            provinceModel.setCityList(<span class="keyword">new</span> ArrayList&lt;CityInfoModel&gt;());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">&quot;city&quot;</span>)) &#123;</span><br><span class="line">            cityModel = <span class="keyword">new</span> CityInfoModel();</span><br><span class="line">            cityModel.setName(attributes.getValue(<span class="number">0</span>));</span><br><span class="line">            cityModel.setDistrictList(<span class="keyword">new</span> ArrayList&lt;DistrictInfoModel&gt;());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">&quot;district&quot;</span>)) &#123;</span><br><span class="line">            districtModel = <span class="keyword">new</span> DistrictInfoModel();</span><br><span class="line">            districtModel.setName(attributes.getValue(<span class="number">0</span>));</span><br><span class="line">            districtModel.setZipcode(attributes.getValue(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endElement</span><span class="params">(String uri, String localName, String qName)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (qName.equals(<span class="string">&quot;district&quot;</span>)) &#123;</span><br><span class="line">            cityModel.getDistrictList().add(districtModel);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">&quot;city&quot;</span>)) &#123;</span><br><span class="line">            provinceModel.getCityList().add(cityModel);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qName.equals(<span class="string">&quot;province&quot;</span>)) &#123;</span><br><span class="line">            provinceList.add(provinceModel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">characters</span><span class="params">(<span class="keyword">char</span>[] ch, <span class="keyword">int</span> start, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> SAXException </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要在activity 中开启线程读取数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">readAddrDatas</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;ProvinceInfoModel&gt; provinceList = <span class="keyword">null</span>;</span><br><span class="line">        AssetManager asset = getAssets();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream input = asset.open(<span class="string">&quot;province_data.xml&quot;</span>);</span><br><span class="line">            SAXParserFactory spf = SAXParserFactory.newInstance();</span><br><span class="line">            SAXParser parser = spf.newSAXParser();</span><br><span class="line">            AddrXmlParser handler = <span class="keyword">new</span> AddrXmlParser();</span><br><span class="line">            parser.parse(input, handler);</span><br><span class="line">            input.close();</span><br><span class="line">            provinceList = handler.getDataList();</span><br><span class="line">            <span class="keyword">if</span> (provinceList != <span class="keyword">null</span> &amp;&amp; !provinceList.isEmpty()) &#123;</span><br><span class="line">                mCurrentProviceName = provinceList.get(<span class="number">0</span>).getName();</span><br><span class="line">                List&lt;CityInfoModel&gt; cityList = provinceList.get(<span class="number">0</span>).getCityList();</span><br><span class="line">                <span class="keyword">if</span> (cityList != <span class="keyword">null</span> &amp;&amp; !cityList.isEmpty()) &#123;</span><br><span class="line">                    mCurrentCityName = cityList.get(<span class="number">0</span>).getName();</span><br><span class="line">                    List&lt;DistrictInfoModel&gt; districtList = cityList.get(<span class="number">0</span>).getDistrictList();</span><br><span class="line">                    mCurrentDistrictName = districtList.get(<span class="number">0</span>).getName();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            mProvinceDatas = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; provinceList.size(); i++) &#123;</span><br><span class="line">                mProvinceDatas.add(provinceList.get(i).getName());</span><br><span class="line">                List&lt;CityInfoModel&gt; cityList = provinceList.get(i).getCityList();</span><br><span class="line">                ArrayList&lt;String&gt; cityNames = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cityList.size(); j++) &#123;</span><br><span class="line">                    cityNames.add(cityList.get(j).getName());</span><br><span class="line">                    List&lt;DistrictInfoModel&gt; districtList = cityList.get(j).getDistrictList();</span><br><span class="line">                    ArrayList&lt;String&gt; distrinctNameArray = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                    DistrictInfoModel[] distrinctArray = <span class="keyword">new</span> DistrictInfoModel[districtList.size()];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; districtList.size(); k++) &#123;</span><br><span class="line">                        DistrictInfoModel districtModel = <span class="keyword">new</span> DistrictInfoModel(districtList.get(k).getName(), districtList.get(k).getZipcode());</span><br><span class="line">                        distrinctArray[k] = districtModel;</span><br><span class="line">                        distrinctNameArray.add(districtModel.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                    mDistrictDatasMap.put(cityNames.get(j), distrinctNameArray);</span><br><span class="line">                &#125;</span><br><span class="line">                mCitisDatasMap.put(provinceList.get(i).getName(), cityNames);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读取完数据需要设置weelview 的数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mProvincePicker.setOnSelectListener(<span class="keyword">new</span> WheelView.OnSelectListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">endSelect</span><span class="params">(<span class="keyword">int</span> id, String text)</span> </span>&#123;</span><br><span class="line">               String provinceText = mProvinceDatas.get(id);</span><br><span class="line">               <span class="keyword">if</span> (!mCurrentProviceName.equals(provinceText)) &#123;</span><br><span class="line">                   mCurrentProviceName = provinceText;</span><br><span class="line">                   ArrayList&lt;String&gt; mCityData = mCitisDatasMap.get(mCurrentProviceName);</span><br><span class="line">                   mCityPicker.resetData(mCityData);</span><br><span class="line">                   mCityPicker.setDefault(<span class="number">0</span>);</span><br><span class="line">                   mCurrentCityName = mCityData.get(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">                   ArrayList&lt;String&gt; mDistrictData = mDistrictDatasMap.get(mCurrentCityName);</span><br><span class="line">                   mCountyPicker.resetData(mDistrictData);</span><br><span class="line">                   mCountyPicker.setDefault(<span class="number">0</span>);</span><br><span class="line">                   mCurrentDistrictName = mDistrictData.get(<span class="number">0</span>);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">selecting</span><span class="params">(<span class="keyword">int</span> id, String text)</span> </span>&#123;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure>

<p>代码不一一写成，详情见源码。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9551637">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>瓣呀，一个非官方的豆瓣app</title>
    <url>/2015/05/05/android-2015-05-05-banya/</url>
    <content><![CDATA[<h1 id="瓣呀，一个非官方的豆瓣app"><a href="#瓣呀，一个非官方的豆瓣app" class="headerlink" title="瓣呀，一个非官方的豆瓣app"></a>瓣呀，一个非官方的豆瓣app</h1><p>源码下载： <a target="_blank" rel="noopener" href="https://github.com/forezp/banya">https://github.com/forezp/banya</a></p>
<span id="more"></span>

<ul>
<li><p>首页分为三大模块，包括：电影、看书、音乐。而电影模块又包括最近热门电影、TOP250；看书模块包括综合、文学、流行、文化、生活五个部分；音乐模块包括流行、经典、韩系、欧美四个模块。</p>
</li>
<li><p>首页界面风格采用Material Design设计规范，使用了CoordinatorLayout和viewpager配合，使用behavior属性对toolbar的显示和隐藏进行了控制，tablayout和viewpager配合，viewpager切换fragment，整体界面模仿了网易云音乐。</p>
</li>
<li><p>抽屉界面的实现是使用DrawerLayout和NavigationView配合，使用的icon来自<a target="_blank" rel="noopener" href="https://design.google.com/icons/index.html">material design icon</a>。</p>
</li>
<li><p>详情界面模仿了豆瓣app的详情界面，包括了电影详情、音乐详情、书籍详情，另外使用了webview 对详情页面和导演、演员、作者歌手的个人信息进行了展示。</p>
</li>
<li><p>项目整体采用mvp+rxjava+retrofit 框架，用butterknif注解，使用glide进行图片展示，另外使用了java8的拉姆达表达式，安卓原生并不支持，需要导插件。</p>
</li>
<li><p>对okhttpClient进行了缓存配置，然而豆瓣API对Cache-Control的设置为no-cache，所以目前没有缓存，需要自己实现，后面会花时间用Realm去实现本地缓存。</p>
</li>
<li><p>整体界面采用了沉浸式布局，另外使用了主题切换。在切换主题时，存在一个bug，切换时 statusBar的颜色并没有改变，这个问题已经提交给了<a target="_blank" rel="noopener" href="https://github.com/laobie/StatusBarUtil">StatusBarUtil</a> 的作者。</p>
</li>
</ul>
<h2 id="ScreenShot"><a href="#ScreenShot" class="headerlink" title="ScreenShot"></a>ScreenShot</h2><p><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-4b643a88dc389ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-4b643a88dc389ac5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-e1957c770e7ded13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-e1957c770e7ded13.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a><br><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-db261ac4eda9332f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-db261ac4eda9332f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-ff6527c9926d5ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-ff6527c9926d5ca3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a><br><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-d491957f5d4937d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-d491957f5d4937d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-7db6a539cedd037f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-7db6a539cedd037f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a><br><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-90e41d49e9bab397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-90e41d49e9bab397.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-31aec938d435e736.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-31aec938d435e736.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a><br><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-fbc8b7784a474dbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-fbc8b7784a474dbf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-56edca81b54f0fcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-56edca81b54f0fcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a><br><a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-51fcc42efce3a2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-51fcc42efce3a2a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a> <a target="_blank" rel="noopener" href="http://upload-images.jianshu.io/upload_images/2279594-4c6e98905233f15b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><img src="http://upload-images.jianshu.io/upload_images/2279594-4c6e98905233f15b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" width="33%"/></a></p>
<h2 id="api"><a href="#api" class="headerlink" title="api"></a>api</h2><p>app所以的api都来自<a target="_blank" rel="noopener" href="https://developers.douban.com/wiki/?title=api_v2">豆瓣Api V2（测试版）</a>;一切数据都归豆瓣所有。</p>
<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>该项目仅供交流学习使用，如果该项目有侵犯版权问题，或被告知需停止共享与使用，本人会及时删除此页面与整个项目。</p>
<h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxJava">RXJava</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/square/okhttp">okhttp</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/square/retrofit">retrofit</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/JakeWharton/butterknife">butterknif</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/bumptech/glide">glide</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/laobie/StatusBarUtil">StatusBarUtil</a></li>
</ul>
<h2 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h2><p>一个在深圳的全栈开发者，对技术有着强烈的追求。</p>
<h2 id="联系我"><a href="#联系我" class="headerlink" title="联系我:"></a>联系我:</h2><ul>
<li>Email:<a href="mailto:&#49;&#x32;&#52;&#x37;&#x34;&#54;&#x34;&#48;&#x36;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;">&#49;&#x32;&#52;&#x37;&#x34;&#54;&#x34;&#48;&#x36;&#x40;&#x71;&#x71;&#x2e;&#99;&#x6f;&#x6d;</a></li>
<li>jianshu: <a target="_blank" rel="noopener" href="http://www.jianshu.com/users/f2550db5eca3/latest_articles">jianshu</a></li>
<li>Blog : <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">csdn blog</a></li>
<li>GitHub: <a target="_blank" rel="noopener" href="https://github.com/forezp">Forezp</a></li>
</ul>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>Copyright 2016 Forezp</p>
<p>Licensed under the Apache License, Version 2.0 (the “License”); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p>
<p><a target="_blank" rel="noopener" href="http://www.apache.org/licenses/LICENSE-2.0">http://www.apache.org/licenses/LICENSE-2.0</a></p>
<p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an “AS IS” BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>拆掉思维的墙</title>
    <url>/2015/05/05/android-2015-05-05-cdswdq/</url>
    <content><![CDATA[<p>你是不是在追求安全感？</p>
<span id="more"></span>

<p>思维有时候给我们太多的禁锢，安全感就是其一。为了生活安全感，有人放弃了梦想；为了职业安全感，有人放弃了多样的可能；为了爱的安全感，有人放弃了真正的人生。<br>安全感的需要源自我们内在的恐惧。恐惧有三层：<br>第一层是恐惧做不成某件事；<br>第二层是恐惧做不成时别人对我们的开法或批评；<br>第三层是恐惧我们无法应对这样的看法或批评。<br>其实，恐惧就像一个懦夫，当你撸起袖子准备跟它大干一场的时候，它却逃的无影踪。<br>排除恐惧要问自己两个触底反弹的问题：如果我失败了，新来替代我的那个家伙，他会怎么办？既然这样，为什么我们不这样去做？</p>
<p>逃出安全感，让有趣的生命扑面而来</p>
<p>逃出安全感的掌控，让有趣的生命扑面而来，生活不是单调的百分之百。可是，生活和工作中我们总会遇到不感兴趣的人和感兴趣的人。前者日复一日重复的活着，就像复读机，数十年如一日。后者总是活力四射，充满好奇，不断尝试并乐于分享其中带来的喜悦。<br>做一个有趣之人，生活也会对你有趣，而无趣之人往往是因为缺乏胆识，不敢冒险，也不能体验探索的乐趣。有趣之人，冒险——投入，成功了是一种收获，不成功也会有快乐甚至智慧。无趣之人，冒险——投入，成功了会担心失败，不成功也会有恐惧。<br>生命不是追求一个结果，而是一个追求快乐的过程。投入到当下之中，只有在投入中体验的快乐才是无条件的快乐。</p>
<p>心智模决定命运</p>
<p>你的思维决定你的疆域。你的见识决定你看到的世界。正如小时候我只知道电灯电话楼上楼下，没有想过网络世界的神奇，更没有想过移动互联网带给生活的便捷。永远不要给可能性设置障碍，要知道凡是所想皆有存在，我们只是需要发现和等待。 </p>
<p>成功学不能学</p>
<p>成功永远都是小概率事件，过的非常惨也一样是小概率事件。这是社会学正态分布告诉我们的。可是，为什么还有所谓的成功学大师？他们在一次次推销自己的成功理论，让你心潮澎湃。但是你要知道，历史和经历是无法模仿的，唯有在自己的梦想之路越走越近。<br>success源自中古英语succeden，前面是拉丁文前缀suc，代表“靠近、接近”。后面是“走”的词根cess。所以，success本意是：越走越近。如果你有一个梦想，就去捍卫它；如果你有一个目标就去争取它。走起来，不羡慕走在高处的人，不轻视走在你后面的人，成功就是越走越近。 </p>
<p>如何找到热衷一生的事业？</p>
<p>如果你还在等待一个热衷一生的事业，打算找到后再全力以赴，那么你是不可能找到的。这就是小说和现实的区别。你只有在该尝试的年纪不停的尝试，在该专注的年纪专注投入，才能找到热衷一生的事业。<br>选择职业与恋爱一样，如果你只和结婚对象谈恋爱，那么很难找到结婚的人。选择职业也要“一见钟情很多，两情相悦一些，白头偕老一个”。<br>职业是你的天赋和现实世界的结合，不要奢望能有30年，50年的规划。在你视野所及的范围内精细计划，在你听说的范围内需要大方向的规划，而那些你连听都没听说过的地方，你需要的是相信。 </p>
<p>原来我还可以这样活</p>
<p>投入当下，体验越来越近的成功感也许是最好的活法。但是，有两种心智模式决定着你的幸福感：受害者模式和掌控者模式。受害者习惯于把自己的痛苦和快乐放在别人手上，面带怨气。掌控者乐观积极，把每件事情都看成生命的一件礼物，自我掌控，总能做好当下。你是哪一种？ </p>
<p>幸福是一种转换力</p>
<p>每个人内在都存在一个男人和一个女人。男人代表社会系统，是通过对外获取资源得以生存；女人代表自我系统，将资源转换为内心的幸福感得以让生存变得更好。小时候，社会系统和自我系统均衡发展，但随着成长我们越来越会看社会的要求，家长亲友的态度，同龄人的攀比。在竞争中社会系统变得越来越强大，而自我系统相对越来越渺小，以至于有些人丧生了自我系统，无论获取再多的资源也无法更好的生活，没有幸福感而言。很多人会掉入父母的剧本里去扮演一个自己，也有很多人落入世俗里随波逐流，从未思考过我是谁，从未想过活出自己。 </p>
<p>上天不需要你成功，只需要你尝试</p>
<p>活出自己需要不断的尝试，在当下立即行动。不要在抱怨中浪费生命，陷入“等死模式”。与其在等待中枯萎不如在等待中绽放。但是，你也许有这样的经验，雄心壮志制定一个长远的计划，然后浅尝辄止，没有了下文。我们要警惕自己变成一个“开始爱好者”，仅仅在开始时热情高涨，却无法坚持下来。但无论如何不要去等待一个万事具备的开始，我们虽然常说好的开始是成功的一半，可是坏的开始也是成功的三分之一。</p>
<p>成长为自己的样子</p>
<p>测评无法预测你的未来，只有内心才知道自己的样子。时常问问自己：我到底希望自己成为什么样子的人？或许给自己设定几个关键词，定下计划，去做你希望成为那样的人。但是要记住，我们的生命就是一个三脚架：自我、家庭、职业。三者的平衡才是最稳固的人生。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>改变shape里面的值</title>
    <url>/2015/05/05/android-2015-05-05-chaneg-shape-solid-color/</url>
    <content><![CDATA[<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;shape xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;solid android:color&#x3D;&quot;#FF4081&quot;&#x2F;&gt;</span><br><span class="line">    &lt;corners android:radius&#x3D;&quot;15dp&quot;&#x2F;&gt;</span><br><span class="line">&lt;&#x2F;shape&gt;</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;RelativeLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    xmlns:tools&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;tools&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:paddingBottom&#x3D;&quot;@dimen&#x2F;activity_vertical_margin&quot;</span><br><span class="line">    android:paddingLeft&#x3D;&quot;@dimen&#x2F;activity_horizontal_margin&quot;</span><br><span class="line">    android:paddingRight&#x3D;&quot;@dimen&#x2F;activity_horizontal_margin&quot;</span><br><span class="line">    android:paddingTop&#x3D;&quot;@dimen&#x2F;activity_vertical_margin&quot;</span><br><span class="line">    tools:context&#x3D;&quot;forezp.com.changesolidcolorfromshape.MainActivity&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;TextView</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;tv&quot;</span><br><span class="line">        android:background&#x3D;&quot;@drawable&#x2F;button&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:textSize&#x3D;&quot;14sp&quot;</span><br><span class="line">        android:padding&#x3D;&quot;10dp&quot;</span><br><span class="line">        android:textColor&#x3D;&quot;#ffffff&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">        android:text&#x3D;&quot;Hello World!&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;RelativeLayout&gt;</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    &#x2F;&#x2F;http:&#x2F;&#x2F;stackoverflow.com&#x2F;questions&#x2F;16775891&#x2F;how-to-change-solid-color-from-the-code</span><br><span class="line">    private TextView tv;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        tv&#x3D;(TextView)findViewById(R.id.tv);</span><br><span class="line">        GradientDrawable myGrad &#x3D; (GradientDrawable)tv.getBackground();</span><br><span class="line">        myGrad.setColor(Color.BLACK);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android eventbus</title>
    <url>/2015/05/05/android-2015-05-05-eventbus/</url>
    <content><![CDATA[<p>最近在研究RxJava ，突然想起了事件分发另一个强大的框架Eventbus ,并且项目经常用到，特意整理了下。<br>what is Eventbus?<br>官方的解释为：<br>EventBus is a publish/subscribe event bus optimized for Android.<br>它是专门为优化安卓一个 发布者/订阅者的事件总线。</p>
<p><img src="http://img.blog.csdn.net/20160622183052058" alt="事件分发流程"></p>
<span id="more"></span>

<p>发布者，发布事件。通过事件总线（其实就是在一个单例内部维持着一个map对象存储了一堆的方法），分发给订阅者。</p>
<p>它的优点：<br>轻量、简单、降低耦合。</p>
<p>用法：<br>1.声明Event事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MessageEvent &#123; &#x2F;* Additional fields if needed *&#x2F; &#125;</span><br></pre></td></tr></table></figure>
<p>2.注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eventBus.register(this);</span><br></pre></td></tr></table></figure>
<p>声明方法，有四种方法，最主要的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Subscribe</span><br><span class="line">   public void onEventMainThread(CommonEvent event) &#123;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>3.发布事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eventBus.post(event);</span><br></pre></td></tr></table></figure>

<p>例子：<br>在oncrete（） 方法中注册，无论是Activity 还是Fragment ,不在这里注册会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">       super.onCreate(savedInstanceState);</span><br><span class="line">       setContentView(R.layout.activity_main);</span><br><span class="line">       EventBus.getDefault().register(this);</span><br><span class="line">       btn&#x3D;(Button)findViewById(R.id.btn);</span><br><span class="line">       tv&#x3D;(TextView)findViewById(R.id.tv);</span><br><span class="line">       btn.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void onClick(View v) &#123;</span><br><span class="line">               Intent intent&#x3D;new Intent(MainActivity.this,SecondActivity.class);</span><br><span class="line">               startActivity(intent);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>在OnDestroy中反注册</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  protected void onDestroy() &#123;</span><br><span class="line">      super.onDestroy();</span><br><span class="line">      EventBus.getDefault().unregister(this);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>声明订阅者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Subscribe</span><br><span class="line">   public void onEventMainThread(CommonEvent event) &#123;</span><br><span class="line"></span><br><span class="line">      if(event.getType().equals(CommonEvent.TYPE_99))&#123;</span><br><span class="line">          tv.setText(&quot;从第二个页面来的：eventtype&#x3D;&quot;+event.getType());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在需要触发事件的位置提交事件：例如我在第二个界面提交事件，在第一个页面接受：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">EventBus.getDefault().post(new CommonEvent(CommonEvent.TYPE_99));</span><br></pre></td></tr></table></figure>

<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9556776">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>android 定时任务</title>
    <url>/2015/05/05/android-2015-05-05-java-timer/</url>
    <content><![CDATA[<h4 id="1-android-自带闹钟定时任务"><a href="#1-android-自带闹钟定时任务" class="headerlink" title="1.android 自带闹钟定时任务"></a>1.android 自带闹钟定时任务</h4><p>安卓闹钟可以配合广播来实现（不推荐），系统资源浪费，安卓系统在5.0以后的定时<br>任务貌似触发时间不准了，因为了为了省电。</p>
<span id="more"></span>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;获取系统闹钟</span><br><span class="line">AlarmManager alarmManager &#x3D; (AlarmManager) getSystemService(ALARM_SERVICE);</span><br><span class="line">Intent intent &#x3D; new Intent(ReportDetailsActivity.this, ReportDetailsActivity.MyReceiver.class);</span><br><span class="line">pendingIntent &#x3D; PendingIntent.getBroadcast(getApplicationContext(), 0, intent, 0);</span><br><span class="line">&#x2F;&#x2F;开启定时任务</span><br><span class="line">alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + 1000, 5 * 1000, pendingIntent);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>记得在manifeast 文件配置该广播</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static class MyReceiver extends BroadcastReceiver &#123;</span><br><span class="line"></span><br><span class="line">       @Override</span><br><span class="line">       public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">            if (bo &gt; 0) &#123;</span><br><span class="line">                if (bo &gt; 240) &#123;&#x2F;&#x2F;刷票</span><br><span class="line">                    handler.sendEmptyMessage(3);&#x2F;&#x2F;弹窗警告 刷票</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    handler.sendEmptyMessage(2);</span><br><span class="line">                &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在OnDestroy()中取消闹钟</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> @Override</span><br><span class="line">protected void onDestroy() &#123;</span><br><span class="line">    alarmManager.cancel(pendingIntent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-开启Thread"><a href="#2-开启Thread" class="headerlink" title="2.开启Thread"></a>2.开启Thread</h4><p>睡5s中去定时操作任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class MyRunnable  implements Runnable&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (isLoop)&#123;</span><br><span class="line">                try &#123;</span><br><span class="line"></span><br><span class="line">                    if (bo &gt; 0) &#123;</span><br><span class="line">                        if (bo &gt; 240) &#123;&#x2F;&#x2F;刷票</span><br><span class="line">                            handler.sendEmptyMessage(3);&#x2F;&#x2F;弹窗警告 刷票</span><br><span class="line">                        &#125; else &#123;</span><br><span class="line">                            handler.sendEmptyMessage(2);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    Thread.sleep(5000);</span><br><span class="line">                &#125;catch (Exception e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在onCreate()方法中开启：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loopThread&#x3D;new Thread(new MyRunnable());</span><br><span class="line">loopThread.start();</span><br></pre></td></tr></table></figure>
<p>在页面销毁时终止掉该Thread</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">isLoop&#x3D;false;</span><br><span class="line">loopThread.interrupt();</span><br></pre></td></tr></table></figure>
<h4 id="3-使用timer类。"><a href="#3-使用timer类。" class="headerlink" title="3. 使用timer类。"></a>3. 使用timer类。</h4><p>开启timer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Timer timer&#x3D;new Timer();</span><br><span class="line">       timer.schedule(new TimerTask() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public void run() &#123;</span><br><span class="line">           &#x2F;&#x2F;TODO ...</span><br><span class="line"></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;,new Date(),5000);</span><br></pre></td></tr></table></figure>

<p>终止timer</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">timer.cancel();</span><br></pre></td></tr></table></figure>
<p>以上三种定时任务除了第一种不要随便使用外，推荐使用第三种和第二种。</p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>NestedScrollView和RecyclerView使用</title>
    <url>/2015/05/05/android-2015-05-05-nestedscrollview-recyclerview/</url>
    <content><![CDATA[<p>NestedScrollView和RecyclerView使用，并设置间距:</p>
<span id="more"></span>

<p>效果图如下：<br><img src="http://oaurstf0m.bkt.clouddn.com/DEREEE360.gif" alt="这里写图片描述"><br>1.NestedScrollView 和RecyclerView嵌套问题（类似ScrollView 和listView）<br>需重写 RecyclerView  的  GridLayoutManager(还有另外2种，随便搜下就有)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class FullyGridLayoutManager extends GridLayoutManager &#123;</span><br><span class="line">    public FullyGridLayoutManager(Context context, int spanCount) &#123;</span><br><span class="line">        super(context, spanCount);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public FullyGridLayoutManager(Context context, int spanCount, int orientation, boolean reverseLayout) &#123;</span><br><span class="line">        super(context, spanCount, orientation, reverseLayout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int[] mMeasuredDimension &#x3D; new int[2];</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onMeasure(RecyclerView.Recycler recycler, RecyclerView.State state, int widthSpec, int heightSpec) &#123;</span><br><span class="line">        final int widthMode &#x3D; View.MeasureSpec.getMode(widthSpec);</span><br><span class="line">        final int heightMode &#x3D; View.MeasureSpec.getMode(heightSpec);</span><br><span class="line">        final int widthSize &#x3D; View.MeasureSpec.getSize(widthSpec);</span><br><span class="line">        final int heightSize &#x3D; View.MeasureSpec.getSize(heightSpec);</span><br><span class="line"></span><br><span class="line">        int width &#x3D; 0;</span><br><span class="line">        int height &#x3D; 0;</span><br><span class="line">        int count &#x3D; getItemCount();</span><br><span class="line">        int span &#x3D; getSpanCount();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; count; i++) &#123;</span><br><span class="line">            measureScrapChild(recycler, i,</span><br><span class="line">                    View.MeasureSpec.makeMeasureSpec(i, View.MeasureSpec.UNSPECIFIED),</span><br><span class="line">                    View.MeasureSpec.makeMeasureSpec(i, View.MeasureSpec.UNSPECIFIED),</span><br><span class="line">                    mMeasuredDimension);</span><br><span class="line"></span><br><span class="line">            if (getOrientation() &#x3D;&#x3D; HORIZONTAL) &#123;</span><br><span class="line">                if (i % span &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    width &#x3D; width + mMeasuredDimension[0];</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    height &#x3D; mMeasuredDimension[1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (i % span &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    height &#x3D; height + mMeasuredDimension[1];</span><br><span class="line">                &#125;</span><br><span class="line">                if (i &#x3D;&#x3D; 0) &#123;</span><br><span class="line">                    width &#x3D; mMeasuredDimension[0];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (widthMode) &#123;</span><br><span class="line">            case View.MeasureSpec.EXACTLY:</span><br><span class="line">                width &#x3D; widthSize;</span><br><span class="line">            case View.MeasureSpec.AT_MOST:</span><br><span class="line">            case View.MeasureSpec.UNSPECIFIED:</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        switch (heightMode) &#123;</span><br><span class="line">            case View.MeasureSpec.EXACTLY:</span><br><span class="line">                height &#x3D; heightSize;</span><br><span class="line">            case View.MeasureSpec.AT_MOST:</span><br><span class="line">            case View.MeasureSpec.UNSPECIFIED:</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        setMeasuredDimension(width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void measureScrapChild(RecyclerView.Recycler recycler, int position, int widthSpec,</span><br><span class="line">                                   int heightSpec, int[] measuredDimension) &#123;</span><br><span class="line">        if (position &lt; getItemCount()) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                View view &#x3D; recycler.getViewForPosition(0);&#x2F;&#x2F;fix 动态添加时报IndexOutOfBoundsException</span><br><span class="line">                if (view !&#x3D; null) &#123;</span><br><span class="line">                    RecyclerView.LayoutParams p &#x3D; (RecyclerView.LayoutParams) view.getLayoutParams();</span><br><span class="line">                    int childWidthSpec &#x3D; ViewGroup.getChildMeasureSpec(widthSpec,</span><br><span class="line">                            getPaddingLeft() + getPaddingRight(), p.width);</span><br><span class="line">                    int childHeightSpec &#x3D; ViewGroup.getChildMeasureSpec(heightSpec,</span><br><span class="line">                            getPaddingTop() + getPaddingBottom(), p.height);</span><br><span class="line">                    view.measure(childWidthSpec, childHeightSpec);</span><br><span class="line">                    measuredDimension[0] &#x3D; view.getMeasuredWidth() + p.leftMargin + p.rightMargin;</span><br><span class="line">                    measuredDimension[1] &#x3D; view.getMeasuredHeight() + p.bottomMargin + p.topMargin;</span><br><span class="line">                    recycler.recycleView(view);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重写NestedScrollView,实际上是NestedScrollView禁止滑动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class MyNestedScrollView extends NestedScrollView &#123;</span><br><span class="line">    private int downX;</span><br><span class="line">    private int downY;</span><br><span class="line">    private int mTouchSlop;</span><br><span class="line"></span><br><span class="line">    public MyNestedScrollView(Context context) &#123;</span><br><span class="line">        super(context);</span><br><span class="line">        mTouchSlop &#x3D; ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyNestedScrollView(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        mTouchSlop &#x3D; ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public MyNestedScrollView(Context context, AttributeSet attrs, int defStyleAttr) &#123;</span><br><span class="line">        super(context, attrs, defStyleAttr);</span><br><span class="line">        mTouchSlop &#x3D; ViewConfiguration.get(context).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onInterceptTouchEvent(MotionEvent e) &#123;</span><br><span class="line">        int action &#x3D; e.getAction();</span><br><span class="line">        switch (action) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                downX &#x3D; (int) e.getRawX();</span><br><span class="line">                downY &#x3D; (int) e.getRawY();</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                int moveY &#x3D; (int) e.getRawY();</span><br><span class="line">                if (Math.abs(moveY - downY) &gt; mTouchSlop) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return super.onInterceptTouchEvent(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>让recyclerView滑动</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">recyclerView.setNestedScrollingEnabled(<span class="keyword">false</span>);</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> 给recyclerView创建Adapter</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class DemoAdapter extends RecyclerView.Adapter&lt;DemoViewHolder&gt; &#123;</span><br><span class="line">    private ArrayList&lt;String&gt; list;</span><br><span class="line">    public Context mContext;</span><br><span class="line"></span><br><span class="line">    public DemoAdapter(Context mContext) &#123;</span><br><span class="line">        this.mContext&#x3D;mContext;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public DemoViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123;</span><br><span class="line">        View mView &#x3D; LayoutInflater.from(mContext).inflate(R.layout.item_viewholder, parent, false);</span><br><span class="line">        DemoViewHolder mViewHolder &#x3D; new DemoViewHolder(mView);</span><br><span class="line">        return mViewHolder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onBindViewHolder(DemoViewHolder holder, int position) &#123;</span><br><span class="line">        Glide.with(mContext).load(&quot;http:&#x2F;&#x2F;img.nongshanghang.cn&#x2F;allimg&#x2F;160906&#x2F;22435210b_1.jpg&quot;).into(  holder.imageView);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getItemCount() &#123;</span><br><span class="line">        return 9;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> Viewholder 部分</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class DemoViewHolder extends RecyclerView.ViewHolder &#123;</span><br><span class="line"></span><br><span class="line">    public DemoViewHolder(View itemView) &#123;</span><br><span class="line">        super(itemView);</span><br><span class="line">        imageView&#x3D;(ImageView)itemView.findViewById(R.id.imageview);</span><br><span class="line">    &#125;</span><br><span class="line">    public ImageView imageView;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> 设置RecyclerView 的item间距</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class SpacesItemDecoration extends RecyclerView.ItemDecoration  &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private int left;</span><br><span class="line">    private int right;</span><br><span class="line">    private int top;</span><br><span class="line">    private int bottom;</span><br><span class="line">    public SpacesItemDecoration(int space) &#123;</span><br><span class="line">        this.left&#x3D;space;</span><br><span class="line">        this.right&#x3D;space;</span><br><span class="line">        this.top&#x3D;space;</span><br><span class="line">        this.bottom&#x3D;space;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public SpacesItemDecoration(int left,int right,int top,int bottom) &#123;</span><br><span class="line">        this.left&#x3D;left;</span><br><span class="line">        this.right&#x3D;right;</span><br><span class="line">        this.top&#x3D;top;</span><br><span class="line">        this.bottom&#x3D;bottom;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void getItemOffsets(Rect outRect, View view, RecyclerView parent, RecyclerView.State state) &#123;</span><br><span class="line">        outRect.left&#x3D;left;</span><br><span class="line">        outRect.right&#x3D;right;</span><br><span class="line">        outRect.bottom&#x3D;bottom;</span><br><span class="line">        outRect.top&#x3D;top;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p> 最后设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">recyclerView&#x3D;(RecyclerView)findViewById(R.id.recyclerview);</span><br><span class="line">     recyclerView.setNestedScrollingEnabled(false);</span><br><span class="line">     layoutManager&#x3D;new FullyGridLayoutManager(this,3,GridLayoutManager.VERTICAL,false);</span><br><span class="line">     adpater&#x3D;new DemoAdapter(this);</span><br><span class="line">     recyclerView.setAdapter(adpater);</span><br><span class="line">     recyclerView.setLayoutManager(layoutManager);</span><br><span class="line">     SpacesItemDecoration decoration;</span><br><span class="line">     &#x2F;&#x2F;  if (Integer.parseInt(android.os.Build.VERSION.SDK) &gt;&#x3D; 19) &#123;</span><br><span class="line">     &#x2F;&#x2F;     decoration &#x3D; new SpacesItemDecoration(ScreenUtils.dipToPx(getActivity(), 4), ScreenUtils.dipToPx(getActivity(), 4), ScreenUtils.dipToPx(getActivity(), 0), ScreenUtils.dipToPx(getActivity(), 8));</span><br><span class="line">     &#x2F;&#x2F;   &#125;else&#123;</span><br><span class="line">     decoration &#x3D; new SpacesItemDecoration(4, 4, 4,4);</span><br><span class="line">     &#x2F;&#x2F;  &#125;</span><br><span class="line">     recyclerView.addItemDecoration(decoration);</span><br><span class="line">     adpater.notifyDataSetChanged();</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>  代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9624181">源码下载</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">csdn博客</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>viewpager</title>
    <url>/2015/05/05/android-2015-05-05-viewpager-jrtt/</url>
    <content><![CDATA[<p>利用简单的Textview 和Viewpager实现滑动、点击换页的效果，效果图如下：</p>
<span id="more"></span>

<p><img src="http://img.blog.csdn.net/20160625113922931" width = "200"  alt="行走的那些事" align=center />　　　<img src="http://img.blog.csdn.net/20160625113940119" width = "200"  alt="行走的那些事" align=center /></p>
<p>先上布局文件代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;LinearLayout xmlns:android&#x3D;&quot;http:&#x2F;&#x2F;schemas.android.com&#x2F;apk&#x2F;res&#x2F;android&quot;</span><br><span class="line">    android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">    android:background&#x3D;&quot;@color&#x2F;white&quot;</span><br><span class="line">    android:orientation&#x3D;&quot;vertical&quot; &gt;</span><br><span class="line"></span><br><span class="line">   &lt;LinearLayout</span><br><span class="line">       android:background&#x3D;&quot;@color&#x2F;red_base&quot;</span><br><span class="line">       android:orientation&#x3D;&quot;horizontal&quot;</span><br><span class="line">       android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">       android:layout_height&#x3D;&quot;50dp&quot;&gt;</span><br><span class="line"></span><br><span class="line">   &lt;&#x2F;LinearLayout&gt;</span><br><span class="line">    &lt;!-- 选项卡 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;40dp&quot;</span><br><span class="line">        android:background&#x3D;&quot;@color&#x2F;white&quot;</span><br><span class="line">        android:orientation&#x3D;&quot;horizontal&quot;</span><br><span class="line">        android:weightSum&#x3D;&quot;5&quot; &gt;</span><br><span class="line"></span><br><span class="line">        &lt;FrameLayout</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_tab1_fl&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">            android:clickable&#x3D;&quot;true&quot;</span><br><span class="line">            android:gravity&#x3D;&quot;center&quot; &gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id&#x3D;&quot;@+id&#x2F;rim_tab1_tv&quot;</span><br><span class="line">                android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class="line">                android:text&#x3D;&quot;全部&quot;</span><br><span class="line">                android:textColor&#x3D;&quot;@color&#x2F;red_base&quot;</span><br><span class="line">                android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;FrameLayout&gt;</span><br><span class="line"></span><br><span class="line">        &lt;View</span><br><span class="line">            android:layout_width&#x3D;&quot;0.5dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_marginBottom&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:background&#x3D;&quot;@color&#x2F;divider_gray_line&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;FrameLayout</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_tab2_fl&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">            android:clickable&#x3D;&quot;true&quot;</span><br><span class="line">            android:gravity&#x3D;&quot;center&quot; &gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id&#x3D;&quot;@+id&#x2F;rim_tab2_tv&quot;</span><br><span class="line">                android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class="line">                android:text&#x3D;&quot;周边&quot;</span><br><span class="line">                android:textColor&#x3D;&quot;@color&#x2F;text_gray_4&quot;</span><br><span class="line">                android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;FrameLayout&gt;</span><br><span class="line"></span><br><span class="line">        &lt;View</span><br><span class="line">            android:layout_width&#x3D;&quot;0.5dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_marginBottom&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:background&#x3D;&quot;@color&#x2F;divider_gray_line&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;FrameLayout</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_tab3_fl&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">            android:clickable&#x3D;&quot;true&quot;</span><br><span class="line">            android:gravity&#x3D;&quot;center&quot; &gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id&#x3D;&quot;@+id&#x2F;rim_tab3_tv&quot;</span><br><span class="line">                android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class="line">                android:text&#x3D;&quot;应援&quot;</span><br><span class="line">                android:textColor&#x3D;&quot;@color&#x2F;text_gray_4&quot;</span><br><span class="line">                android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;FrameLayout&gt;</span><br><span class="line"></span><br><span class="line">        &lt;View</span><br><span class="line">            android:layout_width&#x3D;&quot;0.5dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_marginBottom&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:background&#x3D;&quot;@color&#x2F;divider_gray_line&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;FrameLayout</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_tab4_fl&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">            android:clickable&#x3D;&quot;true&quot;</span><br><span class="line">            android:gravity&#x3D;&quot;center&quot; &gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id&#x3D;&quot;@+id&#x2F;rim_tab4_tv&quot;</span><br><span class="line">                android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class="line">                android:text&#x3D;&quot;话题&quot;</span><br><span class="line">                android:textColor&#x3D;&quot;@color&#x2F;text_gray_4&quot;</span><br><span class="line">                android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;FrameLayout&gt;</span><br><span class="line"></span><br><span class="line">        &lt;View</span><br><span class="line">            android:layout_width&#x3D;&quot;0.5dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_marginBottom&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;10dp&quot;</span><br><span class="line">            android:background&#x3D;&quot;@color&#x2F;divider_gray_line&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;FrameLayout</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_tab5_fl&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;0dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;match_parent&quot;</span><br><span class="line">            android:layout_weight&#x3D;&quot;1&quot;</span><br><span class="line">            android:clickable&#x3D;&quot;true&quot;</span><br><span class="line">            android:gravity&#x3D;&quot;center&quot; &gt;</span><br><span class="line"></span><br><span class="line">            &lt;TextView</span><br><span class="line">                android:id&#x3D;&quot;@+id&#x2F;rim_tab5_tv&quot;</span><br><span class="line">                android:layout_width&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_height&#x3D;&quot;wrap_content&quot;</span><br><span class="line">                android:layout_gravity&#x3D;&quot;center&quot;</span><br><span class="line">                android:text&#x3D;&quot;明星&quot;</span><br><span class="line">                android:textColor&#x3D;&quot;@color&#x2F;text_gray_4&quot;</span><br><span class="line">                android:textSize&#x3D;&quot;16sp&quot; &#x2F;&gt;</span><br><span class="line">        &lt;&#x2F;FrameLayout&gt;</span><br><span class="line">    &lt;&#x2F;LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;LinearLayout</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;3dp&quot;</span><br><span class="line">        android:background&#x3D;&quot;@color&#x2F;white&quot; &gt;</span><br><span class="line"></span><br><span class="line">        &lt;ImageView</span><br><span class="line">            android:id&#x3D;&quot;@+id&#x2F;rim_cursor&quot;</span><br><span class="line">            android:layout_width&#x3D;&quot;80dp&quot;</span><br><span class="line">            android:layout_height&#x3D;&quot;3dp&quot;</span><br><span class="line">            android:layout_marginTop&#x3D;&quot;0dip&quot;</span><br><span class="line">            android:background&#x3D;&quot;@color&#x2F;title_bar_blue&quot; &#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;LinearLayout&gt;</span><br><span class="line"></span><br><span class="line">    &lt;View</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;0.1dp&quot;</span><br><span class="line">        android:background&#x3D;&quot;@color&#x2F;btn_bg_gray&quot; &#x2F;&gt;</span><br><span class="line">    &lt;!-- 选项卡内容显示区域 --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;View</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;10dp&quot;</span><br><span class="line">        android:background&#x3D;&quot;@color&#x2F;bg_light_gray&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;android.support.v4.view.ViewPager</span><br><span class="line">        android:id&#x3D;&quot;@+id&#x2F;rim_third_vp&quot;</span><br><span class="line">        android:layout_width&#x3D;&quot;match_parent&quot;</span><br><span class="line">        android:layout_height&#x3D;&quot;match_parent&quot; &#x2F;&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;LinearLayout&gt;</span><br></pre></td></tr></table></figure>
<p>上面红色指示器的view的初始化</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int screenWidth;&#x2F;&#x2F;指示器</span><br><span class="line">private ImageView cursorImg;</span><br><span class="line">private LinearLayout.LayoutParams lp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> private void initViews()&#123;</span><br><span class="line"></span><br><span class="line">        WindowManager wm &#x3D; (WindowManager)</span><br><span class="line">                getSystemService(Context.WINDOW_SERVICE);</span><br><span class="line"></span><br><span class="line">        int width &#x3D; wm.getDefaultDisplay().getWidth();</span><br><span class="line">        screenWidth&#x3D;width&#x2F;5;</span><br><span class="line">        cursorImg &#x3D; (ImageView) findViewById(R.id.rim_cursor);</span><br><span class="line">        lp &#x3D; (LinearLayout.LayoutParams) cursorImg.getLayoutParams();</span><br><span class="line">        lp.width &#x3D; screenWidth;</span><br><span class="line">        cursorImg.setLayoutParams(lp);</span><br><span class="line">        leftMargin &#x3D; lp.leftMargin;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>初始化indicater</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void initViewPager() &#123;</span><br><span class="line">        viewPager &#x3D; (ViewPager) findViewById(R.id.rim_third_vp);</span><br><span class="line">        fragmentsList &#x3D; new ArrayList&lt;Fragment&gt;();</span><br><span class="line">        fragment1 &#x3D; new RimFragment();     </span><br><span class="line">        fragmentsList.add(fragment1);</span><br><span class="line">        fragmentsList.add(fragment2);</span><br><span class="line">        fragmentsList.add(fragment3);</span><br><span class="line">        fragmentsList.add(fragment4);</span><br><span class="line">        fragmentsList.add(fragment5);</span><br><span class="line"></span><br><span class="line">        viewPager.setAdapter(new FragmentAdapter(getSupportFragmentManager(),</span><br><span class="line">                fragmentsList));</span><br><span class="line">        viewPager.setCurrentItem(0);</span><br><span class="line">        viewPager.setOnPageChangeListener(this);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>设置上面选项卡的点击事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void onClick(View v) &#123;</span><br><span class="line">       switch (v.getId())&#123;</span><br><span class="line">           case R.id.rim_tab1_fl:</span><br><span class="line">               viewPager.setCurrentItem(0);</span><br><span class="line">               num_tab1_tv.setTextColor(getResources().getColor(R.color.red_base));</span><br><span class="line">               num_tab2_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab3_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab4_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab5_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               fragment1.setMsgName(&quot;1&quot;,&quot;周边&quot;);&#x2F;&#x2F;周边的官方和会员的接口参数,官方</span><br><span class="line">               break;</span><br></pre></td></tr></table></figure>

<p>设置viewpager 滑动事件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">   public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) &#123;</span><br><span class="line"></span><br><span class="line">       offset &#x3D; (screenWidth - cursorImg.getLayoutParams().width) &#x2F; 5;</span><br><span class="line">       </span><br><span class="line">       hidePoint(position, positionOffsetPixels);&#x2F;&#x2F;设置红色指示器的位置</span><br><span class="line">       cursorImg.setLayoutParams(lp);</span><br><span class="line">       currentIndex &#x3D; position;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void onPageSelected(int position) &#123;</span><br><span class="line"></span><br><span class="line">       switch (position)&#123;&#x2F;&#x2F;设置点击事件</span><br><span class="line">           case  0:</span><br><span class="line">               fragment1.setMsgName(&quot;1&quot;,&quot;周边&quot;);</span><br><span class="line">               num_tab1_tv.setTextColor(getResources().getColor(R.color.red_base));</span><br><span class="line">               num_tab2_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab3_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab4_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               num_tab5_tv.setTextColor(getResources().getColor(R.color.text_gray_4));</span><br><span class="line">               break;</span><br><span class="line">         </span><br><span class="line">          </span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       if (position&#x3D;&#x3D;0)</span><br><span class="line">       &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       &#125;else &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   @Override</span><br><span class="line">   public void onPageScrollStateChanged(int state) &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;设置指示器的位置</span><br><span class="line">   private void hidePoint(int position, int positionOffsetPixels) &#123;</span><br><span class="line">       if (position &#x3D;&#x3D; 0) &#123;&#x2F;&#x2F; 0&lt;-&gt;1</span><br><span class="line">           lp.leftMargin &#x3D; (int) (positionOffsetPixels &#x2F; 5) + offset;</span><br><span class="line"></span><br><span class="line">       &#125; else if (position &#x3D;&#x3D; 1) &#123;&#x2F;&#x2F; 1&lt;-&gt;2</span><br><span class="line">           lp.leftMargin &#x3D; (int) (positionOffsetPixels &#x2F; 5) + screenWidth</span><br><span class="line">                   + offset;</span><br><span class="line"></span><br><span class="line">       &#125;else  if(position&#x3D;&#x3D;2)&#123;</span><br><span class="line">           lp.leftMargin &#x3D; (int) (positionOffsetPixels &#x2F; 5) + screenWidth*2</span><br><span class="line">                   + offset;</span><br><span class="line">       &#125;</span><br><span class="line">       else  if(position&#x3D;&#x3D;3)&#123;</span><br><span class="line">           lp.leftMargin &#x3D; (int) (positionOffsetPixels &#x2F; 5) + screenWidth*3</span><br><span class="line">                   + offset;</span><br><span class="line">       &#125;</span><br><span class="line">       else  if(position&#x3D;&#x3D;4)&#123;</span><br><span class="line">           lp.leftMargin &#x3D; (int) (positionOffsetPixels &#x2F; 5) + screenWidth*4</span><br><span class="line">                   + offset;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码并不难，希望通过我这个例子，一是巩固自己的学习和理解，二是希望更多的人更好的学习，我会再接再厉，写更多的博文。</p>
<p><a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9559206">源码下载</a></p>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>Rxjava +retrofit+mvp</title>
    <url>/2015/05/05/android-2015-05-05-rxjava-retrofit-mvp/</url>
    <content><![CDATA[<p>最近在看Rxjava，写了一个简单的 demo整合了Rxjava +retrofit+mvp，写完了迫不及待的分享出来了，打算以后的开发都用这个，太强大了，另外OKhTTP用了网络缓存，非常的方便，以后写缓存都不需要写本地数据库了。</p>
<span id="more"></span>

<p>这个项目使用到了拉姆达表达式：<br>在安卓中使用Java 8 lambda表达式，很遗憾安卓原生不支持，需要用插件。<br> 在工程中build.GRADLE导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">      classpath &#39;com.android.tools.build:gradle:2.1.0&#39;</span><br><span class="line">      classpath &#39;me.tatarka:gradle-retrolambda:3.2.5&#39;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 在项目的build.gradle导入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apply plugin: &#39;me.tatarka.retrolambda&#39;</span><br></pre></td></tr></table></figure>
<p> 需要使用到Java8在android根下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  android &#123;</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        sourceCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">        targetCompatibility JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p> 这样就可以在android下使用拉姆达表达式。</p>
<p> 引入RXjAVA、RxAndroid、retrofit  jar包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">compile &#39;io.reactivex:rxandroid:1.2.1&#39;</span><br><span class="line">  compile &#39;com.squareup.retrofit2:retrofit:2.1.0&#39;</span><br><span class="line">  compile &#39;com.squareup.retrofit2:converter-gson:2.1.0&#39;</span><br><span class="line">  compile &#39;com.squareup.retrofit2:adapter-rxjava:2.1.0&#39;</span><br></pre></td></tr></table></figure>
<p> 关于retrofit的用法，<a target="_blank" rel="noopener" href="http://square.github.io/retrofit/">点击见官网</a>。</p>
<p> 关于Rxjava的用法， <a target="_blank" rel="noopener" href="https://github.com/mcxiaoke/RxDocs">翻译的Rxjava中文文档</a></p>
<p> 本文是一个整理好的RxJava+retrofit+Mvp的例子。</p>
<p> 本文的的网络请求来源知乎API.</p>
<p> 1.首先创建retrofit 接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public interface ZhihuApi &#123;</span><br><span class="line">    @GET(&quot;news&#x2F;latest&quot;)</span><br><span class="line">    Observable&lt;NewsTimeLine&gt; getLatestNews();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 2.创建retrofit  service</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">File httpCacheDirectory &#x3D; new File(MyApp.mContext.getCacheDir(), &quot;responses&quot;);</span><br><span class="line">      int cacheSize &#x3D; 10 * 1024 * 1024; &#x2F;&#x2F; 10 MiB</span><br><span class="line">      Cache cache &#x3D; new Cache(httpCacheDirectory, cacheSize);</span><br><span class="line">      OkHttpClient client &#x3D; new OkHttpClient.Builder()</span><br><span class="line">              .addInterceptor(REWRITE_CACHE_CONTROL_INTERCEPTOR)</span><br><span class="line">              .cache(cache).build();</span><br><span class="line">      Retrofit retrofit_zhihu &#x3D; new Retrofit.Builder()</span><br><span class="line">              .baseUrl(ZHIHU_BASE_URL)</span><br><span class="line">              .client(client)</span><br><span class="line">              .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">              .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br><span class="line">              .build();</span><br><span class="line">      ZhihuApiService &#x3D; retrofit_zhihu.create(ZhihuApi.class);</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置json解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.addConverterFactory(GsonConverterFactory.create())</span><br></pre></td></tr></table></figure>

<p>配置Rxjava  适配器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.addCallAdapterFactory(RxJavaCallAdapterFactory.create())</span><br></pre></td></tr></table></figure>
<p>  其中配置了网络缓存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   Interceptor REWRITE_CACHE_CONTROL_INTERCEPTOR &#x3D; chain -&gt; &#123;</span><br><span class="line">        CacheControl.Builder cacheBuilder &#x3D; new CacheControl.Builder();</span><br><span class="line">        cacheBuilder.maxAge(0, TimeUnit.SECONDS);</span><br><span class="line">        cacheBuilder.maxStale(365, TimeUnit.DAYS);</span><br><span class="line">        CacheControl cacheControl &#x3D; cacheBuilder.build();</span><br><span class="line">        Request request &#x3D; chain.request();</span><br><span class="line">        if (!NetUtils.isNetworkAvailable(MyApp.mContext)) &#123;</span><br><span class="line">            request &#x3D; request.newBuilder()</span><br><span class="line">                    .cacheControl(cacheControl)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        Response originalResponse &#x3D; chain.proceed(request);</span><br><span class="line">        if (NetUtils.isNetworkAvailable(MyApp.mContext)) &#123;</span><br><span class="line">            int maxAge &#x3D; 0; &#x2F;&#x2F; read from cache</span><br><span class="line">            return originalResponse.newBuilder()</span><br><span class="line">                    .removeHeader(&quot;Pragma&quot;)</span><br><span class="line">                    .header(&quot;Cache-Control&quot;, &quot;public ,max-age&#x3D;&quot; + maxAge)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            int maxStale &#x3D; 60 * 60 * 24 * 28; &#x2F;&#x2F; tolerate 4-weeks stale</span><br><span class="line">            return originalResponse.newBuilder()</span><br><span class="line">                    .removeHeader(&quot;Pragma&quot;)</span><br><span class="line">                    .header(&quot;Cache-Control&quot;, &quot;public, only-if-cached, max-stale&#x3D;&quot; + maxStale)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  </span><br><span class="line">&#96;&#96;&#96;   </span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">  在MVP的P层进行网络请求，传统的应该是Model  层，写在P层少一次接口回调。</span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>   public void getNews(IGetZhihuNewsView iGetZhihuNewsView){<br>        zhihuApi.getLatestNews( )<br>                .subscribeOn(Schedulers.io())<br>                .observeOn(AndroidSchedulers.mainThread())<br>                .subscribe(newsTimeLine -&gt; {<br>                    disPlayZhihuList(iGetZhihuNewsView,newsTimeLine, context);<br>                },this::loadError);<br>    }</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   </span><br><span class="line">其中view接口</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>public interface IGetZhihuNewsView {<br>    void  getSuccess(NewsTimeLine newsTimeLine);<br>}</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在Activity中</span><br></pre></td></tr></table></figure>
<p>  public class MainActivity extends AppCompatActivity implements IGetZhihuNewsView {<br>    private TextView tv;<br>    @Override<br>    protected void onCreate(Bundle savedInstanceState) {<br>        super.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        tv= (TextView) findViewById(R.id.tv) ;<br>        ZhihuPresenter zhihuPresenter=new ZhihuPresenter(this);<br>        zhihuPresenter.getNews(this);<br>    }</p>
<p>   @Override<br>    public void getSuccess(NewsTimeLine newsTimeLine) {<br>        tv.setText(newsTimeLine.toString());<br>    }<br>}</p>
<pre><code>
  代码比较简单，~~~
  
  [源码下载](https://github.com/forezp/RxJavaRetrofit)
</code></pre>
]]></content>
      <categories>
        <category>android</category>
      </categories>
      <tags>
        <tag>android</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2020/10/30/designPattern-2020-10-30-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。</p>
<p>在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。</p>
<span id="more"></span>

<h3 id="代理模式的定义与特点"><a href="#代理模式的定义与特点" class="headerlink" title="代理模式的定义与特点"></a>代理模式的定义与特点</h3><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<h3 id="代理模式的主要优点有："><a href="#代理模式的主要优点有：" class="headerlink" title="代理模式的主要优点有："></a>代理模式的主要优点有：</h3><ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li>
</ul>
<h3 id="其主要缺点是："><a href="#其主要缺点是：" class="headerlink" title="其主要缺点是："></a>其主要缺点是：</h3><ul>
<li>代理模式会造成系统设计中类的数量增加</li>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
<li>那么如何解决以上提到的缺点呢？答案是可以使用动态代理方式</li>
</ul>
<h3 id="代理模式的结构与实现"><a href="#代理模式的结构与实现" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h3><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p>
<h4 id="1-模式的结构"><a href="#1-模式的结构" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h4><p>代理模式的主要角色如下。</p>
<ul>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<p>其结构图如图 1 所示<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk7fvl8ky9g30i209mmxh.gif"></p>
<p>在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。</p>
<p>根据代理的创建时期，代理模式分为静态代理和动态代理。</p>
<ul>
<li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li>
<li>动态：在程序运行时，运用反射机制动态创建而成</li>
</ul>
<h4 id="2-模式的实现"><a href="#2-模式的实现" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.三个抽象主题</span><br><span class="line">&#x2F;**</span><br><span class="line"> * process check gamer ticket</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface CheckProcess &#123;</span><br><span class="line">    void check();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface DietProcess &#123;</span><br><span class="line">    void diet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * process game</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface GameProcess &#123;</span><br><span class="line">    void play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 三个真实主题</span><br><span class="line">public class BigGamePayer extends GamePayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void play() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; big player start play ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BigChecker implements CheckProcess &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void check() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; start check ticket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dieter implements DietProcess &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void diet() &#123;</span><br><span class="line">      log.info(&quot;&#x3D;&#x3D; start make diet : ice &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3. 代理类</span><br><span class="line">public class ProxyProcess implements GameProcess, CheckProcess, DietProcess &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理检票</span><br><span class="line">    private CheckProcess checkProcess;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理游戏</span><br><span class="line">    private GameProcess  gameProcess;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理饮食</span><br><span class="line">    private DietProcess  dietProcess;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; ProxyProcess(T t) &#123;</span><br><span class="line">        if (t instanceof GameProcess) &#123;</span><br><span class="line">            this.gameProcess &#x3D; (GameProcess) t;</span><br><span class="line">        &#125; else if (t instanceof CheckProcess) &#123;</span><br><span class="line">            this.checkProcess &#x3D; (CheckProcess) t;</span><br><span class="line">        &#125; else if (t instanceof DietProcess) &#123;</span><br><span class="line">            this.dietProcess &#x3D; (DietProcess) t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void play() &#123;</span><br><span class="line">        before();</span><br><span class="line">        this.gameProcess.play();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void check() &#123;</span><br><span class="line">        this.checkProcess.check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void diet() &#123;</span><br><span class="line">        this.dietProcess.diet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void before() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; proxy: start before play game&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void after() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; proxy:  start after play game&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>游戏屋:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GameHome &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        proxyCheck();</span><br><span class="line">        proxyPlay();</span><br><span class="line">        proxyDiete();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void proxyPlay() &#123;</span><br><span class="line">        &#x2F;&#x2F; 代理玩游戏</span><br><span class="line">        BigGamePayer bigGamePayer &#x3D; new BigGamePayer();</span><br><span class="line">        ProxyProcess proxyPayer &#x3D; new ProxyProcess(bigGamePayer);</span><br><span class="line">        proxyPayer.play();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void proxyCheck() &#123;</span><br><span class="line">        &#x2F;&#x2F; 代理检票</span><br><span class="line">        BigChecker bigChecker &#x3D; new BigChecker();</span><br><span class="line">        ProxyProcess proxyProcess &#x3D; new ProxyProcess(bigChecker);</span><br><span class="line">        proxyProcess.check();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void proxyDiete() &#123;</span><br><span class="line">        &#x2F;&#x2F; 代理美食</span><br><span class="line">        Dieter dieter &#x3D; new Dieter();</span><br><span class="line">        ProxyProcess proxyProcess &#x3D; new ProxyProcess(dieter);</span><br><span class="line">        proxyProcess.diet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16:29:18.572 [main] INFO com.ckj.base.designPatternes.proxy.extend.BigChecker - &#x3D;&#x3D;&#x3D; start check ticket</span><br><span class="line">16:29:18.575 [main] INFO com.ckj.base.designPatternes.proxy.proxy.ProxyProcess - &#x3D;&#x3D;&#x3D; proxy: start before play game</span><br><span class="line">16:29:18.575 [main] INFO com.ckj.base.designPatternes.proxy.extend.BigGamePayer - &#x3D;&#x3D;&#x3D; big player start play ...</span><br><span class="line">16:29:18.575 [main] INFO com.ckj.base.designPatternes.proxy.proxy.ProxyProcess - &#x3D;&#x3D;&#x3D; proxy:  start after play game</span><br><span class="line">16:29:18.576 [main] INFO com.ckj.base.designPatternes.proxy.extend.Dieter - &#x3D;&#x3D; start make diet : ice </span><br></pre></td></tr></table></figure>

<h4 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h4><p>在前面介绍的代理模式中，代理类中包含了对真实主题的引用，这种方式存在两个缺点。</p>
<ul>
<li>真实主题与代理主题一一对应，增加真实主题也要增加代理。</li>
<li>设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 SpringAOP，其结构图如图 4 所示。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk7jnux1oeg30hi0g6js3.gif"></p>
<p>改造如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dynamic proxy</span><br><span class="line">    GameProcess proxy &#x3D; (GameProcess) Proxy.newProxyInstance(GameProcess.class.getClassLoader(), new Class[]&#123;GameProcess.class&#125;,</span><br><span class="line">            new InvocationHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            log.info(&quot;start dynamic process...&quot;);</span><br><span class="line">            return method.invoke(new BigGamePayer(), args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.play();</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18:17:11.681 [main] INFO com.ckj.base.designPatternes.proxy.GameHome - start dynamic process...</span><br><span class="line">18:17:11.681 [main] INFO com.ckj.base.designPatternes.proxy.extend.BigGamePayer - &#x3D;&#x3D;&#x3D; big player start play ...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Ribbon源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-Ribbon-resources/</url>
    <content><![CDATA[<h2 id="什么是Ribbon"><a href="#什么是Ribbon" class="headerlink" title="什么是Ribbon"></a>什么是Ribbon</h2><p>Ribbon是Netflix公司开源的一个负载均衡的项目，它属于上述的第二种，是一个客户端负载均衡器，运行在客户端上。它是一个经过了云端测试的IPC库，可以很好地控制HTTP和TCP客户端的一些行为。 Feign已经默认使用了Ribbon。</p>
<ul>
<li>负载均衡</li>
<li>容错</li>
<li>多协议（HTTP，TCP，UDP）支持异步和反应模型</li>
<li>缓存和批处理 </li>
</ul>
<span id="more"></span>

<h2 id="RestTemplate和Ribbon相结合"><a href="#RestTemplate和Ribbon相结合" class="headerlink" title="RestTemplate和Ribbon相结合"></a>RestTemplate和Ribbon相结合</h2><p>Ribbon在Netflix组件是非常重要的一个组件，在Zuul中使用Ribbon做负载均衡，以及Feign组件的结合等。在Spring Cloud 中，作为开发中，做的最多的可能是将RestTemplate和Ribbon相结合，你可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RibbonConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    RestTemplate restTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消费另外一个的服务的接口，差不多是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RibbonService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line">    public String hi(String name) &#123;</span><br><span class="line">        return restTemplate.getForObject(&quot;http:&#x2F;&#x2F;eureka-client&#x2F;hi?name&#x3D;&quot;+name,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="深入理解Ribbon"><a href="#深入理解Ribbon" class="headerlink" title="深入理解Ribbon"></a>深入理解Ribbon</h2><h3 id="LoadBalancerClient"><a href="#LoadBalancerClient" class="headerlink" title="LoadBalancerClient"></a>LoadBalancerClient</h3><p>在Riibon中一个非常重要的组件为LoadBalancerClient，它作为负载均衡的一个客户端。它在spring-cloud-commons包下：<br>的LoadBalancerClient是一个接口，它继承ServiceInstanceChooser，它的实现类是RibbonLoadBalancerClient，这三者之间的关系如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-961a4933f2f92c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>其中LoadBalancerClient接口，有如下三个方法，其中excute()为执行请求，reconstructURI()用来重构url：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface LoadBalancerClient extends ServiceInstanceChooser &#123;</span><br><span class="line">  &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException;</span><br><span class="line">  &lt;T&gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request) throws IOException;</span><br><span class="line">  URI reconstructURI(ServiceInstance instance, URI original);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ServiceInstanceChooser接口，主要有一个方法，用来根据serviceId来获取ServiceInstance，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ServiceInstanceChooser &#123;</span><br><span class="line"></span><br><span class="line">    ServiceInstance choose(String serviceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LoadBalancerClient的实现类为RibbonLoadBalancerClient，这个类是非常重要的一个类，最终的负载均衡的请求处理，由它来执行。它的部分源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RibbonLoadBalancerClient implements LoadBalancerClient &#123;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">	public ServiceInstance choose(String serviceId) &#123;</span><br><span class="line">		Server server &#x3D; getServer(serviceId);</span><br><span class="line">		if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return new RibbonServer(serviceId, server, isSecure(server, serviceId),</span><br><span class="line">				serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected Server getServer(String serviceId) &#123;</span><br><span class="line">		return getServer(getLoadBalancer(serviceId));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected Server getServer(ILoadBalancer loadBalancer) &#123;</span><br><span class="line">		if (loadBalancer &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return loadBalancer.chooseServer(&quot;default&quot;); &#x2F;&#x2F; TODO: better handling of key</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected ILoadBalancer getLoadBalancer(String serviceId) &#123;</span><br><span class="line">		return this.clientFactory.getLoadBalancer(serviceId);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在RibbonLoadBalancerClient的源码中，其中choose()方法是选择具体服务实例的一个方法。该方法通过getServer()方法去获取实例，经过源码跟踪，最终交给了ILoadBalancer类去选择服务实例。</p>
<p>ILoadBalancer在ribbon-loadbalancer的jar包下,它是定义了实现软件负载均衡的一个接口，它需要一组可供选择的服务注册列表信息，以及根据特定方法去选择服务，它的源码如下 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ILoadBalancer &#123;</span><br><span class="line"></span><br><span class="line">    public void addServers(List&lt;Server&gt; newServers);</span><br><span class="line">    public Server chooseServer(Object key);</span><br><span class="line">    public void markServerDown(Server server);</span><br><span class="line">    public List&lt;Server&gt; getReachableServers();</span><br><span class="line">    public List&lt;Server&gt; getAllServers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，addServers()方法是添加一个Server集合；chooseServer()方法是根据key去获取Server；markServerDown()方法用来标记某个服务下线；getReachableServers()获取可用的Server集合；getAllServers()获取所有的Server集合。</p>
<h2 id="DynamicServerListLoadBalancer"><a href="#DynamicServerListLoadBalancer" class="headerlink" title="DynamicServerListLoadBalancer"></a>DynamicServerListLoadBalancer</h2><p>它的继承类为BaseLoadBalancer，它的实现类为DynamicServerListLoadBalancer，这三者之间的关系如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-09ad9b1ece18a1a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>查看上述三个类的源码，可用发现，配置以下信息，IClientConfig、IRule、IPing、ServerList、ServerListFilter和ILoadBalancer，查看BaseLoadBalancer类，它默认的情况下，实现了以下配置：</p>
<ul>
<li>IClientConfig ribbonClientConfig:  DefaultClientConfigImpl配置</li>
<li>IRule ribbonRule: RoundRobinRule 路由策略</li>
<li>IPing ribbonPing: DummyPing </li>
<li>ServerList ribbonServerList: ConfigurationBasedServerList</li>
<li>ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter</li>
<li>ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</li>
</ul>
<p>IClientConfig 用于对客户端或者负载均衡的配置，它的默认实现类为DefaultClientConfigImpl。</p>
<p>IRule用于复杂均衡的策略，它有三个方法，其中choose()是根据key 来获取server,setLoadBalancer()和getLoadBalancer()是用来设置和获取ILoadBalancer的，它的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IRule&#123;</span><br><span class="line"></span><br><span class="line">    public Server choose(Object key);</span><br><span class="line">    </span><br><span class="line">    public void setLoadBalancer(ILoadBalancer lb);</span><br><span class="line">    </span><br><span class="line">    public ILoadBalancer getLoadBalancer();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>IRule有很多默认的实现类，这些实现类根据不同的算法和逻辑来处理负载均衡。Ribbon实现的IRule有一下。在大多数情况下，这些默认的实现类是可以满足需求的，如果有特性的需求，可以自己实现。</p>
<ul>
<li><p>BestAvailableRule 选择最小请求数</p>
</li>
<li><p>ClientConfigEnabledRoundRobinRule 轮询</p>
</li>
<li><p>RandomRule 随机选择一个server</p>
</li>
<li><p>RoundRobinRule 轮询选择server</p>
</li>
<li><p>RetryRule 根据轮询的方式重试</p>
</li>
<li><p>WeightedResponseTimeRule 根据响应时间去分配一个weight ，weight越低，被选择的可能性就越低</p>
</li>
<li><p>ZoneAvoidanceRule 根据server的zone区域和可用性来轮询选择</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-ce636f8c473f6e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>IPing是用来想server发生”ping”，来判断该server是否有响应，从而判断该server是否可用。它有一个isAlive()方法，它的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IPing &#123;</span><br><span class="line">    public boolean isAlive(Server server);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IPing的实现类有PingUrl、PingConstant、NoOpPing、DummyPing和NIWSDiscoveryPing。它门之间的关系如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-a2871eb4f4e82714.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>PingUrl 真实的去ping 某个url，判断其是否alive</li>
<li>PingConstant 固定返回某服务是否可用，默认返回true，即可用</li>
<li>NoOpPing 不去ping,直接返回true,即可用。</li>
<li>DummyPing 直接返回true，并实现了initWithNiwsConfig方法。</li>
<li>NIWSDiscoveryPing，根据DiscoveryEnabledServer的InstanceInfo的InstanceStatus去判断，如果为InstanceStatus.UP，则为可用，否则不可用。</li>
</ul>
<p>ServerList是定义获取所有的server的注册列表信息的接口，它的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ServerList&lt;T extends Server&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;T&gt; getInitialListOfServers();</span><br><span class="line">    public List&lt;T&gt; getUpdatedListOfServers();   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ServerListFilter接口，定于了可根据配置去过滤或者根据特性动态获取符合条件的server列表的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ServerListFilter&lt;T extends Server&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;T&gt; getFilteredListOfServers(List&lt;T&gt; servers);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>阅读DynamicServerListLoadBalancer的源码，DynamicServerListLoadBalancer的构造函数中有个initWithNiwsConfig()方法。在改方法中，经过一系列的初始化配置，最终执行了restOfInit()方法。其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public DynamicServerListLoadBalancer(IClientConfig clientConfig) &#123;</span><br><span class="line">       initWithNiwsConfig(clientConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   public void initWithNiwsConfig(IClientConfig clientConfig) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           super.initWithNiwsConfig(clientConfig);</span><br><span class="line">           String niwsServerListClassName &#x3D; clientConfig.getPropertyAsString(</span><br><span class="line">                   CommonClientConfigKey.NIWSServerListClassName,</span><br><span class="line">                   DefaultClientConfigImpl.DEFAULT_SEVER_LIST_CLASS);</span><br><span class="line"></span><br><span class="line">           ServerList&lt;T&gt; niwsServerListImpl &#x3D; (ServerList&lt;T&gt;) ClientFactory</span><br><span class="line">                   .instantiateInstanceWithClientConfig(niwsServerListClassName, clientConfig);</span><br><span class="line">           this.serverListImpl &#x3D; niwsServerListImpl;</span><br><span class="line"></span><br><span class="line">           if (niwsServerListImpl instanceof AbstractServerList) &#123;</span><br><span class="line">               AbstractServerListFilter&lt;T&gt; niwsFilter &#x3D; ((AbstractServerList) niwsServerListImpl)</span><br><span class="line">                       .getFilterImpl(clientConfig);</span><br><span class="line">               niwsFilter.setLoadBalancerStats(getLoadBalancerStats());</span><br><span class="line">               this.filter &#x3D; niwsFilter;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           String serverListUpdaterClassName &#x3D; clientConfig.getPropertyAsString(</span><br><span class="line">                   CommonClientConfigKey.ServerListUpdaterClassName,</span><br><span class="line">                   DefaultClientConfigImpl.DEFAULT_SERVER_LIST_UPDATER_CLASS</span><br><span class="line">           );</span><br><span class="line"></span><br><span class="line">           this.serverListUpdater &#x3D; (ServerListUpdater) ClientFactory</span><br><span class="line">                   .instantiateInstanceWithClientConfig(serverListUpdaterClassName, clientConfig);</span><br><span class="line"></span><br><span class="line">           restOfInit(clientConfig);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">                   &quot;Exception while initializing NIWSDiscoveryLoadBalancer:&quot;</span><br><span class="line">                           + clientConfig.getClientName()</span><br><span class="line">                           + &quot;, niwsClientConfig:&quot; + clientConfig, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在restOfInit()方法上，有一个 updateListOfServers()的方法，该方法是用来获取所有的ServerList的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void restOfInit(IClientConfig clientConfig) &#123;</span><br><span class="line">       boolean primeConnection &#x3D; this.isEnablePrimingConnections();</span><br><span class="line">       &#x2F;&#x2F; turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span><br><span class="line">       this.setEnablePrimingConnections(false);</span><br><span class="line">       enableAndInitLearnNewServersFeature();</span><br><span class="line"></span><br><span class="line">       updateListOfServers();</span><br><span class="line">       if (primeConnection &amp;&amp; this.getPrimeConnections() !&#x3D; null) &#123;</span><br><span class="line">           this.getPrimeConnections()</span><br><span class="line">                   .primeConnections(getReachableServers());</span><br><span class="line">       &#125;</span><br><span class="line">       this.setEnablePrimingConnections(primeConnection);</span><br><span class="line">       LOGGER.info(&quot;DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;&quot;, clientConfig.getClientName(), this.toString());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进一步跟踪updateListOfServers()方法的源码，最终由serverListImpl.getUpdatedListOfServers()获取所有的服务列表的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@VisibleForTesting</span><br><span class="line"> public void updateListOfServers() &#123;</span><br><span class="line">     List&lt;T&gt; servers &#x3D; new ArrayList&lt;T&gt;();</span><br><span class="line">     if (serverListImpl !&#x3D; null) &#123;</span><br><span class="line">         servers &#x3D; serverListImpl.getUpdatedListOfServers();</span><br><span class="line">         LOGGER.debug(&quot;List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;,</span><br><span class="line">                 getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">         if (filter !&#x3D; null) &#123;</span><br><span class="line">             servers &#x3D; filter.getFilteredListOfServers(servers);</span><br><span class="line">             LOGGER.debug(&quot;Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;,</span><br><span class="line">                     getIdentifier(), servers);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     updateAllServerList(servers);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而serverListImpl是ServerList接口的具体实现类。跟踪代码，ServerList的实现类为DiscoveryEnabledNIWSServerList，在ribbon-eureka.jar的com.netflix.niws.loadbalancer下。其中DiscoveryEnabledNIWSServerList有 getInitialListOfServers()和getUpdatedListOfServers()方法，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public List&lt;DiscoveryEnabledServer&gt; getInitialListOfServers()&#123;</span><br><span class="line">        return obtainServersViaDiscovery();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;DiscoveryEnabledServer&gt; getUpdatedListOfServers()&#123;</span><br><span class="line">        return obtainServersViaDiscovery();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>继续跟踪源码，obtainServersViaDiscovery（），是根据eurekaClientProvider.get()来回去EurekaClient，再根据EurekaClient来获取注册列表信息，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private List&lt;DiscoveryEnabledServer&gt; obtainServersViaDiscovery() &#123;</span><br><span class="line">       List&lt;DiscoveryEnabledServer&gt; serverList &#x3D; new ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line"></span><br><span class="line">       if (eurekaClientProvider &#x3D;&#x3D; null || eurekaClientProvider.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">           logger.warn(&quot;EurekaClient has not been initialized yet, returning an empty list&quot;);</span><br><span class="line">           return new ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       EurekaClient eurekaClient &#x3D; eurekaClientProvider.get();</span><br><span class="line">       if (vipAddresses!&#x3D;null)&#123;</span><br><span class="line">           for (String vipAddress : vipAddresses.split(&quot;,&quot;)) &#123;</span><br><span class="line">               &#x2F;&#x2F; if targetRegion is null, it will be interpreted as the same region of client</span><br><span class="line">               List&lt;InstanceInfo&gt; listOfInstanceInfo &#x3D; eurekaClient.getInstancesByVipAddress(vipAddress, isSecure, targetRegion);</span><br><span class="line">               for (InstanceInfo ii : listOfInstanceInfo) &#123;</span><br><span class="line">                   if (ii.getStatus().equals(InstanceStatus.UP)) &#123;</span><br><span class="line"></span><br><span class="line">                       if(shouldUseOverridePort)&#123;</span><br><span class="line">                           if(logger.isDebugEnabled())&#123;</span><br><span class="line">                               logger.debug(&quot;Overriding port on client name: &quot; + clientName + &quot; to &quot; + overridePort);</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           &#x2F;&#x2F; copy is necessary since the InstanceInfo builder just uses the original reference,</span><br><span class="line">                           &#x2F;&#x2F; and we don&#39;t want to corrupt the global eureka copy of the object which may be</span><br><span class="line">                           &#x2F;&#x2F; used by other clients in our system</span><br><span class="line">                           InstanceInfo copy &#x3D; new InstanceInfo(ii);</span><br><span class="line"></span><br><span class="line">                           if(isSecure)&#123;</span><br><span class="line">                               ii &#x3D; new InstanceInfo.Builder(copy).setSecurePort(overridePort).build();</span><br><span class="line">                           &#125;else&#123;</span><br><span class="line">                               ii &#x3D; new InstanceInfo.Builder(copy).setPort(overridePort).build();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       DiscoveryEnabledServer des &#x3D; new DiscoveryEnabledServer(ii, isSecure, shouldUseIpAddr);</span><br><span class="line">                       des.setZone(DiscoveryClient.getZone(ii));</span><br><span class="line">                       serverList.add(des);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (serverList.size()&gt;0 &amp;&amp; prioritizeVipAddressBasedServers)&#123;</span><br><span class="line">                   break; &#x2F;&#x2F; if the current vipAddress has servers, we dont use subsequent vipAddress based servers</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return serverList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中eurekaClientProvider的实现类是LegacyEurekaClientProvider，它是一个获取eurekaClient类，通过静态的方法去获取eurekaClient，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LegacyEurekaClientProvider implements Provider&lt;EurekaClient&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private volatile EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized EurekaClient get() &#123;</span><br><span class="line">        if (eurekaClient &#x3D;&#x3D; null) &#123;</span><br><span class="line">            eurekaClient &#x3D; DiscoveryManager.getInstance().getDiscoveryClient();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return eurekaClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>EurekaClient的实现类为DiscoveryClient，在之前已经分析了它具有服务注册、获取服务注册列表等的全部功能。</p>
<p>由此可见，负载均衡器是从EurekaClient获取服务信息，并根据IRule去路由，并且根据IPing去判断服务的可用性。</p>
<p>那么现在还有个问题，负载均衡器多久一次去获取一次从Eureka Client获取注册信息呢。</p>
<p>在BaseLoadBalancer类下，BaseLoadBalancer的构造函数，该构造函数开启了一个PingTask任务，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public BaseLoadBalancer(String name, IRule rule, LoadBalancerStats stats,</span><br><span class="line">         IPing ping, IPingStrategy pingStrategy) &#123;</span><br><span class="line">  ...&#x2F;&#x2F;代码省略</span><br><span class="line">     setupPingTask();</span><br><span class="line">      ...&#x2F;&#x2F;代码省略</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>setupPingTask()的具体代码逻辑，它开启了ShutdownEnabledTimer执行PingTask任务，在默认情况下pingIntervalSeconds为10，即每10秒钟，想EurekaClient发送一次”ping”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void setupPingTask() &#123;</span><br><span class="line">    if (canSkipPing()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (lbTimer !&#x3D; null) &#123;</span><br><span class="line">        lbTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    lbTimer &#x3D; new ShutdownEnabledTimer(&quot;NFLoadBalancer-PingTimer-&quot; + name,</span><br><span class="line">            true);</span><br><span class="line">    lbTimer.schedule(new PingTask(), 0, pingIntervalSeconds * 1000);</span><br><span class="line">    forceQuickPing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PingTask源码，即new一个Pinger对象，并执行runPinger()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PingTask extends TimerTask &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            	new Pinger(pingStrategy).runPinger();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(&quot;LoadBalancer [&#123;&#125;]: Error pinging&quot;, name, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看Pinger的runPinger()方法，最终根据  pingerStrategy.pingServers(ping, allServers)来获取服务的可用性，如果该返回结果，如之前相同，则不去向EurekaClient获取注册列表，如果不同则通知ServerStatusChangeListener或者changeListeners发生了改变，进行更新或者重新拉取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void runPinger() throws Exception &#123;</span><br><span class="line">          if (!pingInProgress.compareAndSet(false, true)) &#123; </span><br><span class="line">              return; &#x2F;&#x2F; Ping in progress - nothing to do</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F; we are &quot;in&quot; - we get to Ping</span><br><span class="line"></span><br><span class="line">          Server[] allServers &#x3D; null;</span><br><span class="line">          boolean[] results &#x3D; null;</span><br><span class="line"></span><br><span class="line">          Lock allLock &#x3D; null;</span><br><span class="line">          Lock upLock &#x3D; null;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              &#x2F;*</span><br><span class="line">               * The readLock should be free unless an addServer operation is</span><br><span class="line">               * going on...</span><br><span class="line">               *&#x2F;</span><br><span class="line">              allLock &#x3D; allServerLock.readLock();</span><br><span class="line">              allLock.lock();</span><br><span class="line">              allServers &#x3D; allServerList.toArray(new Server[allServerList.size()]);</span><br><span class="line">              allLock.unlock();</span><br><span class="line"></span><br><span class="line">              int numCandidates &#x3D; allServers.length;</span><br><span class="line">              results &#x3D; pingerStrategy.pingServers(ping, allServers);</span><br><span class="line"></span><br><span class="line">              final List&lt;Server&gt; newUpList &#x3D; new ArrayList&lt;Server&gt;();</span><br><span class="line">              final List&lt;Server&gt; changedServers &#x3D; new ArrayList&lt;Server&gt;();</span><br><span class="line"></span><br><span class="line">              for (int i &#x3D; 0; i &lt; numCandidates; i++) &#123;</span><br><span class="line">                  boolean isAlive &#x3D; results[i];</span><br><span class="line">                  Server svr &#x3D; allServers[i];</span><br><span class="line">                  boolean oldIsAlive &#x3D; svr.isAlive();</span><br><span class="line"></span><br><span class="line">                  svr.setAlive(isAlive);</span><br><span class="line"></span><br><span class="line">                  if (oldIsAlive !&#x3D; isAlive) &#123;</span><br><span class="line">                      changedServers.add(svr);</span><br><span class="line">                      logger.debug(&quot;LoadBalancer [&#123;&#125;]:  Server [&#123;&#125;] status changed to &#123;&#125;&quot;, </span><br><span class="line">                  		name, svr.getId(), (isAlive ? &quot;ALIVE&quot; : &quot;DEAD&quot;));</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  if (isAlive) &#123;</span><br><span class="line">                      newUpList.add(svr);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              upLock &#x3D; upServerLock.writeLock();</span><br><span class="line">              upLock.lock();</span><br><span class="line">              upServerList &#x3D; newUpList;</span><br><span class="line">              upLock.unlock();</span><br><span class="line"></span><br><span class="line">              notifyServerStatusChangeListener(changedServers);</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              pingInProgress.set(false);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由此可见，LoadBalancerClient是在初始化的时候，会向Eureka回去服务注册列表，并且向通过10s一次向EurekaClient发送“ping”，来判断服务的可用性，如果服务的可用性发生了改变或者服务数量和之前的不一致，则更新或者重新拉取。LoadBalancerClient有了这些服务注册列表，就可以根据具体的IRule来进行负载均衡。</p>
<h2 id="RestTemplate是如何和Ribbon结合的"><a href="#RestTemplate是如何和Ribbon结合的" class="headerlink" title="RestTemplate是如何和Ribbon结合的"></a>RestTemplate是如何和Ribbon结合的</h2><p>最后，回答问题的本质，为什么在RestTemplate加一个@LoadBalance注解就可可以开启负载均衡呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">   RestTemplate restTemplate() &#123;</span><br><span class="line">       return new RestTemplate();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>全局搜索ctr+shift+f  @LoadBalanced有哪些类用到了LoadBalanced有哪些类用到了， 发现LoadBalancerAutoConfiguration类，即LoadBalancer自动配置类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(RestTemplate.class)</span><br><span class="line">@ConditionalOnBean(LoadBalancerClient.class)</span><br><span class="line">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span><br><span class="line">public class LoadBalancerAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@LoadBalanced</span><br><span class="line">	@Autowired(required &#x3D; false)</span><br><span class="line">	private List&lt;RestTemplate&gt; restTemplates &#x3D; Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line">	@Bean</span><br><span class="line">	public SmartInitializingSingleton loadBalancedRestTemplateInitializer(</span><br><span class="line">			final List&lt;RestTemplateCustomizer&gt; customizers) &#123;</span><br><span class="line">		return new SmartInitializingSingleton() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void afterSingletonsInstantiated() &#123;</span><br><span class="line">				for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) &#123;</span><br><span class="line">					for (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">						customizer.customize(restTemplate);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	@Configuration</span><br><span class="line">	@ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;)</span><br><span class="line">	static class LoadBalancerInterceptorConfig &#123;</span><br><span class="line">		@Bean</span><br><span class="line">		public LoadBalancerInterceptor ribbonInterceptor(</span><br><span class="line">				LoadBalancerClient loadBalancerClient,</span><br><span class="line">				LoadBalancerRequestFactory requestFactory) &#123;</span><br><span class="line">			return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Bean</span><br><span class="line">		@ConditionalOnMissingBean</span><br><span class="line">		public RestTemplateCustomizer restTemplateCustomizer(</span><br><span class="line">				final LoadBalancerInterceptor loadBalancerInterceptor) &#123;</span><br><span class="line">			return new RestTemplateCustomizer() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void customize(RestTemplate restTemplate) &#123;</span><br><span class="line">					List&lt;ClientHttpRequestInterceptor&gt; list &#x3D; new ArrayList&lt;&gt;(</span><br><span class="line">							restTemplate.getInterceptors());</span><br><span class="line">					list.add(loadBalancerInterceptor);</span><br><span class="line">					restTemplate.setInterceptors(list);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该类中，首先维护了一个被@LoadBalanced修饰的RestTemplate对象的List，在初始化的过程中，通过调用customizer.customize(restTemplate)方法来给RestTemplate增加拦截器LoadBalancerInterceptor。</p>
<p>而LoadBalancerInterceptor，用于实时拦截，在LoadBalancerInterceptor这里实现来负载均衡。LoadBalancerInterceptor的拦截方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,</span><br><span class="line">			final ClientHttpRequestExecution execution) throws IOException &#123;</span><br><span class="line">		final URI originalUri &#x3D; request.getURI();</span><br><span class="line">		String serviceName &#x3D; originalUri.getHost();</span><br><span class="line">		Assert.state(serviceName !&#x3D; null, &quot;Request URI does not contain a valid hostname: &quot; + originalUri);</span><br><span class="line">		return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，Ribbon的负载均衡，主要通过LoadBalancerClient来实现的，而LoadBalancerClient具体交给了ILoadBalancer来处理，ILoadBalancer通过配置IRule、IPing等信息，并向EurekaClient获取注册列表的信息，并默认10秒一次向EurekaClient发送“ping”,进而检查是否更新服务列表，最后，得到注册列表后，ILoadBalancer根据IRule的策略进行负载均衡。</p>
<p>而RestTemplate 被@LoadBalance注解后，能过用负载均衡，主要是维护了一个被@LoadBalance注解的RestTemplate列表，并给列表中的RestTemplate添加拦截器，进而交给负载均衡器去处理。</p>
<h2 id="关注我的公众号"><a href="#关注我的公众号" class="headerlink" title="关注我的公众号"></a>关注我的公众号</h2><p>精彩内容不能错过！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0805748d92bba033.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="forezp.jpg"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-eureka-resources/</url>
    <content><![CDATA[<p>本篇文章以源码的角度来深入理解Eureka.</p>
<span id="more"></span>

<h2 id="Eureka的一些概念"><a href="#Eureka的一些概念" class="headerlink" title="Eureka的一些概念"></a>Eureka的一些概念</h2><ul>
<li><p>Register：服务注册<br>当Eureka客户端向Eureka Server注册时，它提供自身的元数据，比如IP地址、端口，运行状况指示符URL，主页等。</p>
</li>
<li><p>Renew：服务续约<br>Eureka客户会每隔30秒发送一次心跳来续约。 通过续约来告知Eureka Server该Eureka客户仍然存在，没有出现问题。 正常情况下，如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。 建议不要更改续约间隔.</p>
</li>
<li><p>Fetch Registries：获取注册列表信息<br>Eureka客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与Eureka客户端的缓存信息不同， Eureka客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka客户端则会重新获取整个注册表信息。 Eureka服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。Eureka客户端和Eureka 服务器可以使用JSON / XML格式进行通讯。在默认的情况下Eureka客户端使用压缩JSON格式来获取注册列表的信息。</p>
</li>
<li><p>Cancel：服务下线<br>Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：<br>DiscoveryManager.getInstance().shutdownComponent()；</p>
</li>
<li><p>Eviction 服务剔除<br>在默认的情况下，当Eureka客户端连续90秒没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除，即服务剔除。</p>
</li>
</ul>
<h2 id="Eureka的高可用架构"><a href="#Eureka的高可用架构" class="headerlink" title="Eureka的高可用架构"></a>Eureka的高可用架构</h2><p>如图为Eureka的高级架构图，该图片来自于Eureka开源代码的文档，地址为<a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a> 。</p>
<p><img src="https://github.com/Netflix/eureka/raw/master/images/eureka_architecture.png" alt="Eureka的高级架构图"></p>
<p> 从图可以看出在这个体系中，有2个角色，即Eureka Server和Eureka Client。而Eureka Client又分为Applicaton Service和Application Client，即服务提供者何服务消费者。 每个区域有一个Eureka集群，并且每个区域至少有一个eureka服务器可以处理区域故障，以防服务器瘫痪。</p>
<p>Eureka Client向Eureka Serve注册，并将自己的一些客户端信息发送Eureka Serve。然后，Eureka Client通过向Eureka Serve发送心跳（每30秒）来续约服务的。 如果客户端持续不能续约，那么，它将在大约90秒内从服务器注册表中删除。 注册信息和续订被复制到集群中的Eureka Serve所有节点。 来自任何区域的Eureka Client都可以查找注册表信息（每30秒发生一次）。根据这些注册表信息，Application Client可以远程调用Applicaton Service来消费服务。</p>
<h2 id="Register服务注册"><a href="#Register服务注册" class="headerlink" title="Register服务注册"></a>Register服务注册</h2><p>服务注册，即Eureka Client向Eureka Server提交自己的服务信息，包括IP地址、端口、service ID等信息。如果Eureka Client没有写service ID，则默认为 ${spring.application.name}。</p>
<p>服务注册其实很简单，在Eureka Client启动的时候，将自身的服务的信息发送到Eureka Server。现在来简单的阅读下源码。在Maven的依赖包下，找到eureka-client-1.6.2.jar包。在com.netflix.discovery包下有个DiscoveryClient类，该类包含了Eureka Client向Eureka Server的相关方法。其中DiscoveryClient实现了EurekaClient接口，并且它是一个单例模式，而EurekaClient继承了LookupService接口。它们之间的关系如图所示。</p>
<p><img src="http://img.blog.csdn.net/20170611110916402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在DiscoveryClient类有一个服务注册的方法register()，该方法是通过Http请求向Eureka Client注册。其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean register() throws Throwable &#123;</span><br><span class="line">        logger.info(PREFIX + appPathIdentifier + &quot;: registering service...&quot;);</span><br><span class="line">        EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">        try &#123;</span><br><span class="line">            httpResponse &#x3D; eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.warn(&quot;&#123;&#125; - registration failed &#123;&#125;&quot;, PREFIX + appPathIdentifier, e.getMessage(), e);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(&quot;&#123;&#125; - registration status: &#123;&#125;&quot;, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">        &#125;</span><br><span class="line">        return httpResponse.getStatusCode() &#x3D;&#x3D; 204;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在DiscoveryClient类继续追踪register()方法，它被InstanceInfoReplicator 类的run()方法调用，其中InstanceInfoReplicator实现了Runnable接口，run()方法代码如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           discoveryClient.refreshInstanceInfo();</span><br><span class="line"></span><br><span class="line">           Long dirtyTimestamp &#x3D; instanceInfo.isDirtyWithTime();</span><br><span class="line">           if (dirtyTimestamp !&#x3D; null) &#123;</span><br><span class="line">               discoveryClient.register();</span><br><span class="line">               instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Throwable t) &#123;</span><br><span class="line">           logger.warn(&quot;There was a problem with the instance info replicator&quot;, t);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Future next &#x3D; scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">           scheduledPeriodicRef.set(next);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而InstanceInfoReplicator类是在DiscoveryClient初始化过程中使用的，其中有一个initScheduledTasks()方法。该方法主要开启了获取服务注册列表的信息，如果需要向Eureka Server注册，则开启注册，同时开启了定时向Eureka Server服务续约的定时任务，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void initScheduledTasks() &#123;</span><br><span class="line">       ...&#x2F;&#x2F;省略了任务调度获取注册列表的代码</span><br><span class="line">        if (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line">         ... </span><br><span class="line">            &#x2F;&#x2F; Heartbeat timer</span><br><span class="line">            scheduler.schedule(</span><br><span class="line">                    new TimedSupervisorTask(</span><br><span class="line">                            &quot;heartbeat&quot;,</span><br><span class="line">                            scheduler,</span><br><span class="line">                            heartbeatExecutor,</span><br><span class="line">                            renewalIntervalInSecs,</span><br><span class="line">                            TimeUnit.SECONDS,</span><br><span class="line">                            expBackOffBound,</span><br><span class="line">                            new HeartbeatThread()</span><br><span class="line">                    ),</span><br><span class="line">                    renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; InstanceInfo replicator</span><br><span class="line">            instanceInfoReplicator &#x3D; new InstanceInfoReplicator(</span><br><span class="line">                    this,</span><br><span class="line">                    instanceInfo,</span><br><span class="line">                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),</span><br><span class="line">                    2); &#x2F;&#x2F; burstSize</span><br><span class="line"></span><br><span class="line">            statusChangeListener &#x3D; new ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getId() &#123;</span><br><span class="line">                    return &quot;statusChangeListener&quot;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void notify(StatusChangeEvent statusChangeEvent) &#123;</span><br><span class="line">                 </span><br><span class="line">                    instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在来看Eureka server端的代码，在Maven的eureka-core:1.6.2的jar包下。打开com.netflix.eureka包，很轻松的就发现了又一个EurekaBootStrap的类，BootStrapContext具有最先初始化的权限，所以先看这个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void initEurekaServerContext() throws Exception &#123;</span><br><span class="line"> </span><br><span class="line"> ...&#x2F;&#x2F;省略代码</span><br><span class="line">   PeerAwareInstanceRegistry registry;</span><br><span class="line">        if (isAws(applicationInfoManager.getInfo())) &#123;</span><br><span class="line">           ...&#x2F;&#x2F;省略代码，如果是AWS的代码</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            registry &#x3D; new PeerAwareInstanceRegistryImpl(</span><br><span class="line">                    eurekaServerConfig,</span><br><span class="line">                    eurekaClient.getEurekaClientConfig(),</span><br><span class="line">                    serverCodecs,</span><br><span class="line">                    eurekaClient</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PeerEurekaNodes peerEurekaNodes &#x3D; getPeerEurekaNodes(</span><br><span class="line">                registry,</span><br><span class="line">                eurekaServerConfig,</span><br><span class="line">                eurekaClient.getEurekaClientConfig(),</span><br><span class="line">                serverCodecs,</span><br><span class="line">                applicationInfoManager</span><br><span class="line">        );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其中PeerAwareInstanceRegistryImpl和PeerEurekaNodes两个类看其命名，应该和服务注册以及Eureka Server高可用有关。先追踪PeerAwareInstanceRegistryImpl类，在该类有个register()方法，该方法提供了注册，并且将注册后信息同步到其他的Eureka Server服务。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void register(final InstanceInfo info, final boolean isReplication) &#123;</span><br><span class="line">        int leaseDuration &#x3D; Lease.DEFAULT_DURATION_IN_SECS;</span><br><span class="line">        if (info.getLeaseInfo() !&#x3D; null &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; 0) &#123;</span><br><span class="line">            leaseDuration &#x3D; info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">        &#125;</span><br><span class="line">        super.register(info, leaseDuration, isReplication);</span><br><span class="line">        replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中 super.register(info, leaseDuration, isReplication)方法，点击进去到子类AbstractInstanceRegistry可以发现更多细节，其中注册列表的信息被保存在一个Map中。replicateToPeers()方法，即同步到其他Eureka Server的其他Peers节点，追踪代码，发现它会遍历循环向所有的Peers节点注册，最终执行类PeerEurekaNodes的register()方法，该方法通过执行一个任务向其他节点同步该注册信息，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void register(final InstanceInfo info) throws Exception &#123;</span><br><span class="line">      long expiryTime &#x3D; System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">      batchingDispatcher.process(</span><br><span class="line">              taskId(&quot;register&quot;, info),</span><br><span class="line">              new InstanceReplicationTask(targetHost, Action.Register, info, null, true) &#123;</span><br><span class="line">                  public EurekaHttpResponse&lt;Void&gt; execute() &#123;</span><br><span class="line">                      return replicationClient.register(info);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              expiryTime</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过一系列的源码追踪，可以发现PeerAwareInstanceRegistryImpl的register()方法实现了服务的注册，并且向其他Eureka Server的Peer节点同步了该注册信息，那么register()方法被谁调用了呢？之前在Eureka Client的分析可以知道，Eureka Client是通过 http来向Eureka Server注册的，那么Eureka Server肯定会提供一个注册的接口给Eureka Client调用，那么PeerAwareInstanceRegistryImpl的register()方法肯定最终会被暴露的Http接口所调用。在Idea开发工具，按住alt+鼠标左键，可以很快定位到ApplicationResource类的addInstance ()方法，即服务注册的接口，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@POST</span><br><span class="line">    @Consumes(&#123;&quot;application&#x2F;json&quot;, &quot;application&#x2F;xml&quot;&#125;)</span><br><span class="line">    public Response addInstance(InstanceInfo info,</span><br><span class="line">                                @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) &#123;</span><br><span class="line">       </span><br><span class="line">    ...&#x2F;&#x2F;省略代码                 </span><br><span class="line">               registry.register(info, &quot;true&quot;.equals(isReplication));</span><br><span class="line">        return Response.status(204).build();  &#x2F;&#x2F; 204 to be backwards compatible</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Renew服务续约"><a href="#Renew服务续约" class="headerlink" title="Renew服务续约"></a>Renew服务续约</h2><p>服务续约和服务注册非常类似，通过之前的分析可以知道，服务注册在Eureka Client程序启动之后开启，并同时开启服务续约的定时任务。在eureka-client-1.6.2.jar的DiscoveryClient的类下有renew()方法，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * Renew with the eureka service by making the appropriate REST call</span><br><span class="line">   *&#x2F;</span><br><span class="line">  boolean renew() &#123;</span><br><span class="line">      EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">      try &#123;</span><br><span class="line">          httpResponse &#x3D; eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);</span><br><span class="line">          logger.debug(&quot;&#123;&#125; - Heartbeat status: &#123;&#125;&quot;, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">          if (httpResponse.getStatusCode() &#x3D;&#x3D; 404) &#123;</span><br><span class="line">              REREGISTER_COUNTER.increment();</span><br><span class="line">              logger.info(&quot;&#123;&#125; - Re-registering apps&#x2F;&#123;&#125;&quot;, PREFIX + appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">              return register();</span><br><span class="line">          &#125;</span><br><span class="line">          return httpResponse.getStatusCode() &#x3D;&#x3D; 200;</span><br><span class="line">      &#125; catch (Throwable e) &#123;</span><br><span class="line">          logger.error(&quot;&#123;&#125; - was unable to send heartbeat!&quot;, PREFIX + appPathIdentifier, e);</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外服务端的续约接口在eureka-core:1.6.2.jar的 com.netflix.eureka包下的InstanceResource类下，接口方法为renewLease()，它是REST接口。为了减少类篇幅，省略了大部分代码的展示。其中有个registry.renew()方法，即服务续约，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PUT</span><br><span class="line">public Response renewLease(...参数省略）&#123;</span><br><span class="line">     ...  代码省略</span><br><span class="line">    boolean isSuccess&#x3D;registry.renew(app.getName(),id, isFromReplicaNode);</span><br><span class="line">       ...  代码省略</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读者可以跟踪registry.renew的代码一直深入研究。在这里就不再多讲述。另外服务续约有2个参数是可以配置，即Eureka Client发送续约心跳的时间参数和Eureka Server在多长时间内没有收到心跳将实例剔除的时间参数，在默认的情况下这两个参数分别为30秒和90秒，官方给的建议是不要修改，如果有特殊要求还是可以调整的，只需要分别在Eureka Client和Eureka Server修改以下参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka.instance.leaseRenewalIntervalInSeconds</span><br><span class="line">eureka.instance.leaseExpirationDurationInSeconds</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，服务注册列表的获取、服务下线和服务剔除就不在这里进行源码跟踪解读，因为和服务注册和续约类似，有兴趣的朋友可以自己看下源码，深入理解。总的来说，通过读源码，可以发现，整体架构与前面小节的eureka 的高可用架构图完全一致。</p>
<h2 id="Eureka-Client注册一个实例为什么这么慢"><a href="#Eureka-Client注册一个实例为什么这么慢" class="headerlink" title="Eureka Client注册一个实例为什么这么慢"></a>Eureka Client注册一个实例为什么这么慢</h2><ul>
<li>   Eureka Client一启动（不是启动完成），不是立即向Eureka Server注册，它有一个延迟向服务端注册的时间，通过跟踪源码，可以发现默认的延迟时间为40秒，源码在eureka-client-1.6.2.jar的DefaultEurekaClientConfig类下，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int getInitialInstanceInfoReplicationIntervalSeconds() &#123;</span><br><span class="line">    return configInstance.getIntProperty(</span><br><span class="line">        namespace + INITIAL_REGISTRATION_REPLICATION_DELAY_KEY, 40).get();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>   Eureka Server的响应缓存<br>Eureka Server维护每30秒更新的响应缓存,可通过更改配置eureka.server.responseCacheUpdateIntervalMs来修改。 所以即使实例刚刚注册，它也不会出现在调用/ eureka / apps REST端点的结果中。 </p>
</li>
<li><p> Eureka Server刷新缓存<br>  Eureka客户端保留注册表信息的缓存。 该缓存每30秒更新一次（如前所述）。 因 此，客户端决定刷新其本地缓存并发现其他新注册的实例可能需要30秒。</p>
</li>
<li><p>   LoadBalancer Refresh<br>Ribbon的负载平衡器从本地的Eureka Client获取服务注册列表信息。Ribbon本身还维护本地缓存，以避免为每个请求调用本地客户端。 此缓存每30秒刷新一次（可由ribbon.ServerListRefreshInterval配置）。 所以，可能需要30多秒才能使用新注册的实例。</p>
</li>
</ul>
<p>综上几个因素，一个新注册的实例，特别是启动较快的实例（默认延迟40秒注册），不能马上被Eureka Server发现。另外，刚注册的Eureka Client也不能立即被其他服务调用，因为调用方因为各种缓存没有及时的获取到新的注册列表。</p>
<h2 id="Eureka-的自我保护模式"><a href="#Eureka-的自我保护模式" class="headerlink" title="Eureka 的自我保护模式"></a>Eureka 的自我保护模式</h2><p>当一个新的Eureka Server出现时，它尝试从相邻节点获取所有实例注册表信息。如果从Peer节点获取信息时出现问题，Eureka Serve会尝试其他的Peer节点。如果服务器能够成功获取所有实例，则根据该信息设置应该接收的更新阈值。如果有任何时间，Eureka Serve接收到的续约低于为该值配置的百分比（默认为15分钟内低于85％），则服务器开启自我保护模式，即不再剔除注册列表的信息。</p>
<p>这样做的好处就是，如果是Eureka Server自身的网络问题，导致Eureka Client的续约不上，Eureka Client的注册列表信息不再被删除，也就是Eureka Client还可以被其他服务消费。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://cloud.spring.io/spring-cloud-static/Dalston.RELEASE/#netflix-eureka-client-starter">http://cloud.spring.io/spring-cloud-static/Dalston.RELEASE/#netflix-eureka-client-starter</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki">https://github.com/Netflix/eureka/wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication">https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication</a></p>
<p><a target="_blank" rel="noopener" href="http://xujin.org/sc/sc-eureka-register/">http://xujin.org/sc/sc-eureka-register/</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.abhijitsarkar.org/technical/netflix-eureka/">http://blog.abhijitsarkar.org/technical/netflix-eureka/</a></p>
<p><a target="_blank" rel="noopener" href="http://nobodyiam.com/2016/06/25/dive-into-eureka/">http://nobodyiam.com/2016/06/25/dive-into-eureka/</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud_Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul上传文件，中文文件名乱码解决办法</title>
    <url>/2017/08/11/dive-into-sc-2017-08-14-springcloud-upload-file-problem/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在项目中又一个上传文件的oss服务，直接调用服务的上传文件成功，如果经过网关zuul服务，上传中文名字的文件，文件名会出现乱码，最终导致上传失败，如果上传英文名字的文件，没有任何问题。怀疑网关zuul对中文做编码处理。</p>
 <span id="more"></span>

<h2 id="解决问题的过程"><a href="#解决问题的过程" class="headerlink" title="解决问题的过程"></a>解决问题的过程</h2><p>这个问题出现之后，我个人的解决办法如下：</p>
<ul>
<li><p>第一反应是看文档，文档地址：<a target="_blank" rel="noopener" href="http://cloud.spring.io/spring-cloud-static/Dalston.SR1/#_uploading_files_through_zuul">http://cloud.spring.io/spring-cloud-static/Dalston.SR1/#_uploading_files_through_zuul</a></p>
</li>
<li><p>粗略地看了下文档，以为没有给出解决方案（其实已经给出，只是没有理解好文档）。狂撸源码，依然没有找到解决办法。</p>
</li>
<li><p>Google搜，搜到了这条Issue，<a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1385">https://github.com/spring-cloud/spring-cloud-netflix/issues/1385</a></p>
</li>
</ul>
<p>这位大神给出的解决办法，使用zuul servlet去上传文件，而不是默认的spring mvc。使用 zuul servlet之需要在请求uri，前面加上”/zuul”即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-e1eeda790fa3fe15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先列出我的zuul服务的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port: 5000</span><br><span class="line">zuul:</span><br><span class="line">   routes:</span><br><span class="line">      oss-api:</span><br><span class="line">      path: &#x2F;oss&#x2F;**</span><br><span class="line">      serviceId: oss-service</span><br></pre></td></tr></table></figure>
<p>oss服务上传文件的接口，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;file&quot;)</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line">    @PostMapping(&quot;&#x2F;upload&quot;)  </span><br><span class="line">    public RespDTO handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file) &#123;</span><br><span class="line">        &#x2F;&#x2F;上传代码省略</span><br><span class="line">        return RespDTO.onSuc(upLoadResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么，经过网关，调用上传文件的url地址如下：</p>
<blockquote>
<p>localhost:5000/oss/file/upload</p>
</blockquote>
<p>这时如果出现中文文件名，上传文件的文件名会出现失败。按照上述大神的办法，直接在这个uri，前面加上”/zuul”，那么请求地址如下：</p>
<blockquote>
<p>localhost:5000/zuul/oss/file/upload</p>
</blockquote>
<p>测试一下，果然通过，上传中文名的文件乱码问题解决。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud_Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-springcloud-feign-resources/</url>
    <content><![CDATA[<h2 id="什么是Feign"><a href="#什么是Feign" class="headerlink" title="什么是Feign"></a>什么是Feign</h2><p>Feign是由Retrofit，JAXRS-2.0和WebSocket启发的一个java到http客户端绑定。 Feign的主要目标是将Java Http Clients变得简单。Feign的源码地址：<a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<span id="more"></span>

<h2 id="写一个Feign"><a href="#写一个Feign" class="headerlink" title="写一个Feign"></a>写一个Feign</h2><p>在我之前的博文有写到如何用Feign去消费服务，文章地址：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69808079">http://blog.csdn.net/forezp/article/details/69808079</a>  。</p>
<p>简单的实现一个Feign客户端，首先通过@FeignClient，客户端，其中value为调用其他服务的名称，FeignConfig.class为FeignClient的配置文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@FeignClient(value &#x3D; &quot;service-hi&quot;,configuration &#x3D; FeignConfig.class)</span><br><span class="line">public interface SchedualServiceHi &#123;</span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;hi&quot;)</span><br><span class="line">    String sayHiFromClientOne(@RequestParam(value &#x3D; &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Retryer feignRetryer() &#123;</span><br><span class="line">        return new Retryer.Default(100, SECONDS.toMillis(1), 5);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看FeignClient的源码，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface FeignClient &#123;</span><br><span class="line"></span><br><span class="line">@AliasFor(&quot;name&quot;)</span><br><span class="line">String value() default &quot;&quot;;</span><br><span class="line">	</span><br><span class="line">@AliasFor(&quot;value&quot;)</span><br><span class="line">String name() default &quot;&quot;;</span><br><span class="line">	</span><br><span class="line">@AliasFor(&quot;value&quot;)</span><br><span class="line">String name() default &quot;&quot;;</span><br><span class="line">String url() default &quot;&quot;;</span><br><span class="line">boolean decode404() default false;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] configuration() default &#123;&#125;;</span><br><span class="line">Class&lt;?&gt; fallback() default void.class;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; fallbackFactory() default void.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String path() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">boolean primary() default true;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>feign 用于声明具有该接口的REST客户端的接口的注释应该是创建（例如用于自动连接到另一个组件。 如果功能区可用，那将是<br>用于负载平衡后端请求，并且可以配置负载平衡器<br>使用与伪装客户端相同名称（即值）@RibbonClient 。</p>
<p>其中value()和name()一样，是被调用的 service的名称。<br>url(),直接填写硬编码的url,decode404()即404是否被解码，还是抛异常；configuration()，标明FeignClient的配置类，默认的配置类为FeignClientsConfiguration类，可以覆盖Decoder、Encoder和Contract等信息，进行自定义配置。fallback(),填写熔断器的信息类。</p>
<h2 id="FeignClient的配置"><a href="#FeignClient的配置" class="headerlink" title="FeignClient的配置"></a>FeignClient的配置</h2><p>默认的配置类为FeignClientsConfiguration，这个类在spring-cloud-netflix-core的jar包下，打开这个类，可以发现它是一个配置类，注入了很多的相关配置的bean，包括feignRetryer、FeignLoggerFactory、FormattingConversionService等,其中还包括了Decoder、Encoder、Contract，如果这三个bean在没有注入的情况下，会自动注入默认的配置。</p>
<ul>
<li>Decoder feignDecoder: ResponseEntityDecoder(这是对SpringDecoder的封装)</li>
<li>Encoder feignEncoder: SpringEncoder</li>
<li>Logger feignLogger: Slf4jLogger</li>
<li>Contract feignContract: SpringMvcContract</li>
<li>Feign.Builder feignBuilder: HystrixFeign.Builder</li>
</ul>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignClientsConfiguration &#123;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Decoder feignDecoder() &#123;</span><br><span class="line">		return new ResponseEntityDecoder(new SpringDecoder(this.messageConverters));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Encoder feignEncoder() &#123;</span><br><span class="line">		return new SpringEncoder(this.messageConverters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Contract feignContract(ConversionService feignConversionService) &#123;</span><br><span class="line">		return new SpringMvcContract(this.parameterProcessors, feignConversionService);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重写配置：</p>
<p>你可以重写FeignClientsConfiguration中的bean，从而达到自定义配置的目的，比如FeignClientsConfiguration的默认重试次数为Retryer.NEVER_RETRY，即不重试，那么希望做到重写，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Retryer feignRetryer() &#123;</span><br><span class="line">        return new Retryer.Default(100, SECONDS.toMillis(1), 5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述代码更改了该FeignClient的重试次数，重试间隔为100ms，最大重试时间为1s,重试次数为5次。</p>
<h2 id="Feign的工作原理"><a href="#Feign的工作原理" class="headerlink" title="Feign的工作原理"></a>Feign的工作原理</h2><p>feign是一个伪客户端，即它不做任何的请求处理。Feign通过处理注解生成request，从而实现简化HTTP API开发的目的，即开发人员可以使用注解的方式定制request api模板，在发送http request请求之前，feign通过处理注解的方式替换掉request模板中的参数，这种实现方式显得更为直接、可理解。</p>
<p>通过包扫描注入FeignClient的bean，该源码在FeignClientsRegistrar类：<br>首先在启动配置上检查是否有@EnableFeignClients注解，如果有该注解，则开启包扫描，扫描被@FeignClient注解接口。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void registerDefaultConfiguration(AnnotationMetadata metadata,</span><br><span class="line">			BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; defaultAttrs &#x3D; metadata</span><br><span class="line">				.getAnnotationAttributes(EnableFeignClients.class.getName(), true);</span><br><span class="line"></span><br><span class="line">		if (defaultAttrs !&#x3D; null &amp;&amp; defaultAttrs.containsKey(&quot;defaultConfiguration&quot;)) &#123;</span><br><span class="line">			String name;</span><br><span class="line">			if (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">				name &#x3D; &quot;default.&quot; + metadata.getEnclosingClassName();</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				name &#x3D; &quot;default.&quot; + metadata.getClassName();</span><br><span class="line">			&#125;</span><br><span class="line">			registerClientConfiguration(registry, name,</span><br><span class="line">					defaultAttrs.get(&quot;defaultConfiguration&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>扫描到FeignClient后，将信息取出，以bean的形式注入到ioc容器中，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void registerFeignClients(AnnotationMetadata metadata,</span><br><span class="line">			BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		ClassPathScanningCandidateComponentProvider scanner &#x3D; getScanner();</span><br><span class="line">		scanner.setResourceLoader(this.resourceLoader);</span><br><span class="line"></span><br><span class="line">		Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; attrs &#x3D; metadata</span><br><span class="line">				.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">		AnnotationTypeFilter annotationTypeFilter &#x3D; new AnnotationTypeFilter(</span><br><span class="line">				FeignClient.class);</span><br><span class="line">		final Class&lt;?&gt;[] clients &#x3D; attrs &#x3D;&#x3D; null ? null</span><br><span class="line">				: (Class&lt;?&gt;[]) attrs.get(&quot;clients&quot;);</span><br><span class="line">		if (clients &#x3D;&#x3D; null || clients.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">			basePackages &#x3D; getBasePackages(metadata);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			final Set&lt;String&gt; clientClasses &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">			basePackages &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">			for (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">				basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">				clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">			&#125;</span><br><span class="line">			AbstractClassTestingTypeFilter filter &#x3D; new AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				protected boolean match(ClassMetadata metadata) &#123;</span><br><span class="line">					String cleaned &#x3D; metadata.getClassName().replaceAll(&quot;\\$&quot;, &quot;.&quot;);</span><br><span class="line">					return clientClasses.contains(cleaned);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			scanner.addIncludeFilter(</span><br><span class="line">					new AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (String basePackage : basePackages) &#123;</span><br><span class="line">			Set&lt;BeanDefinition&gt; candidateComponents &#x3D; scanner</span><br><span class="line">					.findCandidateComponents(basePackage);</span><br><span class="line">			for (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">				if (candidateComponent instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">					&#x2F;&#x2F; verify annotated class is an interface</span><br><span class="line">					AnnotatedBeanDefinition beanDefinition &#x3D; (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">					AnnotationMetadata annotationMetadata &#x3D; beanDefinition.getMetadata();</span><br><span class="line">					Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">							&quot;@FeignClient can only be specified on an interface&quot;);</span><br><span class="line"></span><br><span class="line">					Map&lt;String, Object&gt; attributes &#x3D; annotationMetadata</span><br><span class="line">							.getAnnotationAttributes(</span><br><span class="line">									FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">					String name &#x3D; getClientName(attributes);</span><br><span class="line">					registerClientConfiguration(registry, name,</span><br><span class="line">							attributes.get(&quot;configuration&quot;));</span><br><span class="line"></span><br><span class="line">					registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void registerFeignClient(BeanDefinitionRegistry registry,</span><br><span class="line">			AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) &#123;</span><br><span class="line">		String className &#x3D; annotationMetadata.getClassName();</span><br><span class="line">		BeanDefinitionBuilder definition &#x3D; BeanDefinitionBuilder</span><br><span class="line">				.genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">		validate(attributes);</span><br><span class="line">		definition.addPropertyValue(&quot;url&quot;, getUrl(attributes));</span><br><span class="line">		definition.addPropertyValue(&quot;path&quot;, getPath(attributes));</span><br><span class="line">		String name &#x3D; getName(attributes);</span><br><span class="line">		definition.addPropertyValue(&quot;name&quot;, name);</span><br><span class="line">		definition.addPropertyValue(&quot;type&quot;, className);</span><br><span class="line">		definition.addPropertyValue(&quot;decode404&quot;, attributes.get(&quot;decode404&quot;));</span><br><span class="line">		definition.addPropertyValue(&quot;fallback&quot;, attributes.get(&quot;fallback&quot;));</span><br><span class="line">		definition.addPropertyValue(&quot;fallbackFactory&quot;, attributes.get(&quot;fallbackFactory&quot;));</span><br><span class="line">		definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">		String alias &#x3D; name + &quot;FeignClient&quot;;</span><br><span class="line">		AbstractBeanDefinition beanDefinition &#x3D; definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">		boolean primary &#x3D; (Boolean)attributes.get(&quot;primary&quot;); &#x2F;&#x2F; has a default, won&#39;t be null</span><br><span class="line"></span><br><span class="line">		beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">		String qualifier &#x3D; getQualifier(attributes);</span><br><span class="line">		if (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">			alias &#x3D; qualifier;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BeanDefinitionHolder holder &#x3D; new BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">				new String[] &#123; alias &#125;);</span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注入bean之后，通过jdk的代理，当请求Feign Client的方法时会被拦截，代码在ReflectiveFeign类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T newInstance(Target&lt;T&gt; target) &#123;</span><br><span class="line">   Map&lt;String, MethodHandler&gt; nameToHandler &#x3D; targetToHandlersByName.apply(target);</span><br><span class="line">   Map&lt;Method, MethodHandler&gt; methodToHandler &#x3D; new LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">   List&lt;DefaultMethodHandler&gt; defaultMethodHandlers &#x3D; new LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line"></span><br><span class="line">   for (Method method : target.type().getMethods()) &#123;</span><br><span class="line">     if (method.getDeclaringClass() &#x3D;&#x3D; Object.class) &#123;</span><br><span class="line">       continue;</span><br><span class="line">     &#125; else if(Util.isDefault(method)) &#123;</span><br><span class="line">       DefaultMethodHandler handler &#x3D; new DefaultMethodHandler(method);</span><br><span class="line">       defaultMethodHandlers.add(handler);</span><br><span class="line">       methodToHandler.put(method, handler);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   InvocationHandler handler &#x3D; factory.create(target, methodToHandler);</span><br><span class="line">   T proxy &#x3D; (T) Proxy.newProxyInstance(target.type().getClassLoader(), new Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">   for(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">     defaultMethodHandler.bindTo(proxy);</span><br><span class="line">   &#125;</span><br><span class="line">   return proxy;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在SynchronousMethodHandler类进行拦截处理，当被拦截会根据参数生成RequestTemplate对象，该对象就是http请求的模板，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public Object invoke(Object[] argv) throws Throwable &#123;</span><br><span class="line">   RequestTemplate template &#x3D; buildTemplateFromArgs.create(argv);</span><br><span class="line">   Retryer retryer &#x3D; this.retryer.clone();</span><br><span class="line">   while (true) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       return executeAndDecode(template);</span><br><span class="line">     &#125; catch (RetryableException e) &#123;</span><br><span class="line">       retryer.continueOrPropagate(e);</span><br><span class="line">       if (logLevel !&#x3D; Logger.Level.NONE) &#123;</span><br><span class="line">         logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">       &#125;</span><br><span class="line">       continue;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中有个executeAndDecode()方法，该方法是通RequestTemplate生成Request请求对象，然后根据用client获取response。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Object executeAndDecode(RequestTemplate template) throws Throwable &#123;</span><br><span class="line">    Request request &#x3D; targetRequest(template);</span><br><span class="line">    ...&#x2F;&#x2F;省略代码</span><br><span class="line">    response &#x3D; client.execute(request, options);</span><br><span class="line">    ...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Client组件"><a href="#Client组件" class="headerlink" title="Client组件"></a>Client组件</h2><p>其中Client组件是一个非常重要的组件，Feign最终发送request请求以及接收response响应，都是由Client组件完成的，其中Client的实现类，只要有Client.Default，该类由HttpURLConnnection实现网络请求，另外还支持HttpClient、Okhttp.</p>
<p>首先来看以下在FeignRibbonClient的自动配置类，FeignRibbonClientAutoConfiguration ，主要在工程启动的时候注入一些bean,其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConditionalOnClass(&#123; ILoadBalancer.class, Feign.class &#125;)</span><br><span class="line">@Configuration</span><br><span class="line">@AutoConfigureBefore(FeignAutoConfiguration.class)</span><br><span class="line">public class FeignRibbonClientAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,</span><br><span class="line">			SpringClientFactory clientFactory) &#123;</span><br><span class="line">		return new LoadBalancerFeignClient(new Client.Default(null, null),</span><br><span class="line">				cachingFactory, clientFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在缺失配置feignClient的情况下，会自动注入new Client.Default(),跟踪Client.Default()源码，它使用的网络请求框架为HttpURLConnection，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public Response execute(Request request, Options options) throws IOException &#123;</span><br><span class="line">    HttpURLConnection connection &#x3D; convertAndSend(request, options);</span><br><span class="line">    return convertResponse(connection).toBuilder().request(request).build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>怎么在feign中使用HttpClient，查看FeignRibbonClientAutoConfiguration的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConditionalOnClass(&#123; ILoadBalancer.class, Feign.class &#125;)</span><br><span class="line">@Configuration</span><br><span class="line">@AutoConfigureBefore(FeignAutoConfiguration.class)</span><br><span class="line">public class FeignRibbonClientAutoConfiguration &#123;</span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">	@ConditionalOnClass(ApacheHttpClient.class)</span><br><span class="line">	@ConditionalOnProperty(value &#x3D; &quot;feign.httpclient.enabled&quot;, matchIfMissing &#x3D; true)</span><br><span class="line">	protected static class HttpClientFeignLoadBalancedConfiguration &#123;</span><br><span class="line"></span><br><span class="line">		@Autowired(required &#x3D; false)</span><br><span class="line">		private HttpClient httpClient;</span><br><span class="line"></span><br><span class="line">		@Bean</span><br><span class="line">		@ConditionalOnMissingBean(Client.class)</span><br><span class="line">		public Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,</span><br><span class="line">				SpringClientFactory clientFactory) &#123;</span><br><span class="line">			ApacheHttpClient delegate;</span><br><span class="line">			if (this.httpClient !&#x3D; null) &#123;</span><br><span class="line">				delegate &#x3D; new ApacheHttpClient(this.httpClient);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				delegate &#x3D; new ApacheHttpClient();</span><br><span class="line">			&#125;</span><br><span class="line">			return new LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从代码@ConditionalOnClass(ApacheHttpClient.class)注解可知道，只需要在pom文件加上HttpClient的classpath就行了，另外需要在配置文件上加上feign.httpclient.enabled为true，从    @ConditionalOnProperty注解可知，这个可以不写，在默认的情况下就为true.</p>
<p>在pom文件加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-httpclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同理，如果想要feign使用Okhttp，则只需要在pom文件上加上feign-okhttp的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-okhttp&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="feign的负载均衡是怎么样实现的呢？"><a href="#feign的负载均衡是怎么样实现的呢？" class="headerlink" title="feign的负载均衡是怎么样实现的呢？"></a>feign的负载均衡是怎么样实现的呢？</h2><p>通过上述的FeignRibbonClientAutoConfiguration类配置Client的类型(httpurlconnection，okhttp和httpclient)时候，可知最终向容器注入的是LoadBalancerFeignClient，即负载均衡客户端。现在来看下LoadBalancerFeignClient的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Response execute(Request request, Request.Options options) throws IOException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		URI asUri &#x3D; URI.create(request.url());</span><br><span class="line">		String clientName &#x3D; asUri.getHost();</span><br><span class="line">		URI uriWithoutHost &#x3D; cleanUrl(request.url(), clientName);</span><br><span class="line">		FeignLoadBalancer.RibbonRequest ribbonRequest &#x3D; new FeignLoadBalancer.RibbonRequest(</span><br><span class="line">				this.delegate, request, uriWithoutHost);</span><br><span class="line"></span><br><span class="line">		IClientConfig requestConfig &#x3D; getClientConfig(options, clientName);</span><br><span class="line">		return lbClient(clientName).executeWithLoadBalancer(ribbonRequest,</span><br><span class="line">				requestConfig).toResponse();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ClientException e) &#123;</span><br><span class="line">		IOException io &#x3D; findIOException(e);</span><br><span class="line">		if (io !&#x3D; null) &#123;</span><br><span class="line">			throw io;</span><br><span class="line">		&#125;</span><br><span class="line">		throw new RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有个executeWithLoadBalancer()方法，即通过负载均衡的方式请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T executeWithLoadBalancer(final S request, final IClientConfig requestConfig) throws ClientException &#123;</span><br><span class="line">      RequestSpecificRetryHandler handler &#x3D; getRequestSpecificRetryHandler(request, requestConfig);</span><br><span class="line">      LoadBalancerCommand&lt;T&gt; command &#x3D; LoadBalancerCommand.&lt;T&gt;builder()</span><br><span class="line">              .withLoadBalancerContext(this)</span><br><span class="line">              .withRetryHandler(handler)</span><br><span class="line">              .withLoadBalancerURI(request.getUri())</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">          return command.submit(</span><br><span class="line">              new ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public Observable&lt;T&gt; call(Server server) &#123;</span><br><span class="line">                      URI finalUri &#x3D; reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                      S requestForServer &#x3D; (S) request.replaceUri(finalUri);</span><br><span class="line">                      try &#123;</span><br><span class="line">                          return Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig));</span><br><span class="line">                      &#125; </span><br><span class="line">                      catch (Exception e) &#123;</span><br><span class="line">                          return Observable.error(e);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .toBlocking()</span><br><span class="line">              .single();</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          Throwable t &#x3D; e.getCause();</span><br><span class="line">          if (t instanceof ClientException) &#123;</span><br><span class="line">              throw (ClientException) t;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              throw new ClientException(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中服务在submit()方法上，点击submit进入具体的方法,这个方法是LoadBalancerCommand的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable&lt;T&gt; o &#x3D; </span><br><span class="line">           (server &#x3D;&#x3D; null ? selectServer() : Observable.just(server))</span><br><span class="line">           .concatMap(new Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               &#x2F;&#x2F; Called for each server being selected</span><br><span class="line">               public Observable&lt;T&gt; call(Server server) &#123;</span><br><span class="line">                   context.setServer(server);</span><br><span class="line">    </span><br><span class="line">   &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中有个selectServe()，该方法是选择服务的进行负载均衡的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Observable&lt;Server&gt; selectServer() &#123;</span><br><span class="line">    return Observable.create(new OnSubscribe&lt;Server&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Subscriber&lt;? super Server&gt; next) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Server server &#x3D; loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   </span><br><span class="line">                next.onNext(server);</span><br><span class="line">                next.onCompleted();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                next.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终负载均衡交给loadBalancerContext来处理，即之前讲述的Ribbon，在这里不再重复。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总到来说，Feign的源码实现的过程如下：</p>
<ul>
<li>首先通过@EnableFeignCleints注解开启FeignCleint</li>
<li>根据Feign的规则实现接口，并加@FeignCleint注解</li>
<li>程序启动后，会进行包扫描，扫描所有的@ FeignCleint的注解的类，并将这些信息注入到ioc容器中。</li>
<li>当接口的方法被调用，通过jdk的代理，来生成具体的RequesTemplate</li>
<li>RequesTemplate在生成Request</li>
<li>Request交给Client去处理，其中Client可以是HttpUrlConnection、HttpClient也可以是Okhttp</li>
<li>最后Client被封装到LoadBalanceClient类，这个类结合类Ribbon做到了负载均衡。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.de-swaef.eu/the-netflix-stack-using-spring-boot-part-3-feign/">https://blog.de-swaef.eu/the-netflix-stack-using-spring-boot-part-3-feign/</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud_Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 博客加载优化</title>
    <url>/2022/12/24/hexo-hexo-y/</url>
    <content><![CDATA[<h1 id="hexo-博客加载优化"><a href="#hexo-博客加载优化" class="headerlink" title="hexo 博客加载优化"></a>hexo 博客加载优化</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近趁着周末折腾自己博客的时候,发现刷页面的时候会有点卡顿,感觉页面性能很低,所以开始了下面的优化,分析下来结果还不错比之前快了很多,那让我们开始吧!</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/1050E4F2-AB1F-423B-8DE0-393C1A892684/3E8FC5EB-EEB0-4C2D-94EC-C948F99002CA_2/D2DBPCbNGLqxlHxMmGlIfcTaOf8xxt6pIZxuqnXNyMwz/Image.png" alt="Image.png"></p>
<p>简单的来说主要以下几个部分的优化:</p>
<ul>
<li><strong>压缩静态资源,提高访问速度</strong></li>
<li><strong>图片懒加载</strong></li>
</ul>
<span id="more"></span>
<h3 id="压缩静态资源"><a href="#压缩静态资源" class="headerlink" title="压缩静态资源"></a>压缩静态资源</h3><p>安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure>

<p>然后我们需要在站点配置文件_config.yml 中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css</span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.min.css&#39;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.min.js&#39;</span><br><span class="line">    - &#39;**&#x2F;jquery.fancybox.pack.js&#39;</span><br><span class="line">    - &#39;**&#x2F;index.js&#39;</span><br><span class="line">    - &#39;**&#x2F;fireworks.js&#39;</span><br></pre></td></tr></table></figure>

<h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>安装插件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure>

<p>_config.yml 中添加以下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 图片懒加载</span><br><span class="line">lazyload:</span><br><span class="line">  enable: true</span><br><span class="line">  onlypost: false</span><br><span class="line">  loadingImg: &#x2F;images&#x2F;loading.gif</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>API网关的工作原理与实战案例</title>
    <url>/2023/03/09/gateway-API%E7%BD%91%E5%85%B3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/52741EAB-FA8B-4F0B-995B-7E0073E6BFE4/6E9D2C7C-B75E-4CBF-BCFD-493C7BB284B3_2/22KDf95eaVwEmpeHBkKPvRBS0Enubdr8y5tBMQpxPgcz/Image.png" alt="Image.png"></p>
<h1 id="API网关的工作原理与实战案例"><a href="#API网关的工作原理与实战案例" class="headerlink" title="API网关的工作原理与实战案例"></a>API网关的工作原理与实战案例</h1><p>API网关是一个在微服务架构中起到重要作用的组件。它可以处理所有客户端请求并对它们进行统一的管理和路由。本文将介绍API网关的工作原理，并给出一个基于Spring Cloud Gateway的实战案例。</p>
<span id="more"></span>
<h2 id="API网关的工作原理"><a href="#API网关的工作原理" class="headerlink" title="API网关的工作原理"></a>API网关的工作原理</h2><p>API网关的工作流程如下：</p>
<ol>
<li>客户端向API网关发送HTTP请求。</li>
<li>API网关解析并验证HTTP请求中的属性。</li>
<li>API网关执行白名单或黑名单检查。</li>
<li>API网关与身份提供者进行身份验证和授权。</li>
<li>限流规则应用于请求。如果超过限制，则请求被拒绝。</li>
<li>现在请求已经通过基本检查，API网关通过路径匹配找到相应的服务进行路由。</li>
<li>API网关将请求转换为适当的协议并将其发送到后端微服务。</li>
<li>API网关可以适当地处理错误，并在错误需要更长时间恢复时处理故障（熔断）。它还可以利用ELK（Elastic-Logstash-Kibana）堆栈进行日志记录和监视。我们有时会在API网关中缓存数据。</li>
</ol>
<p>API网关可以在多个方面帮助您的微服务架构，包括：</p>
<ul>
<li>提高安全性：通过身份验证和授权，API网关可以确保只有授权用户可以访问您的微服务。</li>
<li>提高可靠性：通过限流规则和熔断机制，API网关可以防止服务过载，并保持系统的稳定性。</li>
<li>提高性能：通过缓存数据和负载均衡，API网关可以提高系统的性能。</li>
</ul>
<h2 id="基于Spring-Cloud-Gateway的实战案例"><a href="#基于Spring-Cloud-Gateway的实战案例" class="headerlink" title="基于Spring Cloud Gateway的实战案例"></a>基于Spring Cloud Gateway的实战案例</h2><p>Spring Cloud Gateway是Spring Cloud的一部分，它提供了一种轻量级的方式来构建API网关。以下是一个基于Spring Cloud Gateway的实战案例：</p>
<h2 id="Spring-Cloud-Gateway的基本用法"><a href="#Spring-Cloud-Gateway的基本用法" class="headerlink" title="Spring Cloud Gateway的基本用法"></a>Spring Cloud Gateway的基本用法</h2><p>Spring Cloud Gateway的基本用法可以分为以下几个步骤：</p>
<ol>
<li>在pom.xml中添加Spring Cloud Gateway的依赖：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在application.yml或application.properties中添加路由规则：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: route1</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8081</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;api&#x2F;**</span><br><span class="line">        - id: route2</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8082</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;user&#x2F;**</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动Spring Boot应用程序，并访问<a target="_blank" rel="noopener" href="http://localhost:8080/api/hello%E6%88%96http://localhost:8080/user/list">http://localhost:8080/api/hello或http://localhost:8080/user/list</a></li>
</ol>
<h2 id="Spring-Cloud-Gateway的高级用法"><a href="#Spring-Cloud-Gateway的高级用法" class="headerlink" title="Spring Cloud Gateway的高级用法"></a>Spring Cloud Gateway的高级用法</h2><p>Spring Cloud Gateway的高级用法可以包括以下几个方面：</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器是Spring Cloud Gateway的核心概念之一，它可以在请求和响应之间执行各种操作，例如身份验证、流控、路由、日志等</p>
<p>接下来，我们将进一步探讨Spring Cloud Gateway的高级用法。具体来说，我们将介绍以下几点：</p>
<ul>
<li>自定义过滤器</li>
<li>动态路由</li>
<li>限流策略</li>
<li>断路器</li>
</ul>
<h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>Spring Cloud Gateway的过滤器是请求和响应的处理器，可以在请求被路由到目标服务之前或之后进行一些操作。过滤器可以用来处理身份验证、路由跟踪、访问日志等任务。</p>
<p>下面是一个自定义请求过滤器的例子，它会在请求头中添加一个自定义的跟踪ID：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AddTraceIdFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TRACE_ID_HEADER &#x3D; &quot;X-Trace-Id&quot;;</span><br><span class="line">    private static final int ORDER &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        String traceId &#x3D; UUID.randomUUID().toString();</span><br><span class="line">        ServerHttpRequest request &#x3D; exchange.getRequest().mutate()</span><br><span class="line">                .header(TRACE_ID_HEADER, traceId)</span><br><span class="line">                .build();</span><br><span class="line">        ServerWebExchange mutatedExchange &#x3D; exchange.mutate()</span><br><span class="line">                .request(request)</span><br><span class="line">                .build();</span><br><span class="line">        return chain.filter(mutatedExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return ORDER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过滤器实现了Spring Cloud Gateway的GlobalFilter接口，并重写了其中的filter和getOrder方法。在filter方法中，它生成了一个随机的跟踪ID，并将它添加到请求头中。在getOrder方法中，它指定了过滤器的执行顺序。</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>动态路由是指在运行时根据配置动态地将请求路由到不同的后端服务。Spring Cloud Gateway提供了一些机制来实现动态路由，比如使用Eureka或Consul作为服务发现组件，并结合Spring Cloud Config Server来管理路由规则。</p>
<p>以下是一个简单的动态路由配置的例子，它将根据请求路径将请求路由到不同的后端服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: service1</span><br><span class="line">          uri: lb:&#x2F;&#x2F;service1</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;service1&#x2F;**</span><br><span class="line">        - id: service2</span><br><span class="line">          uri: lb:&#x2F;&#x2F;service2</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;service2&#x2F;**</span><br></pre></td></tr></table></figure>

<p>这个配置文件中定义了两个路由规则，它们分别将以/service1和/service2开头的请求路由到service1和service2这两个后端服务</p>
<h3 id="限流策略"><a href="#限流策略" class="headerlink" title="限流策略"></a>限流策略</h3><p>限流策略通常基于令牌桶算法或漏桶算法实现。这些算法都是一种流量控制算法，通过控制流量的输入速率来保护后端服务。</p>
<ul>
<li>令牌桶算法：在一定的时间间隔内，按照固定的速率往桶中放入令牌。当请求到来时，如果桶中有足够的令牌，则将请求处理掉，并从桶中扣除相应数量的令牌；否则，请求被拒绝。</li>
<li>漏桶算法：设定一个容量为b的漏桶，每单位时间流出r个请求。当请求到来时，如果桶未满，则将请求放入桶中，并等待r秒钟；否则，请求被拒绝。</li>
</ul>
<p>在Spring Cloud Gateway中，可以通过自定义GatewayFilter实现限流策略。在GatewayFilter中，可以通过RateLimiterRegistry创建限流器，并在过滤器链中进行限流操作。</p>
<ol>
<li>添加依赖</li>
</ol>
<p>在pom.xml中添加spring-cloud-starter-gateway和spring-boot-starter-actuator依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置限流策略</li>
</ol>
<p>在配置文件中添加限流策略。这里我们以令牌桶算法为例，设置限流速率为10个请求/秒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      default-filters:</span><br><span class="line">        - name: RequestRateLimiter</span><br><span class="line">          args:</span><br><span class="line">            key-resolver: &quot;#&#123;@userKeyResolver&#125;&quot;</span><br><span class="line">            rate-limiter: &quot;#&#123;@redisRateLimiter&#125;&quot;</span><br><span class="line">      routes:</span><br><span class="line">        - id: test_route</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8080</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;test&#x2F;**</span><br><span class="line">          filters:</span><br><span class="line">            - name: RequestRateLimiter</span><br><span class="line">              args:</span><br><span class="line">                key-resolver: &quot;#&#123;@userKeyResolver&#125;&quot;</span><br><span class="line">                rate-limiter: &quot;#&#123;@redisRateLimiter&#125;&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>实现GatewayFilter</li>
</ol>
<p>创建一个实现GatewayFilter的类，用于创建限流器并进行限流操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RateLimitFilter implements GatewayFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private final RateLimiter rateLimiter;</span><br><span class="line"></span><br><span class="line">    public RateLimitFilter(RateLimiter rateLimiter) &#123;</span><br><span class="line">        this.rateLimiter &#x3D; rateLimiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        String ip &#x3D; exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();</span><br><span class="line">        if (rateLimiter.tryAcquire(ip)) &#123;</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);</span><br><span class="line">            return exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们首先创建了一个名为RateLimitFilter的类，并实现了GatewayFilter接口。构造函数中传入了一个RateLimiter对象，用于进行限流操作。在filter方法中，我们通过ServerWebExchange对象获取请求的IP地址，并尝试获取令牌进行限流。如果获取到令牌，则将请求传递给下一个过滤器或处理程序，否则返回“too many requests”错误响应。</p>
<p>另外，我们还重写了getOrder方法并返回-1，以确保这个过滤器在所有其他过滤器之前运行。这是因为我们希望在进行任何其他操作之前先进行限流。</p>
<p>现在我们已经创建了一个基于网关的限流策略，并使用RateLimiter对象实现了基于令牌桶的算法进行限流操作。接下来我们需要将该过滤器添加到Spring Cloud Gateway中。</p>
<p>我们可以在配置文件中使用路由ID将过滤器应用于特定的路由。例如，假设我们要将上述限流过滤器应用于名为“foo”的路由，我们可以将以下代码添加到application.yml配置文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: foo</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8081</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;foo&#x2F;**</span><br><span class="line">          filters:</span><br><span class="line">            - name: RateLimiter</span><br><span class="line">              args:</span><br><span class="line">                redis-rate-limiter.replenishRate: 10</span><br><span class="line">                redis-rate-limiter.burstCapacity: 20</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用路由ID“foo”来标识我们想要应用这个过滤器的路由。我们还定义了一个名为“RateLimiter”的过滤器，并将其添加到路由的过滤器链中。</p>
<p>在这个示例中，我们使用了Redis限流器来实现限流。我们设置了刷新速率为每秒10个请求，突发容量为20个请求。</p>
<p>当用户请求“/foo”下的任何端点时，我们的限流过滤器会在网关层面上限制请求速率。如果请求速率超过限制，则该请求将被拒绝。</p>
]]></content>
      <categories>
        <category>gateway</category>
      </categories>
      <tags>
        <tag>gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-springcloud-zuul-resources/</url>
    <content><![CDATA[<h2 id="Zuul-架构图"><a href="#Zuul-架构图" class="headerlink" title="Zuul 架构图"></a>Zuul 架构图</h2><p>在zuul中， 整个请求的过程是这样的，首先将请求给zuulservlet处理，zuulservlet中有一个zuulRunner对象，该对象中初始化了RequestContext：作为存储整个请求的一些数据，并被所有的zuulfilter共享。zuulRunner中还有 FilterProcessor，FilterProcessor作为执行所有的zuulfilter的管理器。FilterProcessor从filterloader 中获取zuulfilter，而zuulfilter是被filterFileManager所加载，并支持groovy热加载，采用了轮询的方式热加载。</p>
<span id="more"></span>


<p>有了这些filter之后，zuulservelet首先执行的Pre类型的过滤器，再执行route类型的过滤器，最后执行的是post 类型的过滤器，如果在执行这些过滤器有错误的时候则会执行error类型的过滤器。执行完这些过滤器，最终将请求的结果返回给客户端。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/2279594-2e6134e4743b0483.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zuul.png"></p>
<h2 id="zuul工作原理源码分析"><a href="#zuul工作原理源码分析" class="headerlink" title="zuul工作原理源码分析"></a>zuul工作原理源码分析</h2><p>在之前已经讲过，如何使用zuul，其中不可缺少的一个步骤就是在程序的启动类加上＠EnableZuulProxy，该EnableZuulProxy类代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableCircuitBreaker</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Import(ZuulProxyConfiguration.class)</span><br><span class="line">public @interface EnableZuulProxy &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 其中，引用了ZuulProxyConfiguration，跟踪ZuulProxyConfiguration，该类注入了DiscoveryClient、RibbonCommandFactoryConfiguration用作负载均衡相关的。注入了一些列的filters，比如PreDecorationFilter、RibbonRoutingFilter、SimpleHostRoutingFilter，代码如如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public PreDecorationFilter preDecorationFilter(RouteLocator routeLocator, ProxyRequestHelper proxyRequestHelper) &#123;</span><br><span class="line">	return new PreDecorationFilter(routeLocator, this.server.getServletPrefix(), this.zuulProperties,</span><br><span class="line">			proxyRequestHelper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; route filters</span><br><span class="line">@Bean</span><br><span class="line">public RibbonRoutingFilter ribbonRoutingFilter(ProxyRequestHelper helper,</span><br><span class="line">		RibbonCommandFactory&lt;?&gt; ribbonCommandFactory) &#123;</span><br><span class="line">	RibbonRoutingFilter filter &#x3D; new RibbonRoutingFilter(helper, ribbonCommandFactory, this.requestCustomizers);</span><br><span class="line">	return filter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleHostRoutingFilter simpleHostRoutingFilter(ProxyRequestHelper helper, ZuulProperties zuulProperties) &#123;</span><br><span class="line">	return new SimpleHostRoutingFilter(helper, zuulProperties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 它的父类ZuulConfiguration ，引用了一些相关的配置。在缺失zuulServlet  bean的情况下注入了ZuulServlet，该类是zuul的核心类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	@Bean</span><br><span class="line">@ConditionalOnMissingBean(name &#x3D; &quot;zuulServlet&quot;)</span><br><span class="line">public ServletRegistrationBean zuulServlet() &#123;</span><br><span class="line">	ServletRegistrationBean servlet &#x3D; new ServletRegistrationBean(new ZuulServlet(),</span><br><span class="line">			this.zuulProperties.getServletPattern());</span><br><span class="line">	&#x2F;&#x2F; The whole point of exposing this servlet is to provide a route that doesn&#39;t</span><br><span class="line">	&#x2F;&#x2F; buffer requests.</span><br><span class="line">	servlet.addInitParameter(&quot;buffer-requests&quot;, &quot;false&quot;);</span><br><span class="line">	return servlet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时也注入了其他的过滤器，比如ServletDetectionFilter、DebugFilter、Servlet30WrapperFilter，这些过滤器都是pre类型的。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ServletDetectionFilter servletDetectionFilter() &#123;</span><br><span class="line">	return new ServletDetectionFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public FormBodyWrapperFilter formBodyWrapperFilter() &#123;</span><br><span class="line">	return new FormBodyWrapperFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public DebugFilter debugFilter() &#123;</span><br><span class="line">	return new DebugFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Servlet30WrapperFilter servlet30WrapperFilter() &#123;</span><br><span class="line">	return new Servlet30WrapperFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 它也注入了post类型的，比如 SendResponseFilter，error类型，比如 SendErrorFilter，route类型比如SendForwardFilter，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SendResponseFilter sendResponseFilter() &#123;</span><br><span class="line">	return new SendResponseFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SendErrorFilter sendErrorFilter() &#123;</span><br><span class="line">	return new SendErrorFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SendForwardFilter sendForwardFilter() &#123;</span><br><span class="line">	return new SendForwardFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化ZuulFilterInitializer类，将所有的filter 向FilterRegistry注册。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	@Configuration</span><br><span class="line">protected static class ZuulFilterConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private Map&lt;String, ZuulFilter&gt; filters;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public ZuulFilterInitializer zuulFilterInitializer(</span><br><span class="line">			CounterFactory counterFactory, TracerFactory tracerFactory) &#123;</span><br><span class="line">		FilterLoader filterLoader &#x3D; FilterLoader.getInstance();</span><br><span class="line">		FilterRegistry filterRegistry &#x3D; FilterRegistry.instance();</span><br><span class="line">		return new ZuulFilterInitializer(this.filters, counterFactory, tracerFactory, filterLoader, filterRegistry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 而FilterRegistry管理了一个ConcurrentHashMap，用作存储过滤器的，并有一些基本的CURD过滤器的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class FilterRegistry &#123;</span><br><span class="line"></span><br><span class="line">    private static final FilterRegistry INSTANCE &#x3D; new FilterRegistry();</span><br><span class="line"></span><br><span class="line">    public static final FilterRegistry instance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final ConcurrentHashMap&lt;String, ZuulFilter&gt; filters &#x3D; new ConcurrentHashMap&lt;String, ZuulFilter&gt;();</span><br><span class="line"></span><br><span class="line">    private FilterRegistry() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ZuulFilter remove(String key) &#123;</span><br><span class="line">        return this.filters.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ZuulFilter get(String key) &#123;</span><br><span class="line">        return this.filters.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(String key, ZuulFilter filter) &#123;</span><br><span class="line">        this.filters.putIfAbsent(key, filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return this.filters.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Collection&lt;ZuulFilter&gt; getAllFilters() &#123;</span><br><span class="line">        return this.filters.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> FilterLoader类持有FilterRegistry，FilterFileManager类持有FilterLoader，所以最终是由FilterFileManager注入 filterFilterRegistry的ConcurrentHashMap的。FilterFileManager到开启了轮询机制，定时的去加载过滤器，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void startPoller() &#123;</span><br><span class="line">      poller &#x3D; new Thread(&quot;GroovyFilterFileManagerPoller&quot;) &#123;</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              while (bRunning) &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      sleep(pollingIntervalSeconds * 1000);</span><br><span class="line">                      manageFiles();</span><br><span class="line">                  &#125; catch (Exception e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      poller.setDaemon(true);</span><br><span class="line">      poller.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> Zuulservlet作为类似于Spring MVC中的DispatchServlet,起到了前端控制器的作用，所有的请求都由它接管。它的核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">@Override</span><br><span class="line"> public void service(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Marks this request as having passed through the &quot;Zuul engine&quot;, as opposed to servlets</span><br><span class="line">         &#x2F;&#x2F; explicitly bound in web.xml, for which requests will not have the same data attached</span><br><span class="line">         RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">         context.setZuulEngineRan();</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">             preRoute();</span><br><span class="line">         &#125; catch (ZuulException e) &#123;</span><br><span class="line">             error(e);</span><br><span class="line">             postRoute();</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         try &#123;</span><br><span class="line">             route();</span><br><span class="line">         &#125; catch (ZuulException e) &#123;</span><br><span class="line">             error(e);</span><br><span class="line">             postRoute();</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         try &#123;</span><br><span class="line">             postRoute();</span><br><span class="line">         &#125; catch (ZuulException e) &#123;</span><br><span class="line">             error(e);</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125; catch (Throwable e) &#123;</span><br><span class="line">         error(new ZuulException(e, 500, &quot;UNHANDLED_EXCEPTION_&quot; + e.getClass().getName()));</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         RequestContext.getCurrentContext().unset();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>跟踪init（），可以发现这个方法为每个请求生成了RequestContext,RequestContext继承了ConcurrentHashMap&lt;String, Object&gt;，在请求结束时销毁掉该RequestContext，RequestContext的生命周期为请求到zuulServlet开始处理，直到请求结束返回结果。<br>RequestContext类在存储了很多重要的信息，包括HttpServletRequest、HttpServletRespons、ResponseDataStream、ResponseStatusCode等。 RequestContext对象在处理请求的过程中，一直存在，所以这个对象为所有Filter共享。</p>
<p>从ZuulServlet的service（）方法可知，它是先处理pre()类型的处理器，然后在处理route()类型的处理器，最后再处理post类型的处理器。</p>
<p>首先来看一看pre()的处理过程，它会进入到ZuulRunner,该类的作用是将请求的HttpServletRequest、HttpServletRespons放在RequestContext类中，并包装了一个FilterProcessor，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) &#123;</span><br><span class="line"></span><br><span class="line">        RequestContext ctx &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">        if (bufferRequests) &#123;</span><br><span class="line">            ctx.setRequest(new HttpServletRequestWrapper(servletRequest));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ctx.setRequest(servletRequest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.setResponse(new HttpServletResponseWrapper(servletResponse));</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> public void preRoute() throws ZuulException &#123;</span><br><span class="line">    FilterProcessor.getInstance().preRoute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而FilterProcessor类为调用filters的类，比如调用pre类型所有的过滤器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void preRoute() throws ZuulException &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          runFilters(&quot;pre&quot;);</span><br><span class="line">      &#125; catch (ZuulException e) &#123;</span><br><span class="line">          throw e;</span><br><span class="line">      &#125; catch (Throwable e) &#123;</span><br><span class="line">          throw new ZuulException(e, 500, &quot;UNCAUGHT_EXCEPTION_IN_PRE_FILTER_&quot; + e.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>跟踪runFilters（）方法，可以发现，它最终调用了FilterLoader的getFiltersByType(sType)方法来获取同一类的过滤器，然后用for循环遍历所有的ZuulFilter，执行了 processZuulFilter（）方法，跟踪该方法可以发现最终是执行了ZuulFilter的方法，最终返回了该方法返回的Object对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object runFilters(String sType) throws Throwable &#123;</span><br><span class="line">       if (RequestContext.getCurrentContext().debugRouting()) &#123;</span><br><span class="line">           Debug.addRoutingDebug(&quot;Invoking &#123;&quot; + sType + &quot;&#125; type filters&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       boolean bResult &#x3D; false;</span><br><span class="line">       List&lt;ZuulFilter&gt; list &#x3D; FilterLoader.getInstance().getFiltersByType(sType);</span><br><span class="line">       if (list !&#x3D; null) &#123;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">               ZuulFilter zuulFilter &#x3D; list.get(i);</span><br><span class="line">               Object result &#x3D; processZuulFilter(zuulFilter);</span><br><span class="line">               if (result !&#x3D; null &amp;&amp; result instanceof Boolean) &#123;</span><br><span class="line">                   bResult |&#x3D; ((Boolean) result);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return bResult;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>route、post类型的过滤器的执行过程和pre执行过程类似。</p>
<h2 id="Zuul默认过滤器"><a href="#Zuul默认过滤器" class="headerlink" title="Zuul默认过滤器"></a>Zuul默认过滤器</h2><h4 id="默认的核心过滤器一览表"><a href="#默认的核心过滤器一览表" class="headerlink" title="默认的核心过滤器一览表"></a>默认的核心过滤器一览表</h4><p>Zuul默认注入的过滤器，它们的执行顺序在FilterConstants类，我们可以先定位在这个类，然后再看这个类的过滤器的执行顺序以及相关的注释，可以很轻松定位到相关的过滤器，也可以直接打开<br>spring-cloud-netflix-core.jar的 zuul.filters包，可以看到一些列的filter，现在我以表格的形式，列出默认注入的filter.</p>
<table>
<thead>
<tr>
<th>过滤器</th>
<th align="right">order</th>
<th align="center">描述</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td>ServletDetectionFilter</td>
<td align="right">-3</td>
<td align="center">检测请求是用 DispatcherServlet还是 ZuulServlet</td>
<td align="center">pre</td>
</tr>
<tr>
<td>Servlet30WrapperFilter</td>
<td align="right">-2</td>
<td align="center">在Servlet 3.0 下，包装 requests</td>
<td align="center">pre</td>
</tr>
<tr>
<td>FormBodyWrapperFilter</td>
<td align="right">-1</td>
<td align="center">解析表单数据</td>
<td align="center">pre</td>
</tr>
<tr>
<td>SendErrorFilter</td>
<td align="right">0</td>
<td align="center">如果中途出现错误</td>
<td align="center">error</td>
</tr>
<tr>
<td>DebugFilter</td>
<td align="right">1</td>
<td align="center">设置请求过程是否开启debug</td>
<td align="center">pre</td>
</tr>
<tr>
<td>PreDecorationFilter</td>
<td align="right">5</td>
<td align="center">根据uri决定调用哪一个route过滤器</td>
<td align="center">pre</td>
</tr>
<tr>
<td>RibbonRoutingFilter</td>
<td align="right">10</td>
<td align="center">如果写配置的时候用ServiceId则用这个route过滤器，该过滤器可以用Ribbon 做负载均衡，用hystrix做熔断</td>
<td align="center">route</td>
</tr>
<tr>
<td>SimpleHostRoutingFilter</td>
<td align="right">100</td>
<td align="center">如果写配置的时候用url则用这个route过滤</td>
<td align="center">route</td>
</tr>
<tr>
<td>SendForwardFilter</td>
<td align="right">500</td>
<td align="center">用RequestDispatcher请求转发</td>
<td align="center">route</td>
</tr>
<tr>
<td>SendResponseFilter</td>
<td align="right">1000</td>
<td align="center">用RequestDispatcher请求转发</td>
<td align="center">post</td>
</tr>
</tbody></table>
<p>过滤器的order值越小，就越先执行，并且在执行过滤器的过程中，它们共享了一个RequestContext对象，该对象的生命周期贯穿于请求，可以看出优先执行了pre类型的过滤器，并将执行后的结果放在RequestContext中，供后续的filter使用，比如在执行PreDecorationFilter的时候，决定使用哪一个route，它的结果的是放在RequestContext对象中，后续会执行所有的route的过滤器，如果不满足条件就不执行该过滤器的run方法。最终达到了就执行一个route过滤器的run()方法。</p>
<p>而error类型的过滤器，是在程序发生异常的时候执行的。</p>
<p>post类型的过滤，在默认的情况下，只注入了SendResponseFilter，该类型的过滤器是将最终的请求结果以流的形式输出给客户单。</p>
<h4 id="现在来看SimpleHostRoutingFilter是如何工作"><a href="#现在来看SimpleHostRoutingFilter是如何工作" class="headerlink" title="现在来看SimpleHostRoutingFilter是如何工作?"></a>现在来看SimpleHostRoutingFilter是如何工作?</h4><p>进入到SimpleHostRoutingFilter类的方法的run()方法，核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object run() &#123;</span><br><span class="line">	RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">    &#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">	String uri &#x3D; this.helper.buildZuulRequestURI(request);</span><br><span class="line">	this.helper.addIgnoredHeaders();</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		CloseableHttpResponse response &#x3D; forward(this.httpClient, verb, uri, request,</span><br><span class="line">				headers, params, requestEntity);</span><br><span class="line">		setResponse(response);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;</span><br><span class="line">		throw new ZuulRuntimeException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查阅这个类的全部代码可知，该类创建了一个HttpClient作为请求类，并重构了url,请求到了具体的服务，得到的一个CloseableHttpResponse对象，并将CloseableHttpResponse对象的保存到RequestContext对象中。并调用了ProxyRequestHelper的setResponse方法，将请求状态码，流等信息保存在RequestContext对象中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void setResponse(HttpResponse response) throws IOException &#123;</span><br><span class="line">		RequestContext.getCurrentContext().set(&quot;zuulResponse&quot;, response);</span><br><span class="line">		this.helper.setResponse(response.getStatusLine().getStatusCode(),</span><br><span class="line">				response.getEntity() &#x3D;&#x3D; null ? null : response.getEntity().getContent(),</span><br><span class="line">				revertHeaders(response.getAllHeaders()));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="现在来看SendResponseFilter是如何工作"><a href="#现在来看SendResponseFilter是如何工作" class="headerlink" title="现在来看SendResponseFilter是如何工作?"></a>现在来看SendResponseFilter是如何工作?</h4><p>这个过滤器的order为1000,在默认且正常的情况下，是最后一个执行的过滤器，该过滤器是最终将得到的数据返回给客户端的请求。</p>
<p>在它的run()方法里，有两个方法：addResponseHeaders()和writeResponse()，即添加响应头和写入响应数据流。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public Object run() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		addResponseHeaders();</span><br><span class="line">		writeResponse();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;</span><br><span class="line">		ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中writeResponse（）方法是通过从RequestContext中获取ResponseBody获或者ResponseDataStream来写入到HttpServletResponse中的，但是在默认的情况下ResponseBody为null，而ResponseDataStream在route类型过滤器中已经设置进去了。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void writeResponse() throws Exception &#123;</span><br><span class="line">		RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">	</span><br><span class="line">		HttpServletResponse servletResponse &#x3D; context.getResponse();</span><br><span class="line">			&#x2F;&#x2F;代码省略</span><br><span class="line">		OutputStream outStream &#x3D; servletResponse.getOutputStream();</span><br><span class="line">		InputStream is &#x3D; null;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (RequestContext.getCurrentContext().getResponseBody() !&#x3D; null) &#123;</span><br><span class="line">				String body &#x3D; RequestContext.getCurrentContext().getResponseBody();</span><br><span class="line">				writeResponse(</span><br><span class="line">						new ByteArrayInputStream(</span><br><span class="line">								body.getBytes(servletResponse.getCharacterEncoding())),</span><br><span class="line">						outStream);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;代码省略</span><br><span class="line">			is &#x3D; context.getResponseDataStream();</span><br><span class="line">			InputStream inputStream &#x3D; is;</span><br><span class="line">				&#x2F;&#x2F;代码省略</span><br><span class="line">		</span><br><span class="line">			writeResponse(inputStream, outStream);</span><br><span class="line">				&#x2F;&#x2F;代码省略</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    ..&#x2F;&#x2F;代码省略</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="如何在zuul上做日志处理"><a href="#如何在zuul上做日志处理" class="headerlink" title="如何在zuul上做日志处理"></a>如何在zuul上做日志处理</h2><p>由于zuul作为api网关，所有的请求都经过这里，所以在网关上，可以做请求相关的日志处理。<br>我的需求是这样的，需要记录请求的 url,ip地址，参数，请求发生的时间，整个请求的耗时，请求的响应状态，甚至请求响应的结果等。<br>很显然，需要实现这样的一个功能，需要写一个ZuulFliter，它应该是在请求发送给客户端之前做处理，并且在route过滤器路由之后，在默认的情况下，这个过滤器的order应该为500-1000之间。那么如何获取这些我需要的日志信息呢？找RequestContext,在请求的生命周期里这个对象里，存储了整个请求的所有信息。</p>
<p>现在编码，在代码的注释中，做了详细的说明，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class LoggerFilter extends ZuulFilter &#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return FilterConstants.POST_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() &#123;</span><br><span class="line">        RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request &#x3D; context.getRequest();</span><br><span class="line">        String method &#x3D; request.getMethod();&#x2F;&#x2F;氢气的类型，post get ..</span><br><span class="line">        Map&lt;String, String&gt; params &#x3D; HttpUtils.getParams(request);</span><br><span class="line">        String paramsStr &#x3D; params.toString();&#x2F;&#x2F;请求的参数</span><br><span class="line">        long statrtTime &#x3D; (long) context.get(&quot;startTime&quot;);&#x2F;&#x2F;请求的开始时间</span><br><span class="line">        Throwable throwable &#x3D; context.getThrowable();&#x2F;&#x2F;请求的异常，如果有的话</span><br><span class="line">        request.getRequestURI()；&#x2F;&#x2F;请求的uri</span><br><span class="line">        HttpUtils.getIpAddress(request);&#x2F;&#x2F;请求的iP地址</span><br><span class="line">        context.getResponseStatusCode();&#x2F;&#x2F;请求的状态</span><br><span class="line">        long duration&#x3D;System.currentTimeMillis() - statrtTime);&#x2F;&#x2F;请求耗时</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在读者也许有疑问，如何得到的statrtTime，即请求开始的时间，其实这需要另外一个过滤器，在网络请求route之前(大部分耗时都在route这一步)，在过滤器中，在RequestContext存储一个时间即可，另写一个过滤器，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AccessFilter extends ZuulFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return &quot;pre&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() &#123;</span><br><span class="line">        RequestContext ctx &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">        ctx.set(&quot;startTime&quot;,System.currentTimeMillis());</span><br><span class="line">       </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可能还有这样的需求，我需要将响应结果，也要存储在log中，在之前已经分析了，在route结束后，将从具体服务获取的响应流存储在RequestContext中，在SendResponseFilter过滤器写入在HttpServletResponse中，最终返回给客户端。那么我只需要在SendResponseFilter写入响应流之前把响应流写入到 log日志中即可，那么会引发另外一个问题，因为响应流写入到 log后，RequestContext就没有响应流了，在SendResponseFilter就没有流输入到HttpServletResponse中，导致客户端没有任何的返回数据，那么解决的办法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream inputStream &#x3D;RequestContext.getCurrentContext().getResponseDataStream();</span><br><span class="line">InputStream newInputStream&#x3D; copy(inputStream);</span><br><span class="line">transerferTolog(inputStream);</span><br><span class="line">RequestContext.getCurrentContext().setResponseDataStream(newInputStream);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从RequestContext获取到流之后，首先将流 copy一份，将流转化下字符串，存在日志中，再set到RequestContext中，<br>这样SendResponseFilter就可以将响应返回给客户端。这样的做法有点影响性能，如果不是字符流，可能需要做更多的处理工作。</p>
<h2 id="关注我的公众号"><a href="#关注我的公众号" class="headerlink" title="关注我的公众号"></a>关注我的公众号</h2><p>精彩内容不能错过！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0805748d92bba033.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="forezp.jpg"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud_Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基本概念</title>
    <url>/2020/11/12/internet-2020-11-12-%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>本篇文章简单梳理网络通信的基础概念</p>
<p>在学习Java网络编程之前，我们先来了解什么是计算机网络。</p>
<p>计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p>
<p>那什么是互联网呢？互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p>
<p>对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用<strong>TCP/IP协议</strong>。</p>
<p>TCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。</p>
<span id="more"></span>

<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。</p>
<p>IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似101.202.99.12，而IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。</p>
<p>IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：</p>
<ul>
<li>192.168.x.x</li>
<li>10.x.x.x</li>
</ul>
<p>有一个特殊的IP地址，称之为本机地址，它总是<strong>127.0.0.1</strong>。</p>
<p>IPv4地址实际上是一个32位整数。例如：</p>
<p>106717964 = 0x65ca630c<br>          = 65  ca  63 0c<br>          = 101.202.99.12<br>如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址<strong>127.0.0.1</strong>，还有一个IP地址，例如<strong>101.202.99.12</strong>，可以通过这个IP地址接入网络。</p>
<p>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</p>
<p>如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：</p>
<p>某台计算机的IP是<strong>101.202.99.2</strong>，子网掩码是<strong>255.255.255.0</strong>，那么计算该计算机的网络号是：</p>
<ul>
<li>IP = 101.202.99.2</li>
<li>Mask = 255.255.255.0</li>
<li>Network = IP &amp; Mask = 101.202.99.0</li>
</ul>
<p>每台计算机都需要正确配置IP地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为<strong>网关</strong>。</p>
<p>网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫<strong>路由</strong>。</p>
<p>所以，一台计算机的一个网卡会有3个关键配置：</p>
<p>network</p>
<ul>
<li>IP地址，例如：10.0.2.15</li>
<li>子网掩码，例如：255.255.255.0</li>
<li>网关的IP地址，例如：10.0.2.2<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3>因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。</li>
</ul>
<p>用nslookup可以查看域名对应的IP地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nslookup  https:&#x2F;&#x2F;smalltechnologyjun.com</span><br><span class="line">Server:  xxx.xxx.xxx.xxx</span><br><span class="line">Address: xxx.xxx.xxx.xxx#53</span><br></pre></td></tr></table></figure>

<p>有一个特殊的本机域名<strong>localhost</strong>，它对应的IP地址总是本机地址<strong>127.0.0.1</strong>。</p>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用<strong>分层模型</strong>，每一层负责处理自己的操作。<strong>OSI（Open System Interconnect）网络模型</strong>是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：</p>
<ul>
<li>应用层，提供应用程序之间的通信；</li>
<li>表示层：处理数据格式，加解密等等；</li>
<li>会话层：负责建立和维护会话；</li>
<li>传输层：负责提供端到端的可靠传输；</li>
<li>网络层：负责根据目标地址选择路由来传输数据；</li>
<li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li>
</ul>
<h4 id="互联网实际使用的TCP-IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型："><a href="#互联网实际使用的TCP-IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：" class="headerlink" title="互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型："></a>互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：</h4><pre><code>OSI         TCP/IP 
应用层      应用层 
表示层
会话层
传输层      传输层
网络层      IP层
链路层      网络接口层
物理层
</code></pre>
<h3 id="常用协议"><a href="#常用协议" class="headerlink" title="常用协议"></a>常用协议</h3><p>IP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。</p>
<ul>
<li><p>TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。</p>
</li>
<li><p>UDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。</p>
</li>
</ul>
<p>选择UDP协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择UDP协议。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>计算机网络的基本概念主要有：</p>
<ul>
<li>计算机网络：由两台或更多计算机组成的网络；</li>
<li>互联网：连接网络的网络；</li>
<li>IP地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；</li>
<li>网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；</li>
<li>网络协议：互联网使用TCP/IP协议，它泛指互联网协议簇；</li>
<li>IP协议：一种分组交换传输协议；</li>
<li>TCP协议：一种面向连接，可靠传输的协议；</li>
<li>UDP协议：一种无连接，不可靠传输的协议。</li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络思维导图</title>
    <url>/2020/11/12/internet-2020-11-26-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<p>分享计算机网络思维导图，持续更新ing</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/ChengKeJ/ChengKeJ.github.io/master/img/internet.png"></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Nagle和延迟确认带来的性能问题</title>
    <url>/2022/12/23/internet-nagle/</url>
    <content><![CDATA[<h1 id="Nagle和延迟确认带来的性能问题"><a href="#Nagle和延迟确认带来的性能问题" class="headerlink" title="Nagle和延迟确认带来的性能问题"></a>Nagle和延迟确认带来的性能问题</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从网上看到的一个问题的跟踪@林沛满 ，觉得很有意思记录下来</p>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>从AIX备份数据到Windows极其缓慢，只有1MB/s，备份所用的协议是SFTP，看到这个问题第一反应抓个包，试试Wireshark的三板斧</p>
<h3 id="抓包三板斧"><a href="#抓包三板斧" class="headerlink" title="抓包三板斧"></a>抓包三板斧</h3><ol>
<li>从Statistics →Summary菜单可见，平均速度是11 Mbit/s，的确只比1 MB/s高一些</li>
</ol>
<span id="more"></span>

<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/EF3B1138-D940-4964-B487-C60AC4E5D08F_2/EtZkFgVqobsgX247lVw9nQzEXGuQWP3e8G4Qyyzmwh0z/Image.png" alt="Image.png"></p>
<ol start="2">
<li>从Analyze →Expert Infos菜单看，网络状况堪称完美。连一个Warnings和Notes都没有。这样的网络性能怎么会差？</li>
</ol>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/0A35D2DB-D49E-47D3-9A85-5030507663E0_2/WweckqTyOemsxBQ7nxDxF33Pph8lDpQPhwWfKe48Nb0z/Image.png" alt="Image.png"></p>
<p>3．选定一个从AIX发往Windows的包，然后点击Statistics→TCP StreamGraph→TCP Sequence Graph（Stevens）菜单，从图3可见，这60秒中数据传输得很均匀，没有TCP Zero Window或者死机导致的暂停。</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/AF93E34F-32EF-4367-84A7-FA0CAC47D1E2_2/rMHgascgFBacaJhygVrPR4ut4KYUHQzMUjuxylt600wz/Image.png" alt="Image.png"></p>
<p>试完三板斧，我们只能得到一个结论：备份的确进行得很慢，但是仅凭Wireshark自带的分析工具找不出根本原因，这也许意味着问题不在网络上，而是在接收方或者发送方上。幸好<strong>Wireshark不但能发现网络上的问题，也能反映出接收方和发送方的一些配置，只是需要一些技巧来发现</strong>。</p>
<p>因为数据是从AIX备份到Windows的，所以如果把SFTP（SSH File Transfer Protocol）包过滤出来，理论上应该看到大多数时间花在了从AIX到Windows的传输上。可是由图4发现，从AIX到Windows的包虽然占多数，但没花多少时间。反而从Windows到AIX的两个包（533和535）之间竟然隔了0.2秒。该现象在整个传输过程中出现得很频繁，说不定性能差的原因就在此处了。只要把根本原因找出来，就有希望解决问题。</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/AE3CDB44-D330-47AC-92D3-32D6CA9DD39A_2/gCQjzWaAFAnEdgrLQEO0HcQ3LV9TaNU6EVLKTbPl6Sgz/Image.png" alt="Image.png"></p>
<p>那么这0.2秒之间究竟发生了什么呢？我把过滤条件去掉后得到了图5所示的包。可见Windows发出533号包之后就停下来等，直到0.2秒之后AIX的Ack（534号包）到达了才发出535号。Windows停下来的原因是什么呢？它在这两个包里总共才发了700多字节（96+656）的数据，肯定不会是因为TCP窗口受约束所致。</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/DC666B15-A553-4A1F-BEC2-610F6BE84D33_2/du6xMWrJDCw4SIgAHtWkNhxiVNXUtTJwp8fwCjPG1qkz/Image.png" alt="Image.png"></p>
<p>如果你研究过TCP协议，可能已经想到了愚笨窗口综合症（Silly window syndrome）和纳格（Nagle）算法。在某些情况下，应用层传递给TCP层的数据量很小，比如在SSH客户端以一般速度打字时，几乎是逐个字节传递到TCP层的。传输这么少的数据量却要耗费20字节IP头+20字节TCP头，是非常浪费的，这种情况称为发送方的愚笨窗口综合症，也叫“小包问题”（small packet problem）。为了提高传输效率，纳格提出了一个算法，用程序员喜闻乐见的方式表达就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if有新数据要发送</span><br><span class="line">  if数据量超过MSS（即一个TCP包所能携带的最大数据量）</span><br><span class="line">    立即发送</span><br><span class="line">  else</span><br><span class="line">    if之前发出去的数据尚未确认</span><br><span class="line">      把新数据缓存起来，凑够MSS或等确认到达再发送</span><br><span class="line">    else</span><br><span class="line">      立即发送</span><br><span class="line">    end if</span><br><span class="line">  end if</span><br><span class="line">end if</span><br></pre></td></tr></table></figure>

<p>所示的状况恰好就是小包问题。Windows发了533号包之后，本应该立即发送535的，但是由于535携带的数据量小于MSS，是个小包，根据Nagle算法只好等到533被确认（即收到534）才能接着发。这一等就是0.2秒，所以性能受到了大幅度影响。那为什么AIX要等那么久才确认呢？因为它启用<strong>延迟确认</strong>了。</p>
<h3 id="原因定位"><a href="#原因定位" class="headerlink" title="原因定位"></a>原因定位</h3><p>Nagle和延迟确认本身都没有问题，但一起用就会影响性能。解决方法很简单，要么在Windows上关闭Nagle算法，要么在AIX上关闭延迟确认。这位客户最终选择了前者，性能立即提升了20倍。如果你足够细心，也许已经意识到图3有问题——既然传输过程中会频繁地停顿0.2秒，为什么图3显示数据传输很均匀呢？这是因为抓包时间太长了，有60秒，所以0.2秒的停顿在图上看不出来。假如只截取其中的一秒钟来分析，再点击Statistics →TCP StreamGraph→TCP Sequence Graph（Stevens）菜单，你就能看到图6的结果，0.2秒的停顿就很明显了</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/7B35CAAB-7898-4F0A-AACA-8B750ED9BF16_2/IHeN7rWRRA6hwp37slXx3R9gZ1arZodWDbC3Dx5QjYYz/Image.png" alt="Image.png"></p>
<p>文章到尾声，按理说这种情况，世界到处都有同时启用Nagle和延迟确认的设置在通信，那为什么很少有人发现这个问题呢？估计大部分人都以为是带宽不足吧。</p>
<p>当然网上也有类型的分享，感兴趣的可以看看</p>
<p><a target="_blank" rel="noopener" href="https://www.diglog.com/story/1036249.html">https://www.diglog.com/story/1036249.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.stuartcheshire.org/papers/nagledelayedack/">http://www.stuartcheshire.org/papers/nagledelayedack/</a></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>5分钟入门入redis</title>
    <url>/2016/11/12/j2ee-2016-05-05-5minute-redis/</url>
    <content><![CDATA[<h3 id="1-redis概述"><a href="#1-redis概述" class="headerlink" title="1.redis概述"></a>1.redis概述</h3><p> redis是一个开源的，先进的 key-value 存储可用于构建高性能的存储解决方案。它支持数据结构有字符串，哈希，列表，集合，带有范围查询的排序集，位图，超文本和具有半径查询的地理空间索引。 NoSQL，Not Only [SQL]，泛指非关系型的数据库。所以redis是一种nosql。<em>敲黑板画重点：redis是一种nosql.</em></p>
 <span id="more"></span>
<p>redis的优点：</p>
<ul>
<li>异常快速</li>
<li>支持丰富的数据类型 </li>
<li>操作都是原子的</li>
</ul>
<h3 id="2-下载安装"><a href="#2-下载安装" class="headerlink" title="2.下载安装"></a>2.下载安装</h3><p>linux 系统下安装：</p>
<pre><code>$ wget http://download.redis.io/releases/redis-3.2.6.tar.gz
$ tar xzf redis-3.2.6.tar.gz
$ cd redis-3.2.6
$ make

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">启动服务器：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    $ src/redis-server
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">启动客户端</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 $ src/redis-cli
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line">mac下安装:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
brew install redis
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">启动：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis-server
redis-cli 

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> windows下安装:</span><br><span class="line"></span><br><span class="line">由于官方并没有提供windows 版本，不过微软为了能够应用redis 到 windows服务器，由微软维护了windows版的redis，下载地址：[点击进入](https:&#x2F;&#x2F;github.com&#x2F;MSOpenTech&#x2F;redis&#x2F;releases).建议下载msi 版本，直接安装即可。</span><br><span class="line"></span><br><span class="line">![sss](http:&#x2F;&#x2F;upload-images.jianshu.io&#x2F;upload_images&#x2F;2279594-ddad8a98ff77bace.png?imageMogr2&#x2F;auto-orient&#x2F;strip%7CimageView2&#x2F;2&#x2F;w&#x2F;1240)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">启动成功：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

[35142] 01 May 14:36:28.939 # Warning: no config file specified, using the default config. In order to specify a config file use redis-server /path/to/redis.conf
[35142] 01 May 14:36:28.940 * Max number of open files set to 10032
                _._
              _.-``__ &#39;&#39;-._
        _.-``    `.  `_.  &#39;&#39;-._           Redis 2.6.12 (00000000/0) 64 bit
    .-`` .-```.  ```\/    _.,_ &#39;&#39;-._
  (    &#39;      ,       .-`  | `,    )     Running in stand alone mode
  |`-._`-...-` __...-.``-._|&#39;` _.-&#39;|     Port: 6379
  |    `-._   `._    /     _.-&#39;    |     PID: 35142
    `-._    `-._  `-./  _.-&#39;    _.-&#39;
  |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|
  |    `-._`-._        _.-&#39;_.-&#39;    |           http://redis.io
    `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;
  |`-._`-._    `-.__.-&#39;    _.-&#39;_.-&#39;|
  |    `-._`-._        _.-&#39;_.-&#39;    |
    `-._    `-._`-.__.-&#39;_.-&#39;    _.-&#39;
        `-._    `-.__.-&#39;    _.-&#39;
            `-._        _.-&#39;
                `-.__.-&#39;

[35142] 01 May 14:36:28.941 # Server started, Redis version 2.6.12
[35142] 01 May 14:36:28.941 * The server is now ready to accept connections on port 6379

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">### 3.redis 支持的数据类型</span><br><span class="line"> </span><br><span class="line">#### 3.1字符串</span><br><span class="line">启动客户端 ,存储字符串到redis.</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis&gt; SET name forezp
OK
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">取字符串:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
 redis&gt; get name 
&quot;forezp&quot;
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 3.2Hashes - 哈希值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

redis &gt; HMSET king username forezp password xxdxx age 22
redis &gt; HGETALL king
1) &quot;username&quot;
2) &quot;forezp &quot;
3) &quot;password &quot;
4) &quot;xxdxx &quot;
5) &quot;age &quot;
6) &quot;22&quot;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 3.3 Lists - 列表</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis&gt; lpush pricess jack
(integer) 1
redis 127.0.0.1:6379&gt; lpush pricess jolin
(integer) 2
redis 127.0.0.1:6379&gt; lpush pricess mayun
(integer) 3
redis 127.0.0.1:6379&gt; lrange pricess 0 10
1) &quot;jack&quot;
2) &quot;jolin&quot;
3) &quot;mayun&quot;

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.4 Redis有序集合</span><br><span class="line">Redis有序集合类似Redis集合存储在设定值唯一性。不同的是，一个有序集合的每个成员带有分数，用于以便采取有序set命令，从最小的到最大的分数有关。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis &gt; ZADD kindom 1 redis
(integer) 1
redis&gt; ZADD kindom 2 mongodb
(integer) 1
redis &gt; ZADD kindom 3 mysql
(integer) 1
redis &gt; ZADD kindom 3 mysql
(integer) 0
redis &gt; ZADD kindom 4 mysql
(integer) 0
redis &gt; ZRANGE kindom 0 10 WITHSCORES
1) &quot;redis&quot;
2) &quot;1&quot;
3) &quot;mongodb&quot;
4) &quot;2&quot;
5) &quot;mysql&quot;
6) &quot;4&quot;

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#### 3.5 Redis发布订阅</span><br><span class="line"></span><br><span class="line">开启客户端作为接受者</span><br></pre></td></tr></table></figure>

redis&gt; SUBSCRIBE myking messages...
 (press Ctrl-C to quit
)1) &quot;subscribe&quot;
2) &quot;myking &quot;
3) (integer) 1

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">开启另一个客户端作为发送者：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis &gt; PUBLISH myking &quot;Redis is a great caching technique&quot;
(integer) 1

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这样接受者就可以收到:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
&quot;Redis is a great caching technique&quot;
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#### 3.6 其他的一些操作</span><br><span class="line"></span><br><span class="line">1.获取所以的key</span><br><span class="line"></span><br></pre></td></tr></table></figure>
redis&gt; KEYS *

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">2,判断key是否存在</span><br><span class="line"></span><br></pre></td></tr></table></figure>
EXISTS key
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">3.删除key </span><br><span class="line"></span><br></pre></td></tr></table></figure>
DEL key [key …]
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">4.获取数据类型</span><br><span class="line"></span><br></pre></td></tr></table></figure>

TYPE key
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">5.向尾部添加</span><br><span class="line"></span><br></pre></td></tr></table></figure>
APPEND key value

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">6.获取字符串长度</span><br><span class="line"></span><br></pre></td></tr></table></figure>
strlen key
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">当然这里只是介绍简单的一些操作，复杂的参考官方文档。</span><br><span class="line"></span><br><span class="line">###  4. 在java应用中使用redis---jedis</span><br><span class="line"></span><br><span class="line">前提是redis 已经安装，并且已经开启服务。</span><br><span class="line"></span><br><span class="line"> jedis 下载地址 [https:&#x2F;&#x2F;github.com&#x2F;xetorthio&#x2F;jedis](https:&#x2F;&#x2F;github.com&#x2F;xetorthio&#x2F;jedis)</span><br><span class="line"></span><br><span class="line">&gt;Jedis is a blazingly small and sane [Redis](http:&#x2F;&#x2F;github.com&#x2F;antirez&#x2F;redis) java client.</span><br><span class="line">Jedis was conceived to be EASY to use.</span><br><span class="line"></span><br><span class="line">&gt;翻译： jedis是一个非常小的java客户端，被认为是容易使用。</span><br><span class="line"></span><br><span class="line">*怎么使用？*</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

    public static void main(String[] args)&#123;

        Jedis jedis = new Jedis(&quot;localhost&quot;);
        System.out.println(&quot;Connection to server sucessfully&quot;);
        //check whether server is running or not
        System.out.println(&quot;Server is running: &quot;+jedis.ping());
        jedis.lpush(&quot;forezp-list&quot;, &quot;Redis&quot;);
        jedis.lpush(&quot;forezp-list&quot;, &quot;Mongodb&quot;);
        jedis.lpush(&quot;forezp-list&quot;, &quot;Mysql&quot;);
        // Get the stored data and print it
        List&lt;String&gt; list = jedis.lrange(&quot;forezp-list&quot;, 0 ,5);
        for(int i=0; i&lt;list.size(); i++) &#123;
            System.out.println(&quot;Stored string in redis:: &quot;+list.get(i));
        &#125;

    &#125;

```

运行：

&gt; Connection to server sucessfully
Server is running: PONG
Stored string in redis:: Mysql
Stored string in redis:: Mongodb
Stored string in redis:: Redis
Stored string in redis:: Mysql
Stored string in redis:: Mongodb
Stored string in redis:: Redis

 redis 入门介绍就到这里了。另外，*敲黑板，划重点：* 遇到问题首先不要去百度搜，要去官网搜。聪明的你，是不是自己安装下 ，实践下。

### 优秀文章推荐：
* [史上最简单的 SpringCloud 教程 | 终章](http://blog.csdn.net/forezp/article/details/70148833)
* [史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）](http://blog.csdn.net/forezp/article/details/69696915)
* [史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)](http://blog.csdn.net/forezp/article/details/70037513)
</code></pre>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee redis</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 的那些事儿（下）</title>
    <url>/2022/12/23/internet-tcp-e/</url>
    <content><![CDATA[<h1 id="TCP-的那些事儿（下）"><a href="#TCP-的那些事儿（下）" class="headerlink" title="TCP 的那些事儿（下）"></a>TCP 的那些事儿（下）</h1><p>这篇文章是下篇，所以如果你对TCP不熟悉的话，还请你先看看上篇《<a href="https://smalltechnologyjun.com/2022/12/23/internet-tcp-f/">TCP的那些事儿（上）</a>》 上篇中，我们介绍了TCP的协议头、状态机、数据重传中的东西。但是TCP要解决一个很大的事，那就是要在一个网络根据不同的情况来动态调整自己的发包的速度，小则让自己的连接更稳定，大则让整个网络更稳定。在你阅读下篇之前，你需要做好准备，本篇文章有好些算法和策略，可能会引发你的各种思考，让你的大脑分配很多内存和计算资源，所以，不适合在厕所中阅读。</p>
<h4 id="TCP的RTT算法"><a href="#TCP的RTT算法" class="headerlink" title="TCP的RTT算法"></a>TCP的RTT算法</h4><p>从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p>
<span id="more"></span>

<h4 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h4><p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc793">RFC793</a> 中定义的经典算法是这样的：</p>
<p>1）首先，先采样RTT，记下最近好几次的RTT值。</p>
<p>2）然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）</p>
<p><strong>SRTT = ( α * SRTT ) + ((1- α) * RTT)</strong></p>
<p>3）开始计算RTO。公式如下：</p>
<p><strong>RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</strong></p>
<p>其中：</p>
<ul>
<li>UBOUND是最大的timeout时间，上限值</li>
<li>LBOUND是最小的timeout时间，下限值</li>
<li>β 值一般在1.3到2.0之间。</li>
</ul>
<h4 id="Karn-Partridge-算法"><a href="#Karn-Partridge-算法" class="headerlink" title="Karn / Partridge 算法"></a>Karn / Partridge 算法</h4><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？</p>
<p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li>情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。</li>
<li>情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。</li>
</ul>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/361E07DB-7AFA-4AED-995A-F491516E97DD_2/2DlxiM9BnxMTpaIljpNxnMYThtQI10efa8OLmELjsXwz/Image.png" alt="Image.png"></p>
<p>所以1987年的时候，搞了一个叫<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Karn's_Algorithm">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的RTT做采样</strong>（你看，你不需要去解决不存在的问题）。</p>
<p>但是，这样一来，又会引发一个大BUG——<strong>如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难</strong>。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。</p>
<h4 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h4><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6298">RFC6289</a>）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）</p>
<p><strong>SRTT</strong> <strong>= S****RTT</strong> <strong>+ α</strong> (<strong>RTT <strong>– SRTT</strong>)</strong> —— 计算平滑RTT</p>
<p><strong>DevRTT</strong> <strong>= (1-β**</strong>)<em><strong>DevRTT</strong> <strong>+ β</strong></em>(|<strong>RTT-SRTT</strong>|)** ——计算平滑RTT和真实的差距（加权移动平均）</p>
<p>*RTO= µ * SRTT + ∂ <em>DevRTT</em> —— 神一样的公式</p>
<p>（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609">tcp_rtt_estimator</a>）。</p>
<h4 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h4><p>需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道，<strong>TCP必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过，<strong>TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/7ACFF727-288A-45BF-A9FF-713DB88FD6C5_2/aqQvbtcBrEBDdyyQpca6nNN5gH0nsPcqQkCKwgC6CxIz/Image.png" alt="Image.png"></p>
<p>上图中，我们可以看到：</p>
<ul>
<li>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li>
<li>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</li>
</ul>
<p>于是：</p>
<ul>
<li>接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li>
<li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li>
</ul>
<p>下面我们来看一下发送方的滑动窗口示意图：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/AB245E70-1506-4BA0-8F7A-DDB4D06EE4B3_2/iruBPuFwz4ayJ1yeNUlDYV2kyX3uuMeX4swWVWIkI5Iz/Image.png" alt="Image.png"></p>
<p>（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm">图片来源</a>）</p>
<p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li>#1已收到ack确认的数据。</li>
<li>#2发还没收到ack的。</li>
<li>#3在窗口中还没有发出的（接收方还有空间）。</li>
<li>#4窗口以外的数据（接收方没空间）</li>
</ul>
<p>下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/860DD86C-2EF8-42FC-9403-C3EA0E2ED656_2/HL6M84NMNnTonsGRkEXhg1JcDFXdqWyoL5YPvqltLQoz/Image.png" alt="Image.png"></p>
<p>下面我们来看一个接受端控制发送端的图示：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/3EFE1B7B-95FF-42A6-B628-4C19520E5096_2/qdFxZEf7YtoeIsxFyJ2dSOMbOLISRpuptztFX4COrk8z/Image.png" alt="Image.png"></p>
<p>（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm">图片来源</a>）</p>
<h4 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h4><p>上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？</p>
<p>解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<p><strong>注意</strong>：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sockstress">Wikipedia的SockStress词条</a>）</p>
<p>另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。</p>
<h4 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h4><p>Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。</p>
<p>要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p>
<p>另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc791">RFC 791</a>里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。</p>
<p><strong>如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽</strong>。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。</p>
<p>所以，<strong>Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。</p>
<ul>
<li>如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。</li>
<li>如果这个问题是由Sender端引起的，那么就会使用著名的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">Nagle’s algorithm</a>。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。</li>
</ul>
<p>另外，Nagle算法默认是打开的，所以，对于一些需要小包场景的程序——<strong>比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法</strong>。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<p>setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;value,sizeof(int));</p>
<p>另外，网上有些文章说TCP_CORK的socket option是也关闭Nagle算法，这不对。<strong>TCP_CORK其实是更新激进的Nagle算汉，完全禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送</strong>。最好不要两个选项都设置。</p>
<h4 id="TCP的拥塞处理-–-Congestion-Handling"><a href="#TCP的拥塞处理-–-Congestion-Handling" class="headerlink" title="TCP的拥塞处理 – Congestion Handling"></a>TCP的拥塞处理 – Congestion Handling</h4><p>上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p>
<p>具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是，<strong>如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。</strong>这是一个灾难。</p>
<p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：<strong>TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。</strong></p>
<p>关于拥塞控制的论文请参看《<a target="_blank" rel="noopener" href="http://ee.lbl.gov/papers/congavoid.pdf">Congestion Avoidance and Control</a>》(PDF)</p>
<p>拥塞控制主要是四个算法：<strong>1）慢启动</strong>，<strong>2）拥塞避免</strong>，<strong>3）拥塞发生</strong>，<strong>4）快速恢复</strong>。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p>
<ul>
<li>1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li>
<li>1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复</li>
</ul>
<h4 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h4><p>首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</p>
<p>慢启动的算法如下(cwnd全称Congestion Window)：</p>
<p>1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</p>
<p>2）每当收到一个ACK，cwnd++; 呈线性上升</p>
<p>3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</p>
<p>4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</p>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/649B3672-A121-4995-8C47-A93028A1DDFA_2/NEH6powugEU22V2rJlO9Y4TyKclermn0wXJNODn65Poz/Image.png" alt="Image.png"></p>
<p>这里，我需要提一下的是一篇Google的论文《<a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。 而Linux 3.0以前，比如2.6，Linux采用了<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc3390.txt">RFC3390</a>，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。</p>
<h4 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h4><p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p>
<p>1）收到一个ACK时，cwnd = cwnd + 1/cwnd</p>
<p>2）当每过一个RTT时，cwnd = cwnd + 1</p>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<h4 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h4><p>前面我们说过，当丢包的时候，会有两种情况：</p>
<p>1）等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。</p>
<ul>
<li>sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ul>
<p>2）Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。</p>
<ul>
<li>TCP Tahoe的实现和RTO超时一样。</li>
<li>TCP Reno的实现是：<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
<p>上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<h4 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h4><p><strong>TCP Reno</strong></p>
<p>这个算法定义在<a href="%5Bhttps://tools.ietf.org/html/rfc5681%5D(https://tools.ietf.org/html/rfc5681">RFC5681</a> “”TCP Congestion Control””)。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：</p>
<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
</ul>
<p>然后，真正的Fast Recovery算法如下：</p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）</li>
<li>重传Duplicated ACKs指定的数据包</li>
<li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li>
<li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
<p>如果你仔细思考一下上面的这个算法，你就会知道，<strong>上面这个算法也有问题，那就是——它依赖于3个重复的Acks</strong>。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。</p>
<p>通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲）</p>
<p><strong>TCP New Reno</strong></p>
<p>于是，1995年，TCP New Reno（参见 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6582">RFC 6582</a> ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——</p>
<ul>
<li>当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。</li>
<li>一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程</li>
</ul>
<p>我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。</p>
<h4 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h4><p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/6F737861-7C75-4313-AF12-0DF11B178C76_2/VHbCg38Fli3hzOBLri2eNuZsoCvxhlTnUpBnSwN4W28z/Image.png" alt="Image.png"></p>
<h4 id="FACK算法"><a href="#FACK算法" class="headerlink" title="FACK算法"></a>FACK算法</h4><p>FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）<a target="_blank" rel="noopener" href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf">Forward Acknowledgement: Refining TCP Congestion Control</a> 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。</p>
<ul>
<li>这个算法会把SACK中最大的Sequence Number 保存在<strong>snd.fack</strong>这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方）</li>
<li>然后定义一个<strong>awnd = snd.nxt – snd.fack</strong>（snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network）</li>
<li>如果需要重传数据，那么，<strong>awnd = snd.nxt – snd.fack + retran_data</strong>，也就是说，awnd是传出去的数据 + 重传的数据。</li>
<li>然后触发Fast Recovery 的条件是： ( <strong>( snd.fack – snd.una ) &gt; (3*MSS)</strong> ) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。</li>
</ul>
<p>我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。</p>
<h4 id="其它拥塞控制算法简介"><a href="#其它拥塞控制算法简介" class="headerlink" title="其它拥塞控制算法简介"></a>其它拥塞控制算法简介</h4><h4 id="TCP-Vegas-拥塞控制算法"><a href="#TCP-Vegas-拥塞控制算法" class="headerlink" title="TCP Vegas 拥塞控制算法"></a><strong>TCP Vegas 拥塞控制算法</strong></h4><p>这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a>》这篇论文给了Vegas和 New Reno的对比：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/F9B41F4A-495F-4AE3-B00F-C01C4640E9E1_2/JUQTa06DEwbv7eOSCbcdhR5KzezLCPDTyaoswbucOz4z/Image.png" alt="Image.png"></p>
<p>关于这个算法实现，你可以参看Linux源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h">/net/ipv4/tcp_vegas.h</a>， <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c">/net/ipv4/tcp_vegas.c</a></p>
<h4 id="HSTCP-High-Speed-TCP-算法"><a href="#HSTCP-High-Speed-TCP-算法" class="headerlink" title="HSTCP(High Speed TCP) 算法"></a>HSTCP(High Speed TCP) 算法</h4><p>这个算法来自<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc3649">RFC 3649</a>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HSTCP">Wikipedia词条</a>）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中：</p>
<ul>
<li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li>
<li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li>
</ul>
<p>注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c">/net/ipv4/tcp_highspeed.c</a></p>
<h4 id="TCP-BIC-算法"><a href="#TCP-BIC-算法" class="headerlink" title="TCP BIC 算法"></a>TCP BIC 算法</h4><p>2004年，产内出BIC算法。现在你还可以查得到相关的新闻《Google：<a target="_blank" rel="noopener" href="https://www.google.com/search?lr=lang_zh-CN%7Clang_zh-TW&newwindow=1&biw=1366&bih=597&tbs=lr:lang_1zh-CN%7Clang_1zh-TW&q=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D&oq=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D">美科学家研发BIC-TCP协议 速度是DSL六千倍</a>》 BIC全称<a target="_blank" rel="noopener" href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic">Binary Increase Congestion control</a>，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC-TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c">/net/ipv4/tcp_bic.c</a></p>
<h4 id="TCP-WestWood算法"><a href="#TCP-WestWood算法" class="headerlink" title="TCP WestWood算法"></a>TCP WestWood算法</h4><p>westwood采用和Reno相同的慢启动算法、拥塞避免算法。westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X * RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD * min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd &gt; ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。   关于这个算法实现，你可以参看Linux源码： <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c">/net/ipv4/tcp_westwood.c</a></p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>更多的算法，你可以从Wikipedia的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm">TCP Congestion Avoidance Algorithm</a> 词条中找到相关的线索</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>好了，到这里我想可以结束了，TCP发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。</p>
<p>当然，TCP东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>java反射</title>
    <url>/2016/11/12/j2ee-2016-05-05-java-refelation/</url>
    <content><![CDATA[<p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。【翻译于 官方文档】</p>
<span id="more"></span>

<p>本篇将从以下几个方面讲述反射的知识：</p>
<ul>
<li>calss的使用</li>
<li>方法的反射</li>
<li>构造函数的反射</li>
<li>成员变量的反射</li>
</ul>
<h3 id="一、什么是class类"><a href="#一、什么是class类" class="headerlink" title="一、什么是class类"></a>一、什么是class类</h3><p>在面向对象的世界里，万物皆对象。类是对象，类是java.lang.Class类的实例对象。另外class类只有java虚拟机才能new出来。任何一个类都是Class 类的实例对象。这实例对象有三种表达方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class User&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class ClassTest&#123;</span><br><span class="line">User u&#x3D;new User();</span><br><span class="line"> &#x2F;&#x2F;方式1:</span><br><span class="line"> Class c1&#x3D;User.class;</span><br><span class="line">&#x2F;&#x2F;方式2:</span><br><span class="line">Class c2&#x3D;u.getClass();</span><br><span class="line">&#x2F;&#x2F;方式3:</span><br><span class="line">Class c3&#x3D;Class.forName(&quot;com.forezp.User&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以通过类的类型创建该类的实例对象</span><br><span class="line">User user&#x3D;(User)c1.newInstance();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、class类的动态加载"><a href="#二、class类的动态加载" class="headerlink" title="二、class类的动态加载"></a>二、class类的动态加载</h3><p>Class.forName(类的全称);该方法不仅表示了类的类型，还代表了动态加载类。编译时刻加载类是静态加载、运行时刻加载类是动态加载类。</p>
<h3 id="三、获取方法信息"><a href="#三、获取方法信息" class="headerlink" title="三、获取方法信息"></a>三、获取方法信息</h3><p>基本的数据类型，void关键字都Class 类的实例;可以通过get<br>ame();getSimpleName()获取类的名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Class c1&#x3D;String.class;</span><br><span class="line">Class c2&#x3D;int.class;</span><br><span class="line">Class c3&#x3D;void.class;</span><br><span class="line">System.out.println(c1.getName());</span><br><span class="line">System.out.println(c2.getSimpleName());</span><br></pre></td></tr></table></figure>
<p>获取类的所有方法，并打印出来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void printClassInfo(Object object)&#123;</span><br><span class="line">        Class c&#x3D;object.getClass();</span><br><span class="line">        System.out.println(&quot;类的名称：&quot;+c.getName());</span><br><span class="line"></span><br><span class="line">        &#x2F;**</span><br><span class="line">         * 一个成员方法就是一个method对象</span><br><span class="line">         * getMethod()所有的 public方法，包括父类继承的 public</span><br><span class="line">         * getDeclaredMethods()获取该类所有的方法，包括private ,但不包括继承的方法。</span><br><span class="line">         *&#x2F;</span><br><span class="line">        Method[] methods&#x3D;c.getMethods();&#x2F;&#x2F;获取方法</span><br><span class="line">        &#x2F;&#x2F;获取所以的方法，包括private ,c.getDeclaredMethods();</span><br><span class="line"></span><br><span class="line">        for(int i&#x3D;0;i&lt;methods.length;i++)&#123;</span><br><span class="line">            &#x2F;&#x2F;得到方法的返回类型</span><br><span class="line">            Class returnType&#x3D;methods[i].getReturnType();</span><br><span class="line">            System.out.print(returnType.getName());</span><br><span class="line">            &#x2F;&#x2F;得到方法名：</span><br><span class="line">            System.out.print(methods[i].getName()+&quot;(&quot;);</span><br><span class="line"></span><br><span class="line">            Class[] parameterTypes&#x3D;methods[i].getParameterTypes();</span><br><span class="line">            for(Class class1:parameterTypes)&#123;</span><br><span class="line">                System.out.print(class1.getName()+&quot;,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ReflectTest &#123;</span><br><span class="line"></span><br><span class="line">        public static void main(String[] args)&#123;</span><br><span class="line">                String s&#x3D;&quot;ss&quot;;</span><br><span class="line">                ClassUtil.printClassInfo(s);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<blockquote>
<p>类的名称：java.lang.String</p>
<p>booleanequals(java.lang.Object,)</p>
</blockquote>
<blockquote>
<p>java.lang.StringtoString()</p>
</blockquote>
<blockquote>
<p>inthashCode()</p>
<p>…</p>
</blockquote>
<h3 id="四、获取成员变量的信息"><a href="#四、获取成员变量的信息" class="headerlink" title="四、获取成员变量的信息"></a>四、获取成员变量的信息</h3><p>也可以获取类的成员变量信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public static void printFiledInfo(Object o)&#123;</span><br><span class="line"></span><br><span class="line">       Class c&#x3D;o.getClass();</span><br><span class="line">       &#x2F;**</span><br><span class="line">        * getFileds()获取public</span><br><span class="line">        * getDeclaredFields()获取所有</span><br><span class="line">        *&#x2F;</span><br><span class="line">       Field[] fileds&#x3D;c.getDeclaredFields();</span><br><span class="line"></span><br><span class="line">       for(Field f:fileds)&#123;</span><br><span class="line">           &#x2F;&#x2F;获取成员变量的类型</span><br><span class="line">           Class filedType&#x3D;f.getType();</span><br><span class="line">           System.out.println(filedType.getName()+&quot; &quot;+f.getName());</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">               String s&#x3D;&quot;ss&quot;;</span><br><span class="line">               &#x2F;&#x2F;ClassUtil.printClassInfo(s);</span><br><span class="line">               ClassUtil.printFiledInfo(s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行：</p>
<blockquote>
<p>[C value<br>int hash<br>long serialVersionUID<br>[Ljava.io.ObjectStreamField; serialPersistentFields<br>java.util.Comparator CASE_INSENSITIVE_ORDER<br>int HASHING_SEED<br>int hash32</p>
</blockquote>
<h3 id="五、获取构造函数的信息"><a href="#五、获取构造函数的信息" class="headerlink" title="五、获取构造函数的信息"></a>五、获取构造函数的信息</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void printConstructInfo(Object o)&#123;</span><br><span class="line">        Class c&#x3D;o.getClass();</span><br><span class="line"></span><br><span class="line">        Constructor[] constructors&#x3D;c.getDeclaredConstructors();</span><br><span class="line">        for (Constructor con:constructors)&#123;</span><br><span class="line">            System.out.print(con.getName()+&quot;(&quot;);</span><br><span class="line"></span><br><span class="line">            Class[] typeParas&#x3D;con.getParameterTypes();</span><br><span class="line">            for (Class class1:typeParas)&#123;</span><br><span class="line">                System.out.print(class1.getName()+&quot; ,&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args)&#123;</span><br><span class="line">               String s&#x3D;&quot;ss&quot;;</span><br><span class="line">               &#x2F;&#x2F;ClassUtil.printClassInfo(s);</span><br><span class="line">               &#x2F;&#x2F;ClassUtil.printFiledInfo(s);</span><br><span class="line">               ClassUtil.printConstructInfo(s);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行：</p>
<blockquote>
<p>java.lang.String([B ,)<br>java.lang.String([B ,int ,int ,)<br>java.lang.String([B ,java.nio.charset.Charset ,)<br>java.lang.String([B ,java.lang.String ,)<br>java.lang.String([B ,int ,int ,java.nio.charset.Charset ,)<br>java.lang.String(int ,int ,[C ,)<br>java.lang.String([C ,boolean ,)<br>java.lang.String(java.lang.StringBuilder ,)<br>java.lang.String(java.lang.StringBuffer ,)</p>
</blockquote>
<blockquote>
<p>…</p>
</blockquote>
<h3 id="六、方法反射的操作"><a href="#六、方法反射的操作" class="headerlink" title="六、方法反射的操作"></a>六、方法反射的操作</h3><p>获取一个方法：需要获取方法的名称和方法的参数才能决定一个方法。</p>
<p>方法的反射操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">method.invoke(对象，参数列表);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line"></span><br><span class="line">    public void add(int a,int b)&#123;</span><br><span class="line">        System.out.print(a+b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void toUpper(String a)&#123;</span><br><span class="line">        System.out.print(a.toUpperCase());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">       A a&#x3D;new A();</span><br><span class="line">       Class c&#x3D;a.getClass();</span><br><span class="line">       try &#123;</span><br><span class="line">           Method method&#x3D;c.getMethod(&quot;add&quot;,new Class[]&#123;int.class,int.class&#125;);</span><br><span class="line">           &#x2F;&#x2F;也可以 Method method&#x3D;c.getMethod(&quot;add&quot;,int.class,int.class);</span><br><span class="line">           &#x2F;&#x2F;方法的反射操作</span><br><span class="line">           method.invoke(a,10,10);</span><br><span class="line">       &#125;catch (Exception e)&#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行：</p>
<blockquote>
<p>20</p>
</blockquote>
<p>本篇文章已经讲解了java反射的基本用法， 它可以在运行时判断任意一个对象所属的类；在运行时构造任意一个类的对象；在运行时判断任意一个类所具有的成员变量和方法；在运行时调用任意一个对象的方法；生成动态代理。</p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>filter</title>
    <url>/2016/11/12/j2ee-2016-05-05-filter-aop/</url>
    <content><![CDATA[<h3 id="一、filter简介"><a href="#一、filter简介" class="headerlink" title="一、filter简介"></a>一、filter简介</h3><p>filter是Servlet规范里的一个高级特性，只用于对request、response的进行修改。</p>
<span id="more"></span>

<p>filter提出了FilterChain的概念，客户端请求request在抵达servlet之前都会经过filterChain里的所有fiter，如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-166a5c28d392f743.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="filterchain工作原理，（用processOn画的） "></p>
<h3 id="二、filter的生命周期"><a href="#二、filter的生命周期" class="headerlink" title="二、filter的生命周期"></a>二、filter的生命周期</h3><p>在web.xml中配置filter，当启动服务器时会实例化，并且会初始化，当有网络请求时会进行过滤操作，当 服务器关闭时，会进行销毁，全过程如下图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0bfdef229be804e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="filter生命周期"></p>
<h3 id="三、编写第一个filter"><a href="#三、编写第一个filter" class="headerlink" title="三、编写第一个filter"></a>三、编写第一个filter</h3><p>filter类需实现fiter接口，需复写里面的三个方法，其中init(),在初始化时调用；doFiler()方法每次都会调用，在这个方法中一定要执行chain.doFilter(),否则request不会交给后面的filter或者servler;ondestroy()在关闭服务器时调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class FirstFilter implements Filter &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void destroy() &#123;</span><br><span class="line">		System.out.println(&quot;destroy---FirstFilter&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123;</span><br><span class="line">		System.out.println(&quot;start----doFilter--FirstFilter&quot;);		</span><br><span class="line">		chain.doFilter(request, response);</span><br><span class="line">		System.out.println(&quot;end------doFilter--FirstFilter&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void init(FilterConfig filterConfig) throws ServletException &#123;</span><br><span class="line">		System.out.println(&quot;init----FirstFilter&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>配置filter:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">       &lt;filter-name&gt;FirstFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">       &lt;filter-class&gt;com.forezp.filter.FirstFilter&lt;&#x2F;filter-class&gt;</span><br><span class="line">       </span><br><span class="line">   &lt;&#x2F;filter&gt;</span><br><span class="line">   &lt;filter-mapping&gt;</span><br><span class="line">       &lt;filter-name&gt;FirstFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">       &lt;url-pattern&gt;&#x2F;index.jsp&lt;&#x2F;url-pattern&gt; </span><br><span class="line">        &lt;url-pattern&gt;*.do&lt;&#x2F;url-pattern&gt; </span><br><span class="line">        &lt;dispatcher&gt;REQUEST&lt;&#x2F;dispatcher&gt; </span><br><span class="line">   &lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，url_pattern可以配置多个，也可以用通配符，当访问满足路径匹配，并且符合dispatcher时，request会被filter拦截进行处理，处理完后的response再次被filter拦截，可以进行处理。</p>
<p>其中dispatcher 默认REQUEST，四种不同的dispatcher：</p>
<ul>
<li>REQUEST:请求时有效</li>
<li>FORWARD:当某servlet通过forward到该servlet才有效</li>
<li>INCLUDE: jsp通过&lt; jsp: incluser/&gt; 请求servlet有效</li>
<li>ERROR: &lt; %@page errorPage=”” % &gt;有效</li>
</ul>
<h3 id="四、防盗链"><a href="#四、防盗链" class="headerlink" title="四、防盗链"></a>四、防盗链</h3><p>filter的特性使它可以处理特殊的工作，例如防盗链，字符编码的处理，日志记录，数据加密，过滤一些黑词等等。</p>
<p>例如： 防盗链图片，当其他网站请求本网站图片资源时显示错误的图片，只有本应用先生的图片才显示正确的图片，代码如下：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class ImageFilter implements Filter&#123;</span><br><span class="line">	public void init(FilterConfig config) throws Exception()&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">	public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain)throws Exception&#123;</span><br><span class="line">	HttpServletRequest request&#x3D;(HttpServletRequest )req;</span><br><span class="line">	HttpServletResponse  response&#x3D;(HttpServletResponse)res;</span><br><span class="line">	String referer&#x3D;request.getHeader(&quot;referer&quot;);</span><br><span class="line">		if(referer&#x3D;&#x3D;null||!referer.contains(request.getServerName()))&#123;</span><br><span class="line">		request.getRequestDispatcher(&quot;&#x2F;error.png&quot;).forwar(request,response);</span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		chain.doFilter(request,response);</span><br><span class="line">		  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	public void destroy()&#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 在web.xml中配置：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">		&lt;filter-name&gt;imageFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">		&lt;filter-class&gt;com.forezp.ImageFilter &lt;&#x2F;filter-class&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">&lt;filter-name&gt;imageFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">&lt;url-pattern&gt; &#x2F;images&#x2F;* &lt;&#x2F;url-pattern&gt;</span><br><span class="line"> &lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 当访问images下的所有图片会经过该filter,根据访问头信息，如果说本站点的访问则显示正确图片，否则先生错误图片。</p>
<h3 id="五、字符编码"><a href="#五、字符编码" class="headerlink" title="五、字符编码"></a>五、字符编码</h3><p> 直接上代码：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CharsetFilter implements Filter&#123;</span><br><span class="line">	private String characterEncoding;</span><br><span class="line">	private String enabled;</span><br><span class="line">	public void init(FilterConfig config) throws Exception()&#123;</span><br><span class="line">	characterEncoding&#x3D;config.getInitParameter(&quot;characterEncoding&quot;);</span><br><span class="line">	enabled&#x3D;config.getInitParameter(&quot;enabled&quot;).equals(&quot;true&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">	public void doFilter(ServletRequest req,ServletResponse res,FilterChain chain)throws Exception&#123;</span><br><span class="line">		if(enabled|| characterEncoding!&#x3D;null)&#123;</span><br><span class="line">			req.setCharacterEncoding(characterEncoding);</span><br><span class="line">			res.setCharacterEncoding(characterEncoding);</span><br><span class="line">		&#125;</span><br><span class="line">		chain.doFilter(req,res);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public void destroy()&#123;</span><br><span class="line">	  characterEncoding&#x3D;null;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  在web.xml中配置：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">	&lt;filter-name&gt;CharsetFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">	&lt;filter-class&gt;com.forezp.CharsetFilter &lt;&#x2F;filter-class&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;characterEncoding&lt;&#x2F;param-name&gt;</span><br><span class="line">		&lt;param-value&gt;UTF-8&lt;&#x2F;param-value&gt;</span><br><span class="line">	&lt;&#x2F;init-param&gt;</span><br><span class="line">	&lt;init-param&gt;</span><br><span class="line">		&lt;param-name&gt;enabled&lt;&#x2F;param-name&gt;</span><br><span class="line">		&lt;param-value&gt;true&lt;&#x2F;param-value&gt;</span><br><span class="line">	&lt;&#x2F;init-param&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">	&lt;filter-name&gt;CharsetFilter&lt;&#x2F;filter-name&gt;</span><br><span class="line">	&lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中页面编码方式也必须一致，希望全部用utf-8，另外需要配置Tomcat的／config/server.xml编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; protocal&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">	connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">	redirectPort&#x3D;&quot;8443&quot; URIEncoding&#x3D;&quot;UTF-8&quot;&#x2F;&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外，还有比较常见的日志记录filter、异常捕捉filter、权限校验、内容替换filter等等。</p>
<p>filter有很大的弹性机制，功能强大，而且跟servlet、jsp没耦合.filter是现在面向切面编程aop的一种思想体现，它能够胜任很多工作。</p>
<p>2.5的fiter需要在web.xml中配置，执行顺序按照配置顺序，另外3.0可以用注解的方式配置filter，此时没有配置的顺序。</p>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>servlet</title>
    <url>/2016/11/12/j2ee-2016-05-05-java-servlet/</url>
    <content><![CDATA[<p>###一、什么是servlet</p>
<p>servlet是在服务器上运行的小程序。一个servlet就是一个 java类，并且通过“请求-响应”编程模型来访问的这个驻留在服务器内存里的程序。</p>
<span id="more"></span>

<p>继承关系：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">servlet(interface)-&gt;init(),service(),destroy();</span><br><span class="line">^</span><br><span class="line">genericServlet(abstract class)-&gt;与协议无关</span><br><span class="line">^</span><br><span class="line">httpServlet(abstract class)-&gt;实现了http协议</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>servlet 是一个接口，genericServlet是它的一个抽象实现类，但它没有实现任何的协议，httpServlet是genericServlet的子类，实现了http协议，一般我们写servlet需要继承httpServlet。</p>
</blockquote>
<p>###二、手工书写第一个servlet程序<br>1.创建一个web工程，新建一个 servlet包，创建一个HelloServlet类。需要复写doGet()和doPost()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void doGet(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		System.out.println(&quot;get method invoke&quot;);</span><br><span class="line">		PrintWriter out&#x3D;resp.getWriter();</span><br><span class="line">		out.print(&quot;hello get method&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	protected void doPost(HttpServletRequest req, HttpServletResponse resp)</span><br><span class="line">			throws ServletException, IOException &#123;</span><br><span class="line">		System.out.println(&quot;post method invoke&quot;);</span><br><span class="line">		PrintWriter out&#x3D;resp.getWriter();</span><br><span class="line">		out.print(&quot;hi post method&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在index.jsp上写两个访问servelet的路径方法。其中，&lt; a &gt;标签，是get请求，form表单指明post请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; import&#x3D;&quot;java.util.*&quot; pageEncoding&#x3D;&quot;utf-8&quot;%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String path &#x3D; request.getContextPath();</span><br><span class="line">String basePath &#x3D; request.getScheme()+&quot;:&#x2F;&#x2F;&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort()+path+&quot;&#x2F;&quot;;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-&#x2F;&#x2F;W3C&#x2F;&#x2F;DTD HTML 4.01 Transitional&#x2F;&#x2F;EN&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href&#x3D;&quot;&lt;%&#x3D;basePath%&gt;&quot;&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;title&gt;servelet first&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;pragma&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;cache-control&quot; content&#x3D;&quot;no-cache&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;expires&quot; content&#x3D;&quot;0&quot;&gt;    </span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;keywords&quot; content&#x3D;&quot;keyword1,keyword2,keyword3&quot;&gt;</span><br><span class="line">	&lt;meta http-equiv&#x3D;&quot;description&quot; content&#x3D;&quot;This is my page&quot;&gt;</span><br><span class="line">	&lt;!--</span><br><span class="line">	&lt;link rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; href&#x3D;&quot;styles.css&quot;&gt;</span><br><span class="line">	--&gt;</span><br><span class="line">  &lt;&#x2F;head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;first servlet&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;a href&#x3D;&quot;servlet&#x2F;HelloServlet&quot;&gt;Get方式请求servlet&lt;&#x2F;a&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;servlet&#x2F;HelloServlet&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Post方式请求servlet&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>配置web.xml，需配置servlet的名字和具体的类名，以及访问路径。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;web-app version&#x3D;&quot;2.5&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee </span><br><span class="line">	http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_2_5.xsd&quot;&gt;</span><br><span class="line">	&lt;display-name&gt;&lt;&#x2F;display-name&gt;</span><br><span class="line">	&lt;welcome-file-list&gt;</span><br><span class="line">		&lt;welcome-file&gt;index.jsp&lt;&#x2F;welcome-file&gt;</span><br><span class="line">	&lt;&#x2F;welcome-file-list&gt;</span><br><span class="line"></span><br><span class="line">	&lt;servlet&gt;</span><br><span class="line">		&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;&lt;!-- servlet的名字 --&gt;</span><br><span class="line">		&lt;servlet-class&gt;servlet.HelloServlet&lt;&#x2F;servlet-class&gt;&lt;!-- servlet的具体类型，需要带包名 --&gt;</span><br><span class="line">	&lt;&#x2F;servlet&gt;</span><br><span class="line">	&lt;servlet-mapping&gt;</span><br><span class="line">	&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;&lt;!-- servlet 名字 --&gt;</span><br><span class="line">	&lt;url-pattern&gt;&#x2F;servlet&#x2F;HelloServlet&lt;&#x2F;url-pattern&gt; &lt;!-- servlet访问路径 --&gt;</span><br><span class="line">	&lt;&#x2F;servlet-mapping&gt;</span><br><span class="line">&lt;&#x2F;web-app&gt;</span><br></pre></td></tr></table></figure>
<p>部署该工程，运行，访问index.jsp界面，分别点击超链接和form表单，控制台输出类容：</p>
<blockquote>
<p>get method invoke</p>
<p>post method invoke</p>
</blockquote>
<p>这说明，通过页面的访问，点击超链接和form表单提交按钮，分别访问了servelet里的doGet()和doPost().</p>
<p>这里以get请求来说一下 servlet的执行顺序，如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-c1784d7afba86584.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="get请求执行流程"></p>
<h3 id="三、servlet的生命周期"><a href="#三、servlet的生命周期" class="headerlink" title="三、servlet的生命周期"></a>三、servlet的生命周期</h3><ul>
<li>初始化阶段，可以是在服务器启动初始化，也可以在第一次调用初始化，生成实例。</li>
<li>调用init();</li>
<li>调用servicr();判断是哪一种请求，get请求会调用doGet(),post请求调用doPost();</li>
<li>在服务器停止的时候，调用destroy();</li>
</ul>
<p>几个知识点：</p>
<ul>
<li>Servlet 启动时自动装载servlet，需要在 web.xml配置，在<servlet></servlet>之间添加如下代码：&lt; loadon-starup &gt;1&lt; /loadon-starup&gt;,数字越小，优先级越高。如果不配置，则第一次访问servlet时装载。</li>
<li>servlet被加载的时候，会调用init()方法，在整个生命周期中init（） 只会调用一次，装载后，实例贮存在服务器的内存中。</li>
</ul>
<h3 id="四、Servlet获取表单数据"><a href="#四、Servlet获取表单数据" class="headerlink" title="四、Servlet获取表单数据"></a>四、Servlet获取表单数据</h3><p>post提交表单，form的method属性设为post, 浏览器即以post方式提交表单内容，与get方式一样，servlet可以通过httpServletRequest对象的getParameter(String para)方式获取param对应的参数值。</p>
<p>如下是jsp提交表单的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;用户注册&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;hr&gt;</span><br><span class="line">    &lt;form name&#x3D;&quot;regForm&quot; action&#x3D;&quot;servlet&#x2F;RegServlet&quot; method&#x3D;&quot;post&quot; &gt;</span><br><span class="line">			  &lt;table border&#x3D;&quot;0&quot; width&#x3D;&quot;800&quot; cellspacing&#x3D;&quot;0&quot; cellpadding&#x3D;&quot;0&quot;&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;lalel&quot;&gt;用户名：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;username&quot; &#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;密码：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;mypassword&quot; &gt;&lt;&#x2F;td&gt;</span><br><span class="line">			    	</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;确认密码：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;&lt;input type&#x3D;&quot;password&quot; name&#x3D;&quot;confirmpass&quot; &gt;&lt;&#x2F;td&gt;</span><br><span class="line">			    	</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;电子邮箱：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot; &gt;&lt;&#x2F;td&gt;</span><br><span class="line">			    	</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;性别：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; checked&#x3D;&quot;checked&quot; value&#x3D;&quot;Male&quot;&gt;男&lt;input type&#x3D;&quot;radio&quot; name&#x3D;&quot;gender&quot; value&#x3D;&quot;Female&quot;&gt;女&lt;&#x2F;td&gt;</span><br><span class="line">			    	</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			   </span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;出生日期：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;</span><br><span class="line">			    	  &lt;input name&#x3D;&quot;birthday&quot; type&#x3D;&quot;text&quot; id&#x3D;&quot;control_date&quot; size&#x3D;&quot;10&quot;</span><br><span class="line">                      maxlength&#x3D;&quot;10&quot; onclick&#x3D;&quot;new Calendar().show(this);&quot; readonly&#x3D;&quot;readonly&quot; &#x2F;&gt;</span><br><span class="line">			    	&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;爱好：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;</span><br><span class="line">			    	&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;nba&quot;&gt; NBA  </span><br><span class="line">			    	  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;music&quot;&gt; 音乐  </span><br><span class="line">			    	  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;movie&quot;&gt; 电影  </span><br><span class="line">			    	  &lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;favorite&quot; value&#x3D;&quot;internet&quot;&gt; 上网  </span><br><span class="line">			    	&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;自我介绍：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;</span><br><span class="line">			    		&lt;textarea name&#x3D;&quot;introduce&quot; rows&#x3D;&quot;10&quot; cols&#x3D;&quot;40&quot;&gt;&lt;&#x2F;textarea&gt;</span><br><span class="line">			    	&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;label&quot;&gt;接受协议：&lt;&#x2F;td&gt;</span><br><span class="line">			    	&lt;td class&#x3D;&quot;controler&quot;&gt;</span><br><span class="line">			    		&lt;input type&#x3D;&quot;checkbox&quot; name&#x3D;&quot;isAccept&quot; value&#x3D;&quot;true&quot;&gt;是否接受霸王条款</span><br><span class="line">			    	&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			    &lt;tr&gt;</span><br><span class="line">			    	&lt;td colspan&#x3D;&quot;2&quot; align&#x3D;&quot;center&quot;&gt;</span><br><span class="line">			    		&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;注册&quot;&#x2F;&gt;  </span><br><span class="line">			    	    &lt;input type&#x3D;&quot;reset&quot; value&#x3D;&quot;取消&quot;&#x2F;&gt;  </span><br><span class="line">			    	&lt;&#x2F;td&gt;</span><br><span class="line">			    &lt;&#x2F;tr&gt;</span><br><span class="line">			  &lt;&#x2F;table&gt;</span><br><span class="line">			&lt;&#x2F;form&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>其中兴趣爱好为多个，即字符串数组，需要使用 httpServletRequest的getParameters(String param)获取.</p>
<p>下面是servlet接受信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line"></span><br><span class="line">			username &#x3D; request.getParameter(&quot;username&quot;);</span><br><span class="line">			mypassword &#x3D; request.getParameter(&quot;mypassword&quot;);</span><br><span class="line">			gender &#x3D; request.getParameter(&quot;gender&quot;);</span><br><span class="line">			email &#x3D; request.getParameter(&quot;email&quot;);</span><br><span class="line">			introduce &#x3D; request.getParameter(&quot;introduce&quot;);</span><br><span class="line">			birthday &#x3D; sdf.parse(request.getParameter(&quot;birthday&quot;));</span><br><span class="line">			if(request.getParameterValues(&quot;isAccpet&quot;)!&#x3D;null)</span><br><span class="line">			&#123;</span><br><span class="line">			  isAccept &#x3D; request.getParameter(&quot;isAccept&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			else</span><br><span class="line">			&#123;</span><br><span class="line">			  isAccept &#x3D; &quot;false&quot;;</span><br><span class="line">			&#125;</span><br><span class="line">			&#x2F;&#x2F;用来获取多个复选按钮的值</span><br><span class="line">			favorites &#x3D; request.getParameterValues(&quot;favorite&quot;);</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<h3 id="五、Servlet之间的跳转"><a href="#五、Servlet之间的跳转" class="headerlink" title="五、Servlet之间的跳转"></a>五、Servlet之间的跳转</h3><p><em>1.转向（forward)</em></p>
<p>转向是通过requestDispatcher对象的forward(httpServletRequest req,HttpServletResponse res)方法来实现的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(&quot;&#x2F;servlet&#x2F;LifeCycleServlet&quot;).forward(request,response);</span><br></pre></td></tr></table></figure>
<p>其中getRequestDispatcher方法的参数，必须以“／”开头，表示web的根目录，比如要<br>跳转：　“<a target="_blank" rel="noopener" href="http://locahost:8080/servlet/servet/LifeCycleServlet&quot;">http://locahost:8080/servlet/servet/LifeCycleServlet&quot;</a>, 则参数为”/servlet/LifeCycleServlet”.</p>
<p><em>2.重定向（redirect)</em><br>通过httpServlet的sendDirect(String location)方法。</p>
<h3 id="六、获取初始化参数"><a href="#六、获取初始化参数" class="headerlink" title="六、获取初始化参数"></a>六、获取初始化参数</h3><p>1.在 web.xml中配置servlet时，可以配置一些初始化参数，在servlet可以通过servletConfig接口提供的接口获取这些参数。</p>
<p>在web.xml中配置init-param 参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">		</span><br><span class="line">		&lt;servlet-name&gt;HelloServlet&lt;&#x2F;servlet-name&gt;&lt;!-- servlet的名字 --&gt;</span><br><span class="line">		&lt;servlet-class&gt;servlet.HelloServlet&lt;&#x2F;servlet-class&gt;&lt;!-- servlet的具体类型，需要带包名 --&gt;</span><br><span class="line">		&lt;init-param&gt;</span><br><span class="line">			&lt;param-name&gt;username&lt;&#x2F;param-name&gt;</span><br><span class="line">			&lt;param-value&gt;forezp&lt;&#x2F;param-value&gt;</span><br><span class="line">		&lt;&#x2F;init-param&gt;</span><br><span class="line">	&lt;&#x2F;servlet&gt;</span><br></pre></td></tr></table></figure>
<p>在servlet中获取</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class HelloServlet extends HttpServlet &#123;</span><br><span class="line">	</span><br><span class="line">	@Override</span><br><span class="line">	public void init() throws ServletException &#123;</span><br><span class="line">		&#x2F;&#x2F; TODO Auto-generated method stub</span><br><span class="line">		super.init();</span><br><span class="line">		String name&#x3D;this.getInitParameter(&quot;username&quot;);</span><br><span class="line">		System.out.println(name);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署项目，访问helloServlet就可以看见在控制台打印了forezp</p>
<p>2.也可以配置一些全局的参数:context-param.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;web-app version&#x3D;&quot;2.5&quot; xmlns&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&quot;</span><br><span class="line">	xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee </span><br><span class="line">	http:&#x2F;&#x2F;java.sun.com&#x2F;xml&#x2F;ns&#x2F;javaee&#x2F;web-app_2_5.xsd&quot;&gt;</span><br><span class="line">	&lt;display-name&gt;&lt;&#x2F;display-name&gt;</span><br><span class="line">	&lt;welcome-file-list&gt;</span><br><span class="line">		&lt;welcome-file&gt;index.jsp&lt;&#x2F;welcome-file&gt;</span><br><span class="line">	&lt;&#x2F;welcome-file-list&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;context-param&gt;</span><br><span class="line">		&lt;param-name&gt;haha&lt;&#x2F;param-name&gt;</span><br><span class="line">		&lt;param-value&gt;xixi&lt;&#x2F;param-value&gt;</span><br><span class="line">	&lt;&#x2F;context-param&gt;</span><br><span class="line">	</span><br><span class="line">	&lt;&#x2F;web-app&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>获取方式：</p>
<p>servlet中通过getServletContext()获取servletContext对象，使用ServletContext的getInitParameter()方法获取制定参数名来获取参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ServletContext servletContext&#x3D;getServletConfig().getServletContext();</span><br><span class="line">		String str&#x3D;servletContext.getInitParameter(&quot;haha&quot;);</span><br><span class="line">		System.out.println(str);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="七、servlet九大内置对象"><a href="#七、servlet九大内置对象" class="headerlink" title="七、servlet九大内置对象"></a>七、servlet九大内置对象</h3><p><img src="http://upload-images.jianshu.io/upload_images/2279594-721dfc4ed65824ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>本篇文章是我在学习 servlet的一个总结，参考资料包括《javaweb整合王者归来》，慕课网上的sevlet基础视频。下一篇文章讲讲述jsp的相关内容，尽情期待，感谢大家。</p>
]]></content>
      <categories>
        <category>j2ee</category>
      </categories>
      <tags>
        <tag>j2ee</tag>
      </tags>
  </entry>
  <entry>
    <title>jsp九大内置对象</title>
    <url>/2016/11/12/j2ee-2016-05-05-jsp-9-object/</url>
    <content><![CDATA[<p>jsp内置对象对象是web容器创建的一组对象，不使用new关键词久可以使用的内置对象。<br>九大内置对象包括以下：</p>
<ul>
<li>out  –JspWriter</li>
<li>request –ServletRequest</li>
<li>reponse –ServletResponse</li>
<li>config –ServletConfig</li>
<li>session –HttpSession</li>
<li>application –ServlerContext</li>
<li>page –HttpJspPage</li>
<li>pageContext –PageContext</li>
<li>exception –Exception</li>
</ul>
<span id="more"></span>

<h3 id="1、out对象"><a href="#1、out对象" class="headerlink" title="1、out