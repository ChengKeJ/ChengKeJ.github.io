<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Discord如何存储数万亿条消息</title>
    <url>/2023/04/01/discord/</url>
    <content><![CDATA[<p>Discord是一款专为社群设计的免费网络实时通话软件与数字发行平台，主要针对游戏玩家、教育人士、朋友及商业人士，用户之间可以在软体的聊天频道通过消息、图片、视频和音频进行交流。这款软件可以在Microsoft Windows、macOS、Android、iOS、Linux和网页上运行。</p>
<p>下面的图展示了Discord消息存储的演变历程：</p>
<p><img src="https://res.craft.do/user/full/8cf3a6c7-2a00-8ee8-0195-0eb38fda2eeb/5915084F-1F12-445D-B6F4-BE12D63C75AE_2/y6PCZxe8EwmpdNacqIRuPwKScgJthxcgJyg1eKOEYdsz/67b3962d-becb-4fba-a9ae-115692dfa6e1_3576x3033.jpeg" alt="67b3962d-becb-4fba-a9ae-115692dfa6e1_3576x3033.jpeg"></p>
<span id="more"></span>

<p>MongoDB ➡️ Cassandra ➡️ ScyllaDB</p>
<p>2015年，Discord的第一个版本建立在一个单独的MongoDB副本之上。到了2015年11月左右，MongoDB存储了1亿条消息，但是RAM已经无法再容纳数据和索引了。此时延迟变得不可预测。因此，需要将消息存储转移到另一个数据库。最终选择了Cassandra。</p>
<p>2017年，Discord有12个Cassandra节点，并存储了数十亿条消息。</p>
<p>到2022年初，它已经有177个节点，并存储了数万亿条消息。此时，延迟变得不可预测，并且维护操作的成本变得太高。</p>
<p>问题的原因有以下几点：</p>
<ul>
<li>Cassandra使用LSM树作为内部数据结构。读操作比写操作更昂贵。在具有数百个用户的服务器上可能有很多并发读取，从而导致热点问题。</li>
<li>维护集群（如压缩SSTables）会影响性能。</li>
<li>垃圾回收暂停会导致显著的延迟峰值。</li>
</ul>
<p>ScyllaDB是一个兼容Cassandra的数据库，用C++编写。Discord重新设计了其架构，具有单片API、用Rust编写的数据服务和基于ScyllaDB的存储。</p>
<p>在ScyllaDB中，p99读取延迟为15毫秒，而Cassandra中为40-125毫秒。p99写入延迟为5毫秒，而Cassandra中为5-70毫秒。</p>
<p>ScyllaDB是一个快速、可扩展和高可用的分布式数据库，适用于大规模数据处理和高吞吐量应用程序。它已被广泛应用于云计算、物联网、金融服务、在线广告和游戏等领域，被视为具有很高性价比的数据库解决方案。</p>
<p>以下是一个使用 Java 驱动程序连接 ScyllaDB 并执行查询的示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import com.datastax.driver.core.*;</span><br><span class="line"></span><br><span class="line">public class ScyllaDBExample &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    &#x2F;&#x2F; Connect to the cluster and keyspace</span><br><span class="line">    Cluster cluster &#x3D; Cluster.builder().addContactPoint(&quot;127.0.0.1&quot;).build();</span><br><span class="line">    Session session &#x3D; cluster.connect(&quot;test&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Execute a simple query</span><br><span class="line">    ResultSet results &#x3D; session.execute(&quot;SELECT * FROM users&quot;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Print the results</span><br><span class="line">    for (Row row : results) &#123;</span><br><span class="line">      System.out.format(&quot;%d %s %s\n&quot;, row.getInt(&quot;id&quot;), row.getString(&quot;name&quot;), row.getString(&quot;email&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Close the session and cluster</span><br><span class="line">    session.close();</span><br><span class="line">    cluster.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子使用 DataStax Java 驱动程序连接 ScyllaDB 并执行一个简单的查询来获取所有用户的记录。它打印查询结果，然后关闭会话和集群。</p>
<p>要运行这个示例，你需要将 DataStax Java 驱动程序添加到你的 Java 项目中。可以通过 Maven 或 Gradle 添加以下依赖项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;com.datastax.cassandra&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;cassandra-driver-core&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;4.14.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了默认的本地节点 IP 地址 127.0.0.1，也可以使用 ScyllaDB 集群中的其他节点 IP 地址。在实际应用中，建议使用连接池和预处理语句来提高性能。</p>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="http://scylladb.com/product/technology/shard-per-core-architecture/">scylladb.com/product/technology/shard-per-core-architecture/</a></p>
<p><a target="_blank" rel="noopener" href="http://discord.com/blog/how-discord-stores-trillions-of-messages">discord.com/blog/how-discord-stores-trillions-of-messages</a></p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>什么是gRPC？有什么优点？</title>
    <url>/2023/04/01/grpc/</url>
    <content><![CDATA[<p>RPC（远程过程调用）被称为“远程”，是因为它可以在微服务架构下将服务部署在不同的服务器上时，在远程服务之间进行通信。从用户的角度来看，它就像是一个本地函数调用。</p>
<p>下面的图表说明了gRPC的整体数据流程。</p>
<p><img src="https://res.craft.do/user/full/8cf3a6c7-2a00-8ee8-0195-0eb38fda2eeb/5610CB5D-8792-4108-B0B9-D1582C6C9B59_2/bOxnEzyEycV4MsFrPOFkkGcHzgT4O1YNv1fHHOJTy6kz/b98afdcd-b567-4c90-9f47-5358df0adda6_1280x1619.jpeg" alt="b98afdcd-b567-4c90-9f47-5358df0adda6_1280x1619.jpeg"></p>
<span id="more"></span>

<p>第1步：客户端发出REST调用。请求正文通常以JSON格式呈现。</p>
<p>第2-4步：订单服务（gRPC客户端）接收REST调用，对其进行转换，并向付款服务发出RPC调用。gPRC将客户端存根编码为二进制格式并将其发送到底层传输层。</p>
<p>第5步：gRPC通过HTTP2将数据包通过网络发送。由于二进制编码和网络优化，gRPC的速度比JSON快5倍。</p>
<p>第6-8步：付款服务（gRPC服务器）接收来自网络的数据包，对其进行解码并调用服务器应用程序。</p>
<p>第9-11步：结果从服务器应用程序返回，并被编码并发送到传输层。</p>
<p>第12-14步：订单服务接收数据包，对其进行解码，并将结果发送到客户端应用程序。</p>
<p>在使用gRPC时，需要定义protobuf消息和服务定义。protobuf消息是通信中传输的数据类型，而服务定义则描述了如何使用这些消息来实现RPC方法。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p>下面是一个使用gRPC实现简单加法功能的代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax &#x3D; &quot;proto3&quot;;</span><br><span class="line">package calculator;</span><br><span class="line"></span><br><span class="line">service Calculator &#123;</span><br><span class="line">  rpc Add (AddRequest) returns (AddResponse) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddRequest &#123;</span><br><span class="line">  int32 a &#x3D; 1;</span><br><span class="line">  int32 b &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message AddResponse &#123;</span><br><span class="line">  int32 result &#x3D; 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码定义了一个名为<code>Calculator</code>的服务，该服务具有一个名为<code>Add</code>的RPC方法。此方法将一个请求消息<code>AddRequest</code>作为输入，并返回一个响应消息<code>AddResponse</code>。</p>
<p><code>AddRequest</code>和<code>AddResponse</code>是protobuf消息。它们都具有简单的整数字段。<code>AddRequest</code>包含两个整数字段a和b，表示要相加的两个数字。<code>AddResponse</code>包含一个整数字段result，表示加法的结果。</p>
<p>现在，我们需要在客户端和服务器上实现这个服务。在开始实现客户端代码之前，需要先引入gRPC依赖库。可以通过在Maven或Gradle中添加以下依赖项来实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Maven</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;io.grpc&lt;&#x2F;groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;grpc-netty-shaded&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;version&gt;1.42.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Gradle</span><br><span class="line">implementation &#39;io.grpc:grpc-netty-shaded:1.42.0&#39;</span><br></pre></td></tr></table></figure>

<p>接下来，我们可以编写一个简单的Java客户端程序来调用我们之前定义的加法服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import io.grpc.ManagedChannel;</span><br><span class="line">import io.grpc.ManagedChannelBuilder;</span><br><span class="line">import io.grpc.StatusRuntimeException;</span><br><span class="line">import com.example.grpc.AddRequest;</span><br><span class="line">import com.example.grpc.AddResponse;</span><br><span class="line">import com.example.grpc.MathServiceGrpc;</span><br><span class="line"></span><br><span class="line">public class MathClient &#123;</span><br><span class="line">    private final ManagedChannel channel;</span><br><span class="line">    private final MathServiceGrpc.MathServiceBlockingStub blockingStub;</span><br><span class="line"></span><br><span class="line">    public MathClient(String host, int port) &#123;</span><br><span class="line">        channel &#x3D; ManagedChannelBuilder.forAddress(host, port)</span><br><span class="line">                .usePlaintext()</span><br><span class="line">                .build();</span><br><span class="line">        blockingStub &#x3D; MathServiceGrpc.newBlockingStub(channel);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void shutdown() throws InterruptedException &#123;</span><br><span class="line">        channel.shutdown().awaitTermination(5, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void add(int a, int b) &#123;</span><br><span class="line">        AddRequest request &#x3D; AddRequest.newBuilder()</span><br><span class="line">                .setA(a)</span><br><span class="line">                .setB(b)</span><br><span class="line">                .build();</span><br><span class="line">        AddResponse response;</span><br><span class="line">        try &#123;</span><br><span class="line">            response &#x3D; blockingStub.add(request);</span><br><span class="line">        &#125; catch (StatusRuntimeException e) &#123;</span><br><span class="line">            System.err.println(&quot;RPC failed: &quot; + e.getStatus());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(&quot;Result: &quot; + response.getResult());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        MathClient client &#x3D; new MathClient(&quot;localhost&quot;, 50051);</span><br><span class="line">        try &#123;</span><br><span class="line">            client.add(1, 2);</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            client.shutdown();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在此代码中，我们首先创建了一个<code>ManagedChannel</code>实例，该实例连接到我们的服务器。然后，我们使用这个<code>ManagedChannel</code>实例创建一个新的<code>MathServiceGrpc.MathServiceBlockingStub</code>实例，该实例是通过gRPC自动生成的，可以用来调用我们定义的加法方法。</p>
<p>在<code>add</code>方法中，我们首先构建一个<code>AddRequest</code>实例，该实例包含了我们需要相加的两个整数。然后，我们使用我们之前创建的<code>MathServiceGrpc.MathServiceBlockingStub</code>实例调用<code>add</code>方法，并传递这个<code>AddRequest</code>实例作为参数。最后，我们将结果打印出来。</p>
<p>在<code>main</code>方法中，我们创建一个新的<code>MathClient</code>实例，并使用它来调用<code>add</code>方法。最后，我们在<code>finally</code>块中关闭了<code>MathClient</code>实例。</p>
<p>这个Java客户端代码可以通过以下命令来编译：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ javac MathClient.java</span><br></pre></td></tr></table></figure>

<p>然后，我们可以使用以下命令来运行它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ java MathClient</span><br></pre></td></tr></table></figure>

<p>运行这个程序后，将输出以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Result: 3</span><br></pre></td></tr></table></figure>

<p>这表明我们的加法服务已经成功地在客户端和服务器之间通信了。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul>
<li>gRPC可以实现简单的RPC方法，在客户端和服务器之间成功地进行通信。</li>
<li>protobuf消息和服务定义使得定义和使用RPC方法更容易。</li>
<li>gRPC提供高效的网络传输和编码，从而提高了通信速度和可靠性。</li>
<li>gRPC为开发人员提供了轻松构建分布式系统的强大工具。</li>
<li>在微服务架构下，gRPC使服务之间的通信更加容易和高效。</li>
<li>在实际开发中需要注意潜在的问题，例如网络延迟和数据大小限制，需要仔细设计服务接口和消息类型，以确保通信的稳定性和可靠性。</li>
<li>gRPC是值得尝试的分布式系统开发工具，提供高效的RPC通信和易于使用的接口定义。</li>
</ul>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2020/10/30/designPattern-2020-10-30-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p>在有些情况下，一个客户不能或者不想直接访问另一个对象，这时需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过 12306 网站或者去火车票代售点买。又如找女朋友、找保姆、找工作等都可以通过找中介完成。</p>
<p>在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。</p>
<span id="more"></span>

<h3 id="代理模式的定义与特点"><a href="#代理模式的定义与特点" class="headerlink" title="代理模式的定义与特点"></a>代理模式的定义与特点</h3><p>代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<h3 id="代理模式的主要优点有："><a href="#代理模式的主要优点有：" class="headerlink" title="代理模式的主要优点有："></a>代理模式的主要优点有：</h3><ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性</li>
</ul>
<h3 id="其主要缺点是："><a href="#其主要缺点是：" class="headerlink" title="其主要缺点是："></a>其主要缺点是：</h3><ul>
<li>代理模式会造成系统设计中类的数量增加</li>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度；</li>
<li>那么如何解决以上提到的缺点呢？答案是可以使用动态代理方式</li>
</ul>
<h3 id="代理模式的结构与实现"><a href="#代理模式的结构与实现" class="headerlink" title="代理模式的结构与实现"></a>代理模式的结构与实现</h3><p>代理模式的结构比较简单，主要是通过定义一个继承抽象主题的代理来包含真实主题，从而实现对真实主题的访问，下面来分析其基本结构和实现方法。</p>
<h4 id="1-模式的结构"><a href="#1-模式的结构" class="headerlink" title="1. 模式的结构"></a>1. 模式的结构</h4><p>代理模式的主要角色如下。</p>
<ul>
<li>抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<p>其结构图如图 1 所示<br><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk7fvl8ky9g30i209mmxh.gif"></p>
<p>在代码中，一般代理会被理解为代码增强，实际上就是在原代码逻辑前后增加一些代码逻辑，而使调用者无感知。</p>
<p>根据代理的创建时期，代理模式分为静态代理和动态代理。</p>
<ul>
<li>静态：由程序员创建代理类或特定工具自动生成源代码再对其编译，在程序运行前代理类的 .class 文件就已经存在了。</li>
<li>动态：在程序运行时，运用反射机制动态创建而成</li>
</ul>
<h4 id="2-模式的实现"><a href="#2-模式的实现" class="headerlink" title="2. 模式的实现"></a>2. 模式的实现</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.三个抽象主题</span><br><span class="line">&#x2F;**</span><br><span class="line"> * process check gamer ticket</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface CheckProcess &#123;</span><br><span class="line">    void check();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface DietProcess &#123;</span><br><span class="line">    void diet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * process game</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface GameProcess &#123;</span><br><span class="line">    void play();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">2. 三个真实主题</span><br><span class="line">public class BigGamePayer extends GamePayer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void play() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; big player start play ...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class BigChecker implements CheckProcess &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void check() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; start check ticket&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Dieter implements DietProcess &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void diet() &#123;</span><br><span class="line">      log.info(&quot;&#x3D;&#x3D; start make diet : ice &quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">3. 代理类</span><br><span class="line">public class ProxyProcess implements GameProcess, CheckProcess, DietProcess &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理检票</span><br><span class="line">    private CheckProcess checkProcess;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理游戏</span><br><span class="line">    private GameProcess  gameProcess;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 代理饮食</span><br><span class="line">    private DietProcess  dietProcess;</span><br><span class="line"></span><br><span class="line">    public &lt;T&gt; ProxyProcess(T t) &#123;</span><br><span class="line">        if (t instanceof GameProcess) &#123;</span><br><span class="line">            this.gameProcess &#x3D; (GameProcess) t;</span><br><span class="line">        &#125; else if (t instanceof CheckProcess) &#123;</span><br><span class="line">            this.checkProcess &#x3D; (CheckProcess) t;</span><br><span class="line">        &#125; else if (t instanceof DietProcess) &#123;</span><br><span class="line">            this.dietProcess &#x3D; (DietProcess) t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void play() &#123;</span><br><span class="line">        before();</span><br><span class="line">        this.gameProcess.play();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void check() &#123;</span><br><span class="line">        this.checkProcess.check();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void diet() &#123;</span><br><span class="line">        this.dietProcess.diet();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public void before() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; proxy: start before play game&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void after() &#123;</span><br><span class="line">        log.info(&quot;&#x3D;&#x3D;&#x3D; proxy:  start after play game&quot;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>游戏屋:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class GameHome &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        proxyCheck();</span><br><span class="line">        proxyPlay();</span><br><span class="line">        proxyDiete();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void proxyPlay() &#123;</span><br><span class="line">        &#x2F;&#x2F; 代理玩游戏</span><br><span class="line">        BigGamePayer bigGamePayer &#x3D; new BigGamePayer();</span><br><span class="line">        ProxyProcess proxyPayer &#x3D; new ProxyProcess(bigGamePayer);</span><br><span class="line">        proxyPayer.play();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void proxyCheck() &#123;</span><br><span class="line">        &#x2F;&#x2F; 代理检票</span><br><span class="line">        BigChecker bigChecker &#x3D; new BigChecker();</span><br><span class="line">        ProxyProcess proxyProcess &#x3D; new ProxyProcess(bigChecker);</span><br><span class="line">        proxyProcess.check();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void proxyDiete() &#123;</span><br><span class="line">        &#x2F;&#x2F; 代理美食</span><br><span class="line">        Dieter dieter &#x3D; new Dieter();</span><br><span class="line">        ProxyProcess proxyProcess &#x3D; new ProxyProcess(dieter);</span><br><span class="line">        proxyProcess.diet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">16:29:18.572 [main] INFO com.ckj.base.designPatternes.proxy.extend.BigChecker - &#x3D;&#x3D;&#x3D; start check ticket</span><br><span class="line">16:29:18.575 [main] INFO com.ckj.base.designPatternes.proxy.proxy.ProxyProcess - &#x3D;&#x3D;&#x3D; proxy: start before play game</span><br><span class="line">16:29:18.575 [main] INFO com.ckj.base.designPatternes.proxy.extend.BigGamePayer - &#x3D;&#x3D;&#x3D; big player start play ...</span><br><span class="line">16:29:18.575 [main] INFO com.ckj.base.designPatternes.proxy.proxy.ProxyProcess - &#x3D;&#x3D;&#x3D; proxy:  start after play game</span><br><span class="line">16:29:18.576 [main] INFO com.ckj.base.designPatternes.proxy.extend.Dieter - &#x3D;&#x3D; start make diet : ice </span><br></pre></td></tr></table></figure>

<h4 id="3-动态代理"><a href="#3-动态代理" class="headerlink" title="3. 动态代理"></a>3. 动态代理</h4><p>在前面介绍的代理模式中，代理类中包含了对真实主题的引用，这种方式存在两个缺点。</p>
<ul>
<li>真实主题与代理主题一一对应，增加真实主题也要增加代理。</li>
<li>设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 SpringAOP，其结构图如图 4 所示。</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk7jnux1oeg30hi0g6js3.gif"></p>
<p>改造如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; dynamic proxy</span><br><span class="line">    GameProcess proxy &#x3D; (GameProcess) Proxy.newProxyInstance(GameProcess.class.getClassLoader(), new Class[]&#123;GameProcess.class&#125;,</span><br><span class="line">            new InvocationHandler() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">            log.info(&quot;start dynamic process...&quot;);</span><br><span class="line">            return method.invoke(new BigGamePayer(), args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    proxy.play();</span><br></pre></td></tr></table></figure>
<p>运行结果:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">18:17:11.681 [main] INFO com.ckj.base.designPatternes.proxy.GameHome - start dynamic process...</span><br><span class="line">18:17:11.681 [main] INFO com.ckj.base.designPatternes.proxy.extend.BigGamePayer - &#x3D;&#x3D;&#x3D; big player start play ...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Ribbon源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-Ribbon-resources/</url>
    <content><![CDATA[<h2 id="什么是Ribbon"><a href="#什么是Ribbon" class="headerlink" title="什么是Ribbon"></a>什么是Ribbon</h2><p>Ribbon是Netflix公司开源的一个负载均衡的项目，它属于上述的第二种，是一个客户端负载均衡器，运行在客户端上。它是一个经过了云端测试的IPC库，可以很好地控制HTTP和TCP客户端的一些行为。 Feign已经默认使用了Ribbon。</p>
<ul>
<li>负载均衡</li>
<li>容错</li>
<li>多协议（HTTP，TCP，UDP）支持异步和反应模型</li>
<li>缓存和批处理 </li>
</ul>
<span id="more"></span>

<h2 id="RestTemplate和Ribbon相结合"><a href="#RestTemplate和Ribbon相结合" class="headerlink" title="RestTemplate和Ribbon相结合"></a>RestTemplate和Ribbon相结合</h2><p>Ribbon在Netflix组件是非常重要的一个组件，在Zuul中使用Ribbon做负载均衡，以及Feign组件的结合等。在Spring Cloud 中，作为开发中，做的最多的可能是将RestTemplate和Ribbon相结合，你可能会这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class RibbonConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    @LoadBalanced</span><br><span class="line">    RestTemplate restTemplate() &#123;</span><br><span class="line">        return new RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消费另外一个的服务的接口，差不多是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class RibbonService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line">    public String hi(String name) &#123;</span><br><span class="line">        return restTemplate.getForObject(&quot;http:&#x2F;&#x2F;eureka-client&#x2F;hi?name&#x3D;&quot;+name,String.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="深入理解Ribbon"><a href="#深入理解Ribbon" class="headerlink" title="深入理解Ribbon"></a>深入理解Ribbon</h2><h3 id="LoadBalancerClient"><a href="#LoadBalancerClient" class="headerlink" title="LoadBalancerClient"></a>LoadBalancerClient</h3><p>在Riibon中一个非常重要的组件为LoadBalancerClient，它作为负载均衡的一个客户端。它在spring-cloud-commons包下：<br>的LoadBalancerClient是一个接口，它继承ServiceInstanceChooser，它的实现类是RibbonLoadBalancerClient，这三者之间的关系如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-961a4933f2f92c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>其中LoadBalancerClient接口，有如下三个方法，其中excute()为执行请求，reconstructURI()用来重构url：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface LoadBalancerClient extends ServiceInstanceChooser &#123;</span><br><span class="line">  &lt;T&gt; T execute(String serviceId, LoadBalancerRequest&lt;T&gt; request) throws IOException;</span><br><span class="line">  &lt;T&gt; T execute(String serviceId, ServiceInstance serviceInstance, LoadBalancerRequest&lt;T&gt; request) throws IOException;</span><br><span class="line">  URI reconstructURI(ServiceInstance instance, URI original);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>ServiceInstanceChooser接口，主要有一个方法，用来根据serviceId来获取ServiceInstance，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ServiceInstanceChooser &#123;</span><br><span class="line"></span><br><span class="line">    ServiceInstance choose(String serviceId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>LoadBalancerClient的实现类为RibbonLoadBalancerClient，这个类是非常重要的一个类，最终的负载均衡的请求处理，由它来执行。它的部分源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class RibbonLoadBalancerClient implements LoadBalancerClient &#123;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">	public ServiceInstance choose(String serviceId) &#123;</span><br><span class="line">		Server server &#x3D; getServer(serviceId);</span><br><span class="line">		if (server &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return new RibbonServer(serviceId, server, isSecure(server, serviceId),</span><br><span class="line">				serverIntrospector(serviceId).getMetadata(server));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected Server getServer(String serviceId) &#123;</span><br><span class="line">		return getServer(getLoadBalancer(serviceId));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected Server getServer(ILoadBalancer loadBalancer) &#123;</span><br><span class="line">		if (loadBalancer &#x3D;&#x3D; null) &#123;</span><br><span class="line">			return null;</span><br><span class="line">		&#125;</span><br><span class="line">		return loadBalancer.chooseServer(&quot;default&quot;); &#x2F;&#x2F; TODO: better handling of key</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">protected ILoadBalancer getLoadBalancer(String serviceId) &#123;</span><br><span class="line">		return this.clientFactory.getLoadBalancer(serviceId);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在RibbonLoadBalancerClient的源码中，其中choose()方法是选择具体服务实例的一个方法。该方法通过getServer()方法去获取实例，经过源码跟踪，最终交给了ILoadBalancer类去选择服务实例。</p>
<p>ILoadBalancer在ribbon-loadbalancer的jar包下,它是定义了实现软件负载均衡的一个接口，它需要一组可供选择的服务注册列表信息，以及根据特定方法去选择服务，它的源码如下 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ILoadBalancer &#123;</span><br><span class="line"></span><br><span class="line">    public void addServers(List&lt;Server&gt; newServers);</span><br><span class="line">    public Server chooseServer(Object key);</span><br><span class="line">    public void markServerDown(Server server);</span><br><span class="line">    public List&lt;Server&gt; getReachableServers();</span><br><span class="line">    public List&lt;Server&gt; getAllServers();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中，addServers()方法是添加一个Server集合；chooseServer()方法是根据key去获取Server；markServerDown()方法用来标记某个服务下线；getReachableServers()获取可用的Server集合；getAllServers()获取所有的Server集合。</p>
<h2 id="DynamicServerListLoadBalancer"><a href="#DynamicServerListLoadBalancer" class="headerlink" title="DynamicServerListLoadBalancer"></a>DynamicServerListLoadBalancer</h2><p>它的继承类为BaseLoadBalancer，它的实现类为DynamicServerListLoadBalancer，这三者之间的关系如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-09ad9b1ece18a1a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>查看上述三个类的源码，可用发现，配置以下信息，IClientConfig、IRule、IPing、ServerList、ServerListFilter和ILoadBalancer，查看BaseLoadBalancer类，它默认的情况下，实现了以下配置：</p>
<ul>
<li>IClientConfig ribbonClientConfig:  DefaultClientConfigImpl配置</li>
<li>IRule ribbonRule: RoundRobinRule 路由策略</li>
<li>IPing ribbonPing: DummyPing </li>
<li>ServerList ribbonServerList: ConfigurationBasedServerList</li>
<li>ServerListFilter ribbonServerListFilter: ZonePreferenceServerListFilter</li>
<li>ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</li>
</ul>
<p>IClientConfig 用于对客户端或者负载均衡的配置，它的默认实现类为DefaultClientConfigImpl。</p>
<p>IRule用于复杂均衡的策略，它有三个方法，其中choose()是根据key 来获取server,setLoadBalancer()和getLoadBalancer()是用来设置和获取ILoadBalancer的，它的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IRule&#123;</span><br><span class="line"></span><br><span class="line">    public Server choose(Object key);</span><br><span class="line">    </span><br><span class="line">    public void setLoadBalancer(ILoadBalancer lb);</span><br><span class="line">    </span><br><span class="line">    public ILoadBalancer getLoadBalancer();    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>IRule有很多默认的实现类，这些实现类根据不同的算法和逻辑来处理负载均衡。Ribbon实现的IRule有一下。在大多数情况下，这些默认的实现类是可以满足需求的，如果有特性的需求，可以自己实现。</p>
<ul>
<li><p>BestAvailableRule 选择最小请求数</p>
</li>
<li><p>ClientConfigEnabledRoundRobinRule 轮询</p>
</li>
<li><p>RandomRule 随机选择一个server</p>
</li>
<li><p>RoundRobinRule 轮询选择server</p>
</li>
<li><p>RetryRule 根据轮询的方式重试</p>
</li>
<li><p>WeightedResponseTimeRule 根据响应时间去分配一个weight ，weight越低，被选择的可能性就越低</p>
</li>
<li><p>ZoneAvoidanceRule 根据server的zone区域和可用性来轮询选择</p>
</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-ce636f8c473f6e07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>IPing是用来想server发生”ping”，来判断该server是否有响应，从而判断该server是否可用。它有一个isAlive()方法，它的源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IPing &#123;</span><br><span class="line">    public boolean isAlive(Server server);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>IPing的实现类有PingUrl、PingConstant、NoOpPing、DummyPing和NIWSDiscoveryPing。它门之间的关系如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-a2871eb4f4e82714.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li>PingUrl 真实的去ping 某个url，判断其是否alive</li>
<li>PingConstant 固定返回某服务是否可用，默认返回true，即可用</li>
<li>NoOpPing 不去ping,直接返回true,即可用。</li>
<li>DummyPing 直接返回true，并实现了initWithNiwsConfig方法。</li>
<li>NIWSDiscoveryPing，根据DiscoveryEnabledServer的InstanceInfo的InstanceStatus去判断，如果为InstanceStatus.UP，则为可用，否则不可用。</li>
</ul>
<p>ServerList是定义获取所有的server的注册列表信息的接口，它的代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ServerList&lt;T extends Server&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;T&gt; getInitialListOfServers();</span><br><span class="line">    public List&lt;T&gt; getUpdatedListOfServers();   </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ServerListFilter接口，定于了可根据配置去过滤或者根据特性动态获取符合条件的server列表的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface ServerListFilter&lt;T extends Server&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public List&lt;T&gt; getFilteredListOfServers(List&lt;T&gt; servers);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>阅读DynamicServerListLoadBalancer的源码，DynamicServerListLoadBalancer的构造函数中有个initWithNiwsConfig()方法。在改方法中，经过一系列的初始化配置，最终执行了restOfInit()方法。其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public DynamicServerListLoadBalancer(IClientConfig clientConfig) &#123;</span><br><span class="line">       initWithNiwsConfig(clientConfig);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   @Override</span><br><span class="line">   public void initWithNiwsConfig(IClientConfig clientConfig) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           super.initWithNiwsConfig(clientConfig);</span><br><span class="line">           String niwsServerListClassName &#x3D; clientConfig.getPropertyAsString(</span><br><span class="line">                   CommonClientConfigKey.NIWSServerListClassName,</span><br><span class="line">                   DefaultClientConfigImpl.DEFAULT_SEVER_LIST_CLASS);</span><br><span class="line"></span><br><span class="line">           ServerList&lt;T&gt; niwsServerListImpl &#x3D; (ServerList&lt;T&gt;) ClientFactory</span><br><span class="line">                   .instantiateInstanceWithClientConfig(niwsServerListClassName, clientConfig);</span><br><span class="line">           this.serverListImpl &#x3D; niwsServerListImpl;</span><br><span class="line"></span><br><span class="line">           if (niwsServerListImpl instanceof AbstractServerList) &#123;</span><br><span class="line">               AbstractServerListFilter&lt;T&gt; niwsFilter &#x3D; ((AbstractServerList) niwsServerListImpl)</span><br><span class="line">                       .getFilterImpl(clientConfig);</span><br><span class="line">               niwsFilter.setLoadBalancerStats(getLoadBalancerStats());</span><br><span class="line">               this.filter &#x3D; niwsFilter;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           String serverListUpdaterClassName &#x3D; clientConfig.getPropertyAsString(</span><br><span class="line">                   CommonClientConfigKey.ServerListUpdaterClassName,</span><br><span class="line">                   DefaultClientConfigImpl.DEFAULT_SERVER_LIST_UPDATER_CLASS</span><br><span class="line">           );</span><br><span class="line"></span><br><span class="line">           this.serverListUpdater &#x3D; (ServerListUpdater) ClientFactory</span><br><span class="line">                   .instantiateInstanceWithClientConfig(serverListUpdaterClassName, clientConfig);</span><br><span class="line"></span><br><span class="line">           restOfInit(clientConfig);</span><br><span class="line">       &#125; catch (Exception e) &#123;</span><br><span class="line">           throw new RuntimeException(</span><br><span class="line">                   &quot;Exception while initializing NIWSDiscoveryLoadBalancer:&quot;</span><br><span class="line">                           + clientConfig.getClientName()</span><br><span class="line">                           + &quot;, niwsClientConfig:&quot; + clientConfig, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在restOfInit()方法上，有一个 updateListOfServers()的方法，该方法是用来获取所有的ServerList的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void restOfInit(IClientConfig clientConfig) &#123;</span><br><span class="line">       boolean primeConnection &#x3D; this.isEnablePrimingConnections();</span><br><span class="line">       &#x2F;&#x2F; turn this off to avoid duplicated asynchronous priming done in BaseLoadBalancer.setServerList()</span><br><span class="line">       this.setEnablePrimingConnections(false);</span><br><span class="line">       enableAndInitLearnNewServersFeature();</span><br><span class="line"></span><br><span class="line">       updateListOfServers();</span><br><span class="line">       if (primeConnection &amp;&amp; this.getPrimeConnections() !&#x3D; null) &#123;</span><br><span class="line">           this.getPrimeConnections()</span><br><span class="line">                   .primeConnections(getReachableServers());</span><br><span class="line">       &#125;</span><br><span class="line">       this.setEnablePrimingConnections(primeConnection);</span><br><span class="line">       LOGGER.info(&quot;DynamicServerListLoadBalancer for client &#123;&#125; initialized: &#123;&#125;&quot;, clientConfig.getClientName(), this.toString());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>进一步跟踪updateListOfServers()方法的源码，最终由serverListImpl.getUpdatedListOfServers()获取所有的服务列表的，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@VisibleForTesting</span><br><span class="line"> public void updateListOfServers() &#123;</span><br><span class="line">     List&lt;T&gt; servers &#x3D; new ArrayList&lt;T&gt;();</span><br><span class="line">     if (serverListImpl !&#x3D; null) &#123;</span><br><span class="line">         servers &#x3D; serverListImpl.getUpdatedListOfServers();</span><br><span class="line">         LOGGER.debug(&quot;List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;,</span><br><span class="line">                 getIdentifier(), servers);</span><br><span class="line"></span><br><span class="line">         if (filter !&#x3D; null) &#123;</span><br><span class="line">             servers &#x3D; filter.getFilteredListOfServers(servers);</span><br><span class="line">             LOGGER.debug(&quot;Filtered List of Servers for &#123;&#125; obtained from Discovery client: &#123;&#125;&quot;,</span><br><span class="line">                     getIdentifier(), servers);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     updateAllServerList(servers);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而serverListImpl是ServerList接口的具体实现类。跟踪代码，ServerList的实现类为DiscoveryEnabledNIWSServerList，在ribbon-eureka.jar的com.netflix.niws.loadbalancer下。其中DiscoveryEnabledNIWSServerList有 getInitialListOfServers()和getUpdatedListOfServers()方法，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public List&lt;DiscoveryEnabledServer&gt; getInitialListOfServers()&#123;</span><br><span class="line">        return obtainServersViaDiscovery();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;DiscoveryEnabledServer&gt; getUpdatedListOfServers()&#123;</span><br><span class="line">        return obtainServersViaDiscovery();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>继续跟踪源码，obtainServersViaDiscovery（），是根据eurekaClientProvider.get()来回去EurekaClient，再根据EurekaClient来获取注册列表信息，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">private List&lt;DiscoveryEnabledServer&gt; obtainServersViaDiscovery() &#123;</span><br><span class="line">       List&lt;DiscoveryEnabledServer&gt; serverList &#x3D; new ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line"></span><br><span class="line">       if (eurekaClientProvider &#x3D;&#x3D; null || eurekaClientProvider.get() &#x3D;&#x3D; null) &#123;</span><br><span class="line">           logger.warn(&quot;EurekaClient has not been initialized yet, returning an empty list&quot;);</span><br><span class="line">           return new ArrayList&lt;DiscoveryEnabledServer&gt;();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       EurekaClient eurekaClient &#x3D; eurekaClientProvider.get();</span><br><span class="line">       if (vipAddresses!&#x3D;null)&#123;</span><br><span class="line">           for (String vipAddress : vipAddresses.split(&quot;,&quot;)) &#123;</span><br><span class="line">               &#x2F;&#x2F; if targetRegion is null, it will be interpreted as the same region of client</span><br><span class="line">               List&lt;InstanceInfo&gt; listOfInstanceInfo &#x3D; eurekaClient.getInstancesByVipAddress(vipAddress, isSecure, targetRegion);</span><br><span class="line">               for (InstanceInfo ii : listOfInstanceInfo) &#123;</span><br><span class="line">                   if (ii.getStatus().equals(InstanceStatus.UP)) &#123;</span><br><span class="line"></span><br><span class="line">                       if(shouldUseOverridePort)&#123;</span><br><span class="line">                           if(logger.isDebugEnabled())&#123;</span><br><span class="line">                               logger.debug(&quot;Overriding port on client name: &quot; + clientName + &quot; to &quot; + overridePort);</span><br><span class="line">                           &#125;</span><br><span class="line"></span><br><span class="line">                           &#x2F;&#x2F; copy is necessary since the InstanceInfo builder just uses the original reference,</span><br><span class="line">                           &#x2F;&#x2F; and we don&#39;t want to corrupt the global eureka copy of the object which may be</span><br><span class="line">                           &#x2F;&#x2F; used by other clients in our system</span><br><span class="line">                           InstanceInfo copy &#x3D; new InstanceInfo(ii);</span><br><span class="line"></span><br><span class="line">                           if(isSecure)&#123;</span><br><span class="line">                               ii &#x3D; new InstanceInfo.Builder(copy).setSecurePort(overridePort).build();</span><br><span class="line">                           &#125;else&#123;</span><br><span class="line">                               ii &#x3D; new InstanceInfo.Builder(copy).setPort(overridePort).build();</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       DiscoveryEnabledServer des &#x3D; new DiscoveryEnabledServer(ii, isSecure, shouldUseIpAddr);</span><br><span class="line">                       des.setZone(DiscoveryClient.getZone(ii));</span><br><span class="line">                       serverList.add(des);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               if (serverList.size()&gt;0 &amp;&amp; prioritizeVipAddressBasedServers)&#123;</span><br><span class="line">                   break; &#x2F;&#x2F; if the current vipAddress has servers, we dont use subsequent vipAddress based servers</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return serverList;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>其中eurekaClientProvider的实现类是LegacyEurekaClientProvider，它是一个获取eurekaClient类，通过静态的方法去获取eurekaClient，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class LegacyEurekaClientProvider implements Provider&lt;EurekaClient&gt; &#123;</span><br><span class="line"></span><br><span class="line">    private volatile EurekaClient eurekaClient;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public synchronized EurekaClient get() &#123;</span><br><span class="line">        if (eurekaClient &#x3D;&#x3D; null) &#123;</span><br><span class="line">            eurekaClient &#x3D; DiscoveryManager.getInstance().getDiscoveryClient();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return eurekaClient;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>EurekaClient的实现类为DiscoveryClient，在之前已经分析了它具有服务注册、获取服务注册列表等的全部功能。</p>
<p>由此可见，负载均衡器是从EurekaClient获取服务信息，并根据IRule去路由，并且根据IPing去判断服务的可用性。</p>
<p>那么现在还有个问题，负载均衡器多久一次去获取一次从Eureka Client获取注册信息呢。</p>
<p>在BaseLoadBalancer类下，BaseLoadBalancer的构造函数，该构造函数开启了一个PingTask任务，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public BaseLoadBalancer(String name, IRule rule, LoadBalancerStats stats,</span><br><span class="line">         IPing ping, IPingStrategy pingStrategy) &#123;</span><br><span class="line">  ...&#x2F;&#x2F;代码省略</span><br><span class="line">     setupPingTask();</span><br><span class="line">      ...&#x2F;&#x2F;代码省略</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>setupPingTask()的具体代码逻辑，它开启了ShutdownEnabledTimer执行PingTask任务，在默认情况下pingIntervalSeconds为10，即每10秒钟，想EurekaClient发送一次”ping”。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void setupPingTask() &#123;</span><br><span class="line">    if (canSkipPing()) &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    if (lbTimer !&#x3D; null) &#123;</span><br><span class="line">        lbTimer.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    lbTimer &#x3D; new ShutdownEnabledTimer(&quot;NFLoadBalancer-PingTimer-&quot; + name,</span><br><span class="line">            true);</span><br><span class="line">    lbTimer.schedule(new PingTask(), 0, pingIntervalSeconds * 1000);</span><br><span class="line">    forceQuickPing();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>PingTask源码，即new一个Pinger对象，并执行runPinger()方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class PingTask extends TimerTask &#123;</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">            	new Pinger(pingStrategy).runPinger();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                logger.error(&quot;LoadBalancer [&#123;&#125;]: Error pinging&quot;, name, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看Pinger的runPinger()方法，最终根据  pingerStrategy.pingServers(ping, allServers)来获取服务的可用性，如果该返回结果，如之前相同，则不去向EurekaClient获取注册列表，如果不同则通知ServerStatusChangeListener或者changeListeners发生了改变，进行更新或者重新拉取。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void runPinger() throws Exception &#123;</span><br><span class="line">          if (!pingInProgress.compareAndSet(false, true)) &#123; </span><br><span class="line">              return; &#x2F;&#x2F; Ping in progress - nothing to do</span><br><span class="line">          &#125;</span><br><span class="line">          </span><br><span class="line">          &#x2F;&#x2F; we are &quot;in&quot; - we get to Ping</span><br><span class="line"></span><br><span class="line">          Server[] allServers &#x3D; null;</span><br><span class="line">          boolean[] results &#x3D; null;</span><br><span class="line"></span><br><span class="line">          Lock allLock &#x3D; null;</span><br><span class="line">          Lock upLock &#x3D; null;</span><br><span class="line"></span><br><span class="line">          try &#123;</span><br><span class="line">              &#x2F;*</span><br><span class="line">               * The readLock should be free unless an addServer operation is</span><br><span class="line">               * going on...</span><br><span class="line">               *&#x2F;</span><br><span class="line">              allLock &#x3D; allServerLock.readLock();</span><br><span class="line">              allLock.lock();</span><br><span class="line">              allServers &#x3D; allServerList.toArray(new Server[allServerList.size()]);</span><br><span class="line">              allLock.unlock();</span><br><span class="line"></span><br><span class="line">              int numCandidates &#x3D; allServers.length;</span><br><span class="line">              results &#x3D; pingerStrategy.pingServers(ping, allServers);</span><br><span class="line"></span><br><span class="line">              final List&lt;Server&gt; newUpList &#x3D; new ArrayList&lt;Server&gt;();</span><br><span class="line">              final List&lt;Server&gt; changedServers &#x3D; new ArrayList&lt;Server&gt;();</span><br><span class="line"></span><br><span class="line">              for (int i &#x3D; 0; i &lt; numCandidates; i++) &#123;</span><br><span class="line">                  boolean isAlive &#x3D; results[i];</span><br><span class="line">                  Server svr &#x3D; allServers[i];</span><br><span class="line">                  boolean oldIsAlive &#x3D; svr.isAlive();</span><br><span class="line"></span><br><span class="line">                  svr.setAlive(isAlive);</span><br><span class="line"></span><br><span class="line">                  if (oldIsAlive !&#x3D; isAlive) &#123;</span><br><span class="line">                      changedServers.add(svr);</span><br><span class="line">                      logger.debug(&quot;LoadBalancer [&#123;&#125;]:  Server [&#123;&#125;] status changed to &#123;&#125;&quot;, </span><br><span class="line">                  		name, svr.getId(), (isAlive ? &quot;ALIVE&quot; : &quot;DEAD&quot;));</span><br><span class="line">                  &#125;</span><br><span class="line"></span><br><span class="line">                  if (isAlive) &#123;</span><br><span class="line">                      newUpList.add(svr);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              upLock &#x3D; upServerLock.writeLock();</span><br><span class="line">              upLock.lock();</span><br><span class="line">              upServerList &#x3D; newUpList;</span><br><span class="line">              upLock.unlock();</span><br><span class="line"></span><br><span class="line">              notifyServerStatusChangeListener(changedServers);</span><br><span class="line">          &#125; finally &#123;</span><br><span class="line">              pingInProgress.set(false);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>由此可见，LoadBalancerClient是在初始化的时候，会向Eureka回去服务注册列表，并且向通过10s一次向EurekaClient发送“ping”，来判断服务的可用性，如果服务的可用性发生了改变或者服务数量和之前的不一致，则更新或者重新拉取。LoadBalancerClient有了这些服务注册列表，就可以根据具体的IRule来进行负载均衡。</p>
<h2 id="RestTemplate是如何和Ribbon结合的"><a href="#RestTemplate是如何和Ribbon结合的" class="headerlink" title="RestTemplate是如何和Ribbon结合的"></a>RestTemplate是如何和Ribbon结合的</h2><p>最后，回答问题的本质，为什么在RestTemplate加一个@LoadBalance注解就可可以开启负载均衡呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@LoadBalanced</span><br><span class="line">   RestTemplate restTemplate() &#123;</span><br><span class="line">       return new RestTemplate();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>全局搜索ctr+shift+f  @LoadBalanced有哪些类用到了LoadBalanced有哪些类用到了， 发现LoadBalancerAutoConfiguration类，即LoadBalancer自动配置类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(RestTemplate.class)</span><br><span class="line">@ConditionalOnBean(LoadBalancerClient.class)</span><br><span class="line">@EnableConfigurationProperties(LoadBalancerRetryProperties.class)</span><br><span class="line">public class LoadBalancerAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@LoadBalanced</span><br><span class="line">	@Autowired(required &#x3D; false)</span><br><span class="line">	private List&lt;RestTemplate&gt; restTemplates &#x3D; Collections.emptyList();</span><br><span class="line">&#125;</span><br><span class="line">	@Bean</span><br><span class="line">	public SmartInitializingSingleton loadBalancedRestTemplateInitializer(</span><br><span class="line">			final List&lt;RestTemplateCustomizer&gt; customizers) &#123;</span><br><span class="line">		return new SmartInitializingSingleton() &#123;</span><br><span class="line">			@Override</span><br><span class="line">			public void afterSingletonsInstantiated() &#123;</span><br><span class="line">				for (RestTemplate restTemplate : LoadBalancerAutoConfiguration.this.restTemplates) &#123;</span><br><span class="line">					for (RestTemplateCustomizer customizer : customizers) &#123;</span><br><span class="line">						customizer.customize(restTemplate);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	@Configuration</span><br><span class="line">	@ConditionalOnMissingClass(&quot;org.springframework.retry.support.RetryTemplate&quot;)</span><br><span class="line">	static class LoadBalancerInterceptorConfig &#123;</span><br><span class="line">		@Bean</span><br><span class="line">		public LoadBalancerInterceptor ribbonInterceptor(</span><br><span class="line">				LoadBalancerClient loadBalancerClient,</span><br><span class="line">				LoadBalancerRequestFactory requestFactory) &#123;</span><br><span class="line">			return new LoadBalancerInterceptor(loadBalancerClient, requestFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		@Bean</span><br><span class="line">		@ConditionalOnMissingBean</span><br><span class="line">		public RestTemplateCustomizer restTemplateCustomizer(</span><br><span class="line">				final LoadBalancerInterceptor loadBalancerInterceptor) &#123;</span><br><span class="line">			return new RestTemplateCustomizer() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				public void customize(RestTemplate restTemplate) &#123;</span><br><span class="line">					List&lt;ClientHttpRequestInterceptor&gt; list &#x3D; new ArrayList&lt;&gt;(</span><br><span class="line">							restTemplate.getInterceptors());</span><br><span class="line">					list.add(loadBalancerInterceptor);</span><br><span class="line">					restTemplate.setInterceptors(list);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在该类中，首先维护了一个被@LoadBalanced修饰的RestTemplate对象的List，在初始化的过程中，通过调用customizer.customize(restTemplate)方法来给RestTemplate增加拦截器LoadBalancerInterceptor。</p>
<p>而LoadBalancerInterceptor，用于实时拦截，在LoadBalancerInterceptor这里实现来负载均衡。LoadBalancerInterceptor的拦截方法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">	public ClientHttpResponse intercept(final HttpRequest request, final byte[] body,</span><br><span class="line">			final ClientHttpRequestExecution execution) throws IOException &#123;</span><br><span class="line">		final URI originalUri &#x3D; request.getURI();</span><br><span class="line">		String serviceName &#x3D; originalUri.getHost();</span><br><span class="line">		Assert.state(serviceName !&#x3D; null, &quot;Request URI does not contain a valid hostname: &quot; + originalUri);</span><br><span class="line">		return this.loadBalancer.execute(serviceName, requestFactory.createRequest(request, body, execution));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上所述，Ribbon的负载均衡，主要通过LoadBalancerClient来实现的，而LoadBalancerClient具体交给了ILoadBalancer来处理，ILoadBalancer通过配置IRule、IPing等信息，并向EurekaClient获取注册列表的信息，并默认10秒一次向EurekaClient发送“ping”,进而检查是否更新服务列表，最后，得到注册列表后，ILoadBalancer根据IRule的策略进行负载均衡。</p>
<p>而RestTemplate 被@LoadBalance注解后，能过用负载均衡，主要是维护了一个被@LoadBalance注解的RestTemplate列表，并给列表中的RestTemplate添加拦截器，进而交给负载均衡器去处理。</p>
<h2 id="关注我的公众号"><a href="#关注我的公众号" class="headerlink" title="关注我的公众号"></a>关注我的公众号</h2><p>精彩内容不能错过！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0805748d92bba033.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="forezp.jpg"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>Eureka源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-eureka-resources/</url>
    <content><![CDATA[<p>本篇文章以源码的角度来深入理解Eureka.</p>
<span id="more"></span>

<h2 id="Eureka的一些概念"><a href="#Eureka的一些概念" class="headerlink" title="Eureka的一些概念"></a>Eureka的一些概念</h2><ul>
<li><p>Register：服务注册<br>当Eureka客户端向Eureka Server注册时，它提供自身的元数据，比如IP地址、端口，运行状况指示符URL，主页等。</p>
</li>
<li><p>Renew：服务续约<br>Eureka客户会每隔30秒发送一次心跳来续约。 通过续约来告知Eureka Server该Eureka客户仍然存在，没有出现问题。 正常情况下，如果Eureka Server在90秒没有收到Eureka客户的续约，它会将实例从其注册表中删除。 建议不要更改续约间隔.</p>
</li>
<li><p>Fetch Registries：获取注册列表信息<br>Eureka客户端从服务器获取注册表信息，并将其缓存在本地。客户端会使用该信息查找其他服务，从而进行远程调用。该注册列表信息定期（每30秒钟）更新一次。每次返回注册列表信息可能与Eureka客户端的缓存信息不同， Eureka客户端自动处理。如果由于某种原因导致注册列表信息不能及时匹配，Eureka客户端则会重新获取整个注册表信息。 Eureka服务器缓存注册列表信息，整个注册表以及每个应用程序的信息进行了压缩，压缩内容和没有压缩的内容完全相同。Eureka客户端和Eureka 服务器可以使用JSON / XML格式进行通讯。在默认的情况下Eureka客户端使用压缩JSON格式来获取注册列表的信息。</p>
</li>
<li><p>Cancel：服务下线<br>Eureka客户端在程序关闭时向Eureka服务器发送取消请求。 发送请求后，该客户端实例信息将从服务器的实例注册表中删除。该下线请求不会自动完成，它需要调用以下内容：<br>DiscoveryManager.getInstance().shutdownComponent()；</p>
</li>
<li><p>Eviction 服务剔除<br>在默认的情况下，当Eureka客户端连续90秒没有向Eureka服务器发送服务续约，即心跳，Eureka服务器会将该服务实例从服务注册列表删除，即服务剔除。</p>
</li>
</ul>
<h2 id="Eureka的高可用架构"><a href="#Eureka的高可用架构" class="headerlink" title="Eureka的高可用架构"></a>Eureka的高可用架构</h2><p>如图为Eureka的高级架构图，该图片来自于Eureka开源代码的文档，地址为<a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance">https://github.com/Netflix/eureka/wiki/Eureka-at-a-glance</a> 。</p>
<p><img src="https://github.com/Netflix/eureka/raw/master/images/eureka_architecture.png" alt="Eureka的高级架构图"></p>
<p> 从图可以看出在这个体系中，有2个角色，即Eureka Server和Eureka Client。而Eureka Client又分为Applicaton Service和Application Client，即服务提供者何服务消费者。 每个区域有一个Eureka集群，并且每个区域至少有一个eureka服务器可以处理区域故障，以防服务器瘫痪。</p>
<p>Eureka Client向Eureka Serve注册，并将自己的一些客户端信息发送Eureka Serve。然后，Eureka Client通过向Eureka Serve发送心跳（每30秒）来续约服务的。 如果客户端持续不能续约，那么，它将在大约90秒内从服务器注册表中删除。 注册信息和续订被复制到集群中的Eureka Serve所有节点。 来自任何区域的Eureka Client都可以查找注册表信息（每30秒发生一次）。根据这些注册表信息，Application Client可以远程调用Applicaton Service来消费服务。</p>
<h2 id="Register服务注册"><a href="#Register服务注册" class="headerlink" title="Register服务注册"></a>Register服务注册</h2><p>服务注册，即Eureka Client向Eureka Server提交自己的服务信息，包括IP地址、端口、service ID等信息。如果Eureka Client没有写service ID，则默认为 ${spring.application.name}。</p>
<p>服务注册其实很简单，在Eureka Client启动的时候，将自身的服务的信息发送到Eureka Server。现在来简单的阅读下源码。在Maven的依赖包下，找到eureka-client-1.6.2.jar包。在com.netflix.discovery包下有个DiscoveryClient类，该类包含了Eureka Client向Eureka Server的相关方法。其中DiscoveryClient实现了EurekaClient接口，并且它是一个单例模式，而EurekaClient继承了LookupService接口。它们之间的关系如图所示。</p>
<p><img src="http://img.blog.csdn.net/20170611110916402?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在DiscoveryClient类有一个服务注册的方法register()，该方法是通过Http请求向Eureka Client注册。其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean register() throws Throwable &#123;</span><br><span class="line">        logger.info(PREFIX + appPathIdentifier + &quot;: registering service...&quot;);</span><br><span class="line">        EurekaHttpResponse&lt;Void&gt; httpResponse;</span><br><span class="line">        try &#123;</span><br><span class="line">            httpResponse &#x3D; eurekaTransport.registrationClient.register(instanceInfo);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            logger.warn(&quot;&#123;&#125; - registration failed &#123;&#125;&quot;, PREFIX + appPathIdentifier, e.getMessage(), e);</span><br><span class="line">            throw e;</span><br><span class="line">        &#125;</span><br><span class="line">        if (logger.isInfoEnabled()) &#123;</span><br><span class="line">            logger.info(&quot;&#123;&#125; - registration status: &#123;&#125;&quot;, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">        &#125;</span><br><span class="line">        return httpResponse.getStatusCode() &#x3D;&#x3D; 204;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在DiscoveryClient类继续追踪register()方法，它被InstanceInfoReplicator 类的run()方法调用，其中InstanceInfoReplicator实现了Runnable接口，run()方法代码如下： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void run() &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           discoveryClient.refreshInstanceInfo();</span><br><span class="line"></span><br><span class="line">           Long dirtyTimestamp &#x3D; instanceInfo.isDirtyWithTime();</span><br><span class="line">           if (dirtyTimestamp !&#x3D; null) &#123;</span><br><span class="line">               discoveryClient.register();</span><br><span class="line">               instanceInfo.unsetIsDirty(dirtyTimestamp);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Throwable t) &#123;</span><br><span class="line">           logger.warn(&quot;There was a problem with the instance info replicator&quot;, t);</span><br><span class="line">       &#125; finally &#123;</span><br><span class="line">           Future next &#x3D; scheduler.schedule(this, replicationIntervalSeconds, TimeUnit.SECONDS);</span><br><span class="line">           scheduledPeriodicRef.set(next);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而InstanceInfoReplicator类是在DiscoveryClient初始化过程中使用的，其中有一个initScheduledTasks()方法。该方法主要开启了获取服务注册列表的信息，如果需要向Eureka Server注册，则开启注册，同时开启了定时向Eureka Server服务续约的定时任务，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void initScheduledTasks() &#123;</span><br><span class="line">       ...&#x2F;&#x2F;省略了任务调度获取注册列表的代码</span><br><span class="line">        if (clientConfig.shouldRegisterWithEureka()) &#123;</span><br><span class="line">         ... </span><br><span class="line">            &#x2F;&#x2F; Heartbeat timer</span><br><span class="line">            scheduler.schedule(</span><br><span class="line">                    new TimedSupervisorTask(</span><br><span class="line">                            &quot;heartbeat&quot;,</span><br><span class="line">                            scheduler,</span><br><span class="line">                            heartbeatExecutor,</span><br><span class="line">                            renewalIntervalInSecs,</span><br><span class="line">                            TimeUnit.SECONDS,</span><br><span class="line">                            expBackOffBound,</span><br><span class="line">                            new HeartbeatThread()</span><br><span class="line">                    ),</span><br><span class="line">                    renewalIntervalInSecs, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">            &#x2F;&#x2F; InstanceInfo replicator</span><br><span class="line">            instanceInfoReplicator &#x3D; new InstanceInfoReplicator(</span><br><span class="line">                    this,</span><br><span class="line">                    instanceInfo,</span><br><span class="line">                    clientConfig.getInstanceInfoReplicationIntervalSeconds(),</span><br><span class="line">                    2); &#x2F;&#x2F; burstSize</span><br><span class="line"></span><br><span class="line">            statusChangeListener &#x3D; new ApplicationInfoManager.StatusChangeListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public String getId() &#123;</span><br><span class="line">                    return &quot;statusChangeListener&quot;;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                @Override</span><br><span class="line">                public void notify(StatusChangeEvent statusChangeEvent) &#123;</span><br><span class="line">                 </span><br><span class="line">                    instanceInfoReplicator.onDemandUpdate();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">          ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>然后在来看Eureka server端的代码，在Maven的eureka-core:1.6.2的jar包下。打开com.netflix.eureka包，很轻松的就发现了又一个EurekaBootStrap的类，BootStrapContext具有最先初始化的权限，所以先看这个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected void initEurekaServerContext() throws Exception &#123;</span><br><span class="line"> </span><br><span class="line"> ...&#x2F;&#x2F;省略代码</span><br><span class="line">   PeerAwareInstanceRegistry registry;</span><br><span class="line">        if (isAws(applicationInfoManager.getInfo())) &#123;</span><br><span class="line">           ...&#x2F;&#x2F;省略代码，如果是AWS的代码</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            registry &#x3D; new PeerAwareInstanceRegistryImpl(</span><br><span class="line">                    eurekaServerConfig,</span><br><span class="line">                    eurekaClient.getEurekaClientConfig(),</span><br><span class="line">                    serverCodecs,</span><br><span class="line">                    eurekaClient</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        PeerEurekaNodes peerEurekaNodes &#x3D; getPeerEurekaNodes(</span><br><span class="line">                registry,</span><br><span class="line">                eurekaServerConfig,</span><br><span class="line">                eurekaClient.getEurekaClientConfig(),</span><br><span class="line">                serverCodecs,</span><br><span class="line">                applicationInfoManager</span><br><span class="line">        );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>其中PeerAwareInstanceRegistryImpl和PeerEurekaNodes两个类看其命名，应该和服务注册以及Eureka Server高可用有关。先追踪PeerAwareInstanceRegistryImpl类，在该类有个register()方法，该方法提供了注册，并且将注册后信息同步到其他的Eureka Server服务。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void register(final InstanceInfo info, final boolean isReplication) &#123;</span><br><span class="line">        int leaseDuration &#x3D; Lease.DEFAULT_DURATION_IN_SECS;</span><br><span class="line">        if (info.getLeaseInfo() !&#x3D; null &amp;&amp; info.getLeaseInfo().getDurationInSecs() &gt; 0) &#123;</span><br><span class="line">            leaseDuration &#x3D; info.getLeaseInfo().getDurationInSecs();</span><br><span class="line">        &#125;</span><br><span class="line">        super.register(info, leaseDuration, isReplication);</span><br><span class="line">        replicateToPeers(Action.Register, info.getAppName(), info.getId(), info, null, isReplication);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中 super.register(info, leaseDuration, isReplication)方法，点击进去到子类AbstractInstanceRegistry可以发现更多细节，其中注册列表的信息被保存在一个Map中。replicateToPeers()方法，即同步到其他Eureka Server的其他Peers节点，追踪代码，发现它会遍历循环向所有的Peers节点注册，最终执行类PeerEurekaNodes的register()方法，该方法通过执行一个任务向其他节点同步该注册信息，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void register(final InstanceInfo info) throws Exception &#123;</span><br><span class="line">      long expiryTime &#x3D; System.currentTimeMillis() + getLeaseRenewalOf(info);</span><br><span class="line">      batchingDispatcher.process(</span><br><span class="line">              taskId(&quot;register&quot;, info),</span><br><span class="line">              new InstanceReplicationTask(targetHost, Action.Register, info, null, true) &#123;</span><br><span class="line">                  public EurekaHttpResponse&lt;Void&gt; execute() &#123;</span><br><span class="line">                      return replicationClient.register(info);</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;,</span><br><span class="line">              expiryTime</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过一系列的源码追踪，可以发现PeerAwareInstanceRegistryImpl的register()方法实现了服务的注册，并且向其他Eureka Server的Peer节点同步了该注册信息，那么register()方法被谁调用了呢？之前在Eureka Client的分析可以知道，Eureka Client是通过 http来向Eureka Server注册的，那么Eureka Server肯定会提供一个注册的接口给Eureka Client调用，那么PeerAwareInstanceRegistryImpl的register()方法肯定最终会被暴露的Http接口所调用。在Idea开发工具，按住alt+鼠标左键，可以很快定位到ApplicationResource类的addInstance ()方法，即服务注册的接口，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@POST</span><br><span class="line">    @Consumes(&#123;&quot;application&#x2F;json&quot;, &quot;application&#x2F;xml&quot;&#125;)</span><br><span class="line">    public Response addInstance(InstanceInfo info,</span><br><span class="line">                                @HeaderParam(PeerEurekaNode.HEADER_REPLICATION) String isReplication) &#123;</span><br><span class="line">       </span><br><span class="line">    ...&#x2F;&#x2F;省略代码                 </span><br><span class="line">               registry.register(info, &quot;true&quot;.equals(isReplication));</span><br><span class="line">        return Response.status(204).build();  &#x2F;&#x2F; 204 to be backwards compatible</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Renew服务续约"><a href="#Renew服务续约" class="headerlink" title="Renew服务续约"></a>Renew服务续约</h2><p>服务续约和服务注册非常类似，通过之前的分析可以知道，服务注册在Eureka Client程序启动之后开启，并同时开启服务续约的定时任务。在eureka-client-1.6.2.jar的DiscoveryClient的类下有renew()方法，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">   * Renew with the eureka service by making the appropriate REST call</span><br><span class="line">   *&#x2F;</span><br><span class="line">  boolean renew() &#123;</span><br><span class="line">      EurekaHttpResponse&lt;InstanceInfo&gt; httpResponse;</span><br><span class="line">      try &#123;</span><br><span class="line">          httpResponse &#x3D; eurekaTransport.registrationClient.sendHeartBeat(instanceInfo.getAppName(), instanceInfo.getId(), instanceInfo, null);</span><br><span class="line">          logger.debug(&quot;&#123;&#125; - Heartbeat status: &#123;&#125;&quot;, PREFIX + appPathIdentifier, httpResponse.getStatusCode());</span><br><span class="line">          if (httpResponse.getStatusCode() &#x3D;&#x3D; 404) &#123;</span><br><span class="line">              REREGISTER_COUNTER.increment();</span><br><span class="line">              logger.info(&quot;&#123;&#125; - Re-registering apps&#x2F;&#123;&#125;&quot;, PREFIX + appPathIdentifier, instanceInfo.getAppName());</span><br><span class="line">              return register();</span><br><span class="line">          &#125;</span><br><span class="line">          return httpResponse.getStatusCode() &#x3D;&#x3D; 200;</span><br><span class="line">      &#125; catch (Throwable e) &#123;</span><br><span class="line">          logger.error(&quot;&#123;&#125; - was unable to send heartbeat!&quot;, PREFIX + appPathIdentifier, e);</span><br><span class="line">          return false;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外服务端的续约接口在eureka-core:1.6.2.jar的 com.netflix.eureka包下的InstanceResource类下，接口方法为renewLease()，它是REST接口。为了减少类篇幅，省略了大部分代码的展示。其中有个registry.renew()方法，即服务续约，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@PUT</span><br><span class="line">public Response renewLease(...参数省略）&#123;</span><br><span class="line">     ...  代码省略</span><br><span class="line">    boolean isSuccess&#x3D;registry.renew(app.getName(),id, isFromReplicaNode);</span><br><span class="line">       ...  代码省略</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>读者可以跟踪registry.renew的代码一直深入研究。在这里就不再多讲述。另外服务续约有2个参数是可以配置，即Eureka Client发送续约心跳的时间参数和Eureka Server在多长时间内没有收到心跳将实例剔除的时间参数，在默认的情况下这两个参数分别为30秒和90秒，官方给的建议是不要修改，如果有特殊要求还是可以调整的，只需要分别在Eureka Client和Eureka Server修改以下参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka.instance.leaseRenewalIntervalInSeconds</span><br><span class="line">eureka.instance.leaseExpirationDurationInSeconds</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，服务注册列表的获取、服务下线和服务剔除就不在这里进行源码跟踪解读，因为和服务注册和续约类似，有兴趣的朋友可以自己看下源码，深入理解。总的来说，通过读源码，可以发现，整体架构与前面小节的eureka 的高可用架构图完全一致。</p>
<h2 id="Eureka-Client注册一个实例为什么这么慢"><a href="#Eureka-Client注册一个实例为什么这么慢" class="headerlink" title="Eureka Client注册一个实例为什么这么慢"></a>Eureka Client注册一个实例为什么这么慢</h2><ul>
<li>   Eureka Client一启动（不是启动完成），不是立即向Eureka Server注册，它有一个延迟向服务端注册的时间，通过跟踪源码，可以发现默认的延迟时间为40秒，源码在eureka-client-1.6.2.jar的DefaultEurekaClientConfig类下，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public int getInitialInstanceInfoReplicationIntervalSeconds() &#123;</span><br><span class="line">    return configInstance.getIntProperty(</span><br><span class="line">        namespace + INITIAL_REGISTRATION_REPLICATION_DELAY_KEY, 40).get();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>   Eureka Server的响应缓存<br>Eureka Server维护每30秒更新的响应缓存,可通过更改配置eureka.server.responseCacheUpdateIntervalMs来修改。 所以即使实例刚刚注册，它也不会出现在调用/ eureka / apps REST端点的结果中。 </p>
</li>
<li><p> Eureka Server刷新缓存<br>  Eureka客户端保留注册表信息的缓存。 该缓存每30秒更新一次（如前所述）。 因 此，客户端决定刷新其本地缓存并发现其他新注册的实例可能需要30秒。</p>
</li>
<li><p>   LoadBalancer Refresh<br>Ribbon的负载平衡器从本地的Eureka Client获取服务注册列表信息。Ribbon本身还维护本地缓存，以避免为每个请求调用本地客户端。 此缓存每30秒刷新一次（可由ribbon.ServerListRefreshInterval配置）。 所以，可能需要30多秒才能使用新注册的实例。</p>
</li>
</ul>
<p>综上几个因素，一个新注册的实例，特别是启动较快的实例（默认延迟40秒注册），不能马上被Eureka Server发现。另外，刚注册的Eureka Client也不能立即被其他服务调用，因为调用方因为各种缓存没有及时的获取到新的注册列表。</p>
<h2 id="Eureka-的自我保护模式"><a href="#Eureka-的自我保护模式" class="headerlink" title="Eureka 的自我保护模式"></a>Eureka 的自我保护模式</h2><p>当一个新的Eureka Server出现时，它尝试从相邻节点获取所有实例注册表信息。如果从Peer节点获取信息时出现问题，Eureka Serve会尝试其他的Peer节点。如果服务器能够成功获取所有实例，则根据该信息设置应该接收的更新阈值。如果有任何时间，Eureka Serve接收到的续约低于为该值配置的百分比（默认为15分钟内低于85％），则服务器开启自我保护模式，即不再剔除注册列表的信息。</p>
<p>这样做的好处就是，如果是Eureka Server自身的网络问题，导致Eureka Client的续约不上，Eureka Client的注册列表信息不再被删除，也就是Eureka Client还可以被其他服务消费。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://cloud.spring.io/spring-cloud-static/Dalston.RELEASE/#netflix-eureka-client-starter">http://cloud.spring.io/spring-cloud-static/Dalston.RELEASE/#netflix-eureka-client-starter</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki">https://github.com/Netflix/eureka/wiki</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication">https://github.com/Netflix/eureka/wiki/Understanding-Eureka-Peer-to-Peer-Communication</a></p>
<p><a target="_blank" rel="noopener" href="http://xujin.org/sc/sc-eureka-register/">http://xujin.org/sc/sc-eureka-register/</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.abhijitsarkar.org/technical/netflix-eureka/">http://blog.abhijitsarkar.org/technical/netflix-eureka/</a></p>
<p><a target="_blank" rel="noopener" href="http://nobodyiam.com/2016/06/25/dive-into-eureka/">http://nobodyiam.com/2016/06/25/dive-into-eureka/</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud_Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>Feign源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-springcloud-feign-resources/</url>
    <content><![CDATA[<h2 id="什么是Feign"><a href="#什么是Feign" class="headerlink" title="什么是Feign"></a>什么是Feign</h2><p>Feign是由Retrofit，JAXRS-2.0和WebSocket启发的一个java到http客户端绑定。 Feign的主要目标是将Java Http Clients变得简单。Feign的源码地址：<a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<span id="more"></span>

<h2 id="写一个Feign"><a href="#写一个Feign" class="headerlink" title="写一个Feign"></a>写一个Feign</h2><p>在我之前的博文有写到如何用Feign去消费服务，文章地址：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69808079">http://blog.csdn.net/forezp/article/details/69808079</a>  。</p>
<p>简单的实现一个Feign客户端，首先通过@FeignClient，客户端，其中value为调用其他服务的名称，FeignConfig.class为FeignClient的配置文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@FeignClient(value &#x3D; &quot;service-hi&quot;,configuration &#x3D; FeignConfig.class)</span><br><span class="line">public interface SchedualServiceHi &#123;</span><br><span class="line">    @GetMapping(value &#x3D; &quot;&#x2F;hi&quot;)</span><br><span class="line">    String sayHiFromClientOne(@RequestParam(value &#x3D; &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Retryer feignRetryer() &#123;</span><br><span class="line">        return new Retryer.Default(100, SECONDS.toMillis(1), 5);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>查看FeignClient的源码，其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface FeignClient &#123;</span><br><span class="line"></span><br><span class="line">@AliasFor(&quot;name&quot;)</span><br><span class="line">String value() default &quot;&quot;;</span><br><span class="line">	</span><br><span class="line">@AliasFor(&quot;value&quot;)</span><br><span class="line">String name() default &quot;&quot;;</span><br><span class="line">	</span><br><span class="line">@AliasFor(&quot;value&quot;)</span><br><span class="line">String name() default &quot;&quot;;</span><br><span class="line">String url() default &quot;&quot;;</span><br><span class="line">boolean decode404() default false;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt;[] configuration() default &#123;&#125;;</span><br><span class="line">Class&lt;?&gt; fallback() default void.class;</span><br><span class="line"></span><br><span class="line">Class&lt;?&gt; fallbackFactory() default void.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String path() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">boolean primary() default true;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>feign 用于声明具有该接口的REST客户端的接口的注释应该是创建（例如用于自动连接到另一个组件。 如果功能区可用，那将是<br>用于负载平衡后端请求，并且可以配置负载平衡器<br>使用与伪装客户端相同名称（即值）@RibbonClient 。</p>
<p>其中value()和name()一样，是被调用的 service的名称。<br>url(),直接填写硬编码的url,decode404()即404是否被解码，还是抛异常；configuration()，标明FeignClient的配置类，默认的配置类为FeignClientsConfiguration类，可以覆盖Decoder、Encoder和Contract等信息，进行自定义配置。fallback(),填写熔断器的信息类。</p>
<h2 id="FeignClient的配置"><a href="#FeignClient的配置" class="headerlink" title="FeignClient的配置"></a>FeignClient的配置</h2><p>默认的配置类为FeignClientsConfiguration，这个类在spring-cloud-netflix-core的jar包下，打开这个类，可以发现它是一个配置类，注入了很多的相关配置的bean，包括feignRetryer、FeignLoggerFactory、FormattingConversionService等,其中还包括了Decoder、Encoder、Contract，如果这三个bean在没有注入的情况下，会自动注入默认的配置。</p>
<ul>
<li>Decoder feignDecoder: ResponseEntityDecoder(这是对SpringDecoder的封装)</li>
<li>Encoder feignEncoder: SpringEncoder</li>
<li>Logger feignLogger: Slf4jLogger</li>
<li>Contract feignContract: SpringMvcContract</li>
<li>Feign.Builder feignBuilder: HystrixFeign.Builder</li>
</ul>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignClientsConfiguration &#123;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Decoder feignDecoder() &#123;</span><br><span class="line">		return new ResponseEntityDecoder(new SpringDecoder(this.messageConverters));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Encoder feignEncoder() &#123;</span><br><span class="line">		return new SpringEncoder(this.messageConverters);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Contract feignContract(ConversionService feignConversionService) &#123;</span><br><span class="line">		return new SpringMvcContract(this.parameterProcessors, feignConversionService);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>重写配置：</p>
<p>你可以重写FeignClientsConfiguration中的bean，从而达到自定义配置的目的，比如FeignClientsConfiguration的默认重试次数为Retryer.NEVER_RETRY，即不重试，那么希望做到重写，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">public class FeignConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Retryer feignRetryer() &#123;</span><br><span class="line">        return new Retryer.Default(100, SECONDS.toMillis(1), 5);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在上述代码更改了该FeignClient的重试次数，重试间隔为100ms，最大重试时间为1s,重试次数为5次。</p>
<h2 id="Feign的工作原理"><a href="#Feign的工作原理" class="headerlink" title="Feign的工作原理"></a>Feign的工作原理</h2><p>feign是一个伪客户端，即它不做任何的请求处理。Feign通过处理注解生成request，从而实现简化HTTP API开发的目的，即开发人员可以使用注解的方式定制request api模板，在发送http request请求之前，feign通过处理注解的方式替换掉request模板中的参数，这种实现方式显得更为直接、可理解。</p>
<p>通过包扫描注入FeignClient的bean，该源码在FeignClientsRegistrar类：<br>首先在启动配置上检查是否有@EnableFeignClients注解，如果有该注解，则开启包扫描，扫描被@FeignClient注解接口。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void registerDefaultConfiguration(AnnotationMetadata metadata,</span><br><span class="line">			BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		Map&lt;String, Object&gt; defaultAttrs &#x3D; metadata</span><br><span class="line">				.getAnnotationAttributes(EnableFeignClients.class.getName(), true);</span><br><span class="line"></span><br><span class="line">		if (defaultAttrs !&#x3D; null &amp;&amp; defaultAttrs.containsKey(&quot;defaultConfiguration&quot;)) &#123;</span><br><span class="line">			String name;</span><br><span class="line">			if (metadata.hasEnclosingClass()) &#123;</span><br><span class="line">				name &#x3D; &quot;default.&quot; + metadata.getEnclosingClassName();</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				name &#x3D; &quot;default.&quot; + metadata.getClassName();</span><br><span class="line">			&#125;</span><br><span class="line">			registerClientConfiguration(registry, name,</span><br><span class="line">					defaultAttrs.get(&quot;defaultConfiguration&quot;));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>扫描到FeignClient后，将信息取出，以bean的形式注入到ioc容器中，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void registerFeignClients(AnnotationMetadata metadata,</span><br><span class="line">			BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		ClassPathScanningCandidateComponentProvider scanner &#x3D; getScanner();</span><br><span class="line">		scanner.setResourceLoader(this.resourceLoader);</span><br><span class="line"></span><br><span class="line">		Set&lt;String&gt; basePackages;</span><br><span class="line"></span><br><span class="line">		Map&lt;String, Object&gt; attrs &#x3D; metadata</span><br><span class="line">				.getAnnotationAttributes(EnableFeignClients.class.getName());</span><br><span class="line">		AnnotationTypeFilter annotationTypeFilter &#x3D; new AnnotationTypeFilter(</span><br><span class="line">				FeignClient.class);</span><br><span class="line">		final Class&lt;?&gt;[] clients &#x3D; attrs &#x3D;&#x3D; null ? null</span><br><span class="line">				: (Class&lt;?&gt;[]) attrs.get(&quot;clients&quot;);</span><br><span class="line">		if (clients &#x3D;&#x3D; null || clients.length &#x3D;&#x3D; 0) &#123;</span><br><span class="line">			scanner.addIncludeFilter(annotationTypeFilter);</span><br><span class="line">			basePackages &#x3D; getBasePackages(metadata);</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			final Set&lt;String&gt; clientClasses &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">			basePackages &#x3D; new HashSet&lt;&gt;();</span><br><span class="line">			for (Class&lt;?&gt; clazz : clients) &#123;</span><br><span class="line">				basePackages.add(ClassUtils.getPackageName(clazz));</span><br><span class="line">				clientClasses.add(clazz.getCanonicalName());</span><br><span class="line">			&#125;</span><br><span class="line">			AbstractClassTestingTypeFilter filter &#x3D; new AbstractClassTestingTypeFilter() &#123;</span><br><span class="line">				@Override</span><br><span class="line">				protected boolean match(ClassMetadata metadata) &#123;</span><br><span class="line">					String cleaned &#x3D; metadata.getClassName().replaceAll(&quot;\\$&quot;, &quot;.&quot;);</span><br><span class="line">					return clientClasses.contains(cleaned);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;;</span><br><span class="line">			scanner.addIncludeFilter(</span><br><span class="line">					new AllTypeFilter(Arrays.asList(filter, annotationTypeFilter)));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		for (String basePackage : basePackages) &#123;</span><br><span class="line">			Set&lt;BeanDefinition&gt; candidateComponents &#x3D; scanner</span><br><span class="line">					.findCandidateComponents(basePackage);</span><br><span class="line">			for (BeanDefinition candidateComponent : candidateComponents) &#123;</span><br><span class="line">				if (candidateComponent instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">					&#x2F;&#x2F; verify annotated class is an interface</span><br><span class="line">					AnnotatedBeanDefinition beanDefinition &#x3D; (AnnotatedBeanDefinition) candidateComponent;</span><br><span class="line">					AnnotationMetadata annotationMetadata &#x3D; beanDefinition.getMetadata();</span><br><span class="line">					Assert.isTrue(annotationMetadata.isInterface(),</span><br><span class="line">							&quot;@FeignClient can only be specified on an interface&quot;);</span><br><span class="line"></span><br><span class="line">					Map&lt;String, Object&gt; attributes &#x3D; annotationMetadata</span><br><span class="line">							.getAnnotationAttributes(</span><br><span class="line">									FeignClient.class.getCanonicalName());</span><br><span class="line"></span><br><span class="line">					String name &#x3D; getClientName(attributes);</span><br><span class="line">					registerClientConfiguration(registry, name,</span><br><span class="line">							attributes.get(&quot;configuration&quot;));</span><br><span class="line"></span><br><span class="line">					registerFeignClient(registry, annotationMetadata, attributes);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void registerFeignClient(BeanDefinitionRegistry registry,</span><br><span class="line">			AnnotationMetadata annotationMetadata, Map&lt;String, Object&gt; attributes) &#123;</span><br><span class="line">		String className &#x3D; annotationMetadata.getClassName();</span><br><span class="line">		BeanDefinitionBuilder definition &#x3D; BeanDefinitionBuilder</span><br><span class="line">				.genericBeanDefinition(FeignClientFactoryBean.class);</span><br><span class="line">		validate(attributes);</span><br><span class="line">		definition.addPropertyValue(&quot;url&quot;, getUrl(attributes));</span><br><span class="line">		definition.addPropertyValue(&quot;path&quot;, getPath(attributes));</span><br><span class="line">		String name &#x3D; getName(attributes);</span><br><span class="line">		definition.addPropertyValue(&quot;name&quot;, name);</span><br><span class="line">		definition.addPropertyValue(&quot;type&quot;, className);</span><br><span class="line">		definition.addPropertyValue(&quot;decode404&quot;, attributes.get(&quot;decode404&quot;));</span><br><span class="line">		definition.addPropertyValue(&quot;fallback&quot;, attributes.get(&quot;fallback&quot;));</span><br><span class="line">		definition.addPropertyValue(&quot;fallbackFactory&quot;, attributes.get(&quot;fallbackFactory&quot;));</span><br><span class="line">		definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);</span><br><span class="line"></span><br><span class="line">		String alias &#x3D; name + &quot;FeignClient&quot;;</span><br><span class="line">		AbstractBeanDefinition beanDefinition &#x3D; definition.getBeanDefinition();</span><br><span class="line"></span><br><span class="line">		boolean primary &#x3D; (Boolean)attributes.get(&quot;primary&quot;); &#x2F;&#x2F; has a default, won&#39;t be null</span><br><span class="line"></span><br><span class="line">		beanDefinition.setPrimary(primary);</span><br><span class="line"></span><br><span class="line">		String qualifier &#x3D; getQualifier(attributes);</span><br><span class="line">		if (StringUtils.hasText(qualifier)) &#123;</span><br><span class="line">			alias &#x3D; qualifier;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		BeanDefinitionHolder holder &#x3D; new BeanDefinitionHolder(beanDefinition, className,</span><br><span class="line">				new String[] &#123; alias &#125;);</span><br><span class="line">		BeanDefinitionReaderUtils.registerBeanDefinition(holder, registry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注入bean之后，通过jdk的代理，当请求Feign Client的方法时会被拦截，代码在ReflectiveFeign类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T newInstance(Target&lt;T&gt; target) &#123;</span><br><span class="line">   Map&lt;String, MethodHandler&gt; nameToHandler &#x3D; targetToHandlersByName.apply(target);</span><br><span class="line">   Map&lt;Method, MethodHandler&gt; methodToHandler &#x3D; new LinkedHashMap&lt;Method, MethodHandler&gt;();</span><br><span class="line">   List&lt;DefaultMethodHandler&gt; defaultMethodHandlers &#x3D; new LinkedList&lt;DefaultMethodHandler&gt;();</span><br><span class="line"></span><br><span class="line">   for (Method method : target.type().getMethods()) &#123;</span><br><span class="line">     if (method.getDeclaringClass() &#x3D;&#x3D; Object.class) &#123;</span><br><span class="line">       continue;</span><br><span class="line">     &#125; else if(Util.isDefault(method)) &#123;</span><br><span class="line">       DefaultMethodHandler handler &#x3D; new DefaultMethodHandler(method);</span><br><span class="line">       defaultMethodHandlers.add(handler);</span><br><span class="line">       methodToHandler.put(method, handler);</span><br><span class="line">     &#125; else &#123;</span><br><span class="line">       methodToHandler.put(method, nameToHandler.get(Feign.configKey(target.type(), method)));</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   InvocationHandler handler &#x3D; factory.create(target, methodToHandler);</span><br><span class="line">   T proxy &#x3D; (T) Proxy.newProxyInstance(target.type().getClassLoader(), new Class&lt;?&gt;[]&#123;target.type()&#125;, handler);</span><br><span class="line"></span><br><span class="line">   for(DefaultMethodHandler defaultMethodHandler : defaultMethodHandlers) &#123;</span><br><span class="line">     defaultMethodHandler.bindTo(proxy);</span><br><span class="line">   &#125;</span><br><span class="line">   return proxy;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在SynchronousMethodHandler类进行拦截处理，当被拦截会根据参数生成RequestTemplate对象，该对象就是http请求的模板，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line"> public Object invoke(Object[] argv) throws Throwable &#123;</span><br><span class="line">   RequestTemplate template &#x3D; buildTemplateFromArgs.create(argv);</span><br><span class="line">   Retryer retryer &#x3D; this.retryer.clone();</span><br><span class="line">   while (true) &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">       return executeAndDecode(template);</span><br><span class="line">     &#125; catch (RetryableException e) &#123;</span><br><span class="line">       retryer.continueOrPropagate(e);</span><br><span class="line">       if (logLevel !&#x3D; Logger.Level.NONE) &#123;</span><br><span class="line">         logger.logRetry(metadata.configKey(), logLevel);</span><br><span class="line">       &#125;</span><br><span class="line">       continue;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中有个executeAndDecode()方法，该方法是通RequestTemplate生成Request请求对象，然后根据用client获取response。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Object executeAndDecode(RequestTemplate template) throws Throwable &#123;</span><br><span class="line">    Request request &#x3D; targetRequest(template);</span><br><span class="line">    ...&#x2F;&#x2F;省略代码</span><br><span class="line">    response &#x3D; client.execute(request, options);</span><br><span class="line">    ...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Client组件"><a href="#Client组件" class="headerlink" title="Client组件"></a>Client组件</h2><p>其中Client组件是一个非常重要的组件，Feign最终发送request请求以及接收response响应，都是由Client组件完成的，其中Client的实现类，只要有Client.Default，该类由HttpURLConnnection实现网络请求，另外还支持HttpClient、Okhttp.</p>
<p>首先来看以下在FeignRibbonClient的自动配置类，FeignRibbonClientAutoConfiguration ，主要在工程启动的时候注入一些bean,其代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConditionalOnClass(&#123; ILoadBalancer.class, Feign.class &#125;)</span><br><span class="line">@Configuration</span><br><span class="line">@AutoConfigureBefore(FeignAutoConfiguration.class)</span><br><span class="line">public class FeignRibbonClientAutoConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">	@ConditionalOnMissingBean</span><br><span class="line">	public Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,</span><br><span class="line">			SpringClientFactory clientFactory) &#123;</span><br><span class="line">		return new LoadBalancerFeignClient(new Client.Default(null, null),</span><br><span class="line">				cachingFactory, clientFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在缺失配置feignClient的情况下，会自动注入new Client.Default(),跟踪Client.Default()源码，它使用的网络请求框架为HttpURLConnection，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public Response execute(Request request, Options options) throws IOException &#123;</span><br><span class="line">    HttpURLConnection connection &#x3D; convertAndSend(request, options);</span><br><span class="line">    return convertResponse(connection).toBuilder().request(request).build();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>怎么在feign中使用HttpClient，查看FeignRibbonClientAutoConfiguration的源码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConditionalOnClass(&#123; ILoadBalancer.class, Feign.class &#125;)</span><br><span class="line">@Configuration</span><br><span class="line">@AutoConfigureBefore(FeignAutoConfiguration.class)</span><br><span class="line">public class FeignRibbonClientAutoConfiguration &#123;</span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">	@ConditionalOnClass(ApacheHttpClient.class)</span><br><span class="line">	@ConditionalOnProperty(value &#x3D; &quot;feign.httpclient.enabled&quot;, matchIfMissing &#x3D; true)</span><br><span class="line">	protected static class HttpClientFeignLoadBalancedConfiguration &#123;</span><br><span class="line"></span><br><span class="line">		@Autowired(required &#x3D; false)</span><br><span class="line">		private HttpClient httpClient;</span><br><span class="line"></span><br><span class="line">		@Bean</span><br><span class="line">		@ConditionalOnMissingBean(Client.class)</span><br><span class="line">		public Client feignClient(CachingSpringLoadBalancerFactory cachingFactory,</span><br><span class="line">				SpringClientFactory clientFactory) &#123;</span><br><span class="line">			ApacheHttpClient delegate;</span><br><span class="line">			if (this.httpClient !&#x3D; null) &#123;</span><br><span class="line">				delegate &#x3D; new ApacheHttpClient(this.httpClient);</span><br><span class="line">			&#125;</span><br><span class="line">			else &#123;</span><br><span class="line">				delegate &#x3D; new ApacheHttpClient();</span><br><span class="line">			&#125;</span><br><span class="line">			return new LoadBalancerFeignClient(delegate, cachingFactory, clientFactory);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">...&#x2F;&#x2F;省略代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从代码@ConditionalOnClass(ApacheHttpClient.class)注解可知道，只需要在pom文件加上HttpClient的classpath就行了，另外需要在配置文件上加上feign.httpclient.enabled为true，从    @ConditionalOnProperty注解可知，这个可以不写，在默认的情况下就为true.</p>
<p>在pom文件加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-httpclient&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同理，如果想要feign使用Okhttp，则只需要在pom文件上加上feign-okhttp的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.netflix.feign&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;feign-okhttp&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="feign的负载均衡是怎么样实现的呢？"><a href="#feign的负载均衡是怎么样实现的呢？" class="headerlink" title="feign的负载均衡是怎么样实现的呢？"></a>feign的负载均衡是怎么样实现的呢？</h2><p>通过上述的FeignRibbonClientAutoConfiguration类配置Client的类型(httpurlconnection，okhttp和httpclient)时候，可知最终向容器注入的是LoadBalancerFeignClient，即负载均衡客户端。现在来看下LoadBalancerFeignClient的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Response execute(Request request, Request.Options options) throws IOException &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		URI asUri &#x3D; URI.create(request.url());</span><br><span class="line">		String clientName &#x3D; asUri.getHost();</span><br><span class="line">		URI uriWithoutHost &#x3D; cleanUrl(request.url(), clientName);</span><br><span class="line">		FeignLoadBalancer.RibbonRequest ribbonRequest &#x3D; new FeignLoadBalancer.RibbonRequest(</span><br><span class="line">				this.delegate, request, uriWithoutHost);</span><br><span class="line"></span><br><span class="line">		IClientConfig requestConfig &#x3D; getClientConfig(options, clientName);</span><br><span class="line">		return lbClient(clientName).executeWithLoadBalancer(ribbonRequest,</span><br><span class="line">				requestConfig).toResponse();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (ClientException e) &#123;</span><br><span class="line">		IOException io &#x3D; findIOException(e);</span><br><span class="line">		if (io !&#x3D; null) &#123;</span><br><span class="line">			throw io;</span><br><span class="line">		&#125;</span><br><span class="line">		throw new RuntimeException(e);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有个executeWithLoadBalancer()方法，即通过负载均衡的方式请求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public T executeWithLoadBalancer(final S request, final IClientConfig requestConfig) throws ClientException &#123;</span><br><span class="line">      RequestSpecificRetryHandler handler &#x3D; getRequestSpecificRetryHandler(request, requestConfig);</span><br><span class="line">      LoadBalancerCommand&lt;T&gt; command &#x3D; LoadBalancerCommand.&lt;T&gt;builder()</span><br><span class="line">              .withLoadBalancerContext(this)</span><br><span class="line">              .withRetryHandler(handler)</span><br><span class="line">              .withLoadBalancerURI(request.getUri())</span><br><span class="line">              .build();</span><br><span class="line"></span><br><span class="line">      try &#123;</span><br><span class="line">          return command.submit(</span><br><span class="line">              new ServerOperation&lt;T&gt;() &#123;</span><br><span class="line">                  @Override</span><br><span class="line">                  public Observable&lt;T&gt; call(Server server) &#123;</span><br><span class="line">                      URI finalUri &#x3D; reconstructURIWithServer(server, request.getUri());</span><br><span class="line">                      S requestForServer &#x3D; (S) request.replaceUri(finalUri);</span><br><span class="line">                      try &#123;</span><br><span class="line">                          return Observable.just(AbstractLoadBalancerAwareClient.this.execute(requestForServer, requestConfig));</span><br><span class="line">                      &#125; </span><br><span class="line">                      catch (Exception e) &#123;</span><br><span class="line">                          return Observable.error(e);</span><br><span class="line">                      &#125;</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;)</span><br><span class="line">              .toBlocking()</span><br><span class="line">              .single();</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          Throwable t &#x3D; e.getCause();</span><br><span class="line">          if (t instanceof ClientException) &#123;</span><br><span class="line">              throw (ClientException) t;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">              throw new ClientException(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">  &#125;	</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中服务在submit()方法上，点击submit进入具体的方法,这个方法是LoadBalancerCommand的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Observable&lt;T&gt; o &#x3D; </span><br><span class="line">           (server &#x3D;&#x3D; null ? selectServer() : Observable.just(server))</span><br><span class="line">           .concatMap(new Func1&lt;Server, Observable&lt;T&gt;&gt;() &#123;</span><br><span class="line">               @Override</span><br><span class="line">               &#x2F;&#x2F; Called for each server being selected</span><br><span class="line">               public Observable&lt;T&gt; call(Server server) &#123;</span><br><span class="line">                   context.setServer(server);</span><br><span class="line">    </span><br><span class="line">   &#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上述代码中有个selectServe()，该方法是选择服务的进行负载均衡的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Observable&lt;Server&gt; selectServer() &#123;</span><br><span class="line">    return Observable.create(new OnSubscribe&lt;Server&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void call(Subscriber&lt;? super Server&gt; next) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Server server &#x3D; loadBalancerContext.getServerFromLoadBalancer(loadBalancerURI, loadBalancerKey);   </span><br><span class="line">                next.onNext(server);</span><br><span class="line">                next.onCompleted();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                next.onError(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最终负载均衡交给loadBalancerContext来处理，即之前讲述的Ribbon，在这里不再重复。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总到来说，Feign的源码实现的过程如下：</p>
<ul>
<li>首先通过@EnableFeignCleints注解开启FeignCleint</li>
<li>根据Feign的规则实现接口，并加@FeignCleint注解</li>
<li>程序启动后，会进行包扫描，扫描所有的@ FeignCleint的注解的类，并将这些信息注入到ioc容器中。</li>
<li>当接口的方法被调用，通过jdk的代理，来生成具体的RequesTemplate</li>
<li>RequesTemplate在生成Request</li>
<li>Request交给Client去处理，其中Client可以是HttpUrlConnection、HttpClient也可以是Okhttp</li>
<li>最后Client被封装到LoadBalanceClient类，这个类结合类Ribbon做到了负载均衡。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/OpenFeign/feign">https://github.com/OpenFeign/feign</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.de-swaef.eu/the-netflix-stack-using-spring-boot-part-3-feign/">https://blog.de-swaef.eu/the-netflix-stack-using-spring-boot-part-3-feign/</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud_Feign</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul源码解析</title>
    <url>/2017/08/11/dive-into-sc-2017-08-11-springcloud-zuul-resources/</url>
    <content><![CDATA[<h2 id="Zuul-架构图"><a href="#Zuul-架构图" class="headerlink" title="Zuul 架构图"></a>Zuul 架构图</h2><p>在zuul中， 整个请求的过程是这样的，首先将请求给zuulservlet处理，zuulservlet中有一个zuulRunner对象，该对象中初始化了RequestContext：作为存储整个请求的一些数据，并被所有的zuulfilter共享。zuulRunner中还有 FilterProcessor，FilterProcessor作为执行所有的zuulfilter的管理器。FilterProcessor从filterloader 中获取zuulfilter，而zuulfilter是被filterFileManager所加载，并支持groovy热加载，采用了轮询的方式热加载。</p>
<span id="more"></span>


<p>有了这些filter之后，zuulservelet首先执行的Pre类型的过滤器，再执行route类型的过滤器，最后执行的是post 类型的过滤器，如果在执行这些过滤器有错误的时候则会执行error类型的过滤器。执行完这些过滤器，最终将请求的结果返回给客户端。</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/2279594-2e6134e4743b0483.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zuul.png"></p>
<h2 id="zuul工作原理源码分析"><a href="#zuul工作原理源码分析" class="headerlink" title="zuul工作原理源码分析"></a>zuul工作原理源码分析</h2><p>在之前已经讲过，如何使用zuul，其中不可缺少的一个步骤就是在程序的启动类加上＠EnableZuulProxy，该EnableZuulProxy类代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableCircuitBreaker</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Import(ZuulProxyConfiguration.class)</span><br><span class="line">public @interface EnableZuulProxy &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 其中，引用了ZuulProxyConfiguration，跟踪ZuulProxyConfiguration，该类注入了DiscoveryClient、RibbonCommandFactoryConfiguration用作负载均衡相关的。注入了一些列的filters，比如PreDecorationFilter、RibbonRoutingFilter、SimpleHostRoutingFilter，代码如如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public PreDecorationFilter preDecorationFilter(RouteLocator routeLocator, ProxyRequestHelper proxyRequestHelper) &#123;</span><br><span class="line">	return new PreDecorationFilter(routeLocator, this.server.getServletPrefix(), this.zuulProperties,</span><br><span class="line">			proxyRequestHelper);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; route filters</span><br><span class="line">@Bean</span><br><span class="line">public RibbonRoutingFilter ribbonRoutingFilter(ProxyRequestHelper helper,</span><br><span class="line">		RibbonCommandFactory&lt;?&gt; ribbonCommandFactory) &#123;</span><br><span class="line">	RibbonRoutingFilter filter &#x3D; new RibbonRoutingFilter(helper, ribbonCommandFactory, this.requestCustomizers);</span><br><span class="line">	return filter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SimpleHostRoutingFilter simpleHostRoutingFilter(ProxyRequestHelper helper, ZuulProperties zuulProperties) &#123;</span><br><span class="line">	return new SimpleHostRoutingFilter(helper, zuulProperties);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 它的父类ZuulConfiguration ，引用了一些相关的配置。在缺失zuulServlet  bean的情况下注入了ZuulServlet，该类是zuul的核心类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	@Bean</span><br><span class="line">@ConditionalOnMissingBean(name &#x3D; &quot;zuulServlet&quot;)</span><br><span class="line">public ServletRegistrationBean zuulServlet() &#123;</span><br><span class="line">	ServletRegistrationBean servlet &#x3D; new ServletRegistrationBean(new ZuulServlet(),</span><br><span class="line">			this.zuulProperties.getServletPattern());</span><br><span class="line">	&#x2F;&#x2F; The whole point of exposing this servlet is to provide a route that doesn&#39;t</span><br><span class="line">	&#x2F;&#x2F; buffer requests.</span><br><span class="line">	servlet.addInitParameter(&quot;buffer-requests&quot;, &quot;false&quot;);</span><br><span class="line">	return servlet;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>同时也注入了其他的过滤器，比如ServletDetectionFilter、DebugFilter、Servlet30WrapperFilter，这些过滤器都是pre类型的。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ServletDetectionFilter servletDetectionFilter() &#123;</span><br><span class="line">	return new ServletDetectionFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public FormBodyWrapperFilter formBodyWrapperFilter() &#123;</span><br><span class="line">	return new FormBodyWrapperFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public DebugFilter debugFilter() &#123;</span><br><span class="line">	return new DebugFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public Servlet30WrapperFilter servlet30WrapperFilter() &#123;</span><br><span class="line">	return new Servlet30WrapperFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 它也注入了post类型的，比如 SendResponseFilter，error类型，比如 SendErrorFilter，route类型比如SendForwardFilter，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SendResponseFilter sendResponseFilter() &#123;</span><br><span class="line">	return new SendResponseFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SendErrorFilter sendErrorFilter() &#123;</span><br><span class="line">	return new SendErrorFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">public SendForwardFilter sendForwardFilter() &#123;</span><br><span class="line">	return new SendForwardFilter();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>初始化ZuulFilterInitializer类，将所有的filter 向FilterRegistry注册。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	@Configuration</span><br><span class="line">protected static class ZuulFilterConfiguration &#123;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private Map&lt;String, ZuulFilter&gt; filters;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public ZuulFilterInitializer zuulFilterInitializer(</span><br><span class="line">			CounterFactory counterFactory, TracerFactory tracerFactory) &#123;</span><br><span class="line">		FilterLoader filterLoader &#x3D; FilterLoader.getInstance();</span><br><span class="line">		FilterRegistry filterRegistry &#x3D; FilterRegistry.instance();</span><br><span class="line">		return new ZuulFilterInitializer(this.filters, counterFactory, tracerFactory, filterLoader, filterRegistry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 而FilterRegistry管理了一个ConcurrentHashMap，用作存储过滤器的，并有一些基本的CURD过滤器的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public class FilterRegistry &#123;</span><br><span class="line"></span><br><span class="line">    private static final FilterRegistry INSTANCE &#x3D; new FilterRegistry();</span><br><span class="line"></span><br><span class="line">    public static final FilterRegistry instance() &#123;</span><br><span class="line">        return INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final ConcurrentHashMap&lt;String, ZuulFilter&gt; filters &#x3D; new ConcurrentHashMap&lt;String, ZuulFilter&gt;();</span><br><span class="line"></span><br><span class="line">    private FilterRegistry() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ZuulFilter remove(String key) &#123;</span><br><span class="line">        return this.filters.remove(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public ZuulFilter get(String key) &#123;</span><br><span class="line">        return this.filters.get(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void put(String key, ZuulFilter filter) &#123;</span><br><span class="line">        this.filters.putIfAbsent(key, filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int size() &#123;</span><br><span class="line">        return this.filters.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Collection&lt;ZuulFilter&gt; getAllFilters() &#123;</span><br><span class="line">        return this.filters.values();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> FilterLoader类持有FilterRegistry，FilterFileManager类持有FilterLoader，所以最终是由FilterFileManager注入 filterFilterRegistry的ConcurrentHashMap的。FilterFileManager到开启了轮询机制，定时的去加载过滤器，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void startPoller() &#123;</span><br><span class="line">      poller &#x3D; new Thread(&quot;GroovyFilterFileManagerPoller&quot;) &#123;</span><br><span class="line">          public void run() &#123;</span><br><span class="line">              while (bRunning) &#123;</span><br><span class="line">                  try &#123;</span><br><span class="line">                      sleep(pollingIntervalSeconds * 1000);</span><br><span class="line">                      manageFiles();</span><br><span class="line">                  &#125; catch (Exception e) &#123;</span><br><span class="line">                      e.printStackTrace();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;;</span><br><span class="line">      poller.setDaemon(true);</span><br><span class="line">      poller.start();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> Zuulservlet作为类似于Spring MVC中的DispatchServlet,起到了前端控制器的作用，所有的请求都由它接管。它的核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">@Override</span><br><span class="line"> public void service(javax.servlet.ServletRequest servletRequest, javax.servlet.ServletResponse servletResponse) throws ServletException, IOException &#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         init((HttpServletRequest) servletRequest, (HttpServletResponse) servletResponse);</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; Marks this request as having passed through the &quot;Zuul engine&quot;, as opposed to servlets</span><br><span class="line">         &#x2F;&#x2F; explicitly bound in web.xml, for which requests will not have the same data attached</span><br><span class="line">         RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">         context.setZuulEngineRan();</span><br><span class="line"></span><br><span class="line">         try &#123;</span><br><span class="line">             preRoute();</span><br><span class="line">         &#125; catch (ZuulException e) &#123;</span><br><span class="line">             error(e);</span><br><span class="line">             postRoute();</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         try &#123;</span><br><span class="line">             route();</span><br><span class="line">         &#125; catch (ZuulException e) &#123;</span><br><span class="line">             error(e);</span><br><span class="line">             postRoute();</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line">         try &#123;</span><br><span class="line">             postRoute();</span><br><span class="line">         &#125; catch (ZuulException e) &#123;</span><br><span class="line">             error(e);</span><br><span class="line">             return;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">     &#125; catch (Throwable e) &#123;</span><br><span class="line">         error(new ZuulException(e, 500, &quot;UNHANDLED_EXCEPTION_&quot; + e.getClass().getName()));</span><br><span class="line">     &#125; finally &#123;</span><br><span class="line">         RequestContext.getCurrentContext().unset();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure>
<p>跟踪init（），可以发现这个方法为每个请求生成了RequestContext,RequestContext继承了ConcurrentHashMap&lt;String, Object&gt;，在请求结束时销毁掉该RequestContext，RequestContext的生命周期为请求到zuulServlet开始处理，直到请求结束返回结果。<br>RequestContext类在存储了很多重要的信息，包括HttpServletRequest、HttpServletRespons、ResponseDataStream、ResponseStatusCode等。 RequestContext对象在处理请求的过程中，一直存在，所以这个对象为所有Filter共享。</p>
<p>从ZuulServlet的service（）方法可知，它是先处理pre()类型的处理器，然后在处理route()类型的处理器，最后再处理post类型的处理器。</p>
<p>首先来看一看pre()的处理过程，它会进入到ZuulRunner,该类的作用是将请求的HttpServletRequest、HttpServletRespons放在RequestContext类中，并包装了一个FilterProcessor，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  public void init(HttpServletRequest servletRequest, HttpServletResponse servletResponse) &#123;</span><br><span class="line"></span><br><span class="line">        RequestContext ctx &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">        if (bufferRequests) &#123;</span><br><span class="line">            ctx.setRequest(new HttpServletRequestWrapper(servletRequest));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            ctx.setRequest(servletRequest);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ctx.setResponse(new HttpServletResponseWrapper(servletResponse));</span><br><span class="line">      </span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"> public void preRoute() throws ZuulException &#123;</span><br><span class="line">    FilterProcessor.getInstance().preRoute();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>而FilterProcessor类为调用filters的类，比如调用pre类型所有的过滤器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void preRoute() throws ZuulException &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">          runFilters(&quot;pre&quot;);</span><br><span class="line">      &#125; catch (ZuulException e) &#123;</span><br><span class="line">          throw e;</span><br><span class="line">      &#125; catch (Throwable e) &#123;</span><br><span class="line">          throw new ZuulException(e, 500, &quot;UNCAUGHT_EXCEPTION_IN_PRE_FILTER_&quot; + e.getClass().getName());</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>跟踪runFilters（）方法，可以发现，它最终调用了FilterLoader的getFiltersByType(sType)方法来获取同一类的过滤器，然后用for循环遍历所有的ZuulFilter，执行了 processZuulFilter（）方法，跟踪该方法可以发现最终是执行了ZuulFilter的方法，最终返回了该方法返回的Object对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Object runFilters(String sType) throws Throwable &#123;</span><br><span class="line">       if (RequestContext.getCurrentContext().debugRouting()) &#123;</span><br><span class="line">           Debug.addRoutingDebug(&quot;Invoking &#123;&quot; + sType + &quot;&#125; type filters&quot;);</span><br><span class="line">       &#125;</span><br><span class="line">       boolean bResult &#x3D; false;</span><br><span class="line">       List&lt;ZuulFilter&gt; list &#x3D; FilterLoader.getInstance().getFiltersByType(sType);</span><br><span class="line">       if (list !&#x3D; null) &#123;</span><br><span class="line">           for (int i &#x3D; 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">               ZuulFilter zuulFilter &#x3D; list.get(i);</span><br><span class="line">               Object result &#x3D; processZuulFilter(zuulFilter);</span><br><span class="line">               if (result !&#x3D; null &amp;&amp; result instanceof Boolean) &#123;</span><br><span class="line">                   bResult |&#x3D; ((Boolean) result);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return bResult;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>route、post类型的过滤器的执行过程和pre执行过程类似。</p>
<h2 id="Zuul默认过滤器"><a href="#Zuul默认过滤器" class="headerlink" title="Zuul默认过滤器"></a>Zuul默认过滤器</h2><h4 id="默认的核心过滤器一览表"><a href="#默认的核心过滤器一览表" class="headerlink" title="默认的核心过滤器一览表"></a>默认的核心过滤器一览表</h4><p>Zuul默认注入的过滤器，它们的执行顺序在FilterConstants类，我们可以先定位在这个类，然后再看这个类的过滤器的执行顺序以及相关的注释，可以很轻松定位到相关的过滤器，也可以直接打开<br>spring-cloud-netflix-core.jar的 zuul.filters包，可以看到一些列的filter，现在我以表格的形式，列出默认注入的filter.</p>
<table>
<thead>
<tr>
<th>过滤器</th>
<th align="right">order</th>
<th align="center">描述</th>
<th align="center">类型</th>
</tr>
</thead>
<tbody><tr>
<td>ServletDetectionFilter</td>
<td align="right">-3</td>
<td align="center">检测请求是用 DispatcherServlet还是 ZuulServlet</td>
<td align="center">pre</td>
</tr>
<tr>
<td>Servlet30WrapperFilter</td>
<td align="right">-2</td>
<td align="center">在Servlet 3.0 下，包装 requests</td>
<td align="center">pre</td>
</tr>
<tr>
<td>FormBodyWrapperFilter</td>
<td align="right">-1</td>
<td align="center">解析表单数据</td>
<td align="center">pre</td>
</tr>
<tr>
<td>SendErrorFilter</td>
<td align="right">0</td>
<td align="center">如果中途出现错误</td>
<td align="center">error</td>
</tr>
<tr>
<td>DebugFilter</td>
<td align="right">1</td>
<td align="center">设置请求过程是否开启debug</td>
<td align="center">pre</td>
</tr>
<tr>
<td>PreDecorationFilter</td>
<td align="right">5</td>
<td align="center">根据uri决定调用哪一个route过滤器</td>
<td align="center">pre</td>
</tr>
<tr>
<td>RibbonRoutingFilter</td>
<td align="right">10</td>
<td align="center">如果写配置的时候用ServiceId则用这个route过滤器，该过滤器可以用Ribbon 做负载均衡，用hystrix做熔断</td>
<td align="center">route</td>
</tr>
<tr>
<td>SimpleHostRoutingFilter</td>
<td align="right">100</td>
<td align="center">如果写配置的时候用url则用这个route过滤</td>
<td align="center">route</td>
</tr>
<tr>
<td>SendForwardFilter</td>
<td align="right">500</td>
<td align="center">用RequestDispatcher请求转发</td>
<td align="center">route</td>
</tr>
<tr>
<td>SendResponseFilter</td>
<td align="right">1000</td>
<td align="center">用RequestDispatcher请求转发</td>
<td align="center">post</td>
</tr>
</tbody></table>
<p>过滤器的order值越小，就越先执行，并且在执行过滤器的过程中，它们共享了一个RequestContext对象，该对象的生命周期贯穿于请求，可以看出优先执行了pre类型的过滤器，并将执行后的结果放在RequestContext中，供后续的filter使用，比如在执行PreDecorationFilter的时候，决定使用哪一个route，它的结果的是放在RequestContext对象中，后续会执行所有的route的过滤器，如果不满足条件就不执行该过滤器的run方法。最终达到了就执行一个route过滤器的run()方法。</p>
<p>而error类型的过滤器，是在程序发生异常的时候执行的。</p>
<p>post类型的过滤，在默认的情况下，只注入了SendResponseFilter，该类型的过滤器是将最终的请求结果以流的形式输出给客户单。</p>
<h4 id="现在来看SimpleHostRoutingFilter是如何工作"><a href="#现在来看SimpleHostRoutingFilter是如何工作" class="headerlink" title="现在来看SimpleHostRoutingFilter是如何工作?"></a>现在来看SimpleHostRoutingFilter是如何工作?</h4><p>进入到SimpleHostRoutingFilter类的方法的run()方法，核心代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Object run() &#123;</span><br><span class="line">	RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">    &#x2F;&#x2F;省略代码</span><br><span class="line"></span><br><span class="line">	String uri &#x3D; this.helper.buildZuulRequestURI(request);</span><br><span class="line">	this.helper.addIgnoredHeaders();</span><br><span class="line"></span><br><span class="line">	try &#123;</span><br><span class="line">		CloseableHttpResponse response &#x3D; forward(this.httpClient, verb, uri, request,</span><br><span class="line">				headers, params, requestEntity);</span><br><span class="line">		setResponse(response);</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;</span><br><span class="line">		throw new ZuulRuntimeException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>查阅这个类的全部代码可知，该类创建了一个HttpClient作为请求类，并重构了url,请求到了具体的服务，得到的一个CloseableHttpResponse对象，并将CloseableHttpResponse对象的保存到RequestContext对象中。并调用了ProxyRequestHelper的setResponse方法，将请求状态码，流等信息保存在RequestContext对象中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void setResponse(HttpResponse response) throws IOException &#123;</span><br><span class="line">		RequestContext.getCurrentContext().set(&quot;zuulResponse&quot;, response);</span><br><span class="line">		this.helper.setResponse(response.getStatusLine().getStatusCode(),</span><br><span class="line">				response.getEntity() &#x3D;&#x3D; null ? null : response.getEntity().getContent(),</span><br><span class="line">				revertHeaders(response.getAllHeaders()));</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="现在来看SendResponseFilter是如何工作"><a href="#现在来看SendResponseFilter是如何工作" class="headerlink" title="现在来看SendResponseFilter是如何工作?"></a>现在来看SendResponseFilter是如何工作?</h4><p>这个过滤器的order为1000,在默认且正常的情况下，是最后一个执行的过滤器，该过滤器是最终将得到的数据返回给客户端的请求。</p>
<p>在它的run()方法里，有两个方法：addResponseHeaders()和writeResponse()，即添加响应头和写入响应数据流。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public Object run() &#123;</span><br><span class="line">	try &#123;</span><br><span class="line">		addResponseHeaders();</span><br><span class="line">		writeResponse();</span><br><span class="line">	&#125;</span><br><span class="line">	catch (Exception ex) &#123;</span><br><span class="line">		ReflectionUtils.rethrowRuntimeException(ex);</span><br><span class="line">	&#125;</span><br><span class="line">	return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中writeResponse（）方法是通过从RequestContext中获取ResponseBody获或者ResponseDataStream来写入到HttpServletResponse中的，但是在默认的情况下ResponseBody为null，而ResponseDataStream在route类型过滤器中已经设置进去了。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void writeResponse() throws Exception &#123;</span><br><span class="line">		RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">	</span><br><span class="line">		HttpServletResponse servletResponse &#x3D; context.getResponse();</span><br><span class="line">			&#x2F;&#x2F;代码省略</span><br><span class="line">		OutputStream outStream &#x3D; servletResponse.getOutputStream();</span><br><span class="line">		InputStream is &#x3D; null;</span><br><span class="line">		try &#123;</span><br><span class="line">			if (RequestContext.getCurrentContext().getResponseBody() !&#x3D; null) &#123;</span><br><span class="line">				String body &#x3D; RequestContext.getCurrentContext().getResponseBody();</span><br><span class="line">				writeResponse(</span><br><span class="line">						new ByteArrayInputStream(</span><br><span class="line">								body.getBytes(servletResponse.getCharacterEncoding())),</span><br><span class="line">						outStream);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			&#x2F;&#x2F;代码省略</span><br><span class="line">			is &#x3D; context.getResponseDataStream();</span><br><span class="line">			InputStream inputStream &#x3D; is;</span><br><span class="line">				&#x2F;&#x2F;代码省略</span><br><span class="line">		</span><br><span class="line">			writeResponse(inputStream, outStream);</span><br><span class="line">				&#x2F;&#x2F;代码省略</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	    ..&#x2F;&#x2F;代码省略</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="如何在zuul上做日志处理"><a href="#如何在zuul上做日志处理" class="headerlink" title="如何在zuul上做日志处理"></a>如何在zuul上做日志处理</h2><p>由于zuul作为api网关，所有的请求都经过这里，所以在网关上，可以做请求相关的日志处理。<br>我的需求是这样的，需要记录请求的 url,ip地址，参数，请求发生的时间，整个请求的耗时，请求的响应状态，甚至请求响应的结果等。<br>很显然，需要实现这样的一个功能，需要写一个ZuulFliter，它应该是在请求发送给客户端之前做处理，并且在route过滤器路由之后，在默认的情况下，这个过滤器的order应该为500-1000之间。那么如何获取这些我需要的日志信息呢？找RequestContext,在请求的生命周期里这个对象里，存储了整个请求的所有信息。</p>
<p>现在编码，在代码的注释中，做了详细的说明，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class LoggerFilter extends ZuulFilter &#123;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return FilterConstants.POST_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return FilterConstants.SEND_RESPONSE_FILTER_ORDER - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() &#123;</span><br><span class="line">        RequestContext context &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request &#x3D; context.getRequest();</span><br><span class="line">        String method &#x3D; request.getMethod();&#x2F;&#x2F;氢气的类型，post get ..</span><br><span class="line">        Map&lt;String, String&gt; params &#x3D; HttpUtils.getParams(request);</span><br><span class="line">        String paramsStr &#x3D; params.toString();&#x2F;&#x2F;请求的参数</span><br><span class="line">        long statrtTime &#x3D; (long) context.get(&quot;startTime&quot;);&#x2F;&#x2F;请求的开始时间</span><br><span class="line">        Throwable throwable &#x3D; context.getThrowable();&#x2F;&#x2F;请求的异常，如果有的话</span><br><span class="line">        request.getRequestURI()；&#x2F;&#x2F;请求的uri</span><br><span class="line">        HttpUtils.getIpAddress(request);&#x2F;&#x2F;请求的iP地址</span><br><span class="line">        context.getResponseStatusCode();&#x2F;&#x2F;请求的状态</span><br><span class="line">        long duration&#x3D;System.currentTimeMillis() - statrtTime);&#x2F;&#x2F;请求耗时</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>现在读者也许有疑问，如何得到的statrtTime，即请求开始的时间，其实这需要另外一个过滤器，在网络请求route之前(大部分耗时都在route这一步)，在过滤器中，在RequestContext存储一个时间即可，另写一个过滤器，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AccessFilter extends ZuulFilter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return &quot;pre&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() &#123;</span><br><span class="line">        RequestContext ctx &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">        ctx.set(&quot;startTime&quot;,System.currentTimeMillis());</span><br><span class="line">       </span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可能还有这样的需求，我需要将响应结果，也要存储在log中，在之前已经分析了，在route结束后，将从具体服务获取的响应流存储在RequestContext中，在SendResponseFilter过滤器写入在HttpServletResponse中，最终返回给客户端。那么我只需要在SendResponseFilter写入响应流之前把响应流写入到 log日志中即可，那么会引发另外一个问题，因为响应流写入到 log后，RequestContext就没有响应流了，在SendResponseFilter就没有流输入到HttpServletResponse中，导致客户端没有任何的返回数据，那么解决的办法是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">InputStream inputStream &#x3D;RequestContext.getCurrentContext().getResponseDataStream();</span><br><span class="line">InputStream newInputStream&#x3D; copy(inputStream);</span><br><span class="line">transerferTolog(inputStream);</span><br><span class="line">RequestContext.getCurrentContext().setResponseDataStream(newInputStream);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>从RequestContext获取到流之后，首先将流 copy一份，将流转化下字符串，存在日志中，再set到RequestContext中，<br>这样SendResponseFilter就可以将响应返回给客户端。这样的做法有点影响性能，如果不是字符流，可能需要做更多的处理工作。</p>
<h2 id="关注我的公众号"><a href="#关注我的公众号" class="headerlink" title="关注我的公众号"></a>关注我的公众号</h2><p>精彩内容不能错过！</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0805748d92bba033.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" alt="forezp.jpg"></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud_Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>Zuul上传文件，中文文件名乱码解决办法</title>
    <url>/2017/08/11/dive-into-sc-2017-08-14-springcloud-upload-file-problem/</url>
    <content><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>在项目中又一个上传文件的oss服务，直接调用服务的上传文件成功，如果经过网关zuul服务，上传中文名字的文件，文件名会出现乱码，最终导致上传失败，如果上传英文名字的文件，没有任何问题。怀疑网关zuul对中文做编码处理。</p>
 <span id="more"></span>

<h2 id="解决问题的过程"><a href="#解决问题的过程" class="headerlink" title="解决问题的过程"></a>解决问题的过程</h2><p>这个问题出现之后，我个人的解决办法如下：</p>
<ul>
<li><p>第一反应是看文档，文档地址：<a target="_blank" rel="noopener" href="http://cloud.spring.io/spring-cloud-static/Dalston.SR1/#_uploading_files_through_zuul">http://cloud.spring.io/spring-cloud-static/Dalston.SR1/#_uploading_files_through_zuul</a></p>
</li>
<li><p>粗略地看了下文档，以为没有给出解决方案（其实已经给出，只是没有理解好文档）。狂撸源码，依然没有找到解决办法。</p>
</li>
<li><p>Google搜，搜到了这条Issue，<a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-netflix/issues/1385">https://github.com/spring-cloud/spring-cloud-netflix/issues/1385</a></p>
</li>
</ul>
<p>这位大神给出的解决办法，使用zuul servlet去上传文件，而不是默认的spring mvc。使用 zuul servlet之需要在请求uri，前面加上”/zuul”即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-e1eeda790fa3fe15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先列出我的zuul服务的配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port: 5000</span><br><span class="line">zuul:</span><br><span class="line">   routes:</span><br><span class="line">      oss-api:</span><br><span class="line">      path: &#x2F;oss&#x2F;**</span><br><span class="line">      serviceId: oss-service</span><br></pre></td></tr></table></figure>
<p>oss服务上传文件的接口，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;file&quot;)</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line">    @PostMapping(&quot;&#x2F;upload&quot;)  </span><br><span class="line">    public RespDTO handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file) &#123;</span><br><span class="line">        &#x2F;&#x2F;上传代码省略</span><br><span class="line">        return RespDTO.onSuc(upLoadResult);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>那么，经过网关，调用上传文件的url地址如下：</p>
<blockquote>
<p>localhost:5000/oss/file/upload</p>
</blockquote>
<p>这时如果出现中文文件名，上传文件的文件名会出现失败。按照上述大神的办法，直接在这个uri，前面加上”/zuul”，那么请求地址如下：</p>
<blockquote>
<p>localhost:5000/zuul/oss/file/upload</p>
</blockquote>
<p>测试一下，果然通过，上传中文名的文件乱码问题解决。</p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud_Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>API网关的工作原理与实战案例</title>
    <url>/2023/03/09/gateway-API%E7%BD%91%E5%85%B3%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/52741EAB-FA8B-4F0B-995B-7E0073E6BFE4/6E9D2C7C-B75E-4CBF-BCFD-493C7BB284B3_2/22KDf95eaVwEmpeHBkKPvRBS0Enubdr8y5tBMQpxPgcz/Image.png" alt="Image.png"></p>
<h1 id="API网关的工作原理与实战案例"><a href="#API网关的工作原理与实战案例" class="headerlink" title="API网关的工作原理与实战案例"></a>API网关的工作原理与实战案例</h1><p>API网关是一个在微服务架构中起到重要作用的组件。它可以处理所有客户端请求并对它们进行统一的管理和路由。本文将介绍API网关的工作原理，并给出一个基于Spring Cloud Gateway的实战案例。</p>
<span id="more"></span>
<h2 id="API网关的工作原理"><a href="#API网关的工作原理" class="headerlink" title="API网关的工作原理"></a>API网关的工作原理</h2><p>API网关的工作流程如下：</p>
<ol>
<li>客户端向API网关发送HTTP请求。</li>
<li>API网关解析并验证HTTP请求中的属性。</li>
<li>API网关执行白名单或黑名单检查。</li>
<li>API网关与身份提供者进行身份验证和授权。</li>
<li>限流规则应用于请求。如果超过限制，则请求被拒绝。</li>
<li>现在请求已经通过基本检查，API网关通过路径匹配找到相应的服务进行路由。</li>
<li>API网关将请求转换为适当的协议并将其发送到后端微服务。</li>
<li>API网关可以适当地处理错误，并在错误需要更长时间恢复时处理故障（熔断）。它还可以利用ELK（Elastic-Logstash-Kibana）堆栈进行日志记录和监视。我们有时会在API网关中缓存数据。</li>
</ol>
<p>API网关可以在多个方面帮助您的微服务架构，包括：</p>
<ul>
<li>提高安全性：通过身份验证和授权，API网关可以确保只有授权用户可以访问您的微服务。</li>
<li>提高可靠性：通过限流规则和熔断机制，API网关可以防止服务过载，并保持系统的稳定性。</li>
<li>提高性能：通过缓存数据和负载均衡，API网关可以提高系统的性能。</li>
</ul>
<h2 id="基于Spring-Cloud-Gateway的实战案例"><a href="#基于Spring-Cloud-Gateway的实战案例" class="headerlink" title="基于Spring Cloud Gateway的实战案例"></a>基于Spring Cloud Gateway的实战案例</h2><p>Spring Cloud Gateway是Spring Cloud的一部分，它提供了一种轻量级的方式来构建API网关。以下是一个基于Spring Cloud Gateway的实战案例：</p>
<h2 id="Spring-Cloud-Gateway的基本用法"><a href="#Spring-Cloud-Gateway的基本用法" class="headerlink" title="Spring Cloud Gateway的基本用法"></a>Spring Cloud Gateway的基本用法</h2><p>Spring Cloud Gateway的基本用法可以分为以下几个步骤：</p>
<ol>
<li>在pom.xml中添加Spring Cloud Gateway的依赖：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在application.yml或application.properties中添加路由规则：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: route1</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8081</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;api&#x2F;**</span><br><span class="line">        - id: route2</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8082</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;user&#x2F;**</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>启动Spring Boot应用程序，并访问<a target="_blank" rel="noopener" href="http://localhost:8080/api/hello%E6%88%96http://localhost:8080/user/list">http://localhost:8080/api/hello或http://localhost:8080/user/list</a></li>
</ol>
<h2 id="Spring-Cloud-Gateway的高级用法"><a href="#Spring-Cloud-Gateway的高级用法" class="headerlink" title="Spring Cloud Gateway的高级用法"></a>Spring Cloud Gateway的高级用法</h2><p>Spring Cloud Gateway的高级用法可以包括以下几个方面：</p>
<h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>过滤器是Spring Cloud Gateway的核心概念之一，它可以在请求和响应之间执行各种操作，例如身份验证、流控、路由、日志等</p>
<p>接下来，我们将进一步探讨Spring Cloud Gateway的高级用法。具体来说，我们将介绍以下几点：</p>
<ul>
<li>自定义过滤器</li>
<li>动态路由</li>
<li>限流策略</li>
<li>断路器</li>
</ul>
<h3 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h3><p>Spring Cloud Gateway的过滤器是请求和响应的处理器，可以在请求被路由到目标服务之前或之后进行一些操作。过滤器可以用来处理身份验证、路由跟踪、访问日志等任务。</p>
<p>下面是一个自定义请求过滤器的例子，它会在请求头中添加一个自定义的跟踪ID：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AddTraceIdFilter implements GlobalFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private static final String TRACE_ID_HEADER &#x3D; &quot;X-Trace-Id&quot;;</span><br><span class="line">    private static final int ORDER &#x3D; 1;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        String traceId &#x3D; UUID.randomUUID().toString();</span><br><span class="line">        ServerHttpRequest request &#x3D; exchange.getRequest().mutate()</span><br><span class="line">                .header(TRACE_ID_HEADER, traceId)</span><br><span class="line">                .build();</span><br><span class="line">        ServerWebExchange mutatedExchange &#x3D; exchange.mutate()</span><br><span class="line">                .request(request)</span><br><span class="line">                .build();</span><br><span class="line">        return chain.filter(mutatedExchange);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return ORDER;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个过滤器实现了Spring Cloud Gateway的GlobalFilter接口，并重写了其中的filter和getOrder方法。在filter方法中，它生成了一个随机的跟踪ID，并将它添加到请求头中。在getOrder方法中，它指定了过滤器的执行顺序。</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>动态路由是指在运行时根据配置动态地将请求路由到不同的后端服务。Spring Cloud Gateway提供了一些机制来实现动态路由，比如使用Eureka或Consul作为服务发现组件，并结合Spring Cloud Config Server来管理路由规则。</p>
<p>以下是一个简单的动态路由配置的例子，它将根据请求路径将请求路由到不同的后端服务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: service1</span><br><span class="line">          uri: lb:&#x2F;&#x2F;service1</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;service1&#x2F;**</span><br><span class="line">        - id: service2</span><br><span class="line">          uri: lb:&#x2F;&#x2F;service2</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;service2&#x2F;**</span><br></pre></td></tr></table></figure>

<p>这个配置文件中定义了两个路由规则，它们分别将以/service1和/service2开头的请求路由到service1和service2这两个后端服务</p>
<h3 id="限流策略"><a href="#限流策略" class="headerlink" title="限流策略"></a>限流策略</h3><p>限流策略通常基于令牌桶算法或漏桶算法实现。这些算法都是一种流量控制算法，通过控制流量的输入速率来保护后端服务。</p>
<ul>
<li>令牌桶算法：在一定的时间间隔内，按照固定的速率往桶中放入令牌。当请求到来时，如果桶中有足够的令牌，则将请求处理掉，并从桶中扣除相应数量的令牌；否则，请求被拒绝。</li>
<li>漏桶算法：设定一个容量为b的漏桶，每单位时间流出r个请求。当请求到来时，如果桶未满，则将请求放入桶中，并等待r秒钟；否则，请求被拒绝。</li>
</ul>
<p>在Spring Cloud Gateway中，可以通过自定义GatewayFilter实现限流策略。在GatewayFilter中，可以通过RateLimiterRegistry创建限流器，并在过滤器链中进行限流操作。</p>
<ol>
<li>添加依赖</li>
</ol>
<p>在pom.xml中添加spring-cloud-starter-gateway和spring-boot-starter-actuator依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-gateway&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">  &lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">  &lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置限流策略</li>
</ol>
<p>在配置文件中添加限流策略。这里我们以令牌桶算法为例，设置限流速率为10个请求/秒</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      default-filters:</span><br><span class="line">        - name: RequestRateLimiter</span><br><span class="line">          args:</span><br><span class="line">            key-resolver: &quot;#&#123;@userKeyResolver&#125;&quot;</span><br><span class="line">            rate-limiter: &quot;#&#123;@redisRateLimiter&#125;&quot;</span><br><span class="line">      routes:</span><br><span class="line">        - id: test_route</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8080</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;test&#x2F;**</span><br><span class="line">          filters:</span><br><span class="line">            - name: RequestRateLimiter</span><br><span class="line">              args:</span><br><span class="line">                key-resolver: &quot;#&#123;@userKeyResolver&#125;&quot;</span><br><span class="line">                rate-limiter: &quot;#&#123;@redisRateLimiter&#125;&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>实现GatewayFilter</li>
</ol>
<p>创建一个实现GatewayFilter的类，用于创建限流器并进行限流操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class RateLimitFilter implements GatewayFilter, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    private final RateLimiter rateLimiter;</span><br><span class="line"></span><br><span class="line">    public RateLimitFilter(RateLimiter rateLimiter) &#123;</span><br><span class="line">        this.rateLimiter &#x3D; rateLimiter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;</span><br><span class="line">        String ip &#x3D; exchange.getRequest().getRemoteAddress().getAddress().getHostAddress();</span><br><span class="line">        if (rateLimiter.tryAcquire(ip)) &#123;</span><br><span class="line">            return chain.filter(exchange);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);</span><br><span class="line">            return exchange.getResponse().setComplete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int getOrder() &#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，我们首先创建了一个名为RateLimitFilter的类，并实现了GatewayFilter接口。构造函数中传入了一个RateLimiter对象，用于进行限流操作。在filter方法中，我们通过ServerWebExchange对象获取请求的IP地址，并尝试获取令牌进行限流。如果获取到令牌，则将请求传递给下一个过滤器或处理程序，否则返回“too many requests”错误响应。</p>
<p>另外，我们还重写了getOrder方法并返回-1，以确保这个过滤器在所有其他过滤器之前运行。这是因为我们希望在进行任何其他操作之前先进行限流。</p>
<p>现在我们已经创建了一个基于网关的限流策略，并使用RateLimiter对象实现了基于令牌桶的算法进行限流操作。接下来我们需要将该过滤器添加到Spring Cloud Gateway中。</p>
<p>我们可以在配置文件中使用路由ID将过滤器应用于特定的路由。例如，假设我们要将上述限流过滤器应用于名为“foo”的路由，我们可以将以下代码添加到application.yml配置文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    gateway:</span><br><span class="line">      routes:</span><br><span class="line">        - id: foo</span><br><span class="line">          uri: http:&#x2F;&#x2F;localhost:8081</span><br><span class="line">          predicates:</span><br><span class="line">            - Path&#x3D;&#x2F;foo&#x2F;**</span><br><span class="line">          filters:</span><br><span class="line">            - name: RateLimiter</span><br><span class="line">              args:</span><br><span class="line">                redis-rate-limiter.replenishRate: 10</span><br><span class="line">                redis-rate-limiter.burstCapacity: 20</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用路由ID“foo”来标识我们想要应用这个过滤器的路由。我们还定义了一个名为“RateLimiter”的过滤器，并将其添加到路由的过滤器链中。</p>
<p>在这个示例中，我们使用了Redis限流器来实现限流。我们设置了刷新速率为每秒10个请求，突发容量为20个请求。</p>
<p>当用户请求“/foo”下的任何端点时，我们的限流过滤器会在网关层面上限制请求速率。如果请求速率超过限制，则该请求将被拒绝。</p>
]]></content>
      <categories>
        <category>gateway</category>
      </categories>
      <tags>
        <tag>gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>使用OpenAI的ChatGPT进行智能问答交互的实现</title>
    <url>/2023/03/11/gpt-%E4%BD%BF%E7%94%A8OpenAI%E7%9A%84ChatGPT%E8%BF%9B%E8%A1%8C%E6%99%BA%E8%83%BD%E9%97%AE%E7%AD%94%E4%BA%A4%E4%BA%92%E7%9A%84%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/99C67034-A284-44CC-BA81-7A7B4D3DCA90/43D821FF-FDCD-4E5A-9C9F-BD794E1D6E9A_2/NhN9dKLPx9s5yKJFd9dGhJXkmymvbS4to6YKR3NFu5Az/Image.png" alt="Image.png"></p>
<p>当使用 ChatGPT 进行问答交互时，用户输入的问题需要经过多个组件进行处理，其中包括内容审核、ChatGPT 模型生成回答以及回答的内容审核等。在本文中，我们将详细介绍 ChatGPT 的工作原理，并提供相应的代码示例。</p>
<span id="more"></span>
<h2 id="ChatGPT-的工作原理"><a href="#ChatGPT-的工作原理" class="headerlink" title="ChatGPT 的工作原理"></a>ChatGPT 的工作原理</h2><h3 id="1-模型训练"><a href="#1-模型训练" class="headerlink" title="1. 模型训练"></a>1. 模型训练</h3><p>ChatGPT 是基于 GPT 模型的变种之一，GPT（Generative Pre-trained Transformer）是一种基于 Transformer 的无监督语言模型。ChatGPT 是在 GPT 模型的基础上进行微调得到的，它使用了类似于语言模型的方式来生成回答。</p>
<h3 id="2-问答交互过程"><a href="#2-问答交互过程" class="headerlink" title="2. 问答交互过程"></a>2. 问答交互过程</h3><p>当用户输入问题并提交后，ChatGPT 模型开始进行处理。整个过程主要分为以下几个步骤：</p>
<h4 id="2-1-内容审核"><a href="#2-1-内容审核" class="headerlink" title="2.1 内容审核"></a>2.1 内容审核</h4><p>用户输入的问题首先会经过内容审核组件进行处理。该组件负责检测问题是否包含敏感信息、违规内容等，确保问题的安全性和合法性。如果问题未通过内容审核，则会直接返回固定的提示信息。</p>
<h4 id="2-2-ChatGPT-模型生成回答"><a href="#2-2-ChatGPT-模型生成回答" class="headerlink" title="2.2 ChatGPT 模型生成回答"></a>2.2 ChatGPT 模型生成回答</h4><p>如果问题通过了内容审核，它将被送往 ChatGPT 模型进行处理。ChatGPT 模型使用了前文提到的 GPT 模型，对于输入的问题，模型会生成一个相应的回答。</p>
<h4 id="2-3-回答内容审核"><a href="#2-3-回答内容审核" class="headerlink" title="2.3 回答内容审核"></a>2.3 回答内容审核</h4><p>在生成回答后，回答会再次经过内容审核组件进行处理。该组件主要检测回答是否包含敏感信息、违规内容、不当言论等，确保回答的安全性和合法性。如果回答未通过内容审核，则会直接返回固定的提示信息。</p>
<h4 id="2-4-返回结果"><a href="#2-4-返回结果" class="headerlink" title="2.4 返回结果"></a>2.4 返回结果</h4><p>如果回答通过了内容审核，则会将回答展示给用户；否则，将返回固定的提示信息。整个过程中，ChatGPT 还会对用户的提问行为进行学习，以不断优化生成的回答。</p>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><p>下面是一个简单的 Python 代码示例，它展示了如何使用 ChatGPT 进行问答交互。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import openai</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line"># 定义 OpenAI API 访问密钥</span><br><span class="line">openai.api_key &#x3D; &quot;YOUR_API_KEY&quot;</span><br><span class="line"></span><br><span class="line"># 定义问题和模型 ID</span><br><span class="line">question &#x3D; &quot;Explain how a classification algorithm works&quot;</span><br><span class="line">model_engine &#x3D; &quot;davinci&quot;</span><br><span class="line"></span><br><span class="line"># 进行内容审核</span><br><span class="line">def content_moderation(text):</span><br><span class="line">    # 检测敏感信息</span><br><span class="line">    if re.search(&#39;敏感词&#39;, text, re.IGNORECASE):</span><br><span class="line">        return &quot;Sorry, your question contains sensitive information.&quot;</span><br><span class="line">    # 检测违规内容</span><br><span class="line">    elif re.search(&#39;违规词&#39;, text, re.IGNORECASE):</span><br><span class="line">        return &quot;Sorry, your question contains inappropriate</span><br></pre></td></tr></table></figure>

<p>接下来，我们来演示如何使用ChatGPT进行问答交互。</p>
<p>首先，我们需要使用OpenAI提供的API key来创建一个OpenAI API client。在代码中，我们使用了openai包提供的API类来创建一个API client：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import openai</span><br><span class="line">import os</span><br><span class="line"></span><br><span class="line">openai.api_key &#x3D; os.environ[&quot;OPENAI_API_KEY&quot;]</span><br><span class="line">api &#x3D; openai.api_key</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要指定一个prompt，即用户提出的问题。在本例中，我们将输入“什么是机器学习？”，作为我们的prompt。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">prompt &#x3D; &quot;什么是机器学习？&quot;</span><br></pre></td></tr></table></figure>

<p>然后，我们需要设置一个模型ID来指定使用哪个模型进行推理。在这里，我们使用的是OpenAI官方提供的GPT-3模型（即davinci模型）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">model_engine &#x3D; &quot;davinci&quot;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要调用openai包中的Completion API来对prompt进行推理，并获取AI返回的答案。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response &#x3D; openai.Completion.create(</span><br><span class="line">    engine&#x3D;model_engine,</span><br><span class="line">    prompt&#x3D;prompt,</span><br><span class="line">    max_tokens&#x3D;1024,</span><br><span class="line">    n&#x3D;1,</span><br><span class="line">    stop&#x3D;None,</span><br><span class="line">    temperature&#x3D;0.5,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">answer &#x3D; response.choices[0].text.strip()</span><br></pre></td></tr></table></figure>

<p>在这里，我们设置了max_tokens参数来控制AI生成的答案长度，设置了n参数为1，表示只生成一条答案。我们还设置了temperature参数来控制AI生成答案的创新程度。temperature值越高，生成的答案越随机和创新，但也可能越不准确。在这里，我们将temperature设置为0.5，既能保证答案的准确性，又能保证一定的创新度。</p>
<p>最后，我们将AI生成的答案输出到控制台：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(answer)</span><br></pre></td></tr></table></figure>

<p>这就是使用ChatGPT进行问答交互的基本流程。你可以根据实际需求调整参数，从而得到更加准确的答案。</p>
]]></content>
      <categories>
        <category>ChatGPT</category>
      </categories>
      <tags>
        <tag>ChatGPT</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 博客加载优化</title>
    <url>/2022/12/24/hexo-hexo-y/</url>
    <content><![CDATA[<h1 id="hexo-博客加载优化"><a href="#hexo-博客加载优化" class="headerlink" title="hexo 博客加载优化"></a>hexo 博客加载优化</h1><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近趁着周末折腾自己博客的时候,发现刷页面的时候会有点卡顿,感觉页面性能很低,所以开始了下面的优化,分析下来结果还不错比之前快了很多,那让我们开始吧!</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/1050E4F2-AB1F-423B-8DE0-393C1A892684/3E8FC5EB-EEB0-4C2D-94EC-C948F99002CA_2/D2DBPCbNGLqxlHxMmGlIfcTaOf8xxt6pIZxuqnXNyMwz/Image.png" alt="Image.png"></p>
<p>简单的来说主要以下几个部分的优化:</p>
<ul>
<li><strong>压缩静态资源,提高访问速度</strong></li>
<li><strong>图片懒加载</strong></li>
</ul>
<span id="more"></span>
<h3 id="压缩静态资源"><a href="#压缩静态资源" class="headerlink" title="压缩静态资源"></a>压缩静态资源</h3><p>安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-neat --save</span><br></pre></td></tr></table></figure>

<p>然后我们需要在站点配置文件_config.yml 中添加以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 博文压缩</span><br><span class="line">neat_enable: true</span><br><span class="line"># 压缩html</span><br><span class="line">neat_html:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line"># 压缩css</span><br><span class="line">neat_css:</span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.min.css&#39;</span><br><span class="line"># 压缩js</span><br><span class="line">neat_js:</span><br><span class="line">  enable: true</span><br><span class="line">  mangle: true</span><br><span class="line">  output:</span><br><span class="line">  compress:</span><br><span class="line">  exclude:</span><br><span class="line">    - &#39;**&#x2F;*.min.js&#39;</span><br><span class="line">    - &#39;**&#x2F;jquery.fancybox.pack.js&#39;</span><br><span class="line">    - &#39;**&#x2F;index.js&#39;</span><br><span class="line">    - &#39;**&#x2F;fireworks.js&#39;</span><br></pre></td></tr></table></figure>

<h3 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h3><p>安装插件:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-lazyload-image --save</span><br></pre></td></tr></table></figure>

<p>_config.yml 中添加以下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 图片懒加载</span><br><span class="line">lazyload:</span><br><span class="line">  enable: true</span><br><span class="line">  onlypost: false</span><br><span class="line">  loadingImg: &#x2F;images&#x2F;loading.gif</span><br></pre></td></tr></table></figure>




]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基本概念</title>
    <url>/2020/11/12/internet-2020-11-12-%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>本篇文章简单梳理网络通信的基础概念</p>
<p>在学习Java网络编程之前，我们先来了解什么是计算机网络。</p>
<p>计算机网络是指两台或更多的计算机组成的网络，在同一个网络中，任意两台计算机都可以直接通信，因为所有计算机都需要遵循同一种网络协议。</p>
<p>那什么是互联网呢？互联网是网络的网络（internet），即把很多计算机网络连接起来，形成一个全球统一的互联网。</p>
<p>对某个特定的计算机网络来说，它可能使用网络协议ABC，而另一个计算机网络可能使用网络协议XYZ。如果计算机网络各自的通讯协议不统一，就没法把不同的网络连接起来形成互联网。因此，为了把计算机网络接入互联网，就必须使用<strong>TCP/IP协议</strong>。</p>
<p>TCP/IP协议泛指互联网协议，其中最重要的两个协议是TCP协议和IP协议。只有使用TCP/IP协议的计算机才能够联入互联网，使用其他网络协议（例如NetBIOS、AppleTalk协议等）是无法联入互联网的。</p>
<span id="more"></span>

<h3 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h3><p>在互联网中，一个IP地址用于唯一标识一个网络接口（Network Interface）。一台联入互联网的计算机肯定有一个IP地址，但也可能有多个IP地址。</p>
<p>IP地址分为IPv4和IPv6两种。IPv4采用32位地址，类似101.202.99.12，而IPv6采用128位地址，类似2001:0DA8:100A:0000:0000:1020:F2F3:1428。IPv4地址总共有232个（大约42亿），而IPv6地址则总共有2128个（大约340万亿亿亿亿），IPv4的地址目前已耗尽，而IPv6的地址是根本用不完的。</p>
<p>IP地址又分为公网IP地址和内网IP地址。公网IP地址可以直接被访问，内网IP地址只能在内网访问。内网IP地址类似于：</p>
<ul>
<li>192.168.x.x</li>
<li>10.x.x.x</li>
</ul>
<p>有一个特殊的IP地址，称之为本机地址，它总是<strong>127.0.0.1</strong>。</p>
<p>IPv4地址实际上是一个32位整数。例如：</p>
<p>106717964 = 0x65ca630c<br>          = 65  ca  63 0c<br>          = 101.202.99.12<br>如果一台计算机只有一个网卡，并且接入了网络，那么，它有一个本机地址<strong>127.0.0.1</strong>，还有一个IP地址，例如<strong>101.202.99.12</strong>，可以通过这个IP地址接入网络。</p>
<p>如果一台计算机有两块网卡，那么除了本机地址，它可以有两个IP地址，可以分别接入两个网络。通常连接两个网络的设备是路由器或者交换机，它至少有两个IP地址，分别接入不同的网络，让网络之间连接起来。</p>
<p>如果两台计算机位于同一个网络，那么他们之间可以直接通信，因为他们的IP地址前段是相同的，也就是网络号是相同的。网络号是IP地址通过子网掩码过滤后得到的。例如：</p>
<p>某台计算机的IP是<strong>101.202.99.2</strong>，子网掩码是<strong>255.255.255.0</strong>，那么计算该计算机的网络号是：</p>
<ul>
<li>IP = 101.202.99.2</li>
<li>Mask = 255.255.255.0</li>
<li>Network = IP &amp; Mask = 101.202.99.0</li>
</ul>
<p>每台计算机都需要正确配置IP地址和子网掩码，根据这两个就可以计算网络号，如果两台计算机计算出的网络号相同，说明两台计算机在同一个网络，可以直接通信。如果两台计算机计算出的网络号不同，那么两台计算机不在同一个网络，不能直接通信，它们之间必须通过路由器或者交换机这样的网络设备间接通信，我们把这种设备称为<strong>网关</strong>。</p>
<p>网关的作用就是连接多个网络，负责把来自一个网络的数据包发到另一个网络，这个过程叫<strong>路由</strong>。</p>
<p>所以，一台计算机的一个网卡会有3个关键配置：</p>
<p>network</p>
<ul>
<li>IP地址，例如：10.0.2.15</li>
<li>子网掩码，例如：255.255.255.0</li>
<li>网关的IP地址，例如：10.0.2.2<h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3>因为直接记忆IP地址非常困难，所以我们通常使用域名访问某个特定的服务。域名解析服务器DNS负责把域名翻译成对应的IP，客户端再根据IP地址访问服务器。</li>
</ul>
<p>用nslookup可以查看域名对应的IP地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ nslookup  https:&#x2F;&#x2F;smalltechnologyjun.com</span><br><span class="line">Server:  xxx.xxx.xxx.xxx</span><br><span class="line">Address: xxx.xxx.xxx.xxx#53</span><br></pre></td></tr></table></figure>

<p>有一个特殊的本机域名<strong>localhost</strong>，它对应的IP地址总是本机地址<strong>127.0.0.1</strong>。</p>
<h3 id="网络模型"><a href="#网络模型" class="headerlink" title="网络模型"></a>网络模型</h3><p>由于计算机网络从底层的传输到高层的软件设计十分复杂，要合理地设计计算机网络模型，必须采用<strong>分层模型</strong>，每一层负责处理自己的操作。<strong>OSI（Open System Interconnect）网络模型</strong>是ISO组织定义的一个计算机互联的标准模型，注意它只是一个定义，目的是为了简化网络各层的操作，提供标准接口便于实现和维护。这个模型从上到下依次是：</p>
<ul>
<li>应用层，提供应用程序之间的通信；</li>
<li>表示层：处理数据格式，加解密等等；</li>
<li>会话层：负责建立和维护会话；</li>
<li>传输层：负责提供端到端的可靠传输；</li>
<li>网络层：负责根据目标地址选择路由来传输数据；</li>
<li>链路层和物理层负责把数据进行分片并且真正通过物理网络传输，例如，无线网、光纤等。</li>
</ul>
<h4 id="互联网实际使用的TCP-IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型："><a href="#互联网实际使用的TCP-IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：" class="headerlink" title="互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型："></a>互联网实际使用的TCP/IP模型并不是对应到OSI的7层模型，而是大致对应OSI的5层模型：</h4><pre><code>OSI         TCP/IP 
应用层      应用层 
表示层
会话层
传输层      传输层
网络层      IP层
链路层      网络接口层
物理层
</code></pre>
<h3 id="常用协议"><a href="#常用协议" class="headerlink" title="常用协议"></a>常用协议</h3><p>IP协议是一个分组交换，它不保证可靠传输。而TCP协议是传输控制协议，它是面向连接的协议，支持可靠传输和双向通信。TCP协议是建立在IP协议之上的，简单地说，IP协议只负责发数据包，不保证顺序和正确性，而TCP协议负责控制数据包传输，它在传输数据之前需要先建立连接，建立连接后才能传输数据，传输完后还需要断开连接。TCP协议之所以能保证数据的可靠传输，是通过接收确认、超时重传这些机制实现的。并且，TCP协议允许双向通信，即通信双方可以同时发送和接收数据。</p>
<ul>
<li><p>TCP协议也是应用最广泛的协议，许多高级协议都是建立在TCP协议之上的，例如HTTP、SMTP等。</p>
</li>
<li><p>UDP协议（User Datagram Protocol）是一种数据报文协议，它是无连接协议，不保证可靠传输。因为UDP协议在通信前不需要建立连接，因此它的传输效率比TCP高，而且UDP协议比TCP协议要简单得多。</p>
</li>
</ul>
<p>选择UDP协议时，传输的数据通常是能容忍丢失的，例如，一些语音视频通信的应用会选择UDP协议。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>计算机网络的基本概念主要有：</p>
<ul>
<li>计算机网络：由两台或更多计算机组成的网络；</li>
<li>互联网：连接网络的网络；</li>
<li>IP地址：计算机的网络接口（通常是网卡）在网络中的唯一标识；</li>
<li>网关：负责连接多个网络，并在多个网络之间转发数据的计算机，通常是路由器或交换机；</li>
<li>网络协议：互联网使用TCP/IP协议，它泛指互联网协议簇；</li>
<li>IP协议：一种分组交换传输协议；</li>
<li>TCP协议：一种面向连接，可靠传输的协议；</li>
<li>UDP协议：一种无连接，不可靠传输的协议。</li>
</ul>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络思维导图</title>
    <url>/2020/11/12/internet-2020-11-26-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</url>
    <content><![CDATA[<p>分享计算机网络思维导图，持续更新ing</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/ChengKeJ/ChengKeJ.github.io/master/img/internet.png"></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Nagle和延迟确认带来的性能问题</title>
    <url>/2022/12/23/internet-nagle/</url>
    <content><![CDATA[<h1 id="Nagle和延迟确认带来的性能问题"><a href="#Nagle和延迟确认带来的性能问题" class="headerlink" title="Nagle和延迟确认带来的性能问题"></a>Nagle和延迟确认带来的性能问题</h1><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>从网上看到的一个问题的跟踪@林沛满 ，觉得很有意思记录下来</p>
<h3 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h3><p>从AIX备份数据到Windows极其缓慢，只有1MB/s，备份所用的协议是SFTP，看到这个问题第一反应抓个包，试试Wireshark的三板斧</p>
<h3 id="抓包三板斧"><a href="#抓包三板斧" class="headerlink" title="抓包三板斧"></a>抓包三板斧</h3><ol>
<li>从Statistics →Summary菜单可见，平均速度是11 Mbit/s，的确只比1 MB/s高一些</li>
</ol>
<span id="more"></span>

<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/EF3B1138-D940-4964-B487-C60AC4E5D08F_2/EtZkFgVqobsgX247lVw9nQzEXGuQWP3e8G4Qyyzmwh0z/Image.png" alt="Image.png"></p>
<ol start="2">
<li>从Analyze →Expert Infos菜单看，网络状况堪称完美。连一个Warnings和Notes都没有。这样的网络性能怎么会差？</li>
</ol>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/0A35D2DB-D49E-47D3-9A85-5030507663E0_2/WweckqTyOemsxBQ7nxDxF33Pph8lDpQPhwWfKe48Nb0z/Image.png" alt="Image.png"></p>
<p>3．选定一个从AIX发往Windows的包，然后点击Statistics→TCP StreamGraph→TCP Sequence Graph（Stevens）菜单，从图3可见，这60秒中数据传输得很均匀，没有TCP Zero Window或者死机导致的暂停。</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/AF93E34F-32EF-4367-84A7-FA0CAC47D1E2_2/rMHgascgFBacaJhygVrPR4ut4KYUHQzMUjuxylt600wz/Image.png" alt="Image.png"></p>
<p>试完三板斧，我们只能得到一个结论：备份的确进行得很慢，但是仅凭Wireshark自带的分析工具找不出根本原因，这也许意味着问题不在网络上，而是在接收方或者发送方上。幸好<strong>Wireshark不但能发现网络上的问题，也能反映出接收方和发送方的一些配置，只是需要一些技巧来发现</strong>。</p>
<p>因为数据是从AIX备份到Windows的，所以如果把SFTP（SSH File Transfer Protocol）包过滤出来，理论上应该看到大多数时间花在了从AIX到Windows的传输上。可是由图4发现，从AIX到Windows的包虽然占多数，但没花多少时间。反而从Windows到AIX的两个包（533和535）之间竟然隔了0.2秒。该现象在整个传输过程中出现得很频繁，说不定性能差的原因就在此处了。只要把根本原因找出来，就有希望解决问题。</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/AE3CDB44-D330-47AC-92D3-32D6CA9DD39A_2/gCQjzWaAFAnEdgrLQEO0HcQ3LV9TaNU6EVLKTbPl6Sgz/Image.png" alt="Image.png"></p>
<p>那么这0.2秒之间究竟发生了什么呢？我把过滤条件去掉后得到了图5所示的包。可见Windows发出533号包之后就停下来等，直到0.2秒之后AIX的Ack（534号包）到达了才发出535号。Windows停下来的原因是什么呢？它在这两个包里总共才发了700多字节（96+656）的数据，肯定不会是因为TCP窗口受约束所致。</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/DC666B15-A553-4A1F-BEC2-610F6BE84D33_2/du6xMWrJDCw4SIgAHtWkNhxiVNXUtTJwp8fwCjPG1qkz/Image.png" alt="Image.png"></p>
<p>如果你研究过TCP协议，可能已经想到了愚笨窗口综合症（Silly window syndrome）和纳格（Nagle）算法。在某些情况下，应用层传递给TCP层的数据量很小，比如在SSH客户端以一般速度打字时，几乎是逐个字节传递到TCP层的。传输这么少的数据量却要耗费20字节IP头+20字节TCP头，是非常浪费的，这种情况称为发送方的愚笨窗口综合症，也叫“小包问题”（small packet problem）。为了提高传输效率，纳格提出了一个算法，用程序员喜闻乐见的方式表达就是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if有新数据要发送</span><br><span class="line">  if数据量超过MSS（即一个TCP包所能携带的最大数据量）</span><br><span class="line">    立即发送</span><br><span class="line">  else</span><br><span class="line">    if之前发出去的数据尚未确认</span><br><span class="line">      把新数据缓存起来，凑够MSS或等确认到达再发送</span><br><span class="line">    else</span><br><span class="line">      立即发送</span><br><span class="line">    end if</span><br><span class="line">  end if</span><br><span class="line">end if</span><br></pre></td></tr></table></figure>

<p>所示的状况恰好就是小包问题。Windows发了533号包之后，本应该立即发送535的，但是由于535携带的数据量小于MSS，是个小包，根据Nagle算法只好等到533被确认（即收到534）才能接着发。这一等就是0.2秒，所以性能受到了大幅度影响。那为什么AIX要等那么久才确认呢？因为它启用<strong>延迟确认</strong>了。</p>
<h3 id="原因定位"><a href="#原因定位" class="headerlink" title="原因定位"></a>原因定位</h3><p>Nagle和延迟确认本身都没有问题，但一起用就会影响性能。解决方法很简单，要么在Windows上关闭Nagle算法，要么在AIX上关闭延迟确认。这位客户最终选择了前者，性能立即提升了20倍。如果你足够细心，也许已经意识到图3有问题——既然传输过程中会频繁地停顿0.2秒，为什么图3显示数据传输很均匀呢？这是因为抓包时间太长了，有60秒，所以0.2秒的停顿在图上看不出来。假如只截取其中的一秒钟来分析，再点击Statistics →TCP StreamGraph→TCP Sequence Graph（Stevens）菜单，你就能看到图6的结果，0.2秒的停顿就很明显了</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/0DEEB625-00C3-41BD-B624-683B699924E8/7B35CAAB-7898-4F0A-AACA-8B750ED9BF16_2/IHeN7rWRRA6hwp37slXx3R9gZ1arZodWDbC3Dx5QjYYz/Image.png" alt="Image.png"></p>
<p>文章到尾声，按理说这种情况，世界到处都有同时启用Nagle和延迟确认的设置在通信，那为什么很少有人发现这个问题呢？估计大部分人都以为是带宽不足吧。</p>
<p>当然网上也有类型的分享，感兴趣的可以看看</p>
<p><a target="_blank" rel="noopener" href="https://www.diglog.com/story/1036249.html">https://www.diglog.com/story/1036249.html</a></p>
<p><a target="_blank" rel="noopener" href="http://www.stuartcheshire.org/papers/nagledelayedack/">http://www.stuartcheshire.org/papers/nagledelayedack/</a></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 的那些事儿（下）</title>
    <url>/2022/12/23/internet-tcp-e/</url>
    <content><![CDATA[<h1 id="TCP-的那些事儿（下）"><a href="#TCP-的那些事儿（下）" class="headerlink" title="TCP 的那些事儿（下）"></a>TCP 的那些事儿（下）</h1><p>这篇文章是下篇，所以如果你对TCP不熟悉的话，还请你先看看上篇《<a href="https://smalltechnologyjun.com/2022/12/23/internet-tcp-f/">TCP的那些事儿（上）</a>》 上篇中，我们介绍了TCP的协议头、状态机、数据重传中的东西。但是TCP要解决一个很大的事，那就是要在一个网络根据不同的情况来动态调整自己的发包的速度，小则让自己的连接更稳定，大则让整个网络更稳定。在你阅读下篇之前，你需要做好准备，本篇文章有好些算法和策略，可能会引发你的各种思考，让你的大脑分配很多内存和计算资源，所以，不适合在厕所中阅读。</p>
<h4 id="TCP的RTT算法"><a href="#TCP的RTT算法" class="headerlink" title="TCP的RTT算法"></a>TCP的RTT算法</h4><p>从前面的TCP重传机制我们知道Timeout的设置对于重传非常重要。</p>
<ul>
<li>设长了，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>设短了，会导致可能并没有丢就重发。于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p>而且，这个超时时间在不同的网络的情况下，根本没有办法设置一个死的值。只能动态地设置。 为了动态地设置，TCP引入了RTT——Round Trip Time，也就是一个数据包从发出去到回来的时间。这样发送端就大约知道需要多少的时间，从而可以方便地设置Timeout——RTO（Retransmission TimeOut），以让我们的重传机制更高效。 听起来似乎很简单，好像就是在发送端发包时记下t0，然后接收端再把这个ack回来时再记一个t1，于是RTT = t1 – t0。没那么简单，这只是一个采样，不能代表普遍情况。</p>
<span id="more"></span>

<h4 id="经典算法"><a href="#经典算法" class="headerlink" title="经典算法"></a>经典算法</h4><p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc793">RFC793</a> 中定义的经典算法是这样的：</p>
<p>1）首先，先采样RTT，记下最近好几次的RTT值。</p>
<p>2）然后做平滑计算SRTT（ Smoothed RTT）。公式为：（其中的 α 取值在0.8 到 0.9之间，这个算法英文叫Exponential weighted moving average，中文叫：加权移动平均）</p>
<p><strong>SRTT = ( α * SRTT ) + ((1- α) * RTT)</strong></p>
<p>3）开始计算RTO。公式如下：</p>
<p><strong>RTO = min [ UBOUND,  max [ LBOUND,   (β * SRTT) ]  ]</strong></p>
<p>其中：</p>
<ul>
<li>UBOUND是最大的timeout时间，上限值</li>
<li>LBOUND是最小的timeout时间，下限值</li>
<li>β 值一般在1.3到2.0之间。</li>
</ul>
<h4 id="Karn-Partridge-算法"><a href="#Karn-Partridge-算法" class="headerlink" title="Karn / Partridge 算法"></a>Karn / Partridge 算法</h4><p>但是上面的这个算法在重传的时候会出有一个终极问题——你是用第一次发数据的时间和ack回来的时间做RTT样本值，还是用重传的时间和ACK回来的时间做RTT样本值？</p>
<p>这个问题无论你选那头都是按下葫芦起了瓢。 如下图所示：</p>
<ul>
<li>情况（a）是ack没回来，所以重传。如果你计算第一次发送和ACK的时间，那么，明显算大了。</li>
<li>情况（b）是ack回来慢了，但是导致了重传，但刚重传不一会儿，之前ACK就回来了。如果你是算重传的时间和ACK回来的时间的差，就会算短了。</li>
</ul>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/361E07DB-7AFA-4AED-995A-F491516E97DD_2/2DlxiM9BnxMTpaIljpNxnMYThtQI10efa8OLmELjsXwz/Image.png" alt="Image.png"></p>
<p>所以1987年的时候，搞了一个叫<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Karn's_Algorithm">Karn / Partridge Algorithm</a>，这个算法的最大特点是——<strong>忽略重传，不把重传的RTT做采样</strong>（你看，你不需要去解决不存在的问题）。</p>
<p>但是，这样一来，又会引发一个大BUG——<strong>如果在某一时间，网络闪动，突然变慢了，产生了比较大的延时，这个延时导致要重转所有的包（因为之前的RTO很小），于是，因为重转的不算，所以，RTO就不会被更新，这是一个灾难</strong>。 于是Karn算法用了一个取巧的方式——只要一发生重传，就对现有的RTO值翻倍（这就是所谓的 Exponential backoff），很明显，这种死规矩对于一个需要估计比较准确的RTT也不靠谱。</p>
<h4 id="Jacobson-Karels-算法"><a href="#Jacobson-Karels-算法" class="headerlink" title="Jacobson / Karels 算法"></a>Jacobson / Karels 算法</h4><p>前面两种算法用的都是“加权移动平均”，这种方法最大的毛病就是如果RTT有一个大的波动的话，很难被发现，因为被平滑掉了。所以，1988年，又有人推出来了一个新的算法，这个算法叫Jacobson / Karels Algorithm（参看<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6298">RFC6289</a>）。这个算法引入了最新的RTT的采样和平滑过的SRTT的差距做因子来计算。 公式如下：（其中的DevRTT是Deviation RTT的意思）</p>
<p><strong>SRTT</strong> <strong>= S****RTT</strong> <strong>+ α</strong> (<strong>RTT <strong>– SRTT</strong>)</strong> —— 计算平滑RTT</p>
<p><strong>DevRTT</strong> <strong>= (1-β**</strong>)<em><strong>DevRTT</strong> <strong>+ β</strong></em>(|<strong>RTT-SRTT</strong>|)** ——计算平滑RTT和真实的差距（加权移动平均）</p>
<p>*RTO= µ * SRTT + ∂ <em>DevRTT</em> —— 神一样的公式</p>
<p>（其中：在Linux下，α = 0.125，β = 0.25， μ = 1，∂ = 4 ——这就是算法中的“调得一手好参数”，nobody knows why, it just works…） 最后的这个算法在被用在今天的TCP协议中（Linux的源代码在：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_input.c?v=2.6.32#L609">tcp_rtt_estimator</a>）。</p>
<h4 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h4><p>需要说明一下，如果你不了解TCP的滑动窗口这个事，你等于不了解TCP协议。我们都知道，<strong>TCP必需要解决的可靠传输以及包乱序（reordering）的问题</strong>，所以，TCP必需要知道网络实际的数据处理带宽或是数据处理速度，这样才不会引起网络拥塞，导致丢包。</p>
<p>所以，TCP引入了一些技术和设计来做网络流控，Sliding Window是其中一个技术。 前面我们说过，<strong>TCP头里有一个字段叫Window，又叫Advertised-Window，这个字段是接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。<strong>于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来</strong>。 为了说明滑动窗口，我们需要先看一下TCP缓冲区的一些数据结构：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/7ACFF727-288A-45BF-A9FF-713DB88FD6C5_2/aqQvbtcBrEBDdyyQpca6nNN5gH0nsPcqQkCKwgC6CxIz/Image.png" alt="Image.png"></p>
<p>上图中，我们可以看到：</p>
<ul>
<li>接收端LastByteRead指向了TCP缓冲区中读到的位置，NextByteExpected指向的地方是收到的连续包的最后一个位置，LastByteRcved指向的是收到的包的最后一个位置，我们可以看到中间有些数据还没有到达，所以有数据空白区。</li>
<li>发送端的LastByteAcked指向了被接收端Ack过的位置（表示成功发送确认），LastByteSent表示发出去了，但还没有收到成功确认的Ack，LastByteWritten指向的是上层应用正在写的地方。</li>
</ul>
<p>于是：</p>
<ul>
<li>接收端在给发送端回ACK中会汇报自己的AdvertisedWindow = MaxRcvBuffer – LastByteRcvd – 1;</li>
<li>而发送方会根据这个窗口来控制发送数据的大小，以保证接收方可以处理。</li>
</ul>
<p>下面我们来看一下发送方的滑动窗口示意图：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/AB245E70-1506-4BA0-8F7A-DDB4D06EE4B3_2/iruBPuFwz4ayJ1yeNUlDYV2kyX3uuMeX4swWVWIkI5Iz/Image.png" alt="Image.png"></p>
<p>（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo-6.htm">图片来源</a>）</p>
<p>上图中分成了四个部分，分别是：（其中那个黑模型就是滑动窗口）</p>
<ul>
<li>#1已收到ack确认的数据。</li>
<li>#2发还没收到ack的。</li>
<li>#3在窗口中还没有发出的（接收方还有空间）。</li>
<li>#4窗口以外的数据（接收方没空间）</li>
</ul>
<p>下面是个滑动后的示意图（收到36的ack，并发出了46-51的字节）：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/860DD86C-2EF8-42FC-9403-C3EA0E2ED656_2/HL6M84NMNnTonsGRkEXhg1JcDFXdqWyoL5YPvqltLQoz/Image.png" alt="Image.png"></p>
<p>下面我们来看一个接受端控制发送端的图示：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/3EFE1B7B-95FF-42A6-B628-4C19520E5096_2/qdFxZEf7YtoeIsxFyJ2dSOMbOLISRpuptztFX4COrk8z/Image.png" alt="Image.png"></p>
<p>（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPWindowSizeAdjustmentandFlowControl-2.htm">图片来源</a>）</p>
<h4 id="Zero-Window"><a href="#Zero-Window" class="headerlink" title="Zero Window"></a>Zero Window</h4><p>上图，我们可以看到一个处理缓慢的Server（接收端）是怎么把Client（发送端）的TCP Sliding Window给降成0的。此时，你一定会问，如果Window变成0了，TCP会怎么样？是不是发送端就不发数据了？是的，发送端就不发数据了，你可以想像成“Window Closed”，那你一定还会问，如果发送端不发数据了，接收方一会儿Window size 可用了，怎么通知发送端呢？</p>
<p>解决这个问题，TCP使用了Zero Window Probe技术，缩写为ZWP，也就是说，发送端在窗口变成0后，会发ZWP的包给接收方，让接收方来ack他的Window尺寸，一般这个值会设置成3次，第次大约30-60秒（不同的实现可能会不一样）。如果3次过后还是0的话，有的TCP实现就会发RST把链接断了。</p>
<p><strong>注意</strong>：只要有等待的地方都可能出现DDoS攻击，Zero Window也不例外，一些攻击者会在和HTTP建好链发完GET请求后，就把Window设置为0，然后服务端就只能等待进行ZWP，于是攻击者会并发大量的这样的请求，把服务器端的资源耗尽。（关于这方面的攻击，大家可以移步看一下<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Sockstress">Wikipedia的SockStress词条</a>）</p>
<p>另外，Wireshark中，你可以使用tcp.analysis.zero_window来过滤包，然后使用右键菜单里的follow TCP stream，你可以看到ZeroWindowProbe及ZeroWindowProbeAck的包。</p>
<h4 id="Silly-Window-Syndrome"><a href="#Silly-Window-Syndrome" class="headerlink" title="Silly Window Syndrome"></a>Silly Window Syndrome</h4><p>Silly Window Syndrome翻译成中文就是“糊涂窗口综合症”。正如你上面看到的一样，如果我们的接收方太忙了，来不及取走Receive Windows里的数据，那么，就会导致发送方越来越小。到最后，如果接收方腾出几个字节并告诉发送方现在有几个字节的window，而我们的发送方会义无反顾地发送这几个字节。</p>
<p>要知道，我们的TCP+IP头有40个字节，为了几个字节，要达上这么大的开销，这太不经济了。</p>
<p>另外，你需要知道网络上有个MTU，对于以太网来说，MTU是1500字节，除去TCP+IP头的40个字节，真正的数据传输可以有1460，这就是所谓的MSS（Max Segment Size）注意，TCP的RFC定义这个MSS的默认值是536，这是因为 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc791">RFC 791</a>里说了任何一个IP设备都得最少接收576尺寸的大小（实际上来说576是拨号的网络的MTU，而576减去IP头的20个字节就是536）。</p>
<p><strong>如果你的网络包可以塞满MTU，那么你可以用满整个带宽，如果不能，那么你就会浪费带宽</strong>。（大于MTU的包有两种结局，一种是直接被丢了，另一种是会被重新分块打包发送） 你可以想像成一个MTU就相当于一个飞机的最多可以装的人，如果这飞机里满载的话，带宽最高，如果一个飞机只运一个人的话，无疑成本增加了，也而相当二。</p>
<p>所以，<strong>Silly Windows Syndrome这个现像就像是你本来可以坐200人的飞机里只做了一两个人</strong>。 要解决这个问题也不难，就是避免对小的window size做出响应，直到有足够大的window size再响应，这个思路可以同时实现在sender和receiver两端。</p>
<ul>
<li>如果这个问题是由Receiver端引起的，那么就会使用 David D Clark’s 方案。在receiver端，如果收到的数据导致window size小于某个值，可以直接ack(0)回sender，这样就把window给关闭了，也阻止了sender再发数据过来，等到receiver端处理了一些数据后windows size 大于等于了MSS，或者，receiver buffer有一半为空，就可以把window打开让send 发送数据过来。</li>
<li>如果这个问题是由Sender端引起的，那么就会使用著名的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Nagle%27s_algorithm">Nagle’s algorithm</a>。这个算法的思路也是延时处理，他有两个主要的条件：1）要等到 Window Size&gt;=MSS 或是 Data Size &gt;=MSS，2）收到之前发送数据的ack回包，他才会发数据，否则就是在攒数据。</li>
</ul>
<p>另外，Nagle算法默认是打开的，所以，对于一些需要小包场景的程序——<strong>比如像telnet或ssh这样的交互性比较强的程序，你需要关闭这个算法</strong>。你可以在Socket设置TCP_NODELAY选项来关闭这个算法（关闭Nagle算法没有全局参数，需要根据每个应用自己的特点来关闭）</p>
<p>setsockopt(sock_fd, IPPROTO_TCP, TCP_NODELAY, (char *)&amp;value,sizeof(int));</p>
<p>另外，网上有些文章说TCP_CORK的socket option是也关闭Nagle算法，这不对。<strong>TCP_CORK其实是更新激进的Nagle算汉，完全禁止小包发送，而Nagle算法没有禁止小包发送，只是禁止了大量的小包发送</strong>。最好不要两个选项都设置。</p>
<h4 id="TCP的拥塞处理-–-Congestion-Handling"><a href="#TCP的拥塞处理-–-Congestion-Handling" class="headerlink" title="TCP的拥塞处理 – Congestion Handling"></a>TCP的拥塞处理 – Congestion Handling</h4><p>上面我们知道了，TCP通过Sliding Window来做流控（Flow Control），但是TCP觉得这还不够，因为Sliding Window需要依赖于连接的发送端和接收端，其并不知道网络中间发生了什么。TCP的设计者觉得，一个伟大而牛逼的协议仅仅做到流控并不够，因为流控只是网络模型4层以上的事，TCP的还应该更聪明地知道整个网络上的事。</p>
<p>具体一点，我们知道TCP通过一个timer采样了RTT并计算RTO，但是，<strong>如果网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，于是，这个情况就会进入恶性循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这么行事，那么马上就会形成“网络风暴”，TCP这个协议就会拖垮整个网络。</strong>这是一个灾难。</p>
<p>所以，TCP不能忽略网络上发生的事情，而无脑地一个劲地重发数据，对网络造成更大的伤害。对此TCP的设计理念是：<strong>TCP不是一个自私的协议，当拥塞发生的时候，要做自我牺牲。就像交通阻塞一样，每个车都应该把路让出来，而不要再去抢路了。</strong></p>
<p>关于拥塞控制的论文请参看《<a target="_blank" rel="noopener" href="http://ee.lbl.gov/papers/congavoid.pdf">Congestion Avoidance and Control</a>》(PDF)</p>
<p>拥塞控制主要是四个算法：<strong>1）慢启动</strong>，<strong>2）拥塞避免</strong>，<strong>3）拥塞发生</strong>，<strong>4）快速恢复</strong>。这四个算法不是一天都搞出来的，这个四算法的发展经历了很多时间，到今天都还在优化中。 备注:</p>
<ul>
<li>1988年，TCP-Tahoe 提出了1）慢启动，2）拥塞避免，3）拥塞发生时的快速重传</li>
<li>1990年，TCP Reno 在Tahoe的基础上增加了4）快速恢复</li>
</ul>
<h4 id="慢热启动算法-–-Slow-Start"><a href="#慢热启动算法-–-Slow-Start" class="headerlink" title="慢热启动算法 – Slow Start"></a>慢热启动算法 – Slow Start</h4><p>首先，我们来看一下TCP的慢热启动。慢启动的意思是，刚刚加入网络的连接，一点一点地提速，不要一上来就像那些特权车一样霸道地把路占满。新同学上高速还是要慢一点，不要把已经在高速上的秩序给搞乱了。</p>
<p>慢启动的算法如下(cwnd全称Congestion Window)：</p>
<p>1）连接建好的开始先初始化cwnd = 1，表明可以传一个MSS大小的数据。</p>
<p>2）每当收到一个ACK，cwnd++; 呈线性上升</p>
<p>3）每当过了一个RTT，cwnd = cwnd*2; 呈指数让升</p>
<p>4）还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”（后面会说这个算法）</p>
<p>所以，我们可以看到，如果网速很快的话，ACK也会返回得快，RTT也会短，那么，这个慢启动就一点也不慢。下图说明了这个过程。</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/649B3672-A121-4995-8C47-A93028A1DDFA_2/NEH6powugEU22V2rJlO9Y4TyKclermn0wXJNODn65Poz/Image.png" alt="Image.png"></p>
<p>这里，我需要提一下的是一篇Google的论文《<a target="_blank" rel="noopener" href="https://static.googleusercontent.com/media/research.google.com/zh-CN//pubs/archive/36640.pdf">An Argument for Increasing TCP’s Initial Congestion Window</a>》Linux 3.0后采用了这篇论文的建议——把cwnd 初始化成了 10个MSS。 而Linux 3.0以前，比如2.6，Linux采用了<a target="_blank" rel="noopener" href="https://www.rfc-editor.org/rfc/rfc3390.txt">RFC3390</a>，cwnd是跟MSS的值来变的，如果MSS&lt; 1095，则cwnd = 4；如果MSS&gt;2190，则cwnd=2；其它情况下，则是3。</p>
<h4 id="拥塞避免算法-–-Congestion-Avoidance"><a href="#拥塞避免算法-–-Congestion-Avoidance" class="headerlink" title="拥塞避免算法 – Congestion Avoidance"></a>拥塞避免算法 – Congestion Avoidance</h4><p>前面说过，还有一个ssthresh（slow start threshold），是一个上限，当cwnd &gt;= ssthresh时，就会进入“拥塞避免算法”。一般来说ssthresh的值是65535，单位是字节，当cwnd达到这个值时后，算法如下：</p>
<p>1）收到一个ACK时，cwnd = cwnd + 1/cwnd</p>
<p>2）当每过一个RTT时，cwnd = cwnd + 1</p>
<p>这样就可以避免增长过快导致网络拥塞，慢慢的增加调整到网络的最佳值。很明显，是一个线性上升的算法。</p>
<h4 id="拥塞状态时的算法"><a href="#拥塞状态时的算法" class="headerlink" title="拥塞状态时的算法"></a>拥塞状态时的算法</h4><p>前面我们说过，当丢包的时候，会有两种情况：</p>
<p>1）等到RTO超时，重传数据包。TCP认为这种情况太糟糕，反应也很强烈。</p>
<ul>
<li>sshthresh =  cwnd /2</li>
<li>cwnd 重置为 1</li>
<li>进入慢启动过程</li>
</ul>
<p>2）Fast Retransmit算法，也就是在收到3个duplicate ACK时就开启重传，而不用等到RTO超时。</p>
<ul>
<li>TCP Tahoe的实现和RTO超时一样。</li>
<li>TCP Reno的实现是：<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
<li>进入快速恢复算法——Fast Recovery</li>
</ul>
</li>
</ul>
<p>上面我们可以看到RTO超时后，sshthresh会变成cwnd的一半，这意味着，如果cwnd&lt;=sshthresh时出现的丢包，那么TCP的sshthresh就会减了一半，然后等cwnd又很快地以指数级增涨爬到这个地方时，就会成慢慢的线性增涨。我们可以看到，TCP是怎么通过这种强烈地震荡快速而小心得找到网站流量的平衡点的。</p>
<h4 id="快速恢复算法-–-Fast-Recovery"><a href="#快速恢复算法-–-Fast-Recovery" class="headerlink" title="快速恢复算法 – Fast Recovery"></a>快速恢复算法 – Fast Recovery</h4><p><strong>TCP Reno</strong></p>
<p>这个算法定义在<a href="%5Bhttps://tools.ietf.org/html/rfc5681%5D(https://tools.ietf.org/html/rfc5681">RFC5681</a> “”TCP Congestion Control””)。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕，所以没有必要像RTO超时那么强烈。 注意，正如前面所说，进入Fast Recovery之前，cwnd 和 sshthresh已被更新：</p>
<ul>
<li>cwnd = cwnd /2</li>
<li>sshthresh = cwnd</li>
</ul>
<p>然后，真正的Fast Recovery算法如下：</p>
<ul>
<li>cwnd = sshthresh  + 3 * MSS （3的意思是确认有3个数据包被收到了）</li>
<li>重传Duplicated ACKs指定的数据包</li>
<li>如果再收到 duplicated Acks，那么cwnd = cwnd +1</li>
<li>如果收到了新的Ack，那么，cwnd = sshthresh ，然后就进入了拥塞避免的算法了。</li>
</ul>
<p>如果你仔细思考一下上面的这个算法，你就会知道，<strong>上面这个算法也有问题，那就是——它依赖于3个重复的Acks</strong>。注意，3个重复的Acks并不代表只丢了一个数据包，很有可能是丢了好多包。但这个算法只会重传一个，而剩下的那些包只能等到RTO超时，于是，进入了恶梦模式——超时一个窗口就减半一下，多个超时会超成TCP的传输速度呈级数下降，而且也不会触发Fast Recovery算法了。</p>
<p>通常来说，正如我们前面所说的，SACK或D-SACK的方法可以让Fast Recovery或Sender在做决定时更聪明一些，但是并不是所有的TCP的实现都支持SACK（SACK需要两端都支持），所以，需要一个没有SACK的解决方案。而通过SACK进行拥塞控制的算法是FACK（后面会讲）</p>
<p><strong>TCP New Reno</strong></p>
<p>于是，1995年，TCP New Reno（参见 <a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc6582">RFC 6582</a> ）算法提出来，主要就是在没有SACK的支持下改进Fast Recovery算法的——</p>
<ul>
<li>当sender这边收到了3个Duplicated Acks，进入Fast Retransimit模式，开发重传重复Acks指示的那个包。如果只有这一个包丢了，那么，重传这个包后回来的Ack会把整个已经被sender传输出去的数据ack回来。如果没有的话，说明有多个包丢了。我们叫这个ACK为Partial ACK。</li>
<li>一旦Sender这边发现了Partial ACK出现，那么，sender就可以推理出来有多个包被丢了，于是乎继续重传sliding window里未被ack的第一个包。直到再也收不到了Partial Ack，才真正结束Fast Recovery这个过程</li>
</ul>
<p>我们可以看到，这个“Fast Recovery的变更”是一个非常激进的玩法，他同时延长了Fast Retransmit和Fast Recovery的过程。</p>
<h4 id="算法示意图"><a href="#算法示意图" class="headerlink" title="算法示意图"></a>算法示意图</h4><p>下面我们来看一个简单的图示以同时看一下上面的各种算法的样子：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/6F737861-7C75-4313-AF12-0DF11B178C76_2/VHbCg38Fli3hzOBLri2eNuZsoCvxhlTnUpBnSwN4W28z/Image.png" alt="Image.png"></p>
<h4 id="FACK算法"><a href="#FACK算法" class="headerlink" title="FACK算法"></a>FACK算法</h4><p>FACK全称Forward Acknowledgment 算法，论文地址在这里（PDF）<a target="_blank" rel="noopener" href="http://conferences.sigcomm.org/sigcomm/1996/papers/mathis.pdf">Forward Acknowledgement: Refining TCP Congestion Control</a> 这个算法是其于SACK的，前面我们说过SACK是使用了TCP扩展字段Ack了有哪些数据收到，哪些数据没有收到，他比Fast Retransmit的3 个duplicated acks好处在于，前者只知道有包丢了，不知道是一个还是多个，而SACK可以准确的知道有哪些包丢了。 所以，SACK可以让发送端这边在重传过程中，把那些丢掉的包重传，而不是一个一个的传，但这样的一来，如果重传的包数据比较多的话，又会导致本来就很忙的网络就更忙了。所以，FACK用来做重传过程中的拥塞流控。</p>
<ul>
<li>这个算法会把SACK中最大的Sequence Number 保存在<strong>snd.fack</strong>这个变量中，snd.fack的更新由ack带秋，如果网络一切安好则和snd.una一样（snd.una就是还没有收到ack的地方，也就是前面sliding window里的category #2的第一个地方）</li>
<li>然后定义一个<strong>awnd = snd.nxt – snd.fack</strong>（snd.nxt指向发送端sliding window中正在要被发送的地方——前面sliding windows图示的category#3第一个位置），这样awnd的意思就是在网络上的数据。（所谓awnd意为：actual quantity of data outstanding in the network）</li>
<li>如果需要重传数据，那么，<strong>awnd = snd.nxt – snd.fack + retran_data</strong>，也就是说，awnd是传出去的数据 + 重传的数据。</li>
<li>然后触发Fast Recovery 的条件是： ( <strong>( snd.fack – snd.una ) &gt; (3*MSS)</strong> ) || (dupacks == 3) ) 。这样一来，就不需要等到3个duplicated acks才重传，而是只要sack中的最大的一个数据和ack的数据比较长了（3个MSS），那就触发重传。在整个重传过程中cwnd不变。直到当第一次丢包的snd.nxt&lt;=snd.una（也就是重传的数据都被确认了），然后进来拥塞避免机制——cwnd线性上涨。</li>
</ul>
<p>我们可以看到如果没有FACK在，那么在丢包比较多的情况下，原来保守的算法会低估了需要使用的window的大小，而需要几个RTT的时间才会完成恢复，而FACK会比较激进地来干这事。 但是，FACK如果在一个网络包会被 reordering的网络里会有很大的问题。</p>
<h4 id="其它拥塞控制算法简介"><a href="#其它拥塞控制算法简介" class="headerlink" title="其它拥塞控制算法简介"></a>其它拥塞控制算法简介</h4><h4 id="TCP-Vegas-拥塞控制算法"><a href="#TCP-Vegas-拥塞控制算法" class="headerlink" title="TCP Vegas 拥塞控制算法"></a><strong>TCP Vegas 拥塞控制算法</strong></h4><p>这个算法1994年被提出，它主要对TCP Reno 做了些修改。这个算法通过对RTT的非常重的监控来计算一个基准RTT。然后通过这个基准RTT来估计当前的网络实际带宽，如果实际带宽比我们的期望的带宽要小或是要多的活，那么就开始线性地减少或增加cwnd的大小。如果这个计算出来的RTT大于了Timeout后，那么，不等ack超时就直接重传。（Vegas 的核心思想是用RTT的值来影响拥塞窗口，而不是通过丢包） 这个算法的论文是《<a target="_blank" rel="noopener" href="https://www.cs.cmu.edu/~srini/15-744/F02/readings/BP95.pdf">TCP Vegas: End to End Congestion Avoidance on a Global Internet</a>》这篇论文给了Vegas和 New Reno的对比：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/A1206DF9-3CED-4694-A792-06A1E444D13B/F9B41F4A-495F-4AE3-B00F-C01C4640E9E1_2/JUQTa06DEwbv7eOSCbcdhR5KzezLCPDTyaoswbucOz4z/Image.png" alt="Image.png"></p>
<p>关于这个算法实现，你可以参看Linux源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.h">/net/ipv4/tcp_vegas.h</a>， <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_vegas.c">/net/ipv4/tcp_vegas.c</a></p>
<h4 id="HSTCP-High-Speed-TCP-算法"><a href="#HSTCP-High-Speed-TCP-算法" class="headerlink" title="HSTCP(High Speed TCP) 算法"></a>HSTCP(High Speed TCP) 算法</h4><p>这个算法来自<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc3649">RFC 3649</a>（<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HSTCP">Wikipedia词条</a>）。其对最基础的算法进行了更改，他使得Congestion Window涨得快，减得慢。其中：</p>
<ul>
<li>拥塞避免时的窗口增长方式： cwnd = cwnd + α(cwnd) / cwnd</li>
<li>丢包后窗口下降方式：cwnd = (1- β(cwnd))*cwnd</li>
</ul>
<p>注：α(cwnd)和β(cwnd)都是函数，如果你要让他们和标准的TCP一样，那么让α(cwnd)=1，β(cwnd)=0.5就可以了。 对于α(cwnd)和β(cwnd)的值是个动态的变换的东西。 关于这个算法的实现，你可以参看Linux源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_highspeed.c">/net/ipv4/tcp_highspeed.c</a></p>
<h4 id="TCP-BIC-算法"><a href="#TCP-BIC-算法" class="headerlink" title="TCP BIC 算法"></a>TCP BIC 算法</h4><p>2004年，产内出BIC算法。现在你还可以查得到相关的新闻《Google：<a target="_blank" rel="noopener" href="https://www.google.com/search?lr=lang_zh-CN%7Clang_zh-TW&newwindow=1&biw=1366&bih=597&tbs=lr:lang_1zh-CN%7Clang_1zh-TW&q=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D&oq=%E7%BE%8E%E7%A7%91%E5%AD%A6%E5%AE%B6%E7%A0%94%E5%8F%91BIC-TCP%E5%8D%8F%E8%AE%AE+%E9%80%9F%E5%BA%A6%E6%98%AFDSL%E5%85%AD%E5%8D%83%E5%80%8D">美科学家研发BIC-TCP协议 速度是DSL六千倍</a>》 BIC全称<a target="_blank" rel="noopener" href="http://research.csc.ncsu.edu/netsrv/?q=content/bic-and-cubic">Binary Increase Congestion control</a>，在Linux 2.6.8中是默认拥塞控制算法。BIC的发明者发这么多的拥塞控制算法都在努力找一个合适的cwnd – Congestion Window，而且BIC-TCP的提出者们看穿了事情的本质，其实这就是一个搜索的过程，所以BIC这个算法主要用的是Binary Search——二分查找来干这个事。 关于这个算法实现，你可以参看Linux源码：<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_bic.c">/net/ipv4/tcp_bic.c</a></p>
<h4 id="TCP-WestWood算法"><a href="#TCP-WestWood算法" class="headerlink" title="TCP WestWood算法"></a>TCP WestWood算法</h4><p>westwood采用和Reno相同的慢启动算法、拥塞避免算法。westwood的主要改进方面：在发送端做带宽估计，当探测到丢包时，根据带宽值来设置拥塞窗口、慢启动阈值。 那么，这个算法是怎么测量带宽的？每个RTT时间，会测量一次带宽，测量带宽的公式很简单，就是这段RTT内成功被ack了多少字节。因为，这个带宽和用RTT计算RTO一样，也是需要从每个样本来平滑到一个值的——也是用一个加权移平均的公式。 另外，我们知道，如果一个网络的带宽是每秒可以发送X个字节，而RTT是一个数据发出去后确认需要的时候，所以，X * RTT应该是我们缓冲区大小。所以，在这个算法中，ssthresh的值就是est_BD * min-RTT(最小的RTT值)，如果丢包是Duplicated ACKs引起的，那么如果cwnd &gt; ssthresh，则 cwin = ssthresh。如果是RTO引起的，cwnd = 1，进入慢启动。   关于这个算法实现，你可以参看Linux源码： <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/source/net/ipv4/tcp_westwood.c">/net/ipv4/tcp_westwood.c</a></p>
<h4 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h4><p>更多的算法，你可以从Wikipedia的 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/TCP_congestion-avoidance_algorithm">TCP Congestion Avoidance Algorithm</a> 词条中找到相关的线索</p>
<h4 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h4><p>好了，到这里我想可以结束了，TCP发展到今天，里面的东西可以写上好几本书。本文主要目的，还是把你带入这些古典的基础技术和知识中，希望本文能让你了解TCP，更希望本文能让你开始有学习这些基础或底层知识的兴趣和信心。</p>
<p>当然，TCP东西太多了，不同的人可能有不同的理解，而且本文可能也会有一些荒谬之言甚至错误，还希望得到您的反馈和批评。</p>
<p>（全文完）</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP 的那些事儿（上）</title>
    <url>/2022/12/23/internet-tcp-f/</url>
    <content><![CDATA[<h1 id="TCP-的那些事儿（上）"><a href="#TCP-的那些事儿（上）" class="headerlink" title="TCP 的那些事儿（上）"></a>TCP 的那些事儿（上）</h1><p>TCP是一个巨复杂的协议，因为他要解决很多问题，而这些问题又带出了很多子问题和阴暗面。所以学习TCP本身是个比较痛苦的过程，但对于学习的过程却能让人有很多收获。关于TCP这个协议的细节，我还是推荐你去看<a target="_blank" rel="noopener" href="http://www.kohala.com/start/">W.Richard Stevens</a>的《<a target="_blank" rel="noopener" href="https://book.douban.com/subject/1088054/">TCP/IP 详解 卷1：协议</a>》（当然，你也可以去读一下<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc793">RFC793</a>以及后面N多的RFC）。另外，本文我会使用英文术语，这样方便你通过这些英文关键词来查找相关的技术文档。</p>
<p>之所以想写这篇文章，目的有三个，</p>
<ul>
<li>一个是想锻炼一下自己是否可以用简单的篇幅把这么复杂的TCP协议描清楚的能力。</li>
<li>另一个是觉得现在的好多程序员基本上不会认认真真地读本书，喜欢快餐文化，所以，希望这篇快餐文章可以让你对TCP这个古典技术有所了解，并能体会到软件设计中的种种难处。并且你可以从中有一些软件设计上的收获。</li>
<li>最重要的希望这些基础知识可以让你搞清很多以前一些似是而非的东西，并且你能意识到基础的重要。</li>
</ul>
<p>所以，本文不会面面俱到，只是对TCP协议、算法和原理的科普。</p>
<p>我本来只想写一个篇幅的文章的，但是TCP真TMD的复杂，比C++复杂多了，这30多年来，各种优化变种争论和修改。所以，写着写着就发现只有砍成两篇。</p>
<ul>
<li>上篇中，主要向你介绍TCP协议的定义和丢包时的重传机制。</li>
<li>下篇中，重点介绍TCP的流迭、拥塞处理。<span id="more"></span></li>
</ul>
<p>废话少说，首先，我们需要知道TCP在网络OSI的七层模型中的第四层——Transport层，IP在第三层——Network层，ARP在第二层——Data Link层，在第二层上的数据，我们叫Frame，在第三层上的数据叫Packet，第四层的数据叫Segment。</p>
<p>首先，我们需要知道，我们程序的数据首先会打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传到对端后，各个层解析自己的协议，然后把数据交给更高层的协议处理。</p>
<h4 id="TCP头格式"><a href="#TCP头格式" class="headerlink" title="TCP头格式"></a>TCP头格式</h4><p>接下来，我们来看一下TCP头的格式</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/2ECDCA0E-B498-44FF-BCDA-BCD7B5F57F4F/6CD6A221-6635-4B50-AAB1-32A6F6E49C46_2/Ct8xWuyXZ9y4x5P0TrsThRmIJdJmvj6m7LrfbYRgcnAz/Image.png" alt="Image.png"></p>
<p>TCP头格式（<a target="_blank" rel="noopener" href="https://nmap.org/book/tcpip-ref.html">图片来源</a>）</p>
<p>你需要注意这么几点：</p>
<ul>
<li>TCP的包是没有IP地址的，那是IP层上的事。但是有源端口和目标端口。</li>
<li>一个TCP连接需要四个元组来表示是同一个连接（src_ip, src_port, dst_ip, dst_port）准确说是五元组，还有一个是协议。但因为这里只是说TCP协议，所以，这里我只说四元组。</li>
<li>注意上图中的四个非常重要的东西：<ul>
<li><strong>Sequence Number</strong>是包的序号，<strong>用来解决网络包乱序（reordering）问题。</strong></li>
<li><strong>Acknowledgement Number</strong>就是ACK——用于确认收到，<strong>用来解决不丢包的问题</strong>。</li>
<li><strong>Window又叫Advertised-Window</strong>，也就是著名的滑动窗口（Sliding Window），<strong>用于解决流控的</strong>。</li>
<li><strong>TCP Flag</strong> ，也就是包的类型，<strong>主要是用于操控TCP的状态机的</strong>。</li>
</ul>
</li>
</ul>
<p>关于其它的东西，可以参看下面的图示</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/2ECDCA0E-B498-44FF-BCDA-BCD7B5F57F4F/5A4C4434-8C01-4534-9A71-15D1DB9BE5CC_2/gjlf6ENqyHdLXjljUy3YAoMpHgHUhFur1Cz9oyc4bRwz/Image.png" alt="Image.png"></p>
<p>（<a target="_blank" rel="noopener" href="https://nmap.org/book/tcpip-ref.html">图片来源</a>）</p>
<h4 id="TCP的状态机"><a href="#TCP的状态机" class="headerlink" title="TCP的状态机"></a>TCP的状态机</h4><p>其实，<strong>网络上的传输是没有连接的，包括TCP也是一样的</strong>。而TCP所谓的“连接”，其实只不过是在通讯的双方维护一个“连接状态”，让它看上去好像有连接一样。所以，TCP的状态变换是非常重要的。</p>
<p>下面是：“<strong>TCP协议的状态机</strong>”（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPOperationalOverviewandtheTCPFiniteStateMachineF-2.htm">图片来源</a>） 和 “<strong>TCP建链接</strong>”、“<strong>TCP断链接</strong>”、“<strong>传数据</strong>” 的对照图，我把两个图并排放在一起，这样方便在你对照着看。另外，下面这两个图非常非常的重要，你一定要记牢。（吐个槽：看到这样复杂的状态机，就知道这个协议有多复杂，复杂的东西总是有很多坑爹的事情，所以TCP协议其实也挺坑爹的）</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/2ECDCA0E-B498-44FF-BCDA-BCD7B5F57F4F/A9DB566E-D742-4649-8F98-EF1F0638EFAD_2/okDKlq2bCx5iKaFbc7dTMnZ0XGTM5xgUFfnlU15yf7Ez/Image.png" alt="Image.png"></p>
<p>很多人会问，为什么建链接要3次握手，断链接需要4次挥手？</p>
<ul>
<li><strong>对于建链接的3次握手，</strong>主要是要初始化Sequence Number 的初始值。通信的双方要互相通知对方自己的初始化的Sequence Number（缩写为ISN：Inital Sequence Number）——所以叫SYN，全称Synchronize Sequence Numbers。也就上图中的 x 和 y。这个号要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</li>
<li><strong>对于4次挥手，</strong>其实你仔细看是2次，因为TCP是全双工的，所以，发送方和接收方都需要Fin和Ack。只不过，有一方是被动的，所以看上去就成了所谓的4次挥手。如果两边同时断连接，那就会就进入到CLOSING状态，然后到达TIME_WAIT状态。下图是双方同时断连接的示意图（你同样可以对照着TCP状态机看）：</li>
</ul>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/2ECDCA0E-B498-44FF-BCDA-BCD7B5F57F4F/1323753C-5F53-42ED-B8DD-F2D1104838AB_2/LyUEbQkolv6VHG7lkI2QiEWTSAoSErfQsBmLmRrWDboz/Image.png" alt="Image.png"></p>
<p>两端同时断连接（<a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_TCPConnectionTermination-4.htm">图片来源</a>）</p>
<p>另外，有几个事情需要注意一下：</p>
<ul>
<li><strong>关于建连接时SYN超时</strong>。试想一下，如果server端接到了clien发的SYN后回了SYN-ACK后client掉线了，server端没有收到client回来的ACK，那么，这个连接处于一个中间状态，即没成功，也没失败。于是，server端如果在一定时间内没有收到的TCP会重发SYN-ACK。在Linux下，默认重试次数为5次，重试的间隔时间从1s开始每次都翻售，5次的重试时间间隔为1s, 2s, 4s, 8s, 16s，总共31s，第5次发出后还要等32s都知道第5次也超时了，所以，总共需要 1s + 2s + 4s+ 8s+ 16s + 32s = 2^6 -1 = 63s，TCP才会把断开这个连接。</li>
<li><strong>关于SYN Flood攻击</strong>。一些恶意的人就为此制造了SYN Flood攻击——给服务器发了一个SYN后，就下线了，于是服务器需要默认等63s才会断开连接，这样，攻击者就可以把服务器的syn连接的队列耗尽，让正常的连接请求不能处理。于是，Linux下给了一个叫<strong>tcp_syncookies</strong>的参数来应对这个事——当SYN队列满了后，TCP会通过源地址端口、目标地址端口和时间戳打造出一个特别的Sequence Number发回去（又叫cookie），如果是攻击者则不会有响应，如果是正常连接，则会把这个 SYN Cookie发回来，然后服务端可以通过cookie建连接（即使你不在SYN队列中）。请注意，<strong>请先千万别用tcp_syncookies来处理正常的大负载的连接的情况</strong>。因为，synccookies是妥协版的TCP协议，并不严谨。对于正常的请求，你应该调整三个TCP参数可供你选择，第一个是：tcp_synack_retries 可以用他来减少重试次数；第二个是：tcp_max_syn_backlog，可以增大SYN连接数；第三个是：tcp_abort_on_overflow 处理不过来干脆就直接拒绝连接了。</li>
<li><strong>关于ISN的初始化</strong>。ISN是不能hard code的，不然会出问题的——比如：如果连接建好后始终用1来做ISN，如果client发了30个segment过去，但是网络断了，于是 client重连，又用了1做ISN，但是之前连接的那些包到了，于是就被当成了新连接的包，此时，client的Sequence Number 可能是3，而Server端认为client端的这个号是30了。全乱了。<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc793">RFC793</a>中说，ISN会和一个假的时钟绑在一起，这个时钟会在每4微秒对ISN做加一操作，直到超过2^32，又从0开始。这样，一个ISN的周期大约是4.55个小时。因为，我们假设我们的TCP Segment在网络上的存活时间不会超过Maximum Segment Lifetime（缩写为MSL – <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Maximum_Segment_Lifetime">Wikipedia语条</a>），所以，只要MSL的值小于4.55小时，那么，我们就不会重用到ISN。</li>
<li><strong>关于 MSL 和 TIME_WAIT</strong>。通过上面的ISN的描述，相信你也知道MSL是怎么来的了。我们注意到，在TCP的状态图中，从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL（<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc793">RFC793</a>定义了MSL为2分钟，Linux设置成了30s）为什么要这有TIME_WAIT？为什么不直接给转成CLOSED状态呢？主要有两个原因：1）TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL，2）有足够的时间让这个连接不会跟后面的连接混在一起（你要知道，有些自做主张的路由器会缓存IP数据包，如果连接被重用了，那么这些延迟收到的包就有可能会跟新连接混在一起）。你可以看看这篇文章《<a target="_blank" rel="noopener" href="http://www.serverframework.com/asynchronousevents/2011/01/time-wait-and-its-design-implications-for-protocols-and-scalable-servers.html">TIME_WAIT and its design implications for protocols and scalable client server systems</a>》</li>
<li><strong>关于TIME_WAIT数量太多</strong>。从上面的描述我们可以知道，TIME_WAIT是个很重要的状态，但是如果在大并发的短链接下，TIME_WAIT 就会太多，这也会消耗很多系统资源。只要搜一下，你就会发现，十有八九的处理方式都是教你设置两个参数，一个叫<strong>tcp_tw_reuse</strong>，另一个叫<strong>tcp_tw_recycle</strong>的参数，这两个参数默认值都是被关闭的，后者recyle比前者resue更为激进，resue要温柔一些。另外，如果使用tcp_tw_reuse，必需设置tcp_timestamps=1，否则无效。这里，你一定要注意，<strong>打开这两个参数会有比较大的坑——可能会让TCP连接出一些诡异的问题</strong>（因为如上述一样，如果不等待超时重用连接的话，新的连接可能会建不上。正如<a target="_blank" rel="noopener" href="https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt">官方文档</a>上说的一样“<strong>It should not be changed without advice/request of technical experts</strong>”）。</li>
<li><strong>关于tcp_tw_reuse</strong>。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下<a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/ident?i=tcp_twsk_unique">tcp_twsk_unique</a>的源码 ）。我个人估计还是有一些场景会有问题。</li>
<li><strong>关于tcp_tw_recycle</strong>。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建链接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）（如果你想观摩一下Linux的内核代码，请参看源码 <a target="_blank" rel="noopener" href="http://lxr.free-electrons.com/ident?i=tcp_timewait_state_process">tcp_timewait_state_process</a>）。</li>
<li><strong>关于tcp_max_tw_buckets</strong>。这个是控制并发的TIME_WAIT的数量，默认值是180000，如果超限，那么，系统会把多的给destory掉，然后在日志里打一个警告（如：time wait bucket table overflow），官网文档说这个参数是用来对抗DDoS攻击的。也说的默认值180000并不小。这个还是需要根据实际情况考虑。</li>
</ul>
<p><strong>Again，使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（</strong><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc1122"><strong>RFC 1122</strong></a><strong>）</strong></p>
<p>其实，TIME_WAIT表示的是你主动断连接，所以，这就是所谓的“不作死不会死”。试想，如果让对端断连接，那么这个破问题就是对方的了，呵呵。另外，如果你的服务器是于HTTP服务器，那么设置一个<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/HTTP_persistent_connection">HTTP的KeepAlive</a>有多重要（浏览器会重用一个TCP连接来处理多个HTTP请求），然后让客户端去断链接（你要小心，浏览器可能会非常贪婪，他们不到万不得已不会主动断连接）。</p>
<h4 id="数据传输中的Sequence-Number"><a href="#数据传输中的Sequence-Number" class="headerlink" title="数据传输中的Sequence Number"></a>数据传输中的Sequence Number</h4><p>下图是我从Wireshark中截了个我在访问coolshell.cn时的有数据传输的图给你看一下，SeqNum是怎么变的。（使用Wireshark菜单中的Statistics -&gt;Flow Graph… ）</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/2ECDCA0E-B498-44FF-BCDA-BCD7B5F57F4F/56C26480-DFD5-41C3-AC17-2346FBC74DC7_2/yifLL4pbPm5hx5M1q6RU7iUOsSmn76ZsytyDQyCZfnwz/Image.png" alt="Image.png"></p>
<p>你可以看到，<strong>SeqNum的增加是和传输的字节数相关的</strong>。上图中，三次握手后，来了两个Len:1440的包，而第二个包的SeqNum就成了1441。然后第一个ACK回的是1441，表示第一个1440收到了。</p>
<p><strong>注意</strong>：如果你用Wireshark抓包程序看3次握手，你会发现SeqNum总是为0，不是这样的，Wireshark为了显示更友好，使用了Relative SeqNum——相对序号，你只要在右键菜单中的protocol preference 中取消掉就可以看到“Absolute SeqNum”了</p>
<h4 id="TCP重传机制"><a href="#TCP重传机制" class="headerlink" title="TCP重传机制"></a>TCP重传机制</h4><p>TCP要保证所有的数据包都可以到达，所以，必需要有重传机制。</p>
<p>注意，接收端给发送端的Ack确认只会确认最后一个连续的包，比如，发送端发了1,2,3,4,5一共五份数据，接收端收到了1，2，于是回ack 3，然后收到了4（注意此时3没收到），此时的TCP会怎么办？我们要知道，因为正如前面所说的，<strong>SeqNum和Ack是以字节数为单位，所以ack的时候，不能跳着确认，只能确认最大的连续收到的包</strong>，不然，发送端就以为之前的都收到了。</p>
<h4 id="超时重传机制"><a href="#超时重传机制" class="headerlink" title="超时重传机制"></a>超时重传机制</h4><p>一种是不回ack，死等3，当发送方发现收不到3的ack超时后，会重传3。一旦接收方收到3后，会ack 回 4——意味着3和4都收到了。</p>
<p>但是，这种方式会有比较严重的问题，那就是因为要死等3，所以会导致4和5即便已经收到了，而发送方也完全不知道发生了什么事，因为没有收到Ack，所以，发送方可能会悲观地认为也丢了，所以有可能也会导致4和5的重传。</p>
<p>对此有两种选择：</p>
<ul>
<li>一种是仅重传timeout的包。也就是第3份数据。</li>
<li>另一种是重传timeout后所有的数据，也就是第3，4，5这三份数据。</li>
</ul>
<p>这两种方式有好也有不好。第一种会节省带宽，但是慢，第二种会快一点，但是会浪费带宽，也可能会有无用功。但总体来说都不好。因为都在等timeout，timeout可能会很长（在下篇会说TCP是怎么动态地计算出timeout的）</p>
<h4 id="快速重传机制"><a href="#快速重传机制" class="headerlink" title="快速重传机制"></a>快速重传机制</h4><p>于是，TCP引入了一种叫<strong>Fast Retransmit</strong> 的算法，<strong>不以时间驱动，而以数据驱动重传</strong>。也就是说，如果，包没有连续到达，就ack最后那个可能被丢了的包，如果发送方连续收到3次相同的ack，就重传。Fast Retransmit的好处是不用等timeout了再重传。</p>
<p>比如：如果发送方发出了1，2，3，4，5份数据，第一份先到送了，于是就ack回2，结果2因为某些原因没收到，3到达了，于是还是ack回2，后面的4和5都到了，但是还是ack回2，因为2还是没有收到，于是发送端收到了三个ack=2的确认，知道了2还没有到，于是就马上重转2。然后，接收端收到了2，此时因为3，4，5都收到了，于是ack回6。示意图如下：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/2ECDCA0E-B498-44FF-BCDA-BCD7B5F57F4F/34913B5D-8199-4D3F-857A-A86A28D43531_2/SiiJn9GdvPrJV5INMogwqxyYenjGXSXRrWFzWrk5OBEz/Image.png" alt="Image.png"></p>
<p>Fast Retransmit只解决了一个问题，就是timeout的问题，它依然面临一个艰难的选择，就是，是重传之前的一个还是重传所有的问题。对于上面的示例来说，是重传#2呢还是重传#2，#3，#4，#5呢？因为发送端并不清楚这连续的3个ack(2)是谁传回来的？也许发送端发了20份数据，是#6，#10，#20传来的呢。这样，发送端很有可能要重传从2到20的这堆数据（这就是某些TCP的实际的实现）。可见，这是一把双刃剑。</p>
<h4 id="SACK-方法"><a href="#SACK-方法" class="headerlink" title="SACK 方法"></a>SACK 方法</h4><p>另外一种更好的方式叫：**Selective Acknowledgment (SACK)**（参看<a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc2018">RFC 2018</a>），这种方式需要在TCP头里加一个SACK的东西，ACK还是Fast Retransmit的ACK，SACK则是汇报收到的数据碎版。参看下图：</p>
<p><img src="https://res.craft.do/user/full/d3f184bd-2fc6-ae80-c9ed-d9b26e0cd7ba/doc/2ECDCA0E-B498-44FF-BCDA-BCD7B5F57F4F/17FD241A-881B-4A2C-87F2-B8A50AB1DBA4_2/GyVy6qMvLWzDF09THr7gQATC4TYKtIMiMa3PMm4MMmUz/Image.png" alt="Image.png"></p>
<p>这样，在发送端就可以根据回传的SACK来知道哪些数据到了，哪些没有到。于是就优化了Fast Retransmit的算法。当然，这个协议需要两边都支持。在 Linux下，可以通过<strong>tcp_sack</strong>参数打开这个功能（Linux 2.4后默认打开）。</p>
<p>这里还需要注意一个问题——<strong>接收方Reneging，所谓Reneging的意思就是接收方有权把已经报给发送端SACK里的数据给丢了</strong>。这样干是不被鼓励的，因为这个事会把问题复杂化了，但是，接收方这么做可能会有些极端情况，比如要把内存给别的更重要的东西。<strong>所以，发送方也不能完全依赖SACK，还是要依赖ACK，并维护Time-Out，如果后续的ACK没有增长，那么还是要把SACK的东西重传，另外，接收端这边永远不能把SACK的包标记为Ack。</strong></p>
<p>注意：SACK会消费发送方的资源，试想，如果一个攻击者给数据发送方发一堆SACK的选项，这会导致发送方开始要重传甚至遍历已经发出的数据，这会消耗很多发送端的资源。详细的东西请参看《<a target="_blank" rel="noopener" href="https://www.ibm.com/developerworks/cn/linux/l-tcp-sack/">TCP SACK的性能权衡</a>》</p>
<h4 id="Duplicate-SACK-–-重复收到数据的问题"><a href="#Duplicate-SACK-–-重复收到数据的问题" class="headerlink" title="Duplicate SACK – 重复收到数据的问题"></a>Duplicate SACK – 重复收到数据的问题</h4><p>Duplicate SACK又称D-SACK，<strong>其主要使用了SACK来告诉发送方有哪些数据被重复接收了</strong>。<a target="_blank" rel="noopener" href="https://www.ietf.org/rfc/rfc2883.txt">RFC-2883</a> 里有详细描述和示例。下面举几个例子（来源于<a target="_blank" rel="noopener" href="https://www.ietf.org/rfc/rfc2883.txt">RFC-2883</a>）</p>
<p>D-SACK使用了SACK的第一个段来做标志，</p>
<ul>
<li>如果SACK的第一个段的范围被ACK所覆盖，那么就是D-SACK</li>
<li>如果SACK的第一个段的范围被SACK的第二个段覆盖，那么就是D-SACK</li>
</ul>
<p><strong>示例一：ACK丢包</strong></p>
<p>下面的示例中，丢了两个ACK，所以，发送端重传了第一个数据包（3000-3499），于是接收端发现重复收到，于是回了一个SACK=3000-3500，因为ACK都到了4000意味着收到了4000之前的所有数据，所以这个SACK就是D-SACK——旨在告诉发送端我收到了重复的数据，而且我们的发送端还知道，数据包没有丢，丢的是ACK包。</p>
<p><strong>示例二，网络延误</strong></p>
<p>下面的示例中，网络包（1000-1499）被网络给延误了，导致发送方没有收到ACK，而后面到达的三个包触发了“Fast Retransmit算法”，所以重传，但重传时，被延误的包又到了，所以，回了一个SACK=1000-1500，因为ACK已到了3000，所以，这个SACK是D-SACK——标识收到了重复的包。</p>
<p>这个案例下，发送端知道之前因为“Fast Retransmit算法”触发的重传不是因为发出去的包丢了，也不是因为回应的ACK包丢了，而是因为网络延时了。</p>
<p>可见，引入了D-SACK，有这么几个好处：</p>
<p>1）可以让发送方知道，是发出去的包丢了，还是回来的ACK包丢了。</p>
<p>2）是不是自己的timeout太小了，导致重传。</p>
<p>3）网络上出现了先发的包后到的情况（又称reordering）</p>
<p>4）网络上是不是把我的数据包给复制了。</p>
<p><strong>知道这些东西可以很好得帮助TCP了解网络情况，从而可以更好的做网络上的流控</strong>。</p>
<p>Linux下的tcp_dsack参数用于开启这个功能（Linux 2.4后默认打开）</p>
<p>好了，上篇就到这里结束了。如果你觉得我写得还比较浅显易懂，那么，欢迎移步看下篇</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>关于TCP的所有你想知道的</title>
    <url>/2023/10/14/internet-tcp-g/</url>
    <content><![CDATA[<h2 id="连接导向、可靠和比特流导向"><a href="#连接导向、可靠和比特流导向" class="headerlink" title="连接导向、可靠和比特流导向"></a>连接导向、可靠和比特流导向</h2><p>在网络层的IP协议是不可靠的。它负责将数据包从一个IP地址传递到另一个IP地址，但不对传递的数据包的交付、顺序或完整性做任何保证。这就是TCP发挥作用的地方，它确保数据传输的可靠性。</p>
<p>TCP具有以下三个重要特点：</p>
<ol>
<li>TCP是连接导向的。与将数据从一个服务器发送到多个服务器的UDP不同，TCP在两个特定服务器之间建立连接。</li>
<li>TCP是可靠的。TCP保证分段的传递，无论网络条件如何。</li>
<li>TCP是比特流导向的。使用TCP时，应用层数据被分段处理，传输层对消息的边界不可见。此外，这些分段必须按顺序处理，并且重复的分段将被丢弃。</li>
</ol>
<p>为了标识唯一的TCP连接，我们使用以下字段，通常称为四元组：</p>
<ul>
<li>源IP地址和目标IP地址：位于IP头中，用于指导IP协议进行数据路由。</li>
<li>源端口和目标端口：位于TCP头中，用于指示TCP协议将分段传递给哪个进程。</li>
</ul>
<span id="more"></span>

<h2 id="TCP头部的更多信息"><a href="#TCP头部的更多信息" class="headerlink" title="TCP头部的更多信息"></a>TCP头部的更多信息</h2><p>我们已经提到了TCP头部中的源端口和目标端口。让我们进一步研究TCP头部中的其他字段，特别是在建立TCP连接时至关重要的字段。下面的图表突出显示了这些重要字段。</p>
<ul>
<li>序列号（Sequence Number）：在建立新的TCP连接时，会分配一个随机的32位值作为初始序列号。接收端使用此序列号发送一个确认回复。序列号用作确保接收端对分段进行顺序处理的机制。</li>
<li>确认号（Acknowledgment Number）：接收端使用这个32位的数字来请求下一个TCP分段。这个值是序列号加一。当发送端接收到这个确认回复时，可以假定之前的所有数据都已成功接收。这个机制可以防止数据丢失。</li>
<li>标志位（Flags）：也称为控制位，标志位指示TCP消息的目的。接下来我们将在下一部分中探讨不同类型的TCP消息。控制位指示消息是用于建立连接、传输数据还是终止连接。<ul>
<li>ACK：用于确认。</li>
<li>RST：用于在发生无法恢复的错误时重置连接。</li>
<li>SYN：用于初始的三次握手。序列号字段必须被设置。</li>
<li>FIN：用于终止连接。</li>
</ul>
</li>
</ul>
<p><img src="https://res.craft.do/user/full/b313a1ab-3121-84d1-2506-d702b5c0ba9c/9E78E1A8-8CB2-44ED-B83C-F685864A37D2_2/fpNrZ2USy77He2Pluziwm0ALlXp8PcgTHytTUWZsy9gz/30a07a70-c0dd-4e5e-b949-042c7368cc39_1600x934.png" alt="30a07a70-c0dd-4e5e-b949-042c7368cc39_1600x934.png"></p>
<p>在下面，我们将看到这些字段在TCP连接建立过程中的使用方式。</p>
<h2 id="建立TCP连接：三次握手"><a href="#建立TCP连接：三次握手" class="headerlink" title="建立TCP连接：三次握手"></a>建立TCP连接：三次握手</h2><p>让我们探讨TCP如何建立连接，这个过程被称为三次握手。下面的图表展示了三次握手的过程。</p>
<p>步骤0：最初，客户端和服务器都处于CLOSE状态。服务器通过在特定端口上监听传入连接来开始。</p>
<p>步骤1：客户端通过向服务器发送一个SYN分段来发起连接。它为序列号分配一个随机数，称为初始序列号（ISN）。将SYN控制位设置为1，将客户端转换为SYN-SENT状态。</p>
<p>步骤2：服务器在接收到SYN分段后，为序列号分配一个随机数，并将确认号设置为<em>client_isn+1</em>。然后，它将SYN和ACK控制位都设置为1，并将此分段发送回客户端。此时，服务器进入SYN-RECEIVED状态。</p>
<p>步骤3：客户端在接收到SYN+ACK分段后，发送一个ACK分段，并将确认号设置为<em>server_isn+1</em>。此时，该分段可以携带应用层数据，并且客户端进入ESTABLISHED状态。一旦服务器接收到ACK分段，它也进入ESTABLISHED状态。</p>
<p>值得注意的是，前两次握手不能携带数据，但第三次握手可以。在完成三次握手后，客户端和服务器可以开始交换数据。</p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F781159a5-f60e-4c94-b815-c8abd8d73b12_1600x1442.png" alt="781159a5-f60e-4c94-b815-c8abd8d73b12_1600x1442.png"></p>
<p>TCP是可靠的，那么当一个分段丢失时会发生什么呢？</p>
<ul>
<li>如果SYN分段丢失：如果客户端在设定的时间范围内没有收到SYN+ACK，它会重新发送SYN分段多次（默认为5次）。如果仍然没有收到SYN+ACK分段，客户端会终止连接，从SYN_SENT状态转换到CLOSED状态。</li>
<li>如果SYN+ACK分段丢失：客户端无法区分SYN分段丢失还是SYN+ACK分段丢失，因此它会重新发送SYN分段，并在多次尝试后关闭连接。如果服务器在一定时间内没有收到ACK分段，它会重新发送SYN+ACK分段，并在多次尝试后关闭连接。</li>
<li>如果ACK分段丢失：如果服务器没有收到ACK分段，它会发起重发操作。请注意，客户端不会重新发送ACK分段。如果服务器即使重发了ACK分段仍然无法收到，它会关闭连接。</li>
</ul>
<h2 id="关闭TCP连接：四次握手"><a href="#关闭TCP连接：四次握手" class="headerlink" title="关闭TCP连接：四次握手"></a>关闭TCP连接：四次握手</h2><p>现在让我们转向TCP连接的终止过程。客户端和服务器都可以启动终止。在下图中，客户端启动了终止过程。</p>
<p>步骤1：客户端通过向服务器发送一个FIN分段来启动终止过程，进入FIN_WAIT_1状态。</p>
<p>步骤2：服务器在收到</p>
<p>FIN分段后，回复一个ACK分段，并进入CLOSE_WAIT状态。在收到ACK分段后，客户端进入FIN_WAIT_2状态。</p>
<p>步骤3：服务器完成处理后，向客户端发送一个FIN分段，并进入LAST_ACK状态。</p>
<p>步骤4：客户端在收到FIN分段后，发送一个ACK分段，并进入TIME_WAIT状态。服务器在收到ACK分段后，进入CLOSED状态。等待2MSL（最大报文生存时间）的持续时间后，客户端也转换到CLOSED状态。MSL是TCP分段在网络中存在的最长时间，任意地定义为2分钟。</p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1e386fb3-7fc6-477a-aa50-c314a462a349_1600x1591.png" alt="1e386fb3-7fc6-477a-aa50-c314a462a349_1600x1591.png"></p>
<p>当我们深入研究TCP握手时，让我们考虑三种边缘情况：</p>
<ol>
<li>客户端宕机</li>
<li>服务器宕机</li>
<li>网络电缆损坏</li>
</ol>
<p>如果客户端在建立TCP连接后宕机会发生什么？</p>
<p>假设在客户端和服务器之间建立了TCP连接，然后客户端突然断线。会发生什么？</p>
<p>如果服务器不尝试向客户端发送数据，服务器无法了解客户端的状态。服务器将保持在ESTABLISHED状态。解决这个问题的方法是实现TCP保活。</p>
<p>使用TCP保活，一组计时器与建立的TCP连接关联。当保活计时器超时时，服务器向客户端发送一个保活探测。该探测是一个不携带数据的ACK分段。如果连续发送多个探测分段而没有客户端的响应，服务器将认为TCP连接已经断开。</p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5d679ed7-acee-4b70-8536-867bf71a50bc_1486x1600.png" alt="5d679ed7-acee-4b70-8536-867bf71a50bc_1486x1600.png"></p>
<p>现在让我们更深入地探讨TCP保活的四种情况：</p>
<ol>
<li>客户端正常工作。服务器发送一个保活探测并收到回复。保活计时器重置，服务器在计时器再次超时时发送下一个探测。</li>
<li>客户端进程关闭。在客户端上，当操作系统回收进程资源时，它向服务器发送一个FIN分段。</li>
<li>客户端机器离线并重新启动。如下图所示，当客户端重新上线时，它对先前的连接一无所知。当服务器尝试通过这个失效的连接向客户端发送数据时，客户端会回复一个RST分段，强制服务器关闭连接。</li>
<li>客户端机器离线并且不恢复。我们已经讨论过这种情况-在几次无应答的探测之后，服务器将认为连接已经断开。</li>
</ol>
<p>对于服务器在建立TCP连接后宕机的情况，类似的机制也适用，因为TCP是一种双工协议。</p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程：JMM和volatile关键字</title>
    <url>/2017/11/12/java-concurrent-2017-08-25-jmm-volatile/</url>
    <content><![CDATA[<h2 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h2><p>随着计算机的CPU的飞速发展，CPU的运算能力已经远远超出了从主内存（运行内存）中读取的数据的能力，为了解决这个问题，CPU厂商设计出了CPU内置高速缓存区。高速缓存区的加入使得CPU在运算的过程中直接从高速缓存区读取数据，在一定程度上解决了性能的问题。但也引起了另外一个问题，在CPU多核的情况下，每个处理器都有自己的缓存区，数据如何保持一致性。为了保证多核处理器的数据一致性，引入多处理器的数据一致性的协议，这些协议包括MOSI、Synapse、Firely、DragonProtocol等。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-98d10d5cb7acf7a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="JMM内存模型.png"></p>
<span id="more"></span>

<p>JVM在执行多线程任务时，共享数据保存在主内存中，每一个线程（执行再不同的处理器）有自己的高速缓存，线程对共享数据进行修改的时候，首先是从主内存拷贝到线程的高速缓存，修改之后，然后从高速缓存再拷贝到主内存。当有多个线程执行这样的操作的时候，会导致共享数据出现不可预期的错误。</p>
<p>举个例子：</p>
<blockquote>
<p>i++;//操作</p>
</blockquote>
<p>这个i++操作，线程首先从主内存读取i的值，比如i=0，然后复制到自己的高速缓存区，进行i++操作，最后将操作后的结果从高速缓存区复制到主内存中。如果是两个线程通过操作i++,预期的结果是2。这时结果真的为2吗？答案是否定的。线程1读取主内存的i=0,复制到自己的高速缓存区，这时线程2也读取i=0,复制到自己的高速缓存区，进行i++操作，怎么最终得到的结构为1，而不是2。</p>
<p>为了解决缓存不一致的问题，有两种解决方案：</p>
<ul>
<li>在总线加锁，即同时只有一个线程能执行i++操作（包括读取、修改等）。</li>
<li>通过缓存一致性协议</li>
</ul>
<p>第一种方式就没什么好说的，就是同步代码块或者同步方法。也就只能一个线程能进行对共享数据的读取和修改，其他线程处于线程阻塞状态。<br>第二种方式就是缓存一致性协议，比如Intel 的MESI协议，它的核心思想就是当某个处理器写变量的数据，如果其他处理器也存在这个变量，会发出信号量通知该处理器高速缓存的数据设置为无效状态。当其他处理需要读取该变量的时候，会让其重新从主内存中读，然后再复制到高速缓存区。</p>
<h2 id="编发编程的概念"><a href="#编发编程的概念" class="headerlink" title="编发编程的概念"></a>编发编程的概念</h2><p>并发编程的有三个概念，包括原子性、可见性、有序性。</p>
<h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>原子性是指，操作为原子性的，要么成功，要么失败，不存在第三种情况。比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String s&#x3D;&quot;abc&quot;;</span><br></pre></td></tr></table></figure>

<p>这个复杂操作是原子性的。再比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int i&#x3D;0;</span><br><span class="line">i++;</span><br></pre></td></tr></table></figure>

<p>i=0这是一个赋值操作，这一步是原子性操作；那么i++是原子性操作吗？当然不是，首先它需要读取i=0，然后需要执行运算，写入i的新值1，它包含了读取和写入两个步骤，所以不是原子性操作。</p>
<h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>可见性是指共享数据的时候，一个线程修改了数据，其他线程知道数据被修改，会重新读取最新的主存的数据。<br>举个例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">i&#x3D;0;&#x2F;&#x2F;主内存</span><br><span class="line"></span><br><span class="line">i++;&#x2F;&#x2F;线程1</span><br><span class="line"></span><br><span class="line">j&#x3D;i;&#x2F;&#x2F;线程2</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>线程1修改了i值，但是没有将i值复制到主内存中，线程2读取i的值，并将i的值赋值给j,我们期望j=1,但是由于线程1修改了，没有来得及复制到主内存中，线程2读取了i,并赋值给j，这时j的值为0。<br>也就是线程i值被修改，其他线程并不知道。</p>
<h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>是指代码执行的有序性，因为代码有可能发生指令重排序（Instruction Reorder）。</p>
<p>Java 语言提供了 volatile 和 synchronized 两个关键字来线程代码操作的有序性，volatile 是因为其本身包含“禁止指令重排序”的语义，synchronized 在单线程中执行代码，无论指令是否重排，最终的执行结果是一致的。</p>
<h2 id="volatile详解"><a href="#volatile详解" class="headerlink" title="volatile详解"></a>volatile详解</h2><h3 id="volatile关键字作用"><a href="#volatile关键字作用" class="headerlink" title="volatile关键字作用"></a>volatile关键字作用</h3><p>被volatile关键字修饰变量，起到了2个作用：</p>
<blockquote>
<p>1.某个线程修改了被volatile关键字修饰变量是，根据数据一致性的协议，通过信号量，更改其他线程的高速缓存中volatile关键字修饰变量状态为无效状态，其他线程如果需要重写读取该变量会再次从主内存中读取，而不是读取自己的高速缓存中的。</p>
<p>2.被volatile关键字修饰变量不会指令重排序。</p>
</blockquote>
<h3 id="volatile能够保证可见性和防止指令重排"><a href="#volatile能够保证可见性和防止指令重排" class="headerlink" title="volatile能够保证可见性和防止指令重排"></a>volatile能够保证可见性和防止指令重排</h3><p>在Java并发编程实战一书中有这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class NoVisibility &#123;</span><br><span class="line">    private static boolean ready;</span><br><span class="line">    private static int a;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        new ReadThread().start();</span><br><span class="line">        Thread.sleep(100);</span><br><span class="line">        a &#x3D; 32;</span><br><span class="line">        ready &#x3D; true;</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ReadThread extends Thread &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            while (!ready) &#123;</span><br><span class="line">                Thread.yield();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在上述代码中，有可能（概率非常小，但是有这种可能性）永远不会打印a的值，因为线程ReadThread读取了主内存的ready为false,主线程虽然更新了ready，但是ReadThread的高速缓存中并没有更新。<br>另外：</p>
<blockquote>
<p>a = 32;</p>
<p>ready = true;</p>
</blockquote>
<p>这两行代码有可能发生指令重排。也就是可以打印出a的值为0。</p>
<p>如果在变量加上volatile关键字，可以防止上述两种不正常的情况的发生。</p>
<h3 id="volatile不能保证原子性"><a href="#volatile不能保证原子性" class="headerlink" title="volatile不能保证原子性"></a>volatile不能保证原子性</h3><p>首先用一段代码测试下，开起了10个线程，这10个线程共享一个变量inc（被volatile修饰），并在每个线程循环1000次对inc进行inc++操作。我们预期的结果是10000.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class VolatileTest &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public volatile int inc &#x3D; 0;</span><br><span class="line"></span><br><span class="line">    public void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final VolatileTest test &#x3D; new VolatileTest();</span><br><span class="line">        for (int i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">            new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j &#x3D; 0; j &lt; 1000; j++)</span><br><span class="line">                    test.increase();</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        &#x2F;&#x2F;保证前面的线程都执行完</span><br><span class="line">        Thread.sleep(3000);</span><br><span class="line">        System.out.println(test.inc);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>多次运行main函数，你会发现结果永远都不会为10000，都是小于10000。可能有这样的疑问，volatile保证了共享数据的可见性，线程1修改了inc变量线程2会重新从主内存中重新读，这样就能保证inc++的正确性了啊，可为什么没有得到我们预期的结果呢？</p>
<p>在之前已经讲述过inc++这样的操作不是一个原子性操作，它分为读、加加、写。一种情况，当线程1读取了inc的值，还没有修改，线程2也读取了，线程1修改完了，通知线程2将线程的缓存的 inc的值无效需要重读，可这时它不需要读取inc ，它仍执行写操作，然后赋值给主线程，这时数据就会出现问题。</p>
<p>所以volatile不能保证原子性 。这时需要用锁来保证,在increase方法加上synchronized，重新运行打印的结果为10000 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> public synchronized void increase() &#123;</span><br><span class="line">        inc++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="volatile的使用场景"><a href="#volatile的使用场景" class="headerlink" title="volatile的使用场景"></a>volatile的使用场景</h3><h4 id="状态标记"><a href="#状态标记" class="headerlink" title="状态标记"></a>状态标记</h4><p>volatile最常见的使用场景是状态标记，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private volatile boolean asheep ;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程1</span><br><span class="line"> </span><br><span class="line">while(!asleep)&#123;</span><br><span class="line">    countSheep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;线程2</span><br><span class="line">asheep&#x3D;true;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="防止指令重排"><a href="#防止指令重排" class="headerlink" title="防止指令重排"></a>防止指令重排</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">volatile boolean inited &#x3D; false;</span><br><span class="line">&#x2F;&#x2F;线程1:</span><br><span class="line">context &#x3D; loadContext();  </span><br><span class="line">inited &#x3D; true;  </span><br><span class="line">&#x2F;&#x2F;上面两行代码如果不用volatile修饰，可能会发生指令重排，导致报错</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F;线程2:</span><br><span class="line">while(!inited )&#123;</span><br><span class="line">sleep()</span><br><span class="line">&#125;</span><br><span class="line">doSomethingwithconfig(context);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Java 并发编程实战》</p>
<p>《深入理解JVM》</p>
<p>海子的博客：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3920373.html">http://www.cnblogs.com/dolphin0520/p/3920373.html</a></p>
]]></content>
      <categories>
        <category>java并发编程</category>
      </categories>
      <tags>
        <tag>java java并发编程 volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>Java并发编程：线程封闭和ThreadLocal详解</title>
    <url>/2017/11/12/java-concurrent-2017-08-27-cjava-threadlocal/</url>
    <content><![CDATA[<h2 id="什么是线程封闭"><a href="#什么是线程封闭" class="headerlink" title="什么是线程封闭"></a>什么是线程封闭</h2><p>![测试](<a target="_blank" rel="noopener" href="http://chris/">http://chris</a> .oss-cn-hangzhou.aliyuncs.com/WechatIMG1.jpeg)<br>当访问共享变量时，往往需要加锁来保证数据同步。一种避免使用同步的方式就是不共享数据。如果仅在单线程中访问数据，就不需要同步了。这种技术称为线程封闭。在Java语言中，提供了一些类库和机制来维护线程的封闭性，例如局部变量和ThreadLocal类，本文主要深入讲解如何使用ThreadLocal类来保证线程封闭。</p>
<span id="more"></span>

<h2 id="理解ThreadLocal类"><a href="#理解ThreadLocal类" class="headerlink" title="理解ThreadLocal类"></a>理解ThreadLocal类</h2><p>ThreadLocal类能使线程中的某个值与保存值的对象关联起来，它提供了get、set方法，这些方法为每个使用该变量的线程保存一份独立的副本，因此get总是set当前线程的set最新值。</p>
<p>首先我们来看个例子，这个例子来自于<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3920407.html">http://www.cnblogs.com/dolphin0520/p/3920407.html</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Test1 &#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal &#x3D; new ThreadLocal&lt;Long&gt;();</span><br><span class="line">    ThreadLocal&lt;String&gt; stringLocal &#x3D; new ThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void set() &#123;</span><br><span class="line">        longLocal.set(Thread.currentThread().getId());</span><br><span class="line">        stringLocal.set(Thread.currentThread().getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getLong() &#123;</span><br><span class="line">        return longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getString() &#123;</span><br><span class="line">        return stringLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Test1 test &#x3D; new Test1();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        test.set();</span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread thread1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">            test.set();</span><br><span class="line">            System.out.println(test.getLong());</span><br><span class="line">            System.out.println(test.getString());</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行该程序，代码输出的结果为：</p>
<blockquote>
<p>1</p>
<p>main</p>
<p>10</p>
<p>Thread-0</p>
<p>1</p>
<p>main</p>
</blockquote>
<p>从这段代码可以看出在mian线程和thread1线程确实都保存着各自的副本，它们的副本各自不干扰。</p>
<h2 id="ThreadLocal源码解析"><a href="#ThreadLocal源码解析" class="headerlink" title="ThreadLocal源码解析"></a>ThreadLocal源码解析</h2><p>来从源码的角度来解析ThreadLocal这个类，这个类存放在java.lang包，这个类有很多方法。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-903e2b9e3a60cee5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" alt="image.png"></p>
<p>它内部又个ThreadLocalMap类，主要有set()、get()、setInitialValue 等方法。</p>
<p>首先来看下set方法，获取当前Thread的 map，如果不存在则新建一个并设置值，如果存在设置值，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void set(T value) &#123;</span><br><span class="line">        Thread t &#x3D; Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map &#x3D; getMap(t);</span><br><span class="line">        if (map !&#x3D; null)</span><br><span class="line">            map.set(this, value);</span><br><span class="line">        else</span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>跟踪createMap，可以发现它根据Thread创建来一个ThreadLocalMap。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void createMap(Thread t, T firstValue) &#123;</span><br><span class="line">      t.threadLocals &#x3D; new ThreadLocalMap(this, firstValue);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>t.threadLocals为当前线程的一个变量，也就是ThreadLocal的数据都是存放在当前线程的threadLocals变量里面的，由此可见用ThreadLocal存放的数据是线程安全的。因为它对于不同的线程来，使用ThreadLocal的set方法都会根据线程判断该线程是否存在它的threadLocals成员变量，如果没有就建一个，有的话就存下数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ThreadLocal.ThreadLocalMap threadLocals &#x3D; null;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ThreadLocalMap为ThreadLocal的一个内部类，源码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static class ThreadLocalMap &#123;</span><br><span class="line"></span><br><span class="line">       static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;</span><br><span class="line">           &#x2F;** The value associated with this ThreadLocal. *&#x2F;</span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               super(k);</span><br><span class="line">               value &#x3D; v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以看到ThreadLocalMap的Entry继承了WeakReference，并且使用ThreadLocal作为键值。</p>
<p>在使用ThreadLocal的get方法之前一定要先set，要不然会报空指针异常。还有一种方式就是在初始化的时候调用initialValue（）方法赋值。改造下之前的例子，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test2 &#123;</span><br><span class="line"></span><br><span class="line">    ThreadLocal&lt;Long&gt; longLocal &#x3D; new ThreadLocal&lt;Long&gt;()&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        protected Long initialValue() &#123;</span><br><span class="line">            return Thread.currentThread().getId();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ThreadLocal&lt;String&gt; stringLocal &#x3D; new ThreadLocal&lt;String&gt;()&#123;</span><br><span class="line">        @Override</span><br><span class="line">        protected String initialValue() &#123;</span><br><span class="line">            return Thread.currentThread().getName();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    public long getLong() &#123;</span><br><span class="line">        return longLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getString() &#123;</span><br><span class="line">        return stringLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        final Test2 test &#x3D; new Test2();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Thread thread1 &#x3D; new Thread(() -&gt; &#123;</span><br><span class="line">          </span><br><span class="line">            System.out.println(test.getLong());</span><br><span class="line">            System.out.println(test.getString());</span><br><span class="line">        &#125;);</span><br><span class="line">        thread1.start();</span><br><span class="line">        thread1.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(test.getLong());</span><br><span class="line">        System.out.println(test.getString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行该程序，代码输出的结果为：</p>
<blockquote>
<p>1</p>
<p>main</p>
<p>10</p>
<p>Thread-0</p>
<p>1</p>
<p>main</p>
</blockquote>
<h2 id="ThreadLocal常用的使用场景"><a href="#ThreadLocal常用的使用场景" class="headerlink" title="ThreadLocal常用的使用场景"></a>ThreadLocal常用的使用场景</h2><p>通常讲JDBC连接保存在ThreadLocal对象中，每个对象都有属于自己的连接，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private static ThreadLocal&lt;Connection&gt; connectionHolder</span><br><span class="line">&#x3D; new ThreadLocal&lt;Connection&gt;() &#123;</span><br><span class="line">    public Connection initialValue() &#123;</span><br><span class="line">       return DriverManager.getConnection(DB_URL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">public static Connection getConnection() &#123;</span><br><span class="line">    return connectionHolder.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p>《Java并发编程实战》</p>
<p>《深入理解JVM》</p>
]]></content>
      <categories>
        <category>java并发编程</category>
      </categories>
      <tags>
        <tag>java java并发编程 volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM内存结构</title>
    <url>/2020/10/12/jvm-2020-10-09-jvm%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>1.7和1.8之间JVM内存结构以及它们的差异</p>
<span id="more"></span>

<h4 id="JVM-内存分配"><a href="#JVM-内存分配" class="headerlink" title="JVM 内存分配"></a>JVM 内存分配</h4><p>根据 <a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">JVM 规范</a>，JVM 内存分为虚拟机栈、堆、方法区、程序计数器、本地方法 stack5个部分。</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.programmersought.com/article/74164482693/">https://www.programmersought.com/article/74164482693/</a></p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjk8684wiqj30w70lh47l.jpg"></p>
<table>
<thead>
<tr>
<th>名称</th>
<th>特征</th>
<th>作用</th>
<th>配置参数</th>
<th>异常</th>
</tr>
</thead>
<tbody><tr>
<td>程序计数器</td>
<td>占用内存小，线程私有，生命周期与线程相同</td>
<td>字节码行号指示器</td>
<td>无</td>
<td>无</td>
</tr>
<tr>
<td>虚拟机栈</td>
<td>线程私有，生命周期与线程相同，使用连续的内存空间</td>
<td>Java方法执行的内存模型，存储局部变量表、操作栈、动态链接、方法出口等信息</td>
<td>-Xss</td>
<td>StackOverflowError/OutOfMemoryError</td>
</tr>
<tr>
<td>堆</td>
<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>
<td>保存对象实例，所有对象实例（包括数组）都要在堆上分配</td>
<td>-Xms -Xsx -Xmn</td>
<td>OutOfMemoryError</td>
</tr>
<tr>
<td>方法区</td>
<td>线程共享，生命周期与虚拟机相同，可以不使用连续的内存地址</td>
<td>存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据</td>
<td>-XX:PermSize:16M -XX:MaxPermSize64M / -XX:MetaspaceSize=16M -XX:MaxMetaspaceSize=64M</td>
<td>OutOfMemoryError</td>
</tr>
<tr>
<td>本地方法栈</td>
<td>线程私有</td>
<td>为虚拟机使用到的 Native 方法服务</td>
<td>无</td>
<td>StackOverflowError/OutOfMemoryError</td>
</tr>
</tbody></table>
<h4 id="1-7和1-8之间JVM内存结构以及它们的差异"><a href="#1-7和1-8之间JVM内存结构以及它们的差异" class="headerlink" title="1.7和1.8之间JVM内存结构以及它们的差异"></a>1.7和1.8之间JVM内存结构以及它们的差异</h4><p>事实上，移除永久代的工作是从 JDK 1.7开始的。在 JDK 1.7中，存储在永久生成中的部分数据已经转移到 Java 堆或本机堆。</p>
<p>然而，JDK 1.7中的永久代仍然存在，并且没有被完全删除。</p>
<p>例如，将符号引用转移到本机堆; 将类的文本变量(内嵌字符串)和静态变量转移到 Java 堆。</p>
<p>JDK 1.8 同 JDK 1.7 比，最大的差别就是：元数据区取代了永久代。元空间的本质和永久代类似，都是对 JVM 规范中方法区的实现。</p>
<p>不过元空间与永久代之间最大的区别在于：元数据区并不在虚拟机中，而是使用本地内存。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gjk6ksulhlj31920mctca.jpg"></p>
<blockquote>
<p>方法区是java虚拟机规范中定义的一种概念上的区域，不同的厂商可以对虚拟机进行不同的实现。我们通常使用的Java SE都是由Sun JDK和OpenJDK所提供，这也是应用最广泛的版本。而该版本使用的VM就是HotSpot VM。通常情况下，我们所讲的java虚拟机指的就是HotSpot的版本</p>
</blockquote>
<ul>
<li><p>PermGen(永久代)</p>
<p>Java7及以前版本的Hotspot中方法区位于永久代中。同时，永久代和堆是相互隔离的，但它们使用的物理内存是连续的，永久代的垃圾收集是和老年代捆绑在一起的，因此无论谁满了，都会触发永久代和老年代的垃圾收集。</p>
<p>Java7中永久代中存储的部分数据已经开始转移到Java Heap或Native Memory中了。比如，符号引用(Symbols)转移到了Native Memory；字符串常量池(interned strings)转移到了Java Heap；类的静态变量(class statics)转移到了Java Heap。</p>
<p>绝大部分Java程序员应该都见过java.lang.OutOfMemoryError: PremGen space异常。这里的PermGen space其实指的就是方法区。不过方法区和PermGen space又有着本质的区别。前者是JVM的规范，而后者则是JVM规范的一种实现，并且只有HotSpot才有PermGen space，而对于其他类型的虚拟机，如JRockit(Oracle)、J9(IBM)并没有PermGen space。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出。并且JDK 1.8中永久代的参数PermSize和MaxPermSize已经失效。</p>
</li>
<li><p>Metaspace(元空间)</p>
<p>对于Java8，HotSpot取消了永久代，那么是不是就没有方法区了呢？当然不是，方法区只是一个规范，只不过它的实现变了。</p>
<p>在Java8中，元空间(Metaspace)登上舞台，方法区存在于元空间(Metaspace)。同时，元空间不再与堆连续，而且是存在于本地内存（Native memory）。</p>
<p>JDK1.7后对JVM架构进行了改造，将类元数据放到本地内存中，另外，将字符串常量池和静态变量放到Java堆里。HotSpot VM将会为类的元数据明确分配和释放本地内存。在这种架构下，类元信息就突破了原来 -XX:MaxPermSize的限制，现在可以使用更多的本地内存。这样就从一定程度上解决了原来在运行时生成大量类造成经常Full GC问题，如运行时使用反射、代理等。所以升级以后Java堆空间可能会增加。</p>
<p>元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间的最大区别在于：元空间并不在虚拟机中，而是使用本地内存。本地内存（Native memory），也称为C-Heap，是供JVM自身进程使用的。当Java Heap空间不足时会触发GC，但Native memory空间不够却不会触发GC。默认情况下元空间是可以无限使用本地内存的，但为了不让它如此膨胀，JVM同样提供了参数来限制它使用的使用。</p>
<p>-XX:MetaspaceSize，class metadata的初始空间配额，以bytes为单位，达到该值就会触发垃圾收集进行类型卸载，同时GC会对该值进行调整：如果释放了大量的空间，就适当的降低该值；如果释放了很少的空间，那么在不超过MaxMetaspaceSize（如果设置了的话），适当的提高该值。</p>
<p>-XX：MaxMetaspaceSize，可以为class metadata分配的最大空间。默认是没有限制的。</p>
<p>-XX：MinMetaspaceFreeRatio,在GC之后，最小的Metaspace剩余空间容量的百分比，减少为class metadata分配空间导致的垃圾收集。</p>
<p>-XX:MaxMetaspaceFreeRatio,在GC之后，最大的Metaspace剩余空间容量的百分比，减少为class metadata释放空间导致的垃圾收集。</p>
</li>
<li><p>对于方法区，Java8之后的变化</p>
<p>移除了永久代（PermGen），替换为元空间（Metaspace）</p>
<p>永久代中的class metadata（类元信息）转移到了native memory（本地内存，而不是虚拟机）</p>
<p>永久代中的interned Strings（字符串常量池） 和 class static variables（类静态变量）转移到了Java heap</p>
<p>永久代参数（PermSize MaxPermSize）-&gt; 元空间参数（MetaspaceSize MaxMetaspaceSize</p>
</li>
<li><p>Java8为什么要将永久代替换成Metaspace？</p>
<p>字符串存在永久代中，容易出现性能问题和内存溢出。</p>
<p>类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困 难，太小容易出现永久代溢出，太大则容易导致老年代溢出。</p>
<p>永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。</p>
</li>
</ul>
<h4 id=""><a href="#" class="headerlink" title=""></a></h4>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title>zookeeper 安装教程</title>
    <url>/2020/06/29/kafka-2020-06-29-zookeeper-mac%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="brew安装"><a href="#brew安装" class="headerlink" title="brew安装"></a>brew安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install zookeeper</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x3D;&#x3D;&gt; Downloading https:&#x2F;&#x2F;homebrew.bintray.com&#x2F;bottles&#x2F;zookeeper-3.4.13.mojave.bottle.tar.gz</span><br><span class="line">&#x3D;&#x3D;&gt; Downloading from https:&#x2F;&#x2F;akamai.bintray.com&#x2F;d1&#x2F;d1e4e7738cd147dceb3d91b32480c20ac5da27d129905f336ba51c0c01b8a476?__gd</span><br><span class="line">######################################################################## 100.0%</span><br><span class="line">&#x3D;&#x3D;&gt; Pouring zookeeper-3.4.13.mojave.bottle.tar.gz</span><br><span class="line">&#x3D;&#x3D;&gt; Caveats</span><br><span class="line">To have launchd start zookeeper now and restart at login:</span><br><span class="line">  brew services start zookeeper</span><br><span class="line">Or, if you don&#39;t want&#x2F;need a background service you can just run:</span><br><span class="line">  zkServer start</span><br><span class="line">&#x3D;&#x3D;&gt; Summary</span><br><span class="line">🍺  &#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;zookeeper&#x2F;3.4.13: 244 files, 33.4MB</span><br></pre></td></tr></table></figure>
<p>查看zookeeper 信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">brew info zookeeper</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">zookeeper: stable 3.4.13 (bottled), HEAD</span><br><span class="line">Centralized server for distributed coordination of services</span><br><span class="line">https:&#x2F;&#x2F;zookeeper.apache.org&#x2F;</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;zookeeper&#x2F;3.4.13 (244 files, 33.4MB) *</span><br><span class="line">  Poured from bottle on 2020-06-30 at 17:51:47</span><br><span class="line">From: https:&#x2F;&#x2F;github.com&#x2F;Homebrew&#x2F;homebrew-core&#x2F;blob&#x2F;master&#x2F;Formula&#x2F;zookeeper.rb</span><br><span class="line">&#x3D;&#x3D;&gt; Options</span><br><span class="line">--HEAD</span><br><span class="line">	Install HEAD version</span><br><span class="line">&#x3D;&#x3D;&gt; Caveats</span><br><span class="line">To have launchd start zookeeper now and restart at login:</span><br><span class="line">  brew services start zookeeper</span><br><span class="line">Or, if you don&#39;t want&#x2F;need a background service you can just run:</span><br><span class="line">  zkServer start</span><br><span class="line">&#x3D;&#x3D;&gt; Analytics</span><br><span class="line">install: 7,043 (30 days), 21,263 (90 days), 79,252 (365 days)</span><br><span class="line">install_on_request: 2,192 (30 days), 6,831 (90 days), 25,814 (365 days)</span><br><span class="line">build_error: 0 (30 days)</span><br></pre></td></tr></table></figure>
<p>brew nstall 完成之后 对应配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;etc&#x2F;zookeeper</span><br><span class="line">chengkejundeMacBook-Pro:zookeeper c.kj$ ls</span><br><span class="line">defaults		log4j.properties	zoo.cfg			zoo_sample.cfg</span><br><span class="line">chengkejundeMacBook-Pro:zookeeper c.kj$</span><br></pre></td></tr></table></figure>
<p>修改 zoo.cfg 搭建集群修改这些配置 因为只需要搭建一个伪集群所以没有修改其中参数，感兴趣的可以自己搜索一些教程～</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime&#x3D;2000</span><br><span class="line"># The number of ticks that the initial</span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit&#x3D;10</span><br><span class="line"># The number of ticks that can pass between</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit&#x3D;5</span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use &#x2F;tmp for storage, &#x2F;tmp here is just</span><br><span class="line"># example sakes.</span><br><span class="line">dataDir&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;zookeeper&#x2F;data</span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort&#x3D;2181</span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns&#x3D;60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the</span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http:&#x2F;&#x2F;zookeeper.apache.org&#x2F;doc&#x2F;current&#x2F;zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir</span><br><span class="line">#autopurge.snapRetainCount&#x3D;3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature</span><br><span class="line">#autopurge.purgeInterval&#x3D;1</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>为了能够在任意目录启动zookeeper集群，我们需要配置环境变量.<br> <br> ps:你也可以不配，这不是搭建集群的必要操作，只不过如果你不配置环境变量，那么每次启动zookeeper需要到安装文件的 bin 目录下去启动。<br> <br> 配置如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">chengkejundeMacBook-Pro:data c.kj$ open -e ~&#x2F;.bash_profile</span><br><span class="line">chengkejundeMacBook-Pro:data c.kj$ cat ~&#x2F;.bash_profile</span><br><span class="line">export M3_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;mvn&#x2F;apache-maven-3.3.9</span><br><span class="line">export GRADLE_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;gradle&#x2F;5.2.1</span><br><span class="line">export SCALA_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;scala&#x2F;2.12.8</span><br><span class="line">export ZK_HOME&#x3D;&#x2F;usr&#x2F;local&#x2F;Cellar&#x2F;zookeeper&#x2F;3.4.13</span><br><span class="line">export PATH&#x3D;$M3_HOME&#x2F;bin:$PATH:$GRADLE_HOME&#x2F;bin:$SCALA_HOME&#x2F;bin:$ZK_HOME&#x2F;binchengkejundeMacBook-Pro:data c.kj$</span><br><span class="line">chengkejundeMacBook-Pro:data c.kj$</span><br><span class="line">chengkejundeMacBook-Pro:data c.kj$ source ~&#x2F;.bash_profile</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动命令：<br><code>zkServer start</code></p>
<p>停止命令：<br><code>zkServer stop</code></p>
<p>重启命令：<br><code>zkServer restart</code></p>
<p>查看集群节点状态：<br><code>zkServer status</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">chengkejundeMacBook-Pro:~ c.kj$ zkServer start</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: &#x2F;usr&#x2F;local&#x2F;etc&#x2F;zookeeper&#x2F;zoo.cfg</span><br><span class="line">Starting zookeeper ... already running as process 49422.</span><br><span class="line">chengkejundeMacBook-Pro:~ c.kj$ zkServer status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: &#x2F;usr&#x2F;local&#x2F;etc&#x2F;zookeeper&#x2F;zoo.cfg</span><br><span class="line">Mode: standalone</span><br><span class="line">chengkejundeMacBook-Pro:~ c.kj$</span><br></pre></td></tr></table></figure>
<p>end ~</p>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解kafka系列-生产者</title>
    <url>/2020/07/01/kafka-2020-06-30-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3kafka%E7%B3%BB%E5%88%97-%E7%94%9F%E4%BA%A7%E8%80%85/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><blockquote>
<p>整个Kafka体系结构中引入了以下3个术语。</p>
</blockquote>
<p> （1）Producer：生产者，也就是发送消息的一方。生产者负责创建消息，然后将其投递到Kafka中。</p>
<p> （2）Consumer：消费者，也就是接收消息的一方。消费者连接到Kafka上并接收消息，进而进行相应的业务逻辑处理。</p>
<span id="more"></span>
<p> （3）Broker：服务代理节点。对于Kafka而言，Broker可以简单地看作一个独立的Kafka服务节点或Kafka服务实例。大多数情况下也可以将Broker看作一台Kafka服务器，前提是这台服务器上只部署了一个Kafka实例。一个或多个Broker组成了一个Kafka集群。一般而言，我们更习惯使用首字母小写的broker来表示服务代理节点。</p>
<p>  在Kafka中还有两个特别重要的概念—主题（Topic）与分区（Partition）。Kafka中的消息以主题为单位进行归类，生产者负责将消息发送到特定的主题（发送到Kafka集群中的每一条消息都要指定一个主题），而消费者负责订阅主题并进行消费。</p>
<p>  主题是一个逻辑上的概念，它还可以细分为多个分区，一个分区只属于单个主题，很多时候也会把分区称为主题分区（Topic-Partition）。同一主题下的不同分区包含的消息是不同的，分区在存储层面可以看作一个可追加的日志（Log）文件，消息在被追加到分区日志文件的时候都会分配一个特定的偏移量（offset）。offset是消息在分区中的唯一标识，Kafka通过它来保证消息在分区内的顺序性，不过offset并不跨越分区，也就是说，Kafka保证的是分区有序而不是主题有序。如图所示，主题中有 4 个分区，消息被顺序追加到每个分区日志文件的尾部。Kafka中的分区可以分布在不同的服务器（broker）上，也就是说，一个主题可以横跨多个broker，以此来提供比单个broker更强大的性能。</p>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggao5l941cj30u00km0zz.jpg"></p>
<h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><blockquote>
<p>消息在真正发往Kafka之前，有可能需要经历拦截器（Interceptor）、序列化器（Serializer）和分区器（Partitioner）等一系列的作用，那么在此之后又会发生什么呢？下面我们来看一下生产者客户端的整体架构.</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggall9855yj30wk0qsh18.jpg"></p>
<h4 id="producer-流程："><a href="#producer-流程：" class="headerlink" title="producer 流程："></a>producer 流程：</h4><p>  整个生产者客户端由两个线程协调运行，这两个线程分别为主线程和Sender线程（发送线程）。</p>
<p>  在主线程中由KafkaProducer创建消息，然后通过可能的拦截器、序列化器和分区器的作用之后缓存到消息累加器（RecordAccumulator，也称为消息收集器）中。</p>
<p>  Sender 线程负责从RecordAccumulator中获取消息并将其发送到Kafka中。</p>
<h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>   <font color=#C7063  size=3>生产者拦截器</font> 可以用来在消息发送前做一些准备工作，比如按照某个规则过滤不符合要求的消息、修改消息的内容等，也可以用来在发送回调逻辑前做一些定制化的需求，比如统计类工作。生产者拦截器的使用也很方便，主要是自定义实现 org.apache.kafka.clients.producer.ProducerInterceptor接口。ProducerInterceptor接口中包含3个方法<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggaombbbfoj31bk0u0ncu.jpg"></p>
<p>KafkaProducer() 在将消息序列化和计算分区之前会调用生产者拦截器的onSend（）方法来对消息进行相应的定制化操作。</p>
<p>KafkaProducer() 在消息被应答（Acknowledgement）之前或消息发送失败时调用生产者拦截器的onAcknowledgement（）方法，优先于用户设定的 Callback 之前执行。</p>
<p>close() 主要用于在关闭拦截器时执行一些资源的清理工作。在这 3 个方法中抛出的异常都会被捕获并记录到日志中，但并不会再向上传递。</p>
<p>  <font color=#C7063  size=3>序列化器</font> 生产者需要用序列化器（Serializer) 把对象转换成字节数组才能通过网络发送给Kafka，消费者需要用反序列化器（Deserializer）把从 Kafka 中收到的字节数组转换成相应的对象,Serializer接口中包含3个方法</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggapcp91uuj31tq0qg113.jpg"></p>
<p>configure() 方法用来配置当前类</p>
<p>serialize() 方法用来执行序列化操作</p>
<p>close() 方法用来关闭当前的序列化器，一般情况下 close（）是一个空方法，如果实现了此方法，则必须确保此方法的幂等性，因为这个方法很可能会被KafkaProducer调用多次。</p>
<p><font color=#C7063  size=3>分区器</font> 分区器的作用就是为消息分配分区。序列化器是必需的。消息经过序列化之后就需要确定它发往的分区，如果消息ProducerRecord中指定了partition字段，那么就不需要分区器的作用，因为partition代表的就是所要发往的分区号。</p>
<h4 id="消息累加器-RecordAccumulator"><a href="#消息累加器-RecordAccumulator" class="headerlink" title="消息累加器 RecordAccumulator"></a>消息累加器 RecordAccumulator</h4><p> RecordAccumulator 主要用来缓存消息以便 Sender 线程可以批量发送，进而减少网络传输的资源消耗以提升性能。RecordAccumulator 缓存的大小可以通过生产者客户端参数buffer.memory 配置，默认值为 32MB。<br>  如果生产者发送消息的速度超过发送到服务器的速度，则会导致生产者空间不足，这个时候KafkaProducer的send（）方法调用要么被阻塞，要么抛出异常，这个取决于参数max.block.ms的配置，此参数的默认值为60000，即60秒。</p>
<p> 主线程中发送过来的消息都会被追加到RecordAccumulator的某个双端队列（Deque）中，在RecordAccumulator 的内部为每个分区都维护了一个双端队列，队列中的内容就是ProducerBatch，即 Deque＜ProducerBatch＞。消息写入缓存时，追加到双端队列的尾部；Sender读取消息时，从双端队列的头部读取。注意ProducerBatch不是ProducerRecord，ProducerBatch中可以包含一至多个 ProducerRecord。</p>
<p> 通俗地说，ProducerRecord 是生产者中创建的消息，而ProducerBatch是指一个消息批次，ProducerRecord会被包含在ProducerBatch中，这样可以使字节的使用更加紧凑。与此同时，将较小的ProducerRecord拼凑成一个较大的ProducerBatch,也可以减少网络请求的次数以提升整体的吞吐量</p>
<h4 id="sender-线程"><a href="#sender-线程" class="headerlink" title="sender 线程"></a>sender 线程</h4><p> Sender 从 RecordAccumulator 中获取缓存的消息之后，会进一步将原本＜分区，Deque＜ProducerBatch＞＞的保存形式转变成＜Node，List＜ ProducerBatch＞的形式，其中Node表示Kafka集群的broker节点,Sender 还会进一步封装成＜Node，Request＞的形式，这样就可以将Request请求发往各个Node了，这里的Request是指Kafka的各种协议请求,请求在从Sender线程发往Kafka之前还会保存到InFlightRequests中，InFlightRequests保存对象的具体形式为Map＜NodeId，Deque＜Request＞＞<br> 它的主要作用是缓存了已经发出去但还没有收到响应的请求（NodeId 是一个 String 类型，表示节点的 id 编号)。</p>
<blockquote>
<p>原创不易，如果觉得有点用的话，请毫不留情点个赞，转发一下，这将是我持续输出优质文章的最强动力。</p>
</blockquote>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解kafka系列-消费者</title>
    <url>/2020/06/29/kafka-2020-06-31-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3kafka%E7%B3%BB%E5%88%97-%E6%B6%88%E8%B4%B9%E8%80%85/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>与生产者对应的是消费者，应用程序可以通过KafkaConsumer来订阅主题，并从订阅的主题中拉取消息。不过在使用KafkaConsumer消费消息之前需要先了解消费者和消费组的概念，否则无法理解如何使用KafkaConsumer。</p>
</blockquote>
<span id="more"></span>



<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul>
<li> 消费者（Consumer）负责订阅Kafka中的主题（Topic），并且从订阅的主题上拉取消息。与其他一些消息中间件不同的是：在Kafka的消费理念中还有一层消费组（Consumer Group）的概念，每个消费者都有一个对应的消费组。</li>
</ul>
<p>   当消息发布到主题后，只会被投递给订阅它的每个消费组中的一个消费者。如图所示，某个主题中共有4个分区（Partition）：P0、P1、P2、P3。有两个消费组A和B都订阅了这个主题，消费组A中有4个消费者（C0、C1、C2和C3），消费组B中有2个消费者（C4和C5）。按照Kafka默认的规则，最后的分配结果是消费组A中的每一个消费者分配到1个分区，消费组B中的每一个消费者分配到2个分区，两个消费组之间互不影响。每个消费者只能消费所分配到的分区中的消息。换言之，每一个分区只能被一个消费组中的一个消费者所消费。</p>
<p>   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcvc5xbflj30vw0fu45f.jpg"></p>
<h3 id="分区分配的演变（Rebalance）"><a href="#分区分配的演变（Rebalance）" class="headerlink" title="分区分配的演变（Rebalance）"></a>分区分配的演变（Rebalance）</h3><p>   我们再来看一下消费组内的消费者个数变化时所对应的分区分配的演变。假设目前某消费组内只有一个消费者C0，订阅了一个主题，这个主题包含 7 个分区：P0、P1、P2、P3、P4、P5、P6。也就是说，这个消费者C0订阅了7个分区，具体分配情形如图。</p>
<p>   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcw1dy1irj30v00n478h.jpg"></p>
<p>   消费者与消费组此时消费组内又加入了一个新的消费者C1，按照既定的逻辑，需要将原来消费者C0的部分分区分配给消费者C1消费，如下图所示。消费者C0和C1各自负责消费所分配到的分区，彼此之间并无逻辑上的干扰。</p>
<p>   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcw48m6p6j30w40nq0x8.jpg"></p>
<p>   紧接着消费组内又加入了一个新的消费者C2，消费者C0、C1和C2按照下图方式各自负责消费所分配到的分区。</p>
<p>   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcw48m6p6j30w40nq0x8.jpg"></p>
<p>   消费者与消费组这种模型可以让整体的消费能力具备横向伸缩性，我们可以增加（或减少）消费者的个数来提高（或降低）整体的消费能力。对于分区数固定的情况，一味地增加消费者并不会让消费能力一直得到提升，如果消费者过多，出现了消费者的个数大于分区个数的情况，就会有消费者分配不到任何分区。参考图如下，一共有8个消费者，7个分区，那么最后的消费者C7由于分配不到任何分区而无法消费任何消息。   </p>
<p>   <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcwbn8b1mj30vg0hudje.jpg"></p>
<h3 id="投递模式"><a href="#投递模式" class="headerlink" title="投递模式"></a>投递模式</h3><p>   以上分配逻辑都是基于默认的分区分配策略进行分析的，可以通过消费者客户端参数partition.assignment.strategy 来设置消费者与订阅主题之间的分区分配策略，有关分区分配的更多细节可以再接下来的系列继续聊。</p>
<p>   对于消息中间件而言，一般有两种消息投递模式：</p>
<p>   点对点（P2P，Point-to-Point）模式:  点对点模式是基于队列的，消息生产者发送消息到队列，消息消费者从队列中接收消息。</p>
<p>   发布/订阅（Pub/Sub）模式: 发布订阅模式定义了如何向一个内容节点发布和订阅消息，这个内容节点称为主题（Topic），主题可以认为是消息传递的中介，消息发布者将消息发布到某个主题，而消息订阅者从主题中订阅消息。主题使得消息的订阅者和发布者互相保持独立，不需要进行接触即可保证消息的传递，发布/订阅模式在消息的一对多广播时采用。</p>
<p>   Kafka 同时支持两种消息投递模式，而这正是得益于消费者与消费组模型的契合：</p>
<ul>
<li>如果所有的消费者都隶属于同一个消费组，那么所有的消息都会被均衡地投递给每一个消费者，即每条消息只会被一个消费者处理，这就相当于点对点模式的应用。</li>
<li> 如果所有的消费者都隶属于不同的消费组，那么所有的消息都会被广播给所有的消费者，即每条消息会被所有的消费者处理，这就相当于发布/订阅模式的应用</li>
</ul>
<p>   消费组是一个逻辑上的概念，它将旗下的消费者归为一类，每一个消费者只隶属于一个消费组。每一个消费组都会有一个固定的名称，消费者在进行消费前需要指定其所属消费组的名称，这个可以通过消费者客户端参数group.id来配置，默认值为空字符串。消费者并非逻辑上的概念，它是实际的应用实例，它可以是一个线程，也可以是一个进程。同一个消费组内的消费者既可以部署在同一台机器上，也可以部署在不同的机器上。</p>
<h3 id="创建一个Kafka消费者"><a href="#创建一个Kafka消费者" class="headerlink" title="创建一个Kafka消费者"></a>创建一个Kafka消费者</h3><ul>
<li>以下代码段显示了如何创建KafkaConsumer：</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Properties props &#x3D; new Properties();</span><br><span class="line">  props.put(&quot;bootstrap.servers&quot;, &quot;broker1:9092,broker2:9092&quot;);</span><br><span class="line">  props.put(&quot;group.id&quot;, &quot;CountryCounter&quot;);</span><br><span class="line">  props.put(&quot;key.deserializer&quot;,</span><br><span class="line">      &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">  props.put(&quot;value.deserializer&quot;,</span><br><span class="line">      &quot;org.apache.kafka.common.serialization.StringDeserializer&quot;);</span><br><span class="line">  </span><br><span class="line">  KafkaConsumer&lt;String, String&gt; consumer &#x3D;</span><br><span class="line">      new KafkaConsumer&lt;String, String&gt;(props);</span><br></pre></td></tr></table></figure>
<ul>
<li>订阅主题</li>
</ul>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(Collections.singletonList(&quot;customerCountries&quot;));</span><br></pre></td></tr></table></figure>
<ul>
<li>要订阅所有test主题，我们可以：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">consumer.subscribe(Pattern.compile(&quot;test.*&quot;));</span><br></pre></td></tr></table></figure>
<ul>
<li>轮询循环</li>
</ul>
<p>   消费者API的核心是一个简单的循环，用于轮询服务器以获取更多数据。<br>   一旦用户订阅了主题，轮询循环便会处理协调，分区重新平衡，心跳和数据获取的所有详细信息，从而为开发人员提供了一个干净的API，该API仅从分配的分区中返回可用数据。<br>   消费者的主体如下所示</p>
   <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    while (true) &#123; 1</span><br><span class="line">        ConsumerRecords&lt;String, String&gt; records &#x3D; consumer.poll(100); 2</span><br><span class="line">        for (ConsumerRecord&lt;String, String&gt; record : records) 3</span><br><span class="line">        &#123;</span><br><span class="line">            log.debug(&quot;topic &#x3D; %s, partition &#x3D; %d, offset &#x3D; %d,&quot;</span><br><span class="line">                customer &#x3D; %s, country &#x3D; %s\n&quot;,</span><br><span class="line">                record.topic(), record.partition(), record.offset(),</span><br><span class="line">                record.key(), record.value());</span><br><span class="line"></span><br><span class="line">            int updatedCount &#x3D; 1;</span><br><span class="line">            if (custCountryMap.countainsKey(record.value())) &#123;</span><br><span class="line">                updatedCount &#x3D; custCountryMap.get(record.value()) + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            custCountryMap.put(record.value(), updatedCount)</span><br><span class="line"></span><br><span class="line">            JSONObject json &#x3D; new JSONObject(custCountryMap);</span><br><span class="line">            System.out.println(json.toString(4)) 4</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    consumer.close(); 5</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>反序列化</li>
</ul>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class StringDeserializer implements Deserializer&lt;String&gt; &#123;</span><br><span class="line">    private String encoding &#x3D; &quot;UTF8&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void configure(Map&lt;String, ?&gt; configs, boolean isKey) &#123;</span><br><span class="line">        String propertyName &#x3D; isKey ? &quot;key.deserializer.encoding&quot; : &quot;value.deserializer.encoding&quot;;</span><br><span class="line">        Object encodingValue &#x3D; configs.get(propertyName);</span><br><span class="line">        if (encodingValue &#x3D;&#x3D; null)</span><br><span class="line">            encodingValue &#x3D; configs.get(&quot;deserializer.encoding&quot;);</span><br><span class="line">        if (encodingValue instanceof String)</span><br><span class="line">            encoding &#x3D; (String) encodingValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String deserialize(String topic, byte[] data) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (data &#x3D;&#x3D; null)</span><br><span class="line">                return null;</span><br><span class="line">            else</span><br><span class="line">                return new String(data, encoding);</span><br><span class="line">        &#125; catch (UnsupportedEncodingException e) &#123;</span><br><span class="line">            throw new SerializationException(&quot;Error when deserializing byte[] to string due to unsupported encoding &quot; + encoding);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>消息消费</li>
</ul>
<p>  Kafka中的消费是基于拉模式的。消息的消费一般有两种模式：推模式和拉模式。推模式是服务端主动将消息推送给消费者，而拉模式是消费者主动向服务端发起请求来拉取消息。从轮询循环代码清单中可以看出，Kafka中的消息消费是一个不断轮询的过程，消费者所要做的就是重复地调用poll（）方法，而poll（）方法返回的是所订阅的主题（分区）上的一组消息。对于poll（）方法而言，如果某些分区中没有可供消费的消息，那么此分区对应的消息拉取的结果就为空；如果订阅的所有分区中都没有可供消费的消息，那么poll（）方法返回为空的消息集合。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggcyw50wbjj31nw0eeaib.jpg"></p>
<p>poll（long）方法中timeout的时间单位固定为毫秒，而poll（Duration）方法可以根据Duration中的ofMillis（）、ofSeconds（）、ofMinutes（）、ofHours（）等多种不同的方法指定不同的时间单位，灵活性更强。并且 poll（long）方法也已经被标注为@Deprecated，虽然目前还可以使用，如果条件允许的话，还是推荐使用poll（Duration）的方式。</p>
<p>我们在消费消息的时候可以直接对 ConsumerRecord 中感兴趣的字段进行具体的业务逻辑处理。</p>
<p>poll（）方法的返回值类型是 ConsumerRecords，它用来表示一次拉取操作所获得的消息集，内部包含了若干ConsumerRecord，它提供了一个iterator（）方法来循环遍历消息集内部的消息，iterator（）方法的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Iterator&lt;ConsumerRecord&lt;K, V&gt;&gt; iterator() &#123;</span><br><span class="line">    return new ConcatenatedIterable&lt;&gt;(records.values()).iterator();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>在 ConsumerRecords 类中还提供了几个方法来方便开发人员对消息集进行处理：count（）方法用来计算出消息集中的消息个数，返回类型是int；isEmpty（）方法用来判断消息集是否为空，返回类型是boolean；empty（）方法用来获取一个空的消息集，返回类型是ConsumerRecord＜K，V＞。</p>
<p>到目前为止，可以简单地认为poll（）方法只是拉取一下消息而已，但就其内部逻辑而言并不简单，它涉及消费位移、消费者协调器、组协调器、消费者的选举、分区分配的分发、再均衡的逻辑、心跳等内容</p>
<ul>
<li>位移提交</li>
</ul>
<p>  对于Kafka中的分区而言，它的每条消息都有唯一的offset，用来表示消息在分区中对应的位置。对于消费者而言，它也有一个offset的概念，消费者使用offset来表示消费到分区中某个消息所在的位置。单词“offset”可以翻译为“偏移量”，也可以翻译为“位移”，很多同学可能并没有过多地在意这一点：在很多中文资料中都会交叉使用“偏移量”和“位移”这两个词，并没有很严谨地进行区分。</p>
<p>  我对offset做了一些区分：对于消息在分区中的位置，我们将offset称为“偏移量”；对于消费者消费到的位置，将 offset 称为“位移”，有时候也会更明确地称之为“消费位移”。做这一区分的目的是让读者在遇到 offset 的时候可以很容易甄别出是在讲分区存储层面的内容，还是在讲消费层面的内容</p>
<p>  在每次调用poll（）方法时，它返回的是还没有被消费过的消息集（当然这个前提是消息已经存储在Kafka 中了，并且暂不考虑异常情况的发生），在旧消费者客户端中，消费位移是存储在ZooKeeper中的。而在新消费者客户端中，消费位移存储在Kafka内部的主题__consumer_offsets中。这里把将消费位移存储起来（持久化）的动作称为“提交”，消费者在消费完消息之后需要执行消费位移的提交。</p>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1ggd02ca45zj30w40f2q5a.jpg"></p>
<ul>
<li> 指定位移消费</li>
</ul>
<p>  正是有了消费位移的持久化，才使消费者在关闭、崩溃或者在遇到再均衡的时候，可以让接替的消费者能够根据存储的消费位移继续进行消费 ,可是有一个问题则是 _consumer_offsets 位移信息过期而被删除后，它也没有可以查找的消费位移 ，这个时候就会根据消费者客户端参数auto.offset.reset的配置来决定从何处开始进行消费</p>
<p>  除了查找不到消费位移，位移越界也会触发 auto.offset.reset 参数的执行 ，然而有些时候，我们需要一种更细粒度的掌控，可以让我们从特定的位移处开始拉取消息，哎 ！这个时候 KafkaConsumer 中的 seek（）方法正好提供了这个功能，让我们得以追前消费或回溯消费。seek（）方法的具体定义如下：</p>
  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public void seek(TopicPartition partition, long offset) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>seek（）方法为我们提供了从特定位置读取消息的能力，我们可以通过这个方法来向前跳过若干消息，也可以通过这个方法来向后回溯若干消息，这样为消息的消费提供了很大的灵活性</p>
<blockquote>
<p>原创不易，如果觉得有点用的话，请毫不留情点个赞，转发一下，这将是我持续输出优质文章的最强动力。</p>
</blockquote>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>深入了解kafka系列-主题</title>
    <url>/2020/07/03/kafka-2020-07-03-%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3kafka%E7%B3%BB%E5%88%97-%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote>
<p>主题和分区是Kafka 的两个核心概念，前面系列中讲述的生产者和消费者的设计理念所针对的都是主题和分区层面的操作。主题作为消息的归类，可以再细分为一个或多个分区，分区也可以看作对消息的二次归类。分区的划分不仅为Kafka提供了可伸缩性、水平扩展的功能，还通过多副本机制来为Kafka提供数据冗余以提高数据可靠性。</p>
</blockquote>
<p>从Kafka的底层实现来说，主题和分区都是逻辑上的概念，分区可以有一至多个副本，每个副本对应一个日志文件，每个日志文件对应一至多个日志分段（LogSegment），每个日志分段还可以细分为索引文件、日志存储文件和快照文件等。不过对于使用Kafka进行消息收发的普通用户而言，了解到分区这一层面足以应对大部分的使用场景,这里暂时只说到主题和分区,更底层的内容会在后续这个系列持续讲解~</p>
<span id="more"></span>


<h3 id="主题的管理"><a href="#主题的管理" class="headerlink" title="主题的管理"></a>主题的管理</h3><p>主题的管理包括创建主题、查看主题信息、修改主题和删除主题等操作。可以通过 Kafka提供的 kafka-topics.sh脚本来执行这些操作，这个脚本位于$KAFKA_HOME/bin/目录下，其核心代码仅有一行，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">exec $(dirname $0)&#x2F;kafka-run-class.sh kafka.admin.TopicCommand &quot;$@&quot;</span><br></pre></td></tr></table></figure>

<p>当然主题的管理并非只有使用 kafka-topics.sh 脚本这一种方式，我们还可以通过KafkaAdminClient 的方式实现（这种方式实质上是通过发送 CreateTopicsRequest、DeleteTopicsRequest 等请求来实现的,甚至我们还可以通过直接操纵日志文件和ZooKeeper节点来实现,这个后续我会单独抽出来放在这个系列继续讲解~</p>
<ul>
<li>1 创建主题</li>
</ul>
<p> 如果broker端配置参数auto.create.topics.enable设置为true（默认值就是true），那么当生产者向一个尚未创建的主题发送消息时，会自动创建一个分区数为num.partitions （默认值为1）、副本因子为default.replication.factor（默认值为1）的主题。不建议这样操作,topic 未知难以维护,建议下面这种方式:</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --create --zookeeper localhost:2181&#x2F;kafka100 --topic topic-create --replication-factor 2 --partitions 4</span><br></pre></td></tr></table></figure>
<p> 上面的示例中创建了一个分区数为 4、副本因子为 2 的主题.</p>
<p> 三个broker节点一共创建了8个文件夹，这个数字8实质上是分区数4与副本因子2的乘积。每个副本（或者更确切地说应该是日志，副本与日志一一对应）才真正对应了一个命名形式如＜topic＞-＜partition＞的文件夹。主题、分区、副本和 Log（日志）的关系如图所示</p>
<p> <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gghbnbj175j30wi082adz.jpg"></p>
<p>同一个分区中的多个副本必须分布在不同的broker中，这样才能提供有效的数据冗余。对于示例中的分区数为4、副本因子为2、broker数为3的情况下，按照2、3、3的分区副本个数分配给各个broker是最优的选择。再比如在分区数为3、副本因子为3，并且broker数同样为3的情况下，分配3、3、3的分区副本个数给各个broker是最优的选择，也就是每个broker中都拥有所有分区的一个副本。</p>
<ul>
<li>2 分区副本的分配</li>
</ul>
<p>这里的分区分配是指为集群制定创建主题时的分区副本分配方案，即在哪个broker中创建哪些分区的副本<br>在创建主题时，如果使用了replica-assignment参数，那么就按照指定的方案来进行分区副本的创建；如果没有使用replica-assignment参数，那么就需要按照内部的逻辑来计算分配方案了。使用kafka-topics.sh脚本创建主题时的内部分配逻辑按照机架信息划分成两种策略：未指定机架信息和指定机架信息。如果集群中所有的 broker节点都没有配置broker.rack参数，或者使用disable-rack-aware参数来创建主题，那么采用的就是未指定机架信息的分配策略，否则采用的就是指定机架信息的分配策略</p>
<ul>
<li>3 查看主题</li>
</ul>
<p>kafka-topics.sh脚本有5种指令类型：create、list、describe、alter和delete。其中list和describe指令可以用来方便地查看主题信息,通过list指令可以查看当前所有可用的主题，示例如下:<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --zookeeper localhost:2181 --list</span><br></pre></td></tr></table></figure><br> 查看指定topic信息<br> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bin&#x2F;kafka-topics.sh --zookeeper localhost:2181 --describe --topic topic-create</span><br></pre></td></tr></table></figure></p>
<ul>
<li>4 修改主题</li>
</ul>
<p>当一个主题被创建之后，依然允许我们对其做一定的修改，比如修改分区个数、修改配置等，这个修改的功能就是由kafka-topics.sh脚本中的alter指令提供的。我们首先来看如何增加主题的分区数。以前面的主题topic-config为例，当前分区数为1，修改为3，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># bin&#x2F;kafka-topics.sh --zookeeper localhost:2181&#x2F;kafka --alter --topic topic-config --partitions 3</span><br><span class="line">WARNING: If partitions are increased for a topic that has a key, the partition logic or ordering of the messages will be affected</span><br><span class="line">Adding partitions succeeded!</span><br><span class="line"> </span><br><span class="line"># bin&#x2F;kafka-topics.sh --zookeeper localhost:2181&#x2F;kafka --describe --topic topic-create</span><br><span class="line">Topic:topic-config    PartitionCount:3  ReplicationFactor:1   Configs:</span><br><span class="line">Topic: topic-config    Partition: 0 Leader: 2    Replicas: 2  Isr: 2</span><br><span class="line">Topic: topic-config    Partition: 1 Leader: 0    Replicas: 0  Isr: 0</span><br><span class="line">Topic: topic-config    Partition: 2 Leader: 1    Replicas: 1  Isr: 1</span><br></pre></td></tr></table></figure>
<p>当主题中的消息包含key时（即key不为null），根据key计算分区的行为就会受到影响,对于基于key计算的主题而言，建议在一开始就设置好分区数量，避免以后对其进行调整。目前Kafka只支持增加分区数而不支持减少分区数.</p>
<ul>
<li>5 删除主题</li>
</ul>
<p>如果确定不再使用一个主题，那么最好的方式是将其删除，这样可以释放一些资源，比如磁盘、文件句柄等。kafka-topics.sh脚本中的delete指令就可以用来删除主题，比如删除一个主题topic-delete.</p>
<h3 id="初识KafkaAdminClient"><a href="#初识KafkaAdminClient" class="headerlink" title="初识KafkaAdminClient"></a>初识KafkaAdminClient</h3><p>一般情况下，我们都习惯使用kafka-topics.sh脚本来管理主题，但有时候我们希望将主题管理类的功能集成到公司内部的系统中，打造集管理、监控、运维、告警为一体的生态平台.</p>
<p>KafkaAdminClient继承了org.apache.kafka.clients.admin.AdminClient抽象类，并提供了多种方法。篇幅限制，下面只列出与本章内容相关的一些方法。</p>
<ul>
<li> 创建主题：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreateTopicsResult createTopics（Collection＜NewTopic＞newTopics）</span><br></pre></td></tr></table></figure>

<ul>
<li> 删除主题：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DeleteTopicsResult deleteTopics（Collection＜String＞topics）。</span><br></pre></td></tr></table></figure>

<ul>
<li> 列出所有可用的主题：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ListTopicsResult listTopics（）。</span><br></pre></td></tr></table></figure>

<ul>
<li> 查看主题的信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DescribeTopicsResult describeTopics（Collection＜String＞topicNames）</span><br></pre></td></tr></table></figure>

<ul>
<li> 查询配置信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DescribeConfigsResult describeConfigs（Collection＜ConfigResource＞resources）</span><br></pre></td></tr></table></figure>

<ul>
<li>修改配置信息：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">AlterConfigsResult alterConfigs（Map＜ConfigResource，Config＞configs）</span><br></pre></td></tr></table></figure>

<ul>
<li>增加分区：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CreatePartitionsResult createPartitions（Map＜String，NewPartitions＞newPartitions）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原创不易，如果觉得有点用的话，请毫不留情点个赞，转发一下，这将是我持续输出优质文章的最强动力。</p>
</blockquote>
]]></content>
      <categories>
        <category>kafka</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring5-Reactor函数式编程</title>
    <url>/2020/07/10/kafka-2020-07-10-Spring5-Reactor%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>反应式编程是一种可以替代命令式编程的编程范式。这种可替代性存在的原因在于反应式编程解决了命令式编程中的一些限制。理解这些限制，有助于你更好地理解反应式编程模型的优点</p>
<span id="more"></span>

<h3 id="反应式流规范"><a href="#反应式流规范" class="headerlink" title="反应式流规范"></a>反应式流规范</h3><ul>
<li>对比 Java 中的流</li>
</ul>
<p>  Java的流和反应式流Java的流和反应式流之间有很多相似之处。首先，它们的名字中都有流（Stream）这个词。</p>
<p>  它们还提供了用于处理数据的函数式API。事实上，正如你稍后将会在介绍Reactor时看到的那样，它们甚至可以共享许多相同的操作。</p>
<p>  Java的流通常都是同步的，并且只能处理有限的数据集。从本质上来说，它们只是使用函数来对集合进行迭代的一种方式。</p>
<p>  反应式流支持异步处理任意大小的数据集，同样也包括无限数据集。只要数据就绪，它们就能实时地处理数据，并且能够通过回压来避免压垮数据的消费者。</p>
<ul>
<li>反应式流规范</li>
</ul>
<p>  反应式流规范可以总结为4个接口：Publisher、Subscriber、Subscription和Processor。</p>
<p>  Publisher负责生成数据，并将数据发送给Subscription（每个Subscriber对应一个Subscription）。</p>
<p>  Publisher接口声明了一个方法subscribe()，Subscriber可以通过该方法向Publisher发起订阅。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface Publisher&lt;T&gt; &#123;</span><br><span class="line">    void subscribe(Subscriber&lt;? super T&gt; var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public interface Publisher&lt;T&gt; &#123;</span><br><span class="line">    void subscribe(Subscriber&lt;? super T&gt; var1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Subscriber&lt;T&gt; &#123;</span><br><span class="line">    void onSubscribe(Subscription var1);</span><br><span class="line"></span><br><span class="line">    void onNext(T var1);</span><br><span class="line"></span><br><span class="line">    void onError(Throwable var1);</span><br><span class="line"></span><br><span class="line">    void onComplete();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Subscription &#123;</span><br><span class="line">    void request(long var1);</span><br><span class="line"></span><br><span class="line">    void cancel();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public interface Processor&lt;T, R&gt; extends Subscriber&lt;T&gt;, Publisher&lt;R&gt; &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="初识Reactor"><a href="#初识Reactor" class="headerlink" title="初识Reactor"></a>初识Reactor</h3><p>Reactor项目是反应式流规范的一个实现，提供了一组用于组装反应式流的函数式API。</p>
<p>反应式编程要求我们采取和命令式编程不一样的思维方式。此时我们不会再描述每一步要进行的步骤，反应式编程意味着要构建数据将要流经的管道。当数据流经管道时，可以对它们进行某种形式的修改或者使用。</p>
<p>命令式编程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String a &#x3D; &quot;Apple&quot;;</span><br><span class="line">String s &#x3D; a.toUpperCase();</span><br><span class="line">String s1 &#x3D; &quot;hello&quot; + s + &quot;!&quot;;</span><br><span class="line">System.out.println(s1);</span><br></pre></td></tr></table></figure>

<p>反应式编程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  Mono.just(&quot;Apple&quot;)</span><br><span class="line"> .map(String::toUpperCase)</span><br><span class="line"> .map(x-&gt; &quot;hello&quot; + x + &quot;!&quot;)</span><br><span class="line"> .subscribe(System.out::println);</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;  </span><br><span class="line">控制台：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>helloAPPLE!<br>14:36:38.685 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>helloAPPLE!</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">这个例子中的Mono是Reactor的两种核心类型之一，另一个类型是Flux。两者都实现了反应式流的Publisher接口。Flux代表具有零个、一个或者多个（可能是无限个）数据项的管道.</span><br><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlgy1gglvncheldj31aw0jcai2.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 添加Reactor依赖</span><br><span class="line"></span><br><span class="line">要开始使用Reactor，请将下面的依赖项添加到项目的构建文件中：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre><code>    &lt;!--reactor core--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-core&lt;/artifactId&gt;
&lt;/dependency&gt;
    &lt;!--reactor test--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;io.projectreactor&lt;/groupId&gt;
    &lt;artifactId&gt;reactor-test&lt;/artifactId&gt;
    &lt;version&gt;3.2.6.RELEASE&lt;/version&gt;
    &lt;scope&gt;compile&lt;/scope&gt;
&lt;/dependency&gt;
    
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">### 使用常见的反应式操作</span><br><span class="line"></span><br><span class="line">Flux和Mono是Reactor提供的最基础的构建块，而这两种反应式类型所提供的操作符则是组合使用它们以构建数据流动管线的黏合剂。</span><br><span class="line"></span><br><span class="line">Flux和Mono共有500多个操作，这些操作都可以大致归类为：</span><br><span class="line"></span><br><span class="line">•创建操作；</span><br><span class="line"></span><br><span class="line">•组合操作；</span><br><span class="line"></span><br><span class="line">•转换操作；</span><br><span class="line"></span><br><span class="line">•逻辑操作。</span><br><span class="line"></span><br><span class="line">* 1 创建</span><br><span class="line">		</span><br></pre></td></tr></table></figure>

<pre><code>   Flux&lt;String&gt; fruitFlux = Flux.just(&quot;Apple&quot;,&quot;Orange&quot;);

   fruitFlux.subscribe(System.out::println);
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这里传递给subscribe()方法的lambda表达式实际上是一个java.util.Consumer，用来创建反应式流的Subscriber。在调用subscribe()之后，数据会开始流动。在这个例子中，没有中间操作，所以数据从Flux直接流向订阅者</span><br><span class="line"></span><br><span class="line">要验证预定义的数据是否流经了fruitFlux，我们可以编写如下所示的测试代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<pre><code>   StepVerifier.create(fruitFlux)
   .expectNext(&quot;Apple&quot;)
   .expectNext(&quot;Orange&quot;)
   .verifyComplete();
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">在这个例子中，StepVerifier订阅了fruitFlux，然后断言Flux中的每个数据项是否与预期的水果名称相匹配。最后，它验证Flux在发布完“Strawberry”之后，整个fruitFlux正常完成。</span><br><span class="line"></span><br><span class="line">还可以从数组 集合 Java Stream来作为Flux的源。</span><br></pre></td></tr></table></figure>
<pre><code>  List&lt;String&gt; list = Lists.newArrayList();
    list.add(&quot;Apple&quot;);
    list.add(&quot;Orange&quot;);
    Flux&lt;String&gt; stringFlux = Flux.fromIterable(list);
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlgy1gglweh3r7uj322k0u0ay8.jpg)</span><br><span class="line"></span><br><span class="line">例如，要创建一个每秒发布一个值的Flux，你可以使用Flux上的静态interval() 方法，如下所示：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>   Flux<Long> take = Flux.interval(Duration.ofSeconds(1)).take(5);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">通过interval()方法创建的Flux会从0开始发布值，并且后续的条目依次递增。此外，因为interval()方法没有指定最大值，所以它可能会永远运行。我们也可以使用take()方法将结果限制为前5个条目</span><br><span class="line"></span><br><span class="line">* 2 组合反应式类型</span><br><span class="line"></span><br><span class="line">有时候，我们会需要操作两种反应式类型，并以某种方式将它们合并在一起。或者，在其他情况下，我们可能需要将Flux拆分为多种反应式类型</span><br><span class="line"></span><br><span class="line">合并:</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  Flux<String> fruitFluxA = Flux.just(“Apple”,”Orange”);</p>
<p>  Flux<String> fruitFluxB = Flux.just(“Banana”,”watermelon”);</p>
<p>  fruitFluxA.mergeWith(fruitFluxB).subscribe(System.out::println);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p> com.ckj.superlearn.superlearn.base.ReactorStrategy<br>16:03:07.343 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>Apple<br>Orange<br>Banana<br>watermelon</p>
<p>Process finished with exit code 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlgy1gglzay93rfj30xs0esafw.jpg)</span><br><span class="line"></span><br><span class="line">mergeWith()方法不能完美地保证源Flux之间的先后顺序，所以我们可以考虑使用zip()方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>  Flux<String> fruitFluxA = Flux.just(“Apple”,”Orange”).delayElements(Duration.ofMillis(10));</p>
<p>  Flux<String> fruitFluxB = Flux.just(“Banana”,”watermelon”).delayElements(Duration.ofMillis(50));</p>
<p>  Flux<String> allFlux = fruitFluxA.mergeWith(fruitFluxB);</p>
<p>  allFlux.subscribe(x-&gt; System.out.println(“allFlux:”+x));</p>
<p>  Flux&lt;Tuple2&lt;String, String&gt;&gt; zip = Flux.zip(fruitFluxA, fruitFluxB);</p>
<p>  zip.subscribe(x-&gt; System.out.println(“zip:”+x));</p>
<p>  Thread.sleep(1000);</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">![](https:&#x2F;&#x2F;tva1.sinaimg.cn&#x2F;large&#x2F;007S8ZIlgy1gglzc3zljuj312k0fqq76.jpg)</span><br><span class="line"></span><br><span class="line">控制台：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>/com.ckj.superlearn.superlearn.base.ReactorStrategy<br>16:49:44.543 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>allFlux:Apple<br>allFlux:Orange<br>allFlux:Banana<br>zip:[Apple,Banana]<br>allFlux:watermelon<br>zip:[Orange,watermelon]</p>
<p>Process finished with exit code 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 3 转换和过滤反应式流</span><br><span class="line"></span><br><span class="line">针对具有多个数据项的Flux，skip操作将创建一个新的Flux，它会首先跳过指定数量的数据项，然后从源Flux中发布剩余的数据项。下面的测试方法展示如何使用skip()方法：</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  Flux<String> fruitFluxA = Flux.just(“Apple”,”Orange”,”Banana”,”watermelon”).skip(2);</p>
<pre><code>fruitFluxA.subscribe(x-&gt;&#123;

    System.out.println(x);

    &#125;);
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>/com.ckj.superlearn.superlearn.base.ReactorStrategy<br>17:05:00.141 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>Banana<br>watermelon</p>
<p>Process finished with exit code 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">与之对应相反的是take()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> Flux<String> fruitFluxA = Flux.just(“Apple”,”Orange”,”Banana”,”watermelon”).take(2);</p>
<pre><code>    fruitFluxA.subscribe(x-&gt;&#123;

        System.out.println(x);

    &#125;);
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<p> com.ckj.superlearn.superlearn.base.ReactorStrategy<br>17:20:59.483 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>Apple<br>Orange</p>
<p>Process finished with exit code 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">filter()的过滤效果</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  Flux<String> fruitFluxA = Flux.just(“Apple”,”Orange”,”Banana”,”watermelon”).take(2);</p>
<p>  fruitFluxA.filter(x-&gt;x.equals(“Apple”)).subscribe(x-&gt;{</p>
<pre><code> System.out.println(x);

 &#125;);
</code></pre>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>com.ckj.superlearn.superlearn.base.ReactorStrategy<br>17:24:03.242 [main] DEBUG reactor.util.Loggers$LoggerFactory - Using Slf4j logging framework<br>Apple</p>
<p>Process finished with exit code 0</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">如何使用flatMap()方法和subscribeOn()方法</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  Flux<String> fruitFluxA = Flux.just(“Apple”, “Orange”, “Banana”, “watermelon”, “Apple”, “Orange”, “Banana”,<br>                “watermelon”, “Apple”, “Orange”, “Banana”, “watermelon”, “Apple”, “Orange”, “Banana”, “watermelon”);</p>
<p>   fruitFluxA.flatMap(Mono::just).map(String::toUpperCase).subscribeOn(Schedulers.parallel());</p>
<pre><code>![](https://tva1.sinaimg.cn/large/007S8ZIlgy1ggm1rjb3naj31580kgguh.jpg)

使用flatMap()和subscribeOn()的好处是：我们可以在多个并行线程之间拆分工作，从而增加流的吞吐量。因为工作是并行完成的，无法保证哪项工作首先完成，所以结果Flux中数据项的发布顺序是未知的


  &gt; 原创不易，如果觉得有点用的话，请毫不留情点个赞，转发一下，这将是我持续输出优质文章的最强动力。
</code></pre>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux常用命令</title>
    <url>/2016/05/29/linux-2016-05-05-linux-cmd/</url>
    <content><![CDATA[<p>最近一段时间工作实在是太忙了，所以好久没有写文章了，趁着周末把linux 的相关知识，整理了下。这一篇文件主要记录了一些linux的基础命令。需要读者有linux服务器或者有mac电脑去练习。^`^.</p>
<span id="more"></span>

<p>###一、命令的基本格式</p>
<blockquote>
<p>[root@localhost~]</p>
<p>root为用户名</p>
<p>～表示当前所在位置</p>
<p>localhost主机名</p>
<p>‘#’超级用户</p>
<p>‘$”  普通用户</p>
</blockquote>
<p>命令的基本格式：</p>
<blockquote>
<p>命令  [选项]  [参数]</p>
</blockquote>
<h3 id="二、查询目录的内容"><a href="#二、查询目录的内容" class="headerlink" title="二、查询目录的内容"></a>二、查询目录的内容</h3><p>命令格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls [选项][文件或目录]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>选项：</p>
<p>-a 所有文件</p>
<p>-l  查看详情</p>
<p>-d查看目录属性</p>
<p>-h显示文件大小</p>
</blockquote>
<p>###三、文件处理命令</p>
<p>1、建立目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir -p [目录名]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>-p表述递归建文件夹</p>
</blockquote>
<p>举例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir japan</span><br><span class="line"></span><br><span class="line">mkdir -p japan&#x2F;cangjk</span><br></pre></td></tr></table></figure>

<p>2.切换目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd [目录]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>简化操作：</p>
<blockquote>
<p>cd~  进入当前用户目录</p>
<p>cd- 上次目录</p>
<p>cd.. 进入上一级目录</p>
<p>pwd查看当前目录所在位置</p>
</blockquote>
<p>3.删除目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir [目录]  </span><br></pre></td></tr></table></figure>
<blockquote>
<p>删除所有文件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm -rf [目录]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>删除目录所有文件</p>
</blockquote>
<p>4.复制目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp[选项][原文件目录][目标目录]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>选项：</p>
<p>-r复制目录</p>
<p>-p连文件属性一起复制</p>
<p>-a 相当于-pdr</p>
</blockquote>
<p>5.剪切、改名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv[原文件目录][目标文件目录]</span><br></pre></td></tr></table></figure>

<p>6.常见目录作用</p>
<blockquote>
<p>/ 根目录</p>
<p>/bin 命令保存目录</p>
<p>/boot  启动目录</p>
<p>/dev  设备文件命令</p>
<p>/etc  配置文件保存目录</p>
<p>/home  家目录</p>
<p>/lib  系统库保存命令</p>
<p>/mnt  系统挂载目录</p>
</blockquote>
<h3 id="三、文件搜索命令"><a href="#三、文件搜索命令" class="headerlink" title="三、文件搜索命令"></a>三、文件搜索命令</h3><p>1.locate </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">locate [文件名]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在系统数据库中查找文件的</p>
</blockquote>
<blockquote>
<p>新建的文件，要执行updatedb操作之后才能搜到</p>
</blockquote>
<p>2.命令搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">whereis [选项] [命令名]</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">which [选项][命令名]</span><br></pre></td></tr></table></figure>

<blockquote>
<p>选项：</p>
<p>-b 只查找可执行文件</p>
<p>-m 只查找帮助文件</p>
</blockquote>
<p>3.文件搜索</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find [搜索范围][选项][条件]</span><br></pre></td></tr></table></figure>

<p>直接举例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find  &#x2F;  -name install.log  </span><br><span class="line">在根目录下查找名为install.log文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;root  -inname install.log</span><br><span class="line">忽略大小写查找文件</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;var&#x2F;log -mtime +10</span><br><span class="line"></span><br><span class="line">其中-mtime 文件修改时间</span><br><span class="line">-atime 文件访问时间</span><br><span class="line">-ctime 改变文件属性时间</span><br><span class="line"></span><br><span class="line">+10 10天前</span><br><span class="line">10  10天</span><br><span class="line">-10 10天内</span><br></pre></td></tr></table></figure>


<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find &#x2F;etc -size +20M</span><br><span class="line"></span><br><span class="line">查找文件大于20M的文件</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="四、压缩与解压缩命令"><a href="#四、压缩与解压缩命令" class="headerlink" title="四、压缩与解压缩命令"></a>四、压缩与解压缩命令</h3><p>常见压缩格式：.zip  、 .gz 、 .bz2、<br>.tar.gz  、 .tar.bz2</p>
<p>1.zip格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;压缩文件</span><br><span class="line">zip [压缩文件名][原文件]</span><br><span class="line">&#x2F;&#x2F;压缩目录</span><br><span class="line">zip -r  [压缩文件名][原文件]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch jp&#x2F;cangls</span><br><span class="line"></span><br><span class="line">touch jp&#x2F;longls</span><br><span class="line"></span><br><span class="line">zip -r jp.zip jp</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#解压：</span><br><span class="line">unzip [压缩文件名]</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>gz格式</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 压缩为gz格式，原文件不保留</span><br><span class="line">gzip [原文件]</span><br><span class="line"></span><br><span class="line">#压缩.gz格式，原文件保留</span><br><span class="line"></span><br><span class="line">gzip -c 原文件 &gt; 压缩文件</span><br><span class="line"># 压缩目录：</span><br><span class="line">gzip -r  目录</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解压：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">guzip [文件]</span><br><span class="line"></span><br><span class="line">guzip -r [目录]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>3.tar</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 打包</span><br><span class="line">tar -cvf  打包文件名 原文件</span><br><span class="line"></span><br><span class="line"># 解压</span><br><span class="line"></span><br><span class="line">tar -xvf jp.tar</span><br></pre></td></tr></table></figure>

<p>4.tar.gz</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#打包</span><br><span class="line">tar -zcvf 压缩包名.tar.gz  原文件</span><br><span class="line"></span><br><span class="line">#解压</span><br><span class="line">tar -zxvf  压缩包名.tar.gz</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<h3 id="五、关机和重启"><a href="#五、关机和重启" class="headerlink" title="五、关机和重启"></a>五、关机和重启</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shutdown [选项][时间]</span><br><span class="line"></span><br><span class="line">#选项：</span><br><span class="line">-c 取消前一个关机命令</span><br><span class="line">-h 关机</span><br><span class="line">-r 重启</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">init 6重启</span><br><span class="line"></span><br><span class="line">init 0关机</span><br><span class="line"></span><br><span class="line">logout退出登陆</span><br></pre></td></tr></table></figure>

<p>###六、查看用户信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">w</span><br><span class="line">who</span><br><span class="line">last</span><br><span class="line">lastlog</span><br></pre></td></tr></table></figure>

<p>###七、shell基础</p>
<p>1.什么是shell<br> shell是命令行解释器。</p>
<p>2.echo 输出命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo[选项][输出内容]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<blockquote>
<p>-e:支持转义</p>
</blockquote>
<p>３.创建一个脚本</p>
<p>创建hello.sh</p>
<blockquote>
<p>vim hello.sh<br>进入编辑：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">   #!&#x2F;bin&#x2F;bash</span><br><span class="line">   # the first program</span><br><span class="line">echo &quot;hello world!&quot;</span><br></pre></td></tr></table></figure>
<p> 执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 755 hello.sh</span><br><span class="line"></span><br><span class="line">.&#x2F;hello.sh    </span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash hello.sh</span><br></pre></td></tr></table></figure>

<p>###八、历史命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">history 查看历史命令</span><br><span class="line">history [选项][历史保存文件]</span><br><span class="line">选项：</span><br><span class="line">-c清空历史</span><br><span class="line">-w把缓存中的历史写入历史命令保存文件</span><br></pre></td></tr></table></figure>

<p>###九、输出重定向</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令&gt;文件   以覆盖的方式，把正确的命令输出到指定文件</span><br><span class="line">命令&gt;&gt;文件  以追加的方式，把正确的命令输出到指定文件、</span><br><span class="line">错误命令 2&gt; 文件  以覆盖的方式把错误的命令覆盖到指定文件</span><br><span class="line">错误命令 2&gt;&gt; 文件  以追击的方式把错误的命令覆盖到指定文件</span><br><span class="line"></span><br><span class="line"> 命令&gt;&gt;文件 2&gt;&amp;1  同时追加正确命令和错误命令到 指定文件</span><br><span class="line">命令 &gt;&gt;文件1 2&gt;&gt;文件2   把正确的命令输出到文件1错误的文件2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#&#x2F;bin&#x2F;bash</span><br><span class="line">while command</span><br><span class="line">do</span><br><span class="line">curl -d &quot;userid&#x3D;123343,action&#x3D;getuserinfo&quot; https:&#x2F;&#x2F;app.testasss.com.cn&#x2F; &gt;test.txt</span><br><span class="line">time&#x3D;$(date)</span><br><span class="line">cat&#x3D;$(cat test.txt |cut -d \: -f 3|cut -d \&quot; -f 2)</span><br><span class="line">echo &quot;$time $cat&quot; &gt;&gt;test.log</span><br><span class="line">sleep 15s</span><br><span class="line">done</span><br></pre></td></tr></table></figure>


<p>###十、网络相关</p>
<p>1.ifconfig查看ip</p>
<p>举个例子：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ifconfig&gt;&gt; ip.log</span><br><span class="line">cat ip.log</span><br></pre></td></tr></table></figure>

<p>2.查看网络状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat [选项]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>选项：</p>
<blockquote>
<p>-t: 列出tcp 协议端口<br>-u: 列出upd协议端口<br>-n  ip地址个端口号<br>-l 列出监听状态的<br>-a 所有</p>
</blockquote>
<p>3.查看路由列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -rn</span><br><span class="line">或者</span><br><span class="line">route -n</span><br></pre></td></tr></table></figure>

<p>4.查看某域名与自己的电脑的网络状态</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping www.baodu.com</span><br></pre></td></tr></table></figure>

<p>###十一、vi编辑器<br>vi的升级版是vim</p>
<p>1.vim的操作模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">commond mode  命令模式</span><br><span class="line">inser tmode  编辑模式</span><br><span class="line">lastline mode  底行模式</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>2.模式切换<br>i  进入编辑模式<br>esc  进入命令行模式</p>
<p>3.命令模式</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim [文件]         进入文件或者创建文件（文件不存在的情况下）</span><br><span class="line">vim + [文件名]   进入文件尾部</span><br><span class="line">vim +&#x2F;[字符串] [文件名]  光标定位到文件第一次出现该字符串的位置</span><br></pre></td></tr></table></figure>
<p>4.底行模式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">:w  保存</span><br><span class="line">:q 退出</span><br><span class="line">:! 强制</span><br><span class="line">:15  定位的第15行</span><br><span class="line">&#x2F;[字符串]  光标位置向后搜索该字符串</span><br><span class="line">?[字符串]  光标位置向前搜索该字符串</span><br><span class="line">dd  删除光标所在行</span><br><span class="line"></span><br><span class="line">ctr+f   向下翻页</span><br><span class="line">ctr+b  向上翻页</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>###十二、常用操作快捷键</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ctr+c  终止当前命令</span><br><span class="line">ctr+l 清屏  相当于 clear</span><br><span class="line">ctr+a  光标移到行首</span><br><span class="line">ctr+e  光标移到行尾</span><br><span class="line">ctr+u  把光标所在位置删除到行首</span><br><span class="line">ctr+z  把命令放入后台</span><br><span class="line">ctr+r  在历史命令中搜索</span><br></pre></td></tr></table></figure>
<h3 id="十三、其他"><a href="#十三、其他" class="headerlink" title="十三、其他"></a>十三、其他</h3><p>常用工具：</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vmware  虚拟机</span><br><span class="line">centos.iso   centos系统镜像 ,绝大多数服务器是这个系统</span><br><span class="line">SecureCRT  远程登陆工具</span><br><span class="line">Xshell 远程登陆工具</span><br><span class="line">winscp copy文件工具</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我的springCloud专栏：<a target="_blank" rel="noopener" href="http://blog.csdn.net/column/details/15197.html">http://blog.csdn.net/column/details/15197.html</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>如何创建高性能索引</title>
    <url>/2021/10/29/mysql-mysql-%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h5 id="为什么需要索引"><a href="#为什么需要索引" class="headerlink" title="为什么需要索引?"></a><strong>为什么需要索引?</strong></h5><p><strong>避免去扫全表,存储引擎先走索引找到对应值,然后根据索引记录找到对应的数据行.</strong></p>
<p><strong>优点的话,因为索引使用B+树结构 使得查询数据不再是随机IO,且避免去扫描全表</strong></p>
<p><strong>索引的策略(使用)</strong></p>
<h5 id="单列"><a href="#单列" class="headerlink" title="单列"></a><strong>单列</strong></h5><p><strong>不要在where 后面针对索引列计算,因为无法自动解析计算,所以需要避免索引列的一些计算</strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211013193141024.png" alt="image-20211013193141024"></strong></p>
<span id="more"></span>

<h5 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a><strong>前缀索引</strong></h5><p><strong>使列的前缀区分度趋近于这个列的完整列的区分度,这个时候可以考虑使用前缀索引,避免了索引过大,但同时区分度</strong></p>
<p><strong>差不多的情况.</strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211013193656198.png" alt="image-20211013193656198" style="zoom:60%;" /></strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211013193530306.png" alt="image-20211013193530306"></strong></p>
<h5 id="索引合并的优化"><a href="#索引合并的优化" class="headerlink" title="索引合并的优化?"></a><strong>索引合并的优化?</strong></h5><p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211013194453445.png" alt="image-20211013194453445"></strong></p>
<p><strong>当服务器对多个索引进行联合操作时候,通常会消耗大量的CPU,内存等,有的时候or的索引列区分度不高,查询优</strong></p>
<p><strong>化器评估可能还不如扫全表来的成本低,可能就会放弃走索引. 所以遇到extra using union 合并索引优化的时候</strong> </p>
<p><strong>需要看看自己的索引建立的是否合理?</strong></p>
<h5 id="如何选择合适的索引顺序"><a href="#如何选择合适的索引顺序" class="headerlink" title="如何选择合适的索引顺序?"></a><strong>如何选择合适的索引顺序?</strong></h5><p><strong>如果没有排序或者分组的情况下,将区分度最高的列放在最前面是合理的,但如果涉及排序或者分组的时候,还是应该像前缀索引那样针对查询的结果集的区分度来做判断</strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211013200842505.png" alt="image-20211013200842505" style="zoom:50%;" /></strong></p>
<h5 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a><strong>聚簇索引</strong></h5><p><strong>索引和数据行聚合在一起的,通常数据行不可能放在两个地方,所以聚簇索引的索引一般都是主键</strong></p>
<p><strong>聚簇索引默认是主键，如果表中没有定义主键，InnoDB 会选择一个唯一的非空索引代替</strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211014153327555.png" alt="image-20211014153327555" style="zoom:50%;" /></strong></p>
<ul>
<li><p><strong>缺点:  当主键发生变化的时候,要插入一个已经满的数据行内时,会发生“页分裂”的问题, 导致数据行不连续,导致</strong></p>
<p><strong>全表扫描变慢,其次产生的”页分裂“ 也会占有额外的内存.</strong></p>
</li>
<li><p><strong>优点: 在B+树中查询会更快些,且使用覆盖索引扫描的查询可以直接用叶子结点上的主键</strong></p>
</li>
</ul>
<h5 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h5><p><strong>索引包含了要查询的列,那么就没有必要回表查询(数据行).</strong></p>
<p><strong>优点: 如果走覆盖索引,返回的行数明显会少很多, 对服务器的缓存 IO 负载也会好很多</strong></p>
<h5 id="什么是“延迟关联“？"><a href="#什么是“延迟关联“？" class="headerlink" title="什么是“延迟关联“？"></a><strong>什么是“延迟关联“？</strong></h5><h5 id="超多分页的问题"><a href="#超多分页的问题" class="headerlink" title="超多分页的问题"></a><strong>超多分页的问题</strong></h5><p><strong>随着偏移量 <code>offset</code> 的增加，MySQL 需要花费大量的时间来扫描需要丢弃的数据。本质上就是 <code>offset</code> 过大导致</strong></p>
<p><strong>的大量回表 I/O 查询。</strong></p>
<p><strong>通过使用覆盖索引查询返回需要的主键，再根据主键关联原表获得需要的数据。</strong> </p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211014162823668.png" alt="image-20211014162823668"></strong></p>
<h5 id="使用索引来排序"><a href="#使用索引来排序" class="headerlink" title="使用索引来排序"></a><strong>使用索引来排序</strong></h5><p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211014165259909.png" alt="image-20211014165259909"></strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211014165042661.png" alt="image-20211014165042661"></strong></p>
<p><strong>当第一列是范围查询的时候也不能使用索引作排序查询</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">where retal_date&gt;&quot;2005-05-25&quot; order by inventory_id,customer_id</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p><strong>注意避免 冗余 &amp; 重复&amp;  未使用索引</strong></p>
<h5 id="索引和锁"><a href="#索引和锁" class="headerlink" title="索引和锁"></a><strong>索引和锁</strong></h5><p><strong>在返回给服务器之前的,能够通过索引过滤无效行的形式去避免无效行的锁,返回到服务器数据可以通过where 过滤</strong></p>
<p><strong>之后释放锁.</strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211016095647397.png" alt="image-20211016095647397"></strong></p>
<p><strong><code>use index</code> 索引返回过滤 1-5 行的数据 , <code>use where</code> 索引返回行给服务器,应用 <code>where</code> 过滤</strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211016100036309.png" alt="image-20211016100036309" style="zoom:50%;" /></strong></p>
<p><strong>虽然查询只返回了2<del>4行的数据,但实际获取的是1</del>4行之间的排他锁,InnoDB 会锁住第一行,因为<code>查询优化器</code> 选择</strong></p>
<p><strong>的执行计划是<code>索引范围扫描</code></strong></p>
<h5 id="索引案例学习"><a href="#索引案例学习" class="headerlink" title="索引案例学习"></a>索引案例学习</h5><p><code>IN</code> or <code>&gt;</code> ?  </p>
<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211016103048834.png" alt="image-20211016103048834" style="zoom:50%;" />

<p>explain 结果来看无法区分 这二者的区别,但是 可以从值的范围和多个等于条件来得出不同,第二个就是等值查询</p>
<p>那二者在查询效率上有什么区别吗?</p>
<p>简单的来说第二种等值查询后续列可以继续使用索引,但是第一种范围查询后续列不可以使用索引,因为查询只能使</p>
<p>用索引的最左匹配.所以应该尽可能将范围查询放在索引列的后面.以便优化器可以使用尽可能多的索引列.</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li><p>服务器从存储中读取的块尽可能多的包含所需要的行</p>
</li>
<li><p>顺序IO 比随机IO快,特别是对机械硬盘,如果服务器能够顺序获取数据,那服务器则无需额外的排序</p>
</li>
<li><p>覆盖索引是很快的,如果索引列能返回所有的查询数据,则存储引擎无需回表查询数据行</p>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>如何优化查询</title>
    <url>/2021/10/30/mysql-mysql-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p><strong>查询优化</strong></p>
<p><strong>why?</strong></p>
<h4 id="优化的思路"><a href="#优化的思路" class="headerlink" title="优化的思路"></a><strong>优化的思路</strong></h4><p><strong>客户端到服务器 其中包括 检验连接 查询缓存 解析 以及存储引擎涉及的调用 都会带来 cpu 内存 io等开销我们要</strong></p>
<p><strong>做的就是减少这些…</strong></p>
<h5 id="措施"><a href="#措施" class="headerlink" title="措施"></a><strong>措施</strong></h5><p>​    <strong>一个是检查是不是返回了 程序不需要的大量数据,大量数据会带来大量cpu以及io等损耗…</strong></p>
<p>​    <strong>一个是检查是不是扫了额外的行记录最简单的衡量查询开销的三个指标：1.响应时间2.扫描的行数3.返回的行</strong></p>
<p><strong>数, 关注数据的访问类型全表扫描 索引扫描 范围扫描 唯一索引扫描等…</strong></p>
<span id="more"></span>

<h5 id="using-where？"><a href="#using-where？" class="headerlink" title="using where？"></a><strong>using where？</strong></h5><h5 id="扫描大量数据-返回却很少数的行"><a href="#扫描大量数据-返回却很少数的行" class="headerlink" title=" 扫描大量数据, 返回却很少数的行?"></a><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/cFNOQmbetv8RBaxL6EWXV0kf1_JS53PbHcNtpCbod-FXk3T8PPqnkWpoYjCyjP-yQeMb16IXJHEI683HYXjO9nFNeO3vA7YvVuB_1wT1oEWKXfRSy9YIPovUvkAWArlW1jSLrNbH=s0.png" alt="img"></strong> 扫描大量数据, 返回却很少数的行?</h5><h5 id=""><a href="#" class="headerlink" title=""></a><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/CloQyJONtRGw9ovj3Qx3on2_pEMMq2rs7ShENqfQDO-G0SY6lAcQ6l7mBZCDr9_7HmkeFN5J1aqR0I3uAxIcze75RRYvNfLsXIL0ffBtpm26tMbgbzDIybE3xkYabP7IpnQo4feY=s0.png" alt="img"></strong></h5><h4 id="why-这样优化"><a href="#why-这样优化" class="headerlink" title="why 这样优化 ?"></a><strong>why 这样优化 ?</strong></h4><h5 id="查询执行基础"><a href="#查询执行基础" class="headerlink" title="查询执行基础"></a><strong>查询执行基础</strong></h5><p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211013132735291.png" alt="image-20211013132735291"></strong></p>
<h6 id="Mysql-客户端-服务器的通信协议"><a href="#Mysql-客户端-服务器的通信协议" class="headerlink" title="Mysql 客户端/服务器的通信协议"></a><strong>Mysql 客户端/服务器的通信协议</strong></h6><p><strong>”半双工“协议,单方面一方进行推送,服务器推送数据给客户端,客户端推送查询给服务器,两个动作不能同时发生.</strong></p>
<p><strong>虽然这种通信比较简单快速,但是有一个缺点就是一方必须接收完全部信息才能响应. 这就是为什么客户端进行查询</strong></p>
<p><strong>数据包传送的时候需要进行大小限制“max_allowed_package”  以及这也是为什么在查询返回时加”limit“ 限制.</strong></p>
<h6 id="查询缓存"><a href="#查询缓存" class="headerlink" title="查询缓存"></a><strong>查询缓存</strong></h6><p><strong>查询会和缓存中的查询进行匹配(一个区分大小写的Hash查找实现),如果完全匹配且权限没有问题则会直接返回数</strong></p>
<p><strong>据,反之如果有一个字节不匹配则不会命中缓存</strong></p>
<h6 id="查询优化以及处理-查询优化器"><a href="#查询优化以及处理-查询优化器" class="headerlink" title="查询优化以及处理(查询优化器)"></a><strong>查询优化以及处理</strong>(查询优化器)</h6><p><strong>这个阶段主要将 sql  (转换成 ) —&gt; 执行计划 -&gt; mysql 依据这个执行计划去和存储引擎进行交互.</strong></p>
<p><strong>转换执行计划过程包括 解析sql, 预处理,优化sql 执行计划</strong></p>
<p><strong>查询优化包括静态优化以及动态优化,静态优化主要则是将where 层面的条件以代数的形式去比较选择,通常只做一</strong></p>
<p><strong>次,但是动态优化则是每次都会评估. 常见的mysql能够处理的优化类型:</strong></p>
<p><strong><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211013155103802.png" alt="image-20211013155103802"></strong></p>
<h6 id="查询执行引擎"><a href="#查询执行引擎" class="headerlink" title="查询执行引擎"></a><strong>查询执行引擎</strong></h6><p><strong>Mysql 根据优化后的执行计划调用存储引擎的”handler API“,在解析运行时就为每张表生成handler</strong> </p>
<p><strong>实列.</strong></p>
<h6 id="查询结果返回"><a href="#查询结果返回" class="headerlink" title="查询结果返回"></a><strong>查询结果返回</strong></h6><p><strong>服务器会将返回的结果集的每行数据以客户端/服务器通信协议进行封包处理,通过TCP协议进行传输,传输过程可能</strong></p>
<p><strong>会将封包数据进行缓存,进行批量传输.</strong></p>
<p><strong>其次如果查询是可以缓存,那么mysql 也会在这个阶段缓存对应的结果集</strong></p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>查询一行数据怎么很慢？</title>
    <url>/2021/11/02/mysql-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%9F%A5%E8%AF%A2%E4%B8%80%E8%A1%8C%E6%95%B0%E6%8D%AE%E4%B9%9F%E5%BE%88%E6%85%A2/</url>
    <content><![CDATA[<h5 id="为什么查询一行数据也很慢"><a href="#为什么查询一行数据也很慢" class="headerlink" title="为什么查询一行数据也很慢?"></a>为什么查询一行数据也很慢?</h5><p>1.MySQL数据库本身被堵住了，比如：系统或网络资源不够</p>
<p>2.SQL语句被堵住了，比如：表锁，行锁等，导致存储引擎不执行对应的SQL语句</p>
<p>3.确实是索引使用不当，没有走索引</p>
<p>4.表中数据的特点导致的，走了索引，但回表次数庞大</p>
<p>SQL语句被堵住的原因</p>
<ul>
<li>表锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql&gt; select * from t where id&#x3D;1;</span><br></pre></td></tr></table></figure>

<p>长时间不返回,一般碰到这种情况的话，大概率是表 t 被锁住了。接下来分析原因的时候，一般都是首先执行一下 </p>
<p>show processlist 命令，看看当前语句处于什么状态。然后我们再针对每种状态，去分析它们产生的原因、如何复</p>
<p>现，以及如何处理。</p>
<span id="more"></span>

<p><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211022091452158.png" alt="image-20211022091452158"></p>
<p>(performance_schema=on，相比于设置为 off 会有 10% 左右的性能损失)通过查sys.schema_table_lock_waits </p>
<p>这张表，我们就可以直接找出造成阻塞的 process id，把这个连接用 kill 命令断开即可。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211022093053390.png" alt="image-20211022093053390"></p>
<p> <strong>Waiting for table flush</strong></p>
<p>另外一种查询堵住的情况是: 表t 等待被flush,正常flush是很快的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">flush tables t with read lock;</span><br><span class="line"></span><br><span class="line">flush tables with read lock;</span><br></pre></td></tr></table></figure>

<p>Waiting for table flush 状态的可能情况是：有一个 flush tables 命令被别的语句堵住了，然后它又堵住了我们的 </p>
<p>select 语句。</p>
<p><strong>等行锁</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211022094227519.png" alt="image-20211022094227519"></p>
<p>session A 启动了事务，占有写锁，还不提交，是导致 session B 被堵住的原因</p>
<p>查出是谁占着这个写锁?</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">mysql&gt; select * from t sys.innodb_lock_waits where locked_table&#x3D;&#39;&#96;test&#96;.&#96;t&#96;&#39;\G</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211022094422669.png" alt="image-20211022094422669"></p>
<p><strong>undo log</strong></p>
<p>mysql在事物开始操作数据之前，会先将原始数据备份到一个undo log的地方，这样做的目的有两个。第一是为了</p>
<p>保证事物的原子性，如果事物在执行的过程中出现了某些错误，或者是用户执行了rollback的操作，mysql可以利</p>
<p>用undo log中的备份将数据恢复到事物开始之前的状态。第二是为了实现多版本的并发控制，事物在提交之前，</p>
<p>undo log中保存了未提交之前的数据版本，undo log可以作为旧版数据的快照供其他并发访问的事物实现快照</p>
<p>读。</p>
<p><strong>快照读</strong>:SQL读取的数据是快照版本，也就是历史版本，普通的select查询的就是快照。innodb存储引擎的快照</p>
<p>读，读取的数据将由cache(原始数据)+undo(事物修改过的数据)两部分组成。</p>
<p><strong>当前读</strong>:SQL读取的数据是最新版本，可以通过锁的机制来保证读取的数据无法被其它的事物修改。update，</p>
<p>delete，insert，select … lock in share mode，select … for update都是当前读。</p>
<p>除了undo log，Mysql数据库还有一个<strong>redo log</strong>的概念，mysql在事物开始之后，事物中操作的任何数据，会将最</p>
<p>新的数据备份到一个地方（redo log）,就是在事物执行的过程中，开始将数据写入redo buffer中，最后写入redo </p>
<p>log中，具体的落盘策略可以自行配置。这样做的目的是:为了实现事物的持久性，防止在发生故障的时间点，尚有</p>
<p>脏页未写入磁盘，在mysql重启的时候，根据redo log重做，从而使事物未入磁盘的数据达到持久化这一特定。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211022100827871.png" alt="image-20211022100827871"></p>
<p>session A 先用 start transaction with consistent snapshot 命令启动了一个事务，之后 session B 才开始执行 </p>
<p>update 语句。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20211022100857409.png" alt="image-20211022100857409"></p>
<p>session B 更新完 100 万次，生成了 100 万个回滚日志 (undo log)。带 lock in share mode 的 SQL 语句，是当前</p>
<p>读，因此会直接读到 1000001 这个结果，所以速度很快；而 select * from t where id=1 这个语句，是一致性</p>
<p>读，因此需要从 1000001 开始，依次执行 undo log，执行了 100 万次以后 找到seesionA 一致性视图那个版本 </p>
<p>才将 1 这个结果返回.</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>删除是不是只能跑路？</title>
    <url>/2021/11/01/mysql-redolog-binlog/</url>
    <content><![CDATA[<h5 id="数据恢复过程"><a href="#数据恢复过程" class="headerlink" title="数据恢复过程"></a>数据恢复过程</h5><p>1.最近的一次全量备份 -&gt; 2. 从备份的时间点开始,将备份的binlog 依次取出来重放到误删表之前的那个时刻</p>
<p>这样你的临时库就跟误删之前的线上库一样了,按需要恢复到线上库去。</p>
<h5 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h5><p>与查询流程不一样的是，更新流程还涉及两个重要的日志模块</p>
<p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）</p>
<span id="more"></span>

<h6 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h6><p>WAL 的全称是 Write-Ahead Logging，它的关键点就是先写日志，再写磁盘，也就是先写粉板，等不忙的时候再</p>
<p>写账本。</p>
<p>具体来说，当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log（粉板）里面，并更新内存，</p>
<p>这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往</p>
<p>往是在系统比较空闲的时候做，这就像打烊以后掌柜做的事</p>
<p>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。</p>
<h6 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h6><p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）</p>
<h6 id="redo-log-vs-binlog"><a href="#redo-log-vs-binlog" class="headerlink" title="redo log vs binlog"></a>redo log vs binlog</h6><ul>
<li><p>redolog 是InnoDB特有,binlog 是mysql server 层独有</p>
</li>
<li><p>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原</p>
<p>始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。</p>
</li>
<li><p>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小</p>
<p>后会切换到下一个，并不会覆盖以前的日志</p>
</li>
</ul>
<h5 id="两阶段提交"><a href="#两阶段提交" class="headerlink" title="两阶段提交"></a>两阶段提交</h5><p>什么是”两阶段提交“?</p>
<p>先看数据update的mysql执行过程如图, 浅色 InnoDB 内部执行的，深色 执行器中执行的</p>
<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/2e5bff4910ec189fe1ee6e2ecc7b4bbe.png" alt="img" style="zoom:50%;" />

<p>Innodb更新完内存然后写入redo log -&gt; prepare状态 -&gt; 告知执行器执行完成了，随时可以提交事务。执行器生成</p>
<p>这个操作的 binlog，并把 binlog 写入磁盘 -&gt;更新redo log状态为commit的</p>
<p>为什么必须有“两阶段提交”呢？</p>
<p>这是为了让两份日志之间的逻辑一致.</p>
<p>比如在更新的时候, 如果redo log 完好,意味中数据库重启 crash了 当时数据库数据可以恢复正常,但是归档的数据</p>
<p>会少一条更新的语句.如果后续误删数据利用备份库+binlog进行数据恢复的时候,会少一条更新语句.</p>
<p>反之亦然,binlog完好,但是redo log异常,恢复之后的数据认识更新前的值,后续binlog 恢复出来的值与原值不同.</p>
<p>redo log 和 binlog 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致.</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统里的内存管理</title>
    <url>/2021/09/28/operationSystem-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/%E5%9B%BE%E6%80%AA%E5%85%BD_f2433484b95076e61f00e5b8b98a68f0_68721.jpg" alt="图怪兽_f2433484b95076e61f00e5b8b98a68f0_68721"></p>
<h5 id="存储器结构"><a href="#存储器结构" class="headerlink" title="存储器结构"></a>存储器结构</h5><p>cpu -&gt; 寄存器 -&gt; 高速缓存 -&gt; 主存 -&gt; 磁盘</p>
<h5 id="一种存储器抽象：地址空间"><a href="#一种存储器抽象：地址空间" class="headerlink" title="一种存储器抽象：地址空间"></a>一种存储器抽象：地址空间</h5><p>定义: 存储位置列表,存放可执行程序,程序的数据以及堆栈</p>
<p>地址空间是进程可以用来寻址内存的地址集。每个进程都有它自己的地址空间，独立于其他进程的地址空间，但是</p>
<p>某些进程会希望可以共享地址空间 </p>
<span id="more"></span>


<h5 id="映射内存-基址寄存器和变址寄存器"><a href="#映射内存-基址寄存器和变址寄存器" class="headerlink" title="映射内存? 基址寄存器和变址寄存器"></a>映射内存? 基址寄存器和变址寄存器</h5><p>每个 CPU 配置两个特殊硬件寄存器，通常叫做<code>基址寄存器(basic register)</code>和<code>变址寄存器(limit register)</code>。当</p>
<p>使用基址寄存器和变址寄存器时，程序会装载到内存中的连续位置并且在装载期间无需重定位。当一个进程运行</p>
<p>时，程序的起始物理地址装载到基址寄存器中，程序的长度则装载到变址寄存器中.</p>
<ul>
<li>基址寄存器：存储数据内存的起始位置</li>
<li>变址寄存器：存储应用程序的长度</li>
</ul>
<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210928135552448.png" alt="image-20210927200421691" style="zoom:50%;" />


<h5 id="程序运行所需内存超过物理内存"><a href="#程序运行所需内存超过物理内存" class="headerlink" title="程序运行所需内存超过物理内存?"></a>程序运行所需内存超过物理内存?</h5><p>最简单的一种方式就是<code>交换(swapping)</code>技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把</p>
<p>它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。另外一种策略叫做<code>虚拟</code></p>
<p><code>内存(virtual memory)</code>，虚拟内存技术能够允许应用程序部分的运行在内存中.</p>
<ul>
<li><p><strong>交换</strong></p>
<p>交换在内存创建了多个 <code>空闲区(hole)</code>，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这</p>
<p>项技术称为<code>内存紧缩(memory compaction)</code>,但这项技术会消耗很多CPU的时间,通常不使用</p>
</li>
<li><p><strong>虚拟内存</strong></p>
<p>虚拟内存的基本思想是, <strong>每个程序都有自己的地址空间，这个地址空间被划分为多个称为<code>页面(page)</code>的块</strong>。</p>
<p>每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当</p>
<p>程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内</p>
<p>存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令.</p>
</li>
</ul>
<h5 id="虚拟内存中的分页"><a href="#虚拟内存中的分页" class="headerlink" title="虚拟内存中的分页"></a>虚拟内存中的分页</h5><p>在使用虚拟内存时，虚拟地址不会直接发送到内存总线上。相反，会使用 <code>MMU(Memory Management Unit)</code> 内存</p>
<p>管理单元把虚拟地址映射为物理内存地址</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210928152422814.png" alt="image-20210928152422814"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210928152951607.png" alt="image-20210928152951607"></p>
<h5 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h5><p>CPU -&gt; 虚拟内存地址空间(被分成<code>页面</code>块) -&gt; MMU (内存单元管理) -&gt; 物理内存-&gt; 总线 -&gt; 操作设备</p>
<h5 id="虚拟地址到物理地址的映射"><a href="#虚拟地址到物理地址的映射" class="headerlink" title="虚拟地址到物理地址的映射?"></a>虚拟地址到物理地址的映射?</h5><ul>
<li><p>转换检测缓冲区 TLB (硬件层面)</p>
<p>从硬件方面来解决这个问题，为计算机设置一个小型的硬件设备，能够将虚拟地址直接映射到物理地址，而不</p>
<p>必再访问页表。这种设备被称为<code>转换检测缓冲区(Translation Lookaside Buffer, TLB)</code></p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210928154218704.png" alt="image-20210928154218704"></p>
<h5 id="页面置换算法"><a href="#页面置换算法" class="headerlink" title="页面置换算法"></a>页面置换算法</h5><table>
<thead>
<tr>
<th align="left">算法</th>
<th align="left">注释</th>
</tr>
</thead>
<tbody><tr>
<td align="left">最优算法</td>
<td align="left">不可实现，但可以用作基准</td>
</tr>
<tr>
<td align="left">NRU(最近未使用) 算法</td>
<td align="left">和 LRU 算法很相似</td>
</tr>
<tr>
<td align="left">FIFO(先进先出) 算法</td>
<td align="left">有可能会抛弃重要的页面</td>
</tr>
<tr>
<td align="left">第二次机会算法</td>
<td align="left">比 FIFO 有较大的改善</td>
</tr>
<tr>
<td align="left">时钟算法</td>
<td align="left">实际使用</td>
</tr>
<tr>
<td align="left">LRU(最近最少)算法</td>
<td align="left">比较优秀，但是很难实现</td>
</tr>
<tr>
<td align="left">NFU(最不经常食用)算法</td>
<td align="left">和 LRU 很类似</td>
</tr>
<tr>
<td align="left">老化算法</td>
<td align="left">近似 LRU 的高效算法</td>
</tr>
<tr>
<td align="left">工作集算法</td>
<td align="left">实施起来开销很大</td>
</tr>
<tr>
<td align="left">工作集时钟算法</td>
<td align="left">比较有效的算法</td>
</tr>
</tbody></table>
<h4 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h4><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210927200421691.png" alt="image-20210927200421691" style="zoom:50%;" />
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-下</title>
    <url>/2022/11/29/operationSystem-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86-%E4%B8%8B/</url>
    <content><![CDATA[<h3 id="Linux操作系统概览"><a href="#Linux操作系统概览" class="headerlink" title="Linux操作系统概览"></a>Linux操作系统概览</h3><h3 id="物理内存"><a href="#物理内存" class="headerlink" title="物理内存"></a>物理内存</h3><ul>
<li>物理内存分 NUMA 节点，分别进行管理；</li>
<li>每个 NUMA 节点分成多个内存区域；</li>
<li>每个内存区域分成多个物理页面；</li>
<li>伙伴系统将多个连续的页面作为一个大的内存块分配给上层；</li>
<li>kswapd 负责物理页面的换入换出；</li>
<li>Slub Allocator 将从伙伴系统申请的大内存块切成小块，分配给其他系统</li>
</ul>
<span id="more"></span>

<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/54F862A0-8386-49BF-8B3F-DEE9C8A646AE_2/gyolywXXfXQonISDGUYFDIkKa9pLydFhUuO59MXYMccz/Image.png" alt="Image.png"></p>
<h3 id="用户态的内存映射机制"><a href="#用户态的内存映射机制" class="headerlink" title="用户态的内存映射机制"></a>用户态的内存映射机制</h3><ul>
<li>用户态内存映射函数 mmap，包括用它来做匿名映射和文件映射。</li>
<li>用户态的页表结构，存储位置在 mm_struct 中。</li>
<li>在用户态访问没有映射的内存会引发缺页异常，分配物理页表、补齐页表。如果是匿名映射则分配物理内存；如果是 swap，则将 swap 文件读入；如果是文件映射，则将文件读入。</li>
</ul>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/C4FFEB6E-626D-4F7C-A07C-B7909051941F_2/YRRQqzrK4RPGRwz3EvB7e76eBrpiJvDfVMEnBe1ePmgz/Image.png" alt="Image.png"></p>
<h3 id="内存管理体系"><a href="#内存管理体系" class="headerlink" title="内存管理体系"></a>内存管理体系</h3><p>物理内存根据 NUMA 架构分节点。每个节点里面再分区域。每个区域里面再分页。</p>
<p>物理页面通过伙伴系统进行分配。分配的物理页面要变成虚拟地址让上层可以访问，kswapd 可以根据物理页面的使用情况对页面进行换入换出。</p>
<p>对于内存的分配需求，可能来自内核态，也可能来自用户态。</p>
<p>对于内核态，kmalloc 在分配大内存的时候，以及 vmalloc 分配不连续物理页的时候，直接使用伙伴系统，分配后转换为虚拟地址，访问的时候需要通过内核页表进行映射。</p>
<p>对于 kmem_cache 以及 kmalloc 分配小内存，则使用 slub 分配器，将伙伴系统分配出来的大块内存切成一小块一小块进行分配。</p>
<p>kmem_cache 和 kmalloc 的部分不会被换出，因为用这两个函数分配的内存多用于保持内核关键的数据结构。内核态中 vmalloc 分配的部分会被换出，因而当访问的时候，发现不在，就会调用 do_page_fault。</p>
<p>对于用户态的内存分配，或者直接调用 mmap 系统调用分配，或者调用 malloc。调用 malloc 的时候，如果分配小的内存，就用 sys_brk 系统调用；如果分配大的内存，还是用 sys_mmap 系统调用。正常情况下，用户态的内存都是可以换出的，因而一旦发现内存中不存在，就会调用 do_page_fault。</p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/AAC4B331-77B6-490B-AD71-D52671D0CD4B_2/ReuYEXAMBNYZdkWFnsIweuNA5bWuXjakI3cOoF17P24z/Image.png" alt="Image.png"></p>
<h3 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h3><p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/3635231F-E1A2-4D50-9AA1-F6180AEE5E32_2/iBnsEdRlLYuPwGGHc7FP7JeimBUgBFKMfQsc8JBJlj8z/Image.png" alt="Image.png"></p>
<h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进程间通信的各种模式</p>
<ul>
<li>类似瀑布开发模式的管道</li>
<li>类似邮件模式的消息队列</li>
<li>类似会议室联合开发的共享内存加信号量</li>
<li>类似应急预案的信号</li>
</ul>
<p>当你自己使用的时候，可以根据不同的通信需要，选择不同的模式。</p>
<ul>
<li>管道，请你记住这是命令行中常用的模式，面试问到的话，不要忘了。</li>
<li>消息队列其实很少使用，因为有太多的用户级别的消息队列，功能更强大。</li>
<li>共享内存加信号量是常用的模式。这个需要牢记，常见到一些知名的以 C 语言开发的开源软件都会用到它。</li>
<li>信号更加常用，机制也比较复杂。  我们后面会有单独的一节来解析。</li>
</ul>
<h3 id="信号处理机制"><a href="#信号处理机制" class="headerlink" title="信号处理机制"></a>信号处理机制</h3><ul>
<li>在用户程序里面，有两个函数可以调用，一个是 signal，一个是 sigaction，推荐使用 sigaction。</li>
<li>用户程序调用的是 Glibc 里面的函数，signal 调用的是 __sysv_signal，里面默认设置了一些参数，使得 signal 的功能受到了限制，sigaction 调用的是 __sigaction，参数用户可以任意设定。</li>
<li>无论是 __sysv_signal 还是 __sigaction，调用的都是统一的一个系统调用 rt_sigaction。</li>
<li>在内核中，rt_sigaction 调用的是 do_sigaction 设置信号处理函数。在每一个进程的 task_struct 里面，都有一个 sighand 指向 struct sighand_struct，里面是一个数组，下标是信号，里面的内容是信号处理函数</li>
</ul>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/2BFFB341-CBA5-415D-B622-4660FA7E21F4_2/KaQpKUuNBQZOs0H0AjSyb429l4rWcPVzPDcRBlRp5e4z/Image.png" alt="Image.png"></p>
<h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>两种网络协议模型</p>
<p>TCP/UDP-&gt;IPv4-&gt;ARP</p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/C4628019-6678-4EB3-A3B8-4D5690D4B98C_2/r2y0FpjvrnqkwP1Wc4DbyzQcpqT9yLX4yEM3FvHk6kMz/Image.png" alt="Image.png"></p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/6E92901F-753E-4B8E-91C3-877D3363C0D5_2/Sf7zAu9vqNfmrx1LSVt31uqOEbz4tc89owaFvFZijPIz/Image.png" alt="Image.png"></p>
<h3 id="socket-使用"><a href="#socket-使用" class="headerlink" title="socket 使用"></a>socket 使用</h3><p>在传输层有两个主流的协议 TCP 和 UDP，所以我们的 socket 程序设计也是主要操作这两个协议</p>
<p>当然，无论是用 socket 操作 TCP，还是 UDP，我们首先都要调用 socket 函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int socket(int domain, int type, int protocol);</span><br></pre></td></tr></table></figure>

<p>socket 函数用于创建一个 socket 的文件描述符，唯一标识一个 socket。我们把它叫作文件描述符，因为在内核中，我们会创建类似文件系统的数据结构，并且后续的操作都有用到它。</p>
<p>socket 函数有三个参数。</p>
<ul>
<li>domain：表示使用什么 IP 层协议。AF_INET 表示 IPv4，AF_INET6 表示 IPv6。</li>
<li>type：表示 socket 类型。SOCK_STREAM，顾名思义就是 TCP 面向流的，SOCK_DGRAM 就是 UDP 面向数据报的，SOCK_RAW 可以直接操作 IP 层，或者非 TCP 和 UDP 的协议。例如 ICMP。</li>
<li>protocol 表示的协议，包括 IPPROTO_TCP、IPPTOTO_UDP。</li>
</ul>
<p>通信结束后，我们还要像关闭文件一样，关闭 socket。</p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/97946327-C21F-4382-9662-C41528A79BAB_2/EAvPXq6hczBRBQIMLCTnxysVegNqp1yLDhGljpld8ycz/Image.png" alt="Image.png"></p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/F64B2722-8919-4559-93F6-0B6CC46A32F5_2/rha3Ow2oy8QOMKG1yDMfRAXHwC1bVsS8a0j0ovvcx5gz/Image.png" alt="Image.png"></p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/D6E491A5-7013-421B-8098-F07A09F6D26D_2/UgVyZJPW4RQwvKEdsW0y4syUJUY0R8XEpVfXTyjbG5Mz/Image.png" alt="Image.png"></p>
<p>TCP 协议的 socket 调用的过程</p>
<ul>
<li>服务端和客户端都调用 socket，得到文件描述符；</li>
<li>服务端调用 listen，进行监听；</li>
<li>服务端调用 accept，等待客户端连接；</li>
<li>客户端调用 connect，连接服务端；</li>
<li>服务端 accept 返回用于传输的 socket 的文件描述符；</li>
<li>客户端调用 write 写入数据；</li>
<li>服务端调用 read 读取数据。</li>
</ul>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/A19CFA41-22C4-44E4-8658-26EA7A6DAF34_2/2sfEA0VpYPWw3jrxDzNbHuahg9gzndSpiJCtQV0Zp0wz/Image.png" alt="Image.png"></p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/4BB3A853-9927-404F-AA28-CF4D698D83EE_2/nx9zzzwm2GMnxBjnX60KCYFeRxDKUIYjXxNkL9OQVxcz/Image.png" alt="Image.png"></p>
<h3 id="发送网络包"><a href="#发送网络包" class="headerlink" title="发送网络包"></a>发送网络包</h3><ul>
<li>VFS 层：write 系统调用找到 struct file，根据里面的 file_operations 的定义，调用 sock_write_iter 函数。sock_write_iter 函数调用 sock_sendmsg 函数。</li>
<li>Socket 层：从 struct file 里面的 private_data 得到 struct socket，根据里面 ops 的定义，调用 inet_sendmsg 函数。</li>
<li>Sock 层：从 struct socket 里面的 sk 得到 struct sock，根据里面 sk_prot 的定义，调用 tcp_sendmsg 函数。</li>
<li>TCP 层：tcp_sendmsg 函数会调用 tcp_write_xmit 函数，tcp_write_xmit 函数会调用 tcp_transmit_skb，在这里实现了 TCP 层面向连接的逻辑。</li>
<li>IP 层：扩展 struct sock，得到 struct inet_connection_sock，根据里面 icsk_af_ops 的定义，调用 ip_queue_xmit 函数。</li>
<li>IP 层：ip_route_output_ports 函数里面会调用 fib_lookup 查找路由表。FIB 全称是 Forwarding Information Base，转发信息表，也就是路由表。</li>
<li>在 IP 层里面要做的另一个事情是填写 IP 层的头。</li>
<li>在 IP 层还要做的一件事情就是通过 iptables 规则。</li>
<li>MAC 层：IP 层调用 ip_finish_output 进行 MAC 层。</li>
<li>MAC 层需要 ARP 获得 MAC 地址，因而要调用 ___neigh_lookup_noref 查找属于同一个网段的邻居，他会调用 neigh_probe 发送 ARP。</li>
<li>有了 MAC 地址，就可以调用 dev_queue_xmit 发送二层网络包了，它会调用 __dev_xmit_skb 会将请求放入队列。</li>
<li>设备层：网络包的发送回触发一个软中断 NET_TX_SOFTIRQ 来处理队列中的数据。这个软中断的处理函数是 net_tx_action。</li>
<li>在软中断处理函数中，会将网络包从队列上拿下来，调用网络设备的传输函数 ixgb_xmit_frame，将网络包发的设备的队列上去。</li>
</ul>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/270716AA-E236-465E-80A1-292DCF65B298_2/HMTyLROXlkM3o1cfy02cIdPByVX09deaLD45R7cKI98z/Image.png" alt="Image.png"></p>
<h3 id="接收网络包"><a href="#接收网络包" class="headerlink" title="接收网络包"></a>接收网络包</h3><ul>
<li>硬件网卡接收到网络包之后，通过 DMA 技术，将网络包放入 Ring Buffer；</li>
<li>硬件网卡通过中断通知 CPU 新的网络包的到来；</li>
<li>网卡驱动程序会注册中断处理函数 ixgb_intr；</li>
<li>中断处理函数处理完需要暂时屏蔽中断的核心流程之后，通过软中断 NET_RX_SOFTIRQ 触发接下来的处理过程；</li>
<li>NET_RX_SOFTIRQ 软中断处理函数 net_rx_action，net_rx_action 会调用 napi_poll，进而调用 ixgb_clean_rx_irq，从 Ring Buffer 中读取数据到内核 struct sk_buff；</li>
<li>调用 netif_receive_skb 进入内核网络协议栈，进行一些关于 VLAN 的二层逻辑处理后，调用 ip_rcv 进入三层 IP 层；</li>
<li>在 IP 层，会处理 iptables 规则，然后调用 ip_local_deliver 交给更上层 TCP 层；</li>
<li>在 TCP 层调用 tcp_v4_rcv，这里面有三个队列需要处理，如果当前的 Socket 不是正在被读；取，则放入 backlog 队列，如果正在被读取，不需要很实时的话，则放入 prequeue 队列，其他情况调用 tcp_v4_do_rcv；</li>
<li>在 tcp_v4_do_rcv 中，如果是处于 TCP_ESTABLISHED 状态，调用 tcp_rcv_established，其他的状态，调用 tcp_rcv_state_process；</li>
<li>在 tcp_rcv_established 中，调用 tcp_data_queue，如果序列号能够接的上，则放入 sk_receive_queue 队列；如果序列号接不上，则暂时放入 out_of_order_queue 队列，等序列号能够接上的时候，再放入 sk_receive_queue 队列。</li>
</ul>
<p>至此内核接收网络包的过程到此结束，接下来就是用户态读取网络包的过程，这个过程分成几个层次。</p>
<ul>
<li>VFS 层：read 系统调用找到 struct file，根据里面的 file_operations 的定义，调用 sock_read_iter 函数。sock_read_iter 函数调用 sock_recvmsg 函数。</li>
<li>Socket 层：从 struct file 里面的 private_data 得到 struct socket，根据里面 ops 的定义，调用 inet_recvmsg 函数。</li>
<li>Sock 层：从 struct socket 里面的 sk 得到 struct sock，根据里面 sk_prot 的定义，调用 tcp_recvmsg 函数。</li>
<li>TCP 层：tcp_recvmsg 函数会依次读取 receive_queue 队列、prequeue 队列和 backlog 队列。</li>
</ul>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/0C89A4BD-8DAA-4F0B-B89D-53F0E8CA786B_2/bvnNjlSpIY0yAwtpnKqgzZqPyypszsw79x3ii9IXPa0z/Image.png" alt="Image.png"></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统-上</title>
    <url>/2022/11/28/operationSystem-%E7%B3%BB%E7%BB%9F%E6%95%B4%E7%90%86/</url>
    <content><![CDATA[<h3 id="Linux操作系统概览"><a href="#Linux操作系统概览" class="headerlink" title="Linux操作系统概览"></a>Linux操作系统概览</h3><h3 id="内核初始化"><a href="#内核初始化" class="headerlink" title="内核初始化"></a>内核初始化</h3><p>用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态</p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/6C97FED1-4457-463A-BB9F-129E0522EFC1_2/w6pwUQCiKUXyUFfECuUj53pGxyxlHwBMM0mT6ky8jmQz/Image.png" alt="Image.png"></p>
<span id="more"></span>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/392EA7C3-802C-4D65-A9CC-8FEB117635BC_2/ifMx6XfepiWStQxnATEWxjaF2EH1t0DRLPTQmuNgoBkz/Image.png" alt="Image.png"></p>
<h3 id="内核初始化-1"><a href="#内核初始化-1" class="headerlink" title="内核初始化"></a>内核初始化</h3><p>用户态 - 系统调用 - 保存寄存器 - 内核态执行系统调用 - 恢复寄存器 - 返回用户态</p>
<p>do_execve-&gt;do_execveat_common-&gt;exec_binprm-&gt;search_binary_handler</p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/8C0B8233-7698-4735-983B-DCA5476B4827_2/ntxnj3T9WNpUiswKlq0hzHi6KeBvKpLyygeYM53KBRcz/Image.png" alt="Image.png"></p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/721E1E53-41CE-4DA9-BACA-0A68E2ADBF17_2/qNlEQyxFiV5as40yQuGord3RZPkmiB1hrv7SPj0cAsMz/Image.png" alt="Image.png"></p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/5A829BA1-FA33-4101-B84F-E8069AD1EFAB_2/19f0pAliUCw9ft44zNHvz7IFw5lINP573slQmyC6Iw8z/Image.png" alt="Image.png"></p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/2B6A58A2-8FEC-4FDA-B0C4-5D4CA8A971A3_2/j7yivE32hoQX2EubcOy6a2l2CTs74B4HPuDL72feOyYz/Image.png" alt="Image.png"></p>
<h3 id="系统调用的过程"><a href="#系统调用的过程" class="headerlink" title="系统调用的过程"></a>系统调用的过程</h3><p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/0DDD62AD-0D19-43BF-AD55-A235DD08F56E_2/r4HVzwJt9D9PxiCCPNsbDHxzykazwdhg6mvKRU0GFi0z/Image.png" alt="Image.png"></p>
<h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程从代码到二进制到运行时的过程</p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/83C26296-53BB-4CF2-9CCC-E0B32AD17B4E_2/dTncQCCyjMofAX3mvYPcVytn3yYMcF6FaDrUr1stS8Ez/Image.png" alt="Image.png"></p>
<p><strong>进程相当于一个项目，而线程就是为了完成项目需求，而建立的一个个开发任务</strong></p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/AE54E495-E4F5-4B9C-8E03-6E2404114B09_2/0st7LYGrhqK203dy0pF42f9hwcypDhRmpVUnBixYn5Az/Image.png" alt="Image.png"></p>
<p>在程序执行过程中，一旦调用到系统调用，就需要进入内核继续执行。那如何将用户态的执行和内核态的执行串起来呢？</p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/864FAF36-4E49-4C6C-BBC8-71989BA8C622_2/dlxgGJ42HolHy9XVGfST1BVW84jwGjAf3sQkd8FNJ6Iz/Image.png" alt="Image.png"></p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>一个 CPU 上有一个队列，CFS 的队列是一棵红黑树，树的每一个节点都是一个 sched_entity，每个 sched_entity 都属于一个 task_struct，task_struct 里面有指针指向这个进程属于哪个调度类, 在调度的时候，依次调用调度类的函数，从 CPU 的队列中取出下一个进程</p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/E10D30AB-2AC7-40DA-AE9B-6917192F7560_2/tzkiy5maOcJ81T3exx6kisPDro8km6F8USEqMqUyMs0z/Image.png" alt="Image.png"></p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/5A746A48-918A-4C3C-A2ED-29DD2B01842C_2/EOgwSuwPTg7nN1yB0OJps1dTdOYJ0ZcKo2hilJvzBesz/Image.png" alt="Image.png"></p>
<h3 id="主动调度"><a href="#主动调度" class="headerlink" title="主动调度"></a>主动调度</h3><p>主动调度的过程，也即一个运行中的进程主动调用 __schedule 让出 CPU。在 __schedule 里面会做两件事情，第一是选取下一个进程，第二是进行上下文切换。而上下文切换又分用户态进程空间的切换和内核态的切换</p>
<h3 id="抢占式调度"><a href="#抢占式调度" class="headerlink" title="抢占式调度"></a>抢占式调度</h3><p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/C7BAE4F0-C716-45D2-A357-144B01BEEC0A_2/HuO73nvDo8bhM0YHq6u93dezjxnnrAvTqnCqEjUF7sYz/Image.png" alt="Image.png"></p>
<h3 id="进程Fork创建的过程"><a href="#进程Fork创建的过程" class="headerlink" title="进程Fork创建的过程"></a>进程Fork创建的过程</h3><p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/FB7EC04C-FB5E-41BE-81CB-773F97093A7C_2/KElztMcWw4pPlSUkLP6CLeRjsnLZxj4eiD5J8WdB9Aoz/download.jpeg" alt="download.jpeg"></p>
<h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>创建进程的话，调用的系统调用是 fork，在 copy_process 函数里面，会将五大结构 files_struct、fs_struct、sighand_struct、signal_struct、mm_struct 都复制一遍，从此父进程和子进程各用各的数据结构。而创建线程的话，调用的是系统调用 clone，在 copy_process 函数里面， 五大结构仅仅是引用计数加一，也即线程共享进程的数据结构。</p>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/66A8A068-5535-43C4-A2AE-78AE022856F7_2/6XpCOaTI7wC0oF3OpcpYjyCRxpsabAaeIHH2AwT5pZoz/Image.png" alt="Image.png"></p>
<h3 id="一个进程运行需要的内存结构"><a href="#一个进程运行需要的内存结构" class="headerlink" title="一个进程运行需要的内存结构"></a>一个进程运行需要的内存结构</h3><p>用户态：</p>
<ul>
<li>代码段、全局变量、BSS</li>
<li>函数栈</li>
<li>堆</li>
<li>内存映射区</li>
</ul>
<p>内核态：</p>
<ul>
<li>内核的代码、全局变量、BSS</li>
<li>内核数据结构例如 task_struct</li>
<li>内核栈</li>
<li>内核中动态分配的内存</li>
</ul>
<p><img src="https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/7966A56D-2424-4582-B71A-030F9507492F_2/CAI6OWeaBX0A0rZNg7ghsdMKmxbQxrbGlBy9kphqZU0z/Image.png" alt="Image.png"></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统里的进程和线程</title>
    <url>/2021/09/28/operationSystem-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/%E5%9B%BE%E6%80%AA%E5%85%BD_81f15acdf27c9e27dd3e2e54d3360863_79599.png" alt="图怪兽_81f15acdf27c9e27dd3e2e54d3360863_79599"></p>
<h5 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程?"></a>什么是进程?</h5><p>一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个</p>
<p>进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。</p>
<h5 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型?"></a>进程模型?</h5><p>一个进程就是一个正在执行的程序的实例，进程也包括<code>程序计数器</code>、<code>寄存器</code>和<code>变量的当前值</code>。从概念上来说，每个</p>
<p>进程都有各自的<code>虚拟 CPU</code>，但是实际情况是 CPU 会在各个进程之间进行来回切换。</p>
<span id="more"></span>



<p><strong>举例</strong></p>
<p>4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当</p>
<p>然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序</p>
<p>运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。</p>
<p><strong>概述</strong></p>
<p>进程是某一类特定活动的总和，它有程序、输入输出以及状态。单个处理器可以被若干进程共享，它使用某</p>
<p>种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务</p>
<h5 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h5><p>每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间存在关联关系</p>
<ol>
<li><code>运行态</code>，运行态指的就是进程实际占用 CPU 时间片运行时 (获得CPU 时间片)</li>
<li><code>就绪态</code>，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态 (还没有获得CPU 时间片)</li>
<li><code>阻塞态</code>，除非某种外部事件发生，否则进程不能运行</li>
</ol>
<p><strong>程序调度</strong> 指的是，决定哪个进程优先被运行和运行多久</p>
<p><strong>操作系统最底层的就是调度程序</strong>，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐</p>
<p>藏在调度程序中。事实上，调度程序只是一段非常小的程序</p>
<h5 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h5><p>操作系统为了执行进程间的切换，会维护着一张表格，这张表就是 <code>进程表(process table)</code>。每个进程占用一个</p>
<p>进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、</p>
<p>账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再</p>
<p>次启动，就像从未被中断过一样。</p>
<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210927135216802.png" alt="image-20210927135216802" style="zoom:50%;" />

<h5 id="为什么要用线程"><a href="#为什么要用线程" class="headerlink" title="为什么要用线程?"></a>为什么要用线程?</h5><ul>
<li>多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的</li>
<li>线程要比进程<code>更轻量级</code>，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。</li>
<li>第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度</li>
</ul>
<h5 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型?"></a>线程模型?</h5><p>进程中拥有一个执行的线程，通常简写为 <code>线程(thread)</code>。线程会有程序计数器，用来记录接着要执行哪一条指</p>
<p>令；线程还拥有寄存器，用来保存线程当前正在使用的变量；线程还会有堆栈，用来记录程序的执行路径。尽管线</p>
<p>程必须在某个进程中执行，但是进程和线程完完全全是两个不同的概念，并且他们可以分开处理。进程用于把资源</p>
<p>集中在一起，而<strong>线程则是 CPU 上调度执行的实体</strong>。</p>
<p>在多个线程中，各个线程共享同一地址空间和其他资源。在多个进程中，进程共享物理内存、磁盘、打印机和其他</p>
<p>资源。</p>
<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210927141721690.png" alt="image-20210927141721690" style="zoom:50%;" />

<h5 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h5><p>和进程一样，线程可以处于下面这几种状态：<strong>运行中、阻塞、就绪和终止</strong></p>
<h5 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h5><ul>
<li>在用户空间中实现线程</li>
<li>在内核空间中实现线程</li>
<li>在用户和内核空间中混合实现线程</li>
</ul>
<p>用户态VS内核态线程</p>
<ol>
<li><p>当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运</p>
<p>行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU </p>
<p>时间片（或者没有可运行的线程存在了）为止。</p>
</li>
<li><p>在内核中创建或者销毁线程的开销比较大</p>
</li>
<li><p>用户级线程和内核级线程之间的主要差别在于<code>性能</code>。用户级线程的切换需要少量的机器指令（想象一下Java程</p>
<p>序的线程切换），而内核线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这会导致了若干数量</p>
<p>级的延迟。另一方面，在使用内核级线程时，一旦线程阻塞在 I/O 上就不需要在用户级线程中那样将整个进程</p>
<p>挂起</p>
</li>
</ol>
<h5 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h5><ul>
<li><code>竞态条件</code>  <code>临界区</code> <code>忙等互斥</code> <code> 睡眠与唤醒</code> <code>信号量</code> <code>互斥量</code>  <code>管程</code> <code> 消息传递</code> <code>屏障</code> <code>避免锁</code></li>
</ul>
<h5 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h5><p>如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 <code>调度程序</code></p>
<p><code>(scheduler)</code> 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 <code>调度算法(scheduling algorithm)</code></p>
<ul>
<li><p><strong>批处理系统中的调度:</strong> <code>先来先服务</code>, <code>最短作业优先</code>, <code>最短剩余优先</code></p>
</li>
<li><p><strong>实时系统中的调度:</strong> </p>
<p>实时系统可以分为两类，<code>硬实时(hard real time)</code> 和 <code>软实时(soft real time)</code> 系统，前者意味着必须要满</p>
<p>足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。</p>
</li>
<li><p><strong>交互式系统中的调度:</strong> </p>
<p><code>轮询调度</code> 一种最古老、最简单、最公平并且最广泛使用的算法就是 <code>轮询算法(round-robin)</code>。每个进程都会被</p>
<p>分配一个时间段，称为<code>时间片(quantum)</code>，在这个时间片内允许进程运行</p>
<p><code>优先级调度</code>轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等</p>
<p>级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了<code>优先</code></p>
<p><code>级调度(priority scheduling)</code></p>
</li>
</ul>
<h5 id="概览图"><a href="#概览图" class="headerlink" title="概览图"></a>概览图</h5><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210927092731492.png" alt="image-20210927092731492" style="zoom:80%;" />

<h4 id="文章参考："><a href="#文章参考：" class="headerlink" title="文章参考："></a>文章参考：</h4><p>《现代操作系统》第四版</p>
<p>《Modern Operation System》fourth</p>
<p> <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/SATA%E7%A1%AC%E7%9B%98/3947233?fr=aladdin">https://baike.baidu.com/item/SATA硬盘/3947233?fr=aladdin</a></p>
<p> <a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/1329947?fr=aladdin">https://baike.baidu.com/item/虚拟地址/1329947?fr=aladdin</a></p>
<p> <a target="_blank" rel="noopener" href="https://www.cnblogs.com/cxuanBlog/p/12448298.html">https://www.cnblogs.com/cxuanBlog/p/12448298.html</a></p>
]]></content>
      <categories>
        <category>OS</category>
      </categories>
      <tags>
        <tag>OS</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫，看看我最近博客都写了啥，带你制作高逼格的数据聚合云图</title>
    <url>/2017/04/04/python-2017-04-04-python-blogs/</url>
    <content><![CDATA[<p>今天一时兴起，想用python爬爬自己的博客，通过数据聚合，制作高逼格的云图(对词汇出现频率视觉上的展示)，看看最近我到底写了啥文章。</p>
<h2 id="一、直接上几张我的博客数据的云图"><a href="#一、直接上几张我的博客数据的云图" class="headerlink" title="一、直接上几张我的博客数据的云图"></a>一、直接上几张我的博客数据的云图</h2><h4 id="1-1-爬取文章的标题的聚合"><a href="#1-1-爬取文章的标题的聚合" class="headerlink" title="1.1 爬取文章的标题的聚合"></a>1.1 爬取文章的标题的聚合</h4><p><img src="http://upload-images.jianshu.io/upload_images/2279594-661382846e212a86.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="爬取的文章标题的数据聚合"></p>
<span id="more"></span>

<p><img src="http://upload-images.jianshu.io/upload_images/2279594-03d5c12e7a0309d7.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="爬取的文章标题的数据聚合"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-c7a31451ae8f9e2c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="爬取的文章标题的数据聚合"></p>
<h4 id="1-2-爬取文章的摘要的聚合"><a href="#1-2-爬取文章的摘要的聚合" class="headerlink" title="1.2 爬取文章的摘要的聚合"></a>1.2 爬取文章的摘要的聚合</h4><p><img src="http://upload-images.jianshu.io/upload_images/2279594-9e1ad67661db5d2c.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="33.jpeg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-19e435f576714e3e.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="34.jpeg"></p>
<h4 id="1-3-爬取文章的标题-摘要的聚合"><a href="#1-3-爬取文章的标题-摘要的聚合" class="headerlink" title="1.3 爬取文章的标题+摘要的聚合"></a>1.3 爬取文章的标题+摘要的聚合</h4><p><img src="http://upload-images.jianshu.io/upload_images/2279594-09f48b5098ee2f02.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="21.jpeg"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-7d75005594f939b4.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="22.jpeg"></p>
<p><strong>我最近写了SpringCloud系列教程，还有一些微服务架构方面，从云图上看，基本吻合。你若不信，可以进我的博客看看，数据还是非常准确的</strong></p>
<h2 id="二、技术栈"><a href="#二、技术栈" class="headerlink" title="二、技术栈"></a>二、技术栈</h2><ul>
<li>开发工具: pycharm</li>
<li>爬虫技术：bs64、requsts、jieba</li>
<li>分析工具：wordArt</li>
</ul>
<h2 id="三、爬虫构架设计"><a href="#三、爬虫构架设计" class="headerlink" title="三、爬虫构架设计"></a>三、爬虫构架设计</h2><p><img src="http://upload-images.jianshu.io/upload_images/2279594-c1c0cbb4a6c38d51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Azure.png"></p>
<p>整个爬虫架构非常简单：</p>
<ul>
<li>爬取我的博客：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp">http://blog.csdn.net/forezp</a></li>
<li>获取数据</li>
<li>将数据用“结巴”库，分词。</li>
<li>将得到的数据在在artword上制作云图。</li>
<li>将制作出来的云图展示给用户。</li>
</ul>
<h2 id="四、具体实现"><a href="#四、具体实现" class="headerlink" title="四、具体实现"></a>四、具体实现</h2><p>先根据博客地址爬去数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;blog.csdn.net&#x2F;forezp&#39;</span><br><span class="line"></span><br><span class="line">titles&#x3D;set()</span><br><span class="line"></span><br><span class="line">def download(url):</span><br><span class="line">    if url is None:</span><br><span class="line">        return None</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; requests.get(url, headers&#x3D;&#123;</span><br><span class="line">            &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.143 Safari&#x2F;537.36&#39;,</span><br><span class="line">        &#125;)</span><br><span class="line">        if (response.status_code &#x3D;&#x3D; 200):</span><br><span class="line">            return response.content</span><br><span class="line">        return None</span><br><span class="line">    except:</span><br><span class="line">        return None</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解析标题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def parse_title(html):</span><br><span class="line">    if html is None:</span><br><span class="line">        return None</span><br><span class="line">    soup &#x3D; BeautifulSoup(html, &quot;html.parser&quot;)</span><br><span class="line">    links &#x3D; soup.find_all(&#39;a&#39;, href&#x3D;re.compile(r&#39;&#x2F;forezp&#x2F;article&#x2F;details&#39;))</span><br><span class="line">    for link in links:</span><br><span class="line"></span><br><span class="line">        titles.add(link.get_text())</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解析摘要：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">def parse_descrtion(html):</span><br><span class="line">    if html is None:</span><br><span class="line">        return None</span><br><span class="line">    soup&#x3D;BeautifulSoup(html, &quot;html.parser&quot;)</span><br><span class="line">    disciptions&#x3D;soup.find_all(&#39;div&#39;,attrs&#x3D;&#123;&#39;class&#39;: &#39;article_description&#39;&#125;)</span><br><span class="line">    for link in disciptions:</span><br><span class="line"></span><br><span class="line">        titles.add(link.get_text())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 用“结巴”分词，”激8”分词怎么用，看这里：<a target="_blank" rel="noopener" href="https://github.com/fxsjy/jieba/">https://github.com/fxsjy/jieba/</a> </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def jiebaSet():</span><br><span class="line">    strs&#x3D;&#39;&#39;</span><br><span class="line">    if titles.__len__()&#x3D;&#x3D;0:</span><br><span class="line">        return</span><br><span class="line">    for item in titles:</span><br><span class="line">        strs&#x3D;strs+item;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    tags &#x3D; jieba.analyse.extract_tags(strs, topK&#x3D;100, withWeight&#x3D;True)</span><br><span class="line">    for item in tags:</span><br><span class="line">        print(item[0] + &#39;\t&#39; + str(int(item[1] * 1000)))</span><br></pre></td></tr></table></figure>
<p> 因为数据比较少，所以我直接打印在控制台，并把它复制下来，更好的方法是存在mongodb中。</p>
<p> 制作云图：<br> 用 artword在线工具，地址：<a target="_blank" rel="noopener" href="https://wordart.com/">https://wordart.com</a></p>
<p> 首先：<br> 导入从控制台复制过来的数据：</p>
<p> <img src="http://upload-images.jianshu.io/upload_images/2279594-de72be046ecac0d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>令人尴尬的是，这个网站在绘制图的时候不支持中文，需要你从c:/windows/fonts下选择一个支持中文的字体，mac 用户从windows拷下文件夹也可以，或者在网上下。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-fc5c023b1cf9f2c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>然后点击Visulize就可以生成高逼格的云图了。讲解完毕，有什么需要改进的请大家留言。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/ZhihuSpiderMan/tree/master/blogspider">https://github.com/forezp/ZhihuSpiderMan/tree/master/blogspider</a></p>
<h4 id="五、文章参考"><a href="#五、文章参考" class="headerlink" title="五、文章参考"></a>五、文章参考</h4><p><a target="_blank" rel="noopener" href="http://www.jianshu.com/p/4fb27471295f">超简单：快速制作一款高逼格词云图</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/68951699">如何爬取百万知乎用户信息，并做了简单的分析</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>如何爬知乎的百万用户</title>
    <url>/2017/04/04/python-2017-04-04-python-zh/</url>
    <content><![CDATA[<h3 id="一、使用的技术栈："><a href="#一、使用的技术栈：" class="headerlink" title="一、使用的技术栈："></a>一、使用的技术栈：</h3><ul>
<li>爬虫：python27 +requests+json+bs4+time</li>
<li>分析工具： ELK套件</li>
<li>开发工具：pycharm</li>
</ul>
<h3 id="二、数据成果"><a href="#二、数据成果" class="headerlink" title="二、数据成果"></a>二、数据成果</h3><h3 id="三、简单的可视化分析"><a href="#三、简单的可视化分析" class="headerlink" title="三、简单的可视化分析"></a>三、简单的可视化分析</h3><p>1.性别分布</p>
<ul>
<li>0 绿色代表的是男性 ^ . ^</li>
<li>1 代表的是女性</li>
<li>-1 性别不确定</li>
</ul>
<p>可见知乎的用户男性颇多。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-22b13dd888296ab7.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="WechatIMG2.jpeg"></p>
<span id="more"></span>

<p>2.粉丝最多的top30</p>
<p>粉丝最多的前三十名：依次是张佳玮、李开复、黄继新等等，去知乎上查这些人，也差不多这个排名，说明爬取的数据具有一定的说服力。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-8a57509513af7829.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="粉丝最多的top30"></p>
<p>3.写文章最多的top30<br><img src="http://upload-images.jianshu.io/upload_images/2279594-c29b348c4eb380f9.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="写文章最多的top30"></p>
<h3 id="四、爬虫架构"><a href="#四、爬虫架构" class="headerlink" title="四、爬虫架构"></a>四、爬虫架构</h3><p>爬虫架构图如下：<br><img src="http://upload-images.jianshu.io/upload_images/2279594-26c9bd69af563fd5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="爬虫架构图"></p>
<p>说明：</p>
<ul>
<li>选择一个活跃的用户（比如李开复）的url作为入口url.并将已爬取的url存在set中。</li>
<li>抓取内容，并解析该用户的关注的用户的列表url，添加这些url到另一个set中，并用已爬取的url作为过滤。</li>
<li>解析该用户的个人信息，并存取到本地磁盘。</li>
<li>logstash取实时的获取本地磁盘的用户数据，并给elsticsearch</li>
<li>kibana和elasticsearch配合，将数据转换成用户友好的可视化图形。</li>
</ul>
<h4 id="五-编码"><a href="#五-编码" class="headerlink" title="五.编码"></a>五.编码</h4><p>爬取一个url:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def download(url):</span><br><span class="line">    if url is None:</span><br><span class="line">        return None</span><br><span class="line">    try:</span><br><span class="line">        response &#x3D; requests.get(url, headers&#x3D;&#123;</span><br><span class="line">            &#39;User-Agent&#39;: &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_11_6) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;53.0.2785.143 Safari&#x2F;537.36&#39;,</span><br><span class="line">            &#39;authorization&#39;: &#39;your authorization &#39;</span><br><span class="line">        &#125;)</span><br><span class="line">        print (response.content)</span><br><span class="line">        if (response.status_code &#x3D;&#x3D; 200):</span><br><span class="line">            return response.content</span><br><span class="line">        return None</span><br><span class="line">    except:</span><br><span class="line">        return None</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>解析内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def parse(response):</span><br><span class="line">    try:</span><br><span class="line">        print (response)</span><br><span class="line">        json_body &#x3D; json.loads(response);</span><br><span class="line">        json_data &#x3D; json_body[&#39;data&#39;]</span><br><span class="line">        for item in json_data:</span><br><span class="line">            if (not old_url_tokens.__contains__(item[&#39;url_token&#39;])):</span><br><span class="line">                if(new_url_tokens.__len__()&lt;2000):</span><br><span class="line">                   new_url_tokens.add(item[&#39;url_token&#39;])</span><br><span class="line">            if (not saved_users_set.__contains__(item[&#39;url_token&#39;])):</span><br><span class="line">                jj&#x3D;json.dumps(item)</span><br><span class="line">                save(item[&#39;url_token&#39;],jj )</span><br><span class="line">                saved_users_set.add(item[&#39;url_token&#39;])</span><br><span class="line"></span><br><span class="line">        if (not json_body[&#39;paging&#39;][&#39;is_end&#39;]):</span><br><span class="line">            next_url &#x3D; json_body[&#39;paging&#39;][&#39;next&#39;]</span><br><span class="line">            response2 &#x3D; download(next_url)</span><br><span class="line">            parse(response2)</span><br><span class="line"></span><br><span class="line">    except:</span><br><span class="line">        print (&#39;parse fail&#39;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>存本地文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def save(url_token, strs):</span><br><span class="line">    f &#x3D; file(&quot;\\Users\\forezp\\Downloads\\zhihu\\user_&quot; + url_token + &quot;.txt&quot;, &quot;w+&quot;)</span><br><span class="line">    f.writelines(strs)</span><br><span class="line">    f.close()</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>代码说明：</p>
<ul>
<li>需要修改获取requests请求头的authorization。</li>
<li>需要修改你的文件存储路径。</li>
</ul>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/ZhihuSpiderMan">点击这里</a>，记得star哦！</p>
<h3 id="六-如何获取authorization"><a href="#六-如何获取authorization" class="headerlink" title="六.如何获取authorization"></a>六.如何获取authorization</h3><ul>
<li>打开chorme，打开<a target="_blank" rel="noopener" href="https://www.zhihu.com/%EF%BC%8C">https://www.zhihu.com/，</a>  </li>
<li>登陆，首页随便找个用户，进入他的个人主页，F12(或鼠标右键，点检查)</li>
<li>点击关注，刷新页面，见图：</li>
</ul>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0fa965cff3cddc64.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="如何获取authorization"></p>
<h3 id="七、可改进的地方"><a href="#七、可改进的地方" class="headerlink" title="七、可改进的地方"></a>七、可改进的地方</h3><ul>
<li>可增加线程池，提高爬虫效率</li>
<li>存储url的时候我才用的set(),并且采用缓存策略，最多只存2000个url，防止内存不够，其实可以存在redis中。</li>
<li>存储爬取后的用户我说采取的是本地文件的方式，更好的方式应该是存在mongodb中。</li>
<li>对爬取的用户应该有一个信息的过滤，比如用户的粉丝数需要大与100或者参与话题数大于10等才存储。防止抓取了过多的僵尸用户。</li>
</ul>
<h3 id="八-关于ELK套件"><a href="#八-关于ELK套件" class="headerlink" title="八.关于ELK套件"></a>八.关于ELK套件</h3><p>关于elk的套件安装就不讨论了，具体见官网就行了。网站：<a target="_blank" rel="noopener" href="https://www.elastic.co/">https://www.elastic.co/</a></p>
<p>另外logstash的配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">input &#123;</span><br><span class="line">  # For detail config for log4j as input,</span><br><span class="line">  # See: https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;logstash&#x2F;current&#x2F;plugins-inputs-log4j.html</span><br><span class="line"></span><br><span class="line">    file &#123;</span><br><span class="line">        path &#x3D;&gt; &quot;&#x2F;Users&#x2F;forezp&#x2F;Downloads&#x2F;zhihu&#x2F;*&quot;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  #Only matched data are send to output.</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">  # For detail config for elasticsearch as output,</span><br><span class="line">  # See: https:&#x2F;&#x2F;www.elastic.co&#x2F;guide&#x2F;en&#x2F;logstash&#x2F;current&#x2F;plugins-outputs-elasticsearch.html</span><br><span class="line"> elasticsearch &#123;</span><br><span class="line">    action &#x3D;&gt; &quot;index&quot;          #The operation on ES</span><br><span class="line">    hosts  &#x3D;&gt; &quot;localhost:9200&quot;   #ElasticSearch host, can be array.</span><br><span class="line">    index  &#x3D;&gt; &quot;zhihu&quot;         #The index to write data to.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="九、结语"><a href="#九、结语" class="headerlink" title="九、结语"></a>九、结语</h3><p>从爬取的用户数据可分析的地方很多，比如地域、学历、年龄等等，我就不一一列举了。另外，我觉得爬虫是一件非常有意思的事情，在这个内容消费升级的年代，如何在广阔的互联网的数据海洋中挖掘有价值的数据，是一件值得思考和需不断践行的事情。最后，本文仅用作交流学习。如果知乎告知我侵权，我会立刻删除本文。</p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python 爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 基础-数据结构-整数集合</title>
    <url>/2020/07/22/redis-2020-07-22-redis-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%95%B4%E6%95%B0%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h4 id="整数集合定义"><a href="#整数集合定义" class="headerlink" title="整数集合定义:"></a>整数集合定义:</h4><p>整数集合（intset）是Redis用于保存整数值的集合抽象数据结构，它可以保存类型为int16_t、int32_t或者int64_t的整数值，并且保证集合中不会出现重复元素。</p>
<h4 id="整数集合使用场景"><a href="#整数集合使用场景" class="headerlink" title="整数集合使用场景:"></a>整数集合使用场景:</h4><p>整数集合（intset）是集合键的底层实现之一，当一个集合只包含整数值元素，并且这个集合的元素数量不多时，Redis就会使用整数集合作为集合键的底层实现</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 基础-数据结构-跳跃表</title>
    <url>/2020/07/22/redis-2020-07-22-redis-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    <content><![CDATA[<h4 id="跳跃表定义"><a href="#跳跃表定义" class="headerlink" title="跳跃表定义:"></a>跳跃表定义:</h4><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</p>
<p>跳跃表支持平均O（logN）、最坏O（N）复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</p>
<span id="more"></span>
<h4 id="跳跃表使用场景"><a href="#跳跃表使用场景" class="headerlink" title="跳跃表使用场景:"></a>跳跃表使用场景:</h4><p>Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员（member）是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现,<br>和链表、字典等数据结构被广泛地应用在Redis内部不同，Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另一个是在集群节点中用作内部数据结构，除此之外，跳跃表在Redis里面没有其他用途。</p>
<h4 id="跳跃表构成"><a href="#跳跃表构成" class="headerlink" title="跳跃表构成:"></a>跳跃表构成:</h4><p>Redis的跳跃表由redis.h/zskiplistNode和redis.h/zskiplist两个结构定义。</p>
<p> zskiplistNode结构用于表示跳跃表节点:</p>
<ul>
<li>层（level）：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。</li>
</ul>
<p>  每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</p>
<ul>
<li><p>后退（backward）指针：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</p>
</li>
<li><p> 分值（score）：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</p>
</li>
<li><p> 成员对象（obj）：各个节点中的o1、o2和o3是节点所保存的成员对象。</p>
</li>
</ul>
<p>zskiplist结构:用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。</p>
<ul>
<li><p>header：指向跳跃表的表头节点。</p>
</li>
<li><p>tail：指向跳跃表的表尾节点</p>
</li>
<li><p>level：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）</p>
</li>
<li><p>length：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内</p>
</li>
</ul>
<h4 id="跳跃表展示图"><a href="#跳跃表展示图" class="headerlink" title="跳跃表展示图:"></a>跳跃表展示图:</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh0013kywqj30w40c442f.jpg"></p>
<h4 id="zskiplistNod-结构详细介绍："><a href="#zskiplistNod-结构详细介绍：" class="headerlink" title="zskiplistNod 结构详细介绍："></a>zskiplistNod 结构详细介绍：</h4><ul>
<li>结构定义：</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh00aw82t7j317s0l041b.jpg"></p>
<p>跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh01aoczwpj30yc0c2tcy.jpg">  </p>
<p>查询遍历过程：</p>
<ul>
<li><p>1）迭代程序首先访问跳跃表的第一个节点（表头），然后从第四层的前进指针移动到表中的第二个节点。</p>
</li>
<li><p>2）在第二个节点时，程序沿着第二层的前进指针移动到表中的第三个节点。</p>
</li>
<li><p>3）在第三个节点时，程序同样沿着第二层的前进指针移动到表中的第四个节点。</p>
</li>
<li><p>4）当程序再次沿着第四个节点的前进指针移动时，它碰到一个NULL，程序知道这时已经到达了跳跃表的表尾，于是结束这次遍历。</p>
</li>
</ul>
<p>举个查询例子：</p>
<p>假如要查询 数值为3.0的位置，从头节点出发遍历到3.0, 沿途经历的层：查找的过程只经过了一个层，并且层的跨度为3，所以目标节点在跳跃表中的位置为3。是不是很快！</p>
<h4 id="zskiplist-结构详细介绍："><a href="#zskiplist-结构详细介绍：" class="headerlink" title="zskiplist 结构详细介绍："></a>zskiplist 结构详细介绍：</h4><ul>
<li>结构定义：</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh00w61phgj316q0bumyv.jpg"></p>
<p>通过使用一个zskiplist结构来持有这些节点，程序可以更方便地对整个跳跃表进行处理，比如快速访问跳跃表的表头节点和表尾节点，或者快速地获取跳跃表节点的数量（也即是跳跃表的长度）等信息</p>
<h4 id="跳跃表常见api"><a href="#跳跃表常见api" class="headerlink" title="跳跃表常见api"></a>跳跃表常见api</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh01ipeqxfj30r80miakt.jpg"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul>
<li><p>跳跃表是有序集合的底层实现之一。</p>
</li>
<li><p>Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</p>
</li>
<li><p>每个跳跃表节点的层高都是1至32之间的随机数。</p>
</li>
<li><p>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的。❑跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 基础-5大对象</title>
    <url>/2020/07/22/redis-2020-07-27-redis-%E5%9F%BA%E7%A1%80-5%E5%A4%A7%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h4 id="对象的类型与编码"><a href="#对象的类型与编码" class="headerlink" title="对象的类型与编码:"></a>对象的类型与编码:</h4><p>对象类型-&gt;对象编码-&gt;对象所使用的数据结构</p>
<p>Redis使用对象来表示数据库中的键和值，每次当我们在Redis的数据库中新创建一个键值对时，我们至少会创建两个对象，一个对象用作键值对的键（键对象），另一个对象用作键值对的值（值对象）</p>
<p>Redis中的每个对象都由一个redisObject结构表示，该结构中和保存数据有关的三个属性分别是type属性、encoding属性和ptr属性</p>
<span id="more"></span>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1aokij6gj31860eumz2.jpg"></p>
<ul>
<li>类型</li>
</ul>
<p>对象的type属性记录了对象的类型，这个属性的值可以是列出的常量的其中一个。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1aqpij1xj30r20h6tdu.jpg"></p>
<p>一般键是字符串，值是字符串对象、列表对象、哈希对象、集合对象或者有序集合对象的其中一种。</p>
<p>不同类型值对象的可以通过TYPE命令输出<br><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1avi4btfj30s20c8q7c.jpg"></p>
<ul>
<li>编码和底层实现</li>
</ul>
<p>对象的ptr指针指向对象的底层实现数据结构，而这些数据结构由对象的encoding属性决定。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1ay5hjl8j30sq0aatbf.jpg"></p>
<p>使用OBJECT ENCODING命令可以查看一个数据库键的值对象的编码，从而知道对应使用的数据结构。</p>
<p>通过encoding属性来设定对象所使用的编码，而不是为特定类型的对象关联一种固定的编码，极大地提升了Redis的灵活性和效率，因为Redis可以根据不同的使用场景来为一个对象设置不同的编码，从而优化对象在某一场景下的效率</p>
<p>举个例子，在列表对象包含的元素比较少时，Redis使用压缩列表作为列表对象的底层实现：</p>
<p>❑因为压缩列表比双端链表更节约内存，并且在元素数量较少时，在内存中以连续块方式保存的压缩列表比起双端链表可以更快被载入到缓存中；</p>
<p>❑随着列表对象包含的元素越来越多，使用压缩列表来保存元素的优势逐渐消失时，对象就会将底层实现从压缩列表转向功能更强、也更适合保存大量元素的双端链表上面；其他类型的对象也会通过使用多种不同的编码来进行类似的优化。</p>
<h4 id="字符串对象"><a href="#字符串对象" class="headerlink" title="字符串对象"></a>字符串对象</h4><p>字符串对象保存的是一个字符串值，并且这个字符串值的长度大于32字节，那么字符串对象将使用一个简单动态字符串（SDS）来保存这个字符串值，并将对象的编码设置为raw，小与32字节编码设置则为embstr。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1be9pfucj31640b240y.jpg"></p>
<ul>
<li>embstr编码和raw编码对比：</li>
</ul>
<p>embstr编码 创建字符串对象分配一次内存，raw编码分配两次内存，同理释放内存也是，且embstr编码的字符串对象在内存上是连续的，更好的利用缓存的优势。</p>
<ul>
<li>编码的转换</li>
</ul>
<p>embstr编码的字符串对象在执行APPEND命令之后，对象的编码从embstr变为raw</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1btzg9ssj31fa0ewdi5.jpg"></p>
<ul>
<li>字符串命令的实现</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1bv1g61vj30wr0u0wzq.jpg"></p>
<h4 id="哈希对象"><a href="#哈希对象" class="headerlink" title="哈希对象"></a>哈希对象</h4><p>哈希对象的编码可以是ziplist或者hashtable</p>
<p>当哈希对象可以同时满足以下两个条件时，哈希对象使用ziplist编码：</p>
<ul>
<li><p>哈希对象保存的所有键值对的键和值的字符串长度都小于64字节；</p>
</li>
<li><p>哈希对象保存的键值对数量小于512个；不能满足这两个条件的哈希对象需要使用hashtable编码。</p>
</li>
</ul>
<p>举个例子，如果我们执行以下HSET命令，那么服务器将创建一个列表对象作为profile键的值：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1ceyr7ezj31fa0c040f.jpg"></p>
<p>如果profile键的值对象使用的是ziplist编码：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1cgljoefj31200jmn16.jpg"></p>
<p>profile哈希对象的压缩列表底层实现:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1chfkv5oj315w06eq4z.jpg"></p>
<p>如果profile键的值对象使用的是hashtable编码：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1cjz4sd9j310y0k8af6.jpg"></p>
<p>哈希命令的实现：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh1cm3idw4j30zo0nggxk.jpg"></p>
<h4 id="列表对象"><a href="#列表对象" class="headerlink" title="列表对象"></a>列表对象</h4><p>列表对象的编码可以是ziplist或者linkedlist</p>
<p>ziplist编码的列表对象使用压缩列表作为底层实现，每个压缩列表节点（entry）保存了一个列表元素</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tcs5jd3j30z20863zu.jpg"></p>
<p>linkedlist编码的列表对象使用双端链表作为底层实现，每个双端链表节点（node）都保存了一个字符串对象，而每个字符串对象都保存了一个列表元素。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tdx6bicj313w086wgn.jpg"></p>
<p>StringObject 是字符串对象的简写,完整如下：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tei8lzsj30u404kdgu.jpg"></p>
<p>当列表对象可以同时满足以下两个条件时，列表对象使用ziplist编码：</p>
<ul>
<li><p>列表对象保存的所有字符串元素的长度都小于64字节；</p>
</li>
<li><p>列表对象保存的元素数量小于512个；不能满足这两个条件的列表对象需要使用linkedlist编码。</p>
</li>
</ul>
<p>列表命令的实现</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tfra0mkj30sa0o2h1l.jpg"></p>
<h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4><p>集合对象的编码可以是intset或者hashtable。</p>
<p>intset编码的集合对象使用整数集合作为底层实现，集合对象包含的所有元素都被保存在整数集合里面。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tretdeqj30yg08y0uw.jpg"></p>
<p>hashtable编码的集合对象使用字典作为底层实现，字典的每个键都是一个字符串对象，每个字符串对象包含了一个集合元素，而字典的值则全部被设置为NULL</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6trr0e0cj30we0ckaeb.jpg"></p>
<p>集合命令的实现</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tu7cmc0j30vw0is7h2.jpg"></p>
<h4 id="有序集合对象"><a href="#有序集合对象" class="headerlink" title="有序集合对象"></a>有序集合对象</h4><p>有序集合的编码可以是ziplist或者skiplist。</p>
<p>ziplist编码的压缩列表对象使用压缩列表作为底层实现，每个集合元素使用两个紧挨在一起的压缩列表节点来保存，第一个节点保存元素的成员（member），而第二个元素则保存元素的分值（score）</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6twum182j310q0eo77q.jpg"></p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6tx9fbsyj30x204g75r.jpg"></p>
<p>skiplist编码的有序集合对象使用zset结构作为底层实现，一个zset结构同时包含一个字典和一个跳跃表：</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6ty5nhk6j318c074wf2.jpg"></p>
<ul>
<li>为什么有序集合需要同时使用跳跃表和字典来实现？</li>
</ul>
<p>理论上单独使用任何一种结构都可以实现有序集合，但从复杂度来说，<br>单独使用字典实现，虽然查找分值是O(1),但因为字典是无序的,所以排序O(NlogN）复杂度。<br>单独使用跳跃表实现，虽然可以有序，但是查询分值复杂度从O（1）上升为O（logN).</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6uc2evb0j30xk0gkgqe.jpg"></p>
<p>有序集合命令的实现</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6udkfts7j30xk0pe7jc.jpg"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 对象</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 基础-数据结构-简单动态字符串</title>
    <url>/2020/07/28/redis-2020-07-28-redis-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%AE%80%E5%8D%95%E5%8A%A8%E6%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h4 id="简单动态字符串定义"><a href="#简单动态字符串定义" class="headerlink" title="简单动态字符串定义:"></a>简单动态字符串定义:</h4><p>每个sds.h/sdshdr结构表示一个SDS值</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6v5tmf5jj31840eq0ur.jpg"></p>
<span id="more"></span>


<p>SDS示例:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6v6tnl68j30xy0d4wge.jpg"></p>
<p>SDS和C字符一样保留空字符结尾，但是不会计算在len属性里，自动分配1字节空间和末尾添加空字符都是sds函数自动完成的。</p>
<h4 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别:"></a>SDS与C字符串的区别:</h4><ul>
<li>常数复杂度获取字符串长度</li>
</ul>
<p>C字符串本身的长度不记录，所以获取对应的长度是O(n)复杂度。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vg9k270j313w0u0gv5.jpg"></p>
<p>因为SDS在len属性中记录了SDS本身的长度，所以获取一个SDS长度的复杂度仅为O（1）.</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vh7vqaxj31180bqdhg.jpg"></p>
<p>这个结构确保了获取字符串长度的工作不会成为Redis的性能瓶颈。</p>
<ul>
<li>杜绝缓冲区溢出</li>
</ul>
<p>C字符串除了O(n)复杂度之外，还会存在缓冲区溢出（buffer overflow）</p>
<p>使用sds api对 sds修改的时候，会先检查其对应空间是否满足，不满足会自动拓展，在执行修改。</p>
<p>举个例子，SDS的API里面也有一个用于执行拼接操作的sdscat函数，它可以将一个C字符串拼接到给定SDS所保存的字符串的后面，</p>
<p>但是在执行拼接操作之前，sdscat会先检查给定SDS的空间是否足够，如果不够的话，sdscat就会先扩展SDS的空间，然后才执行拼接操作</p>
<p>拼接操作之前:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vni0q9ij30yk0aw0uf.jpg"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sdscat(s,&quot; Cluster&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>拼接操作之后:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vnxuvqtj30vk060dgr.jpg"></p>
<ul>
<li>减少修改字符串时带来的内存重分配次数</li>
</ul>
<p>每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作:</p>
<p>比如拼接操作（append），截断操作（trim）。</p>
<p>因为内存重分配涉及复杂的算法，并且可能需要执行系统调用，所以它通常是一个比较耗时的操作。</p>
<p>为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录</p>
<p>SDS实现了空间预分配和惰性空间释放两种优化策略：</p>
<ul>
<li>1.空间预分配<ul>
<li>如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同</li>
<li>如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间</li>
</ul>
</li>
</ul>
<blockquote>
<p>执行sdscat之前：</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vv4w7sdj30yg0bqq4v.jpg"></p>
<blockquote>
<p>执行sdscat之后：</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vyesgypj30zk066q3v.jpg"></p>
<blockquote>
<p>再次执行sdscat：</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6vzveb5xj315k06e0tm.jpg"></p>
<blockquote>
<p>过这种预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次</p>
</blockquote>
<ul>
<li>2.惰性空间释放</li>
</ul>
<p>  惰性空间释放用于优化SDS的字符串缩短操作：当SDS的API需要缩短SDS保存的字符串时，程序并不立即使用内存重分配来回收缩短后多出来的字节，而是使用free属性将这些字节的数量记录起来，并等待将来使用。</p>
<blockquote>
<p>执行sdstrim之前:</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6welfjn7j30u807it9m.jpg"></p>
<blockquote>
<p>执行sdstrim之后:</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6wg7f5aqj3140090jsd.jpg"></p>
<blockquote>
<p>再次执行sdscat之后：</p>
</blockquote>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6wh8yuupj317k08yt9r.jpg"></p>
<p>  当然SDS也提供了相应的API，让我们可以在有需要时，真正地释放SDS的未使用空间，所以不用担心惰性空间释放策略会造成内存浪费。</p>
<ul>
<li>二进制安全</li>
</ul>
<p>C字符串中的字符必须符合某种编码（比如ASCII），并且除了字符串的末尾之外，字符串里面不能包含空字符，否则最先被程序读入的空字符将被误认为是字符串结尾，这些限制使得C字符串只能保存文本数据，而不能保存像图片、音频、视频、压缩文件这样的二进制数据  </p>
<p>为了确保Redis可以适用于各种不同的使用场景，SDS的API都是二进制安全的（binary-safe），所有SDSAPI都会以处理二进制的方式来处理SDS存放在buf数组里的数据也是我们将SDS的buf属性称为字节数组的原因。</p>
<p>通过使用二进制安全的SDS，而不是C字符串，使得Redis不仅可以保存文本数据，还可以保存任意格式的二进制数据</p>
<ul>
<li>C字符串和SDS之间的区别</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6wndju9hj30xg08k77q.jpg"></p>
<h4 id="SDS-API"><a href="#SDS-API" class="headerlink" title="SDS API"></a>SDS API</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6wom8r58j30w80msds9.jpg"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1）常数复杂度获取字符串长度。</p>
<p>2）杜绝缓冲区溢出。</p>
<p>3）减少修改字符串长度时所需的内存重分配次数。</p>
<p>4）二进制安全。</p>
<p>5）兼容部分C字符串函数。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 基础-数据结构-字典</title>
    <url>/2020/07/29/redis-2020-07-29-redis-%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h4 id="字典定义"><a href="#字典定义" class="headerlink" title="字典定义:"></a>字典定义:</h4><p>字典（dictionary）， 又名映射（map）或关联数组（associative array）， 是一种抽象数据结构， 由一集键值对（key-value pairs）组成， 各个键值对的键各不相同， 程序可以添加新的键值对到字典中， 或者基于键进行查找、更新或删除等操作。</p>
<span id="more"></span>

<p>字典的主要用途有以下两个： 1.实现数据库键空间（key space）2.用作 Hash 类型键的底层实现之一,具体可以看redis 5大对象那篇文章。</p>
<h4 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h4><p>Redis的字典使用哈希表作为底层实现，一个哈希表里面可以有多个哈希表节点，而每个哈希表节点就保存了字典中的一个键值对。</p>
<ul>
<li>哈希表</li>
</ul>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6x5esz0sj317w0h4dim.jpg"></p>
<p>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点（键值对）的数量。sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面</p>
<p>一个大小为4的空哈希表:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh6x8e3dn2j30xa0eeq62.jpg"></p>
<ul>
<li>哈希表节点</li>
</ul>
<p>哈希表节点使用dictEntry结构表示，每个dictEntry结构都保存着一个键值对。</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7nrf2momj317o0icdhx.jpg"></p>
<p>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7nu7hg4qj312w08m0un.jpg"></p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7nx14aclj317s0hc413.jpg"></p>
<p>type属性和privdata属性是针对不同类型的键值对，为创建多态字典而设置的：</p>
<ul>
<li><p>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数。</p>
</li>
<li><p>而privdata属性则保存了需要传给那些类型特定函数的可选参数。</p>
</li>
</ul>
<p>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用</p>
<p>除了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7o1vruinj316c0fygot.jpg"></p>
<h4 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h4><p>当有新的键值对添加到字典中，需要根据key 算出对应的哈希值和索引值，然后再根据索引值，将包含新键值对的哈希表节点放到哈希表数组的指定索引上面</p>
<p>Redis计算哈希值和索引值的方法如下:</p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7o7ofn6gj318208odhy.jpg"></p>
<ul>
<li>举列：</li>
</ul>
<p>  我们要将一个键值对k0和v0添加到字典，先利用上面语句获取hash值，然后获取对应的索引值。</p>
<p>  <img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7oaramw2j31560caacn.jpg"></p>
<h4 id="解决键冲突"><a href="#解决键冲突" class="headerlink" title="解决键冲突"></a>解决键冲突</h4><p>当有两个或以上数量的键被分配到了哈希表数组的同一个索引上面时，我们称这些键发生了冲突（collision）.</p>
<p>Redis的哈希表使用链地址法（separate chaining）来解决键冲突，每个哈希表节点都有一个next指针，多个哈希表节点可以用next指针构成一个单向链表，被分配到同一个索引上的多个节点可以用这个单向链表连接起来，这就解决了键冲突的问题。  </p>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7t7jdv02j30z40bgacf.jpg"></p>
<h4 id="rehash"><a href="#rehash" class="headerlink" title="rehash"></a>rehash</h4><p>扩展和收缩哈希表的工作可以通过执行rehash（重新散列）操作来完成，Redis对字典的哈希表执行rehash的步骤如下：</p>
<p>1）为字典的ht[1]哈希表分配空间，这个哈希表的空间大小取决于要执行的操作，以及ht[0]当前包含的键值对数量（也即是ht[0].used属性的值）：</p>
<ul>
<li>如果执行的是扩展操作，那么ht[1]的大小为第一个大于等于ht[0].used*2的2 n（2的n次方幂）；</li>
<li>如果执行的是收缩操作，那么ht[1]的大小为第一个大于等于ht[0].used的2 n。</li>
</ul>
<p>2）将保存在ht[0]中的所有键值对rehash到ht[1]上面：rehash指的是重新计算键的哈希值和索引值，然后将键值对放置到ht[1]哈希表的指定位置上。</p>
<p>3）当ht[0]包含的所有键值对都迁移到了ht[1]之后（ht[0]变为空表），释放ht[0]，将ht[1]设置为ht[0]，并在ht[1]新创建一个空白哈希表，为下一次rehash做准备。</p>
<blockquote>
<p>执行rehash之前的字典</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7tfuiudnj310a0hi0wp.jpg"></p>
<blockquote>
<p>为字典的ht[1]哈希表分配空间</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7tfuiudnj310a0hi0wp.jpg"></p>
<blockquote>
<p>将ht[0]包含的四个键值对都rehash到ht[1]</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7ticpjpwj314c0i8434.jpg"></p>
<blockquote>
<p>释放ht[0]，并将ht[1]设置为ht[0]，然后为ht[1]分配一个空白哈希表</p>
</blockquote>
<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7tiy9y4vj310k0huwik.jpg"></p>
<p>另一方面，当哈希表的负载因子小于0.1时，程序自动开始对哈希表执行收缩操作</p>
<h4 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h4><p>背景：如果哈希表里保存的键值对数量不是四个，而是四百万、四千万甚至四亿个键值对，那么要一次性将这些键值对全部rehash到ht[1]的话，庞大的计算量可能会导致服务器在一段时间内停止服务。</p>
<p>为了避免rehash对服务器性能造成影响，服务器不是一次性将ht[0]里面的所有键值对全部rehash到ht[1]，而是分多次、渐进式地将ht[0]里面的键值对慢慢地rehash到ht[1]。</p>
<p>以下是哈希表渐进式rehash的详细步骤：</p>
<ul>
<li><p>1）为ht[1]分配空间，让字典同时持有ht[0]和ht[1]两个哈希表。</p>
</li>
<li><p>2）在字典中维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash工作正式开始。</p>
</li>
<li><p>3）在rehash进行期间，每次对字典执行添加、删除、查找或者更新操作时，程序除了执行指定的操作以外，还会顺带将ht[0]哈希表在rehashidx索引上的所有键值对rehash到ht[1]，当rehash工作完成之后，程序将rehashidx属性的值增一。</p>
</li>
<li><p>4）随着字典操作的不断执行，最终在某个时间点上，ht[0]的所有键值对都会被rehash至ht[1]，这时程序将rehashidx属性的值设为-1，表示rehash操作已完成。渐进式rehash的好处在于它采取分而治之的方式，将rehash键值对所需的计算工作均摊到对字典的每个添加、删除、查找和更新操作上，从而避免了集中式rehash而带来的庞大计算量</p>
</li>
</ul>
<p>在渐进式rehash执行期间，新添加到字典的键值对一律会被保存到ht[1]里面，而ht[0]则不再进行任何添加操作，这一措施保证了ht[0]包含的键值对数量会只减不增，并随着rehash操作的执行而最终变成空表。</p>
<h4 id="字典API"><a href="#字典API" class="headerlink" title="字典API"></a>字典API</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlgy1gh7w8rgux8j31080bk0x6.jpg"></p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 的线程模型</title>
    <url>/2020/10/26/redis-2020-10-26-redis-%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h3 id="Redis-的线程模型"><a href="#Redis-的线程模型" class="headerlink" title="Redis 的线程模型"></a>Redis 的线程模型</h3><p>Redis 内部使用文件事件处理器 file event handler ，这个文件事件处理器是单线程的，所以 Redis 才叫做单线程的模型。它采用 IO 多路复用机制同时监听多个 socket，将产生事件的 socket 压入内存队列中，事件分派器根据 socket 上的事件类型来选择对应的事件处理器进行处理。</p>
<span id="more"></span>
<p>文件事件处理器的结构包含 4 个部分：</p>
<ul>
<li>多个 socket</li>
<li>IO 多路复用程序</li>
<li>文件事件分派器</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<p>多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将产生事件的 socket 放入队列中排队，事件分派器每次从队列中取出一个 socket，根据 socket 的事件类型交给对应的事件处理器进行处理。</p>
<p>来看客户端与 Redis 的一次通信过程：</p>
<p>Redis-single-thread-model</p>
<p><img src="https://tva1.sinaimg.cn/large/0081Kckwgy1gk2qyo3nu4j31c80r8n45.jpg"></p>
<p>要明白，通信是通过 socket 来完成的，不懂的同学可以先去看一看 socket 网络编程。</p>
<p>首先，Redis 服务端进程初始化的时候，会将 server socket 的 AE_READABLE 事件与连接应答处理器关联。</p>
<p>客户端 socket01 向 Redis 进程的 server socket 请求建立连接，此时 server socket 会产生一个 AE_READABLE 事件，IO 多路复用程序监听到 server socket 产生的事件后，将该 socket 压入队列中。文件事件分派器从队列中获取 socket，交给连接应答处理器。连接应答处理器会创建一个能与客户端通信的 socket01，并将该 socket01 的 AE_READABLE 事件与命令请求处理器关联。</p>
<p>假设此时客户端发送了一个 set key value 请求，此时 Redis 中的 socket01 会产生 AE_READABLE 事件，IO 多路复用程序将 socket01 压入队列，此时事件分派器从队列中获取到 socket01 产生的 AE_READABLE 事件，由于前面 socket01 的 AE_READABLE 事件已经与命令请求处理器关联，因此事件分派器将事件交给命令请求处理器来处理。命令请求处理器读取 socket01 的 key value 并在自己内存中完成 key value 的设置。操作完成后，它会将 socket01 的 AE_WRITABLE 事件与命令回复处理器关联。</p>
<p>如果此时客户端准备好接收返回结果了，那么 Redis 中的 socket01 会产生一个 AE_WRITABLE 事件，同样压入队列中，事件分派器找到相关联的命令回复处理器，由命令回复处理器对 socket01 输入本次操作的一个结果，比如 ok ，之后解除 socket01 的 AE_WRITABLE 事件与命令回复处理器的关联。</p>
<p>这样便完成了一次通信。</p>
<h3 id="为啥-Redis-单线程模型也能效率这么高？"><a href="#为啥-Redis-单线程模型也能效率这么高？" class="headerlink" title="为啥 Redis 单线程模型也能效率这么高？"></a>为啥 Redis 单线程模型也能效率这么高？</h3><ul>
<li>纯内存操作。</li>
<li>核心是基于非阻塞的 IO 多路复用机制。</li>
<li> C 语言实现，一般来说，C 语言实现的程序“距离”操作系统更近，执行速度相对会更快。</li>
<li> 单线程反而避免了多线程的频繁上下文切换问题，预防了多线程可能产生的竞争问题。</li>
</ul>
<h3 id="Redis-6-0-开始引入多线程"><a href="#Redis-6-0-开始引入多线程" class="headerlink" title="Redis 6.0 开始引入多线程"></a>Redis 6.0 开始引入多线程</h3><p>注意！ Redis 6.0 之后的版本抛弃了单线程模型这一设计，原本使用单线程运行的 Redis 也开始选择性地使用多线程模型。</p>
<p>前面还在强调 Redis 单线程模型的高效性，现在为什么又要引入多线程？这其实说明 Redis 在有些方面，单线程已经不具有优势了。因为读写网络的 Read/Write 系统调用在 Redis 执行期间占用了大部分 CPU 时间，如果把网络读写做成多线程的方式对性能会有很大提升。</p>
<p>Redis 的多线程部分只是用来处理网络数据的读写和协议解析，执行命令仍然是单线程。 之所以这么设计是不想 Redis 因为多线程而变得复杂，需要去控制 key、lua、事务、LPUSH/LPOP 等等的并发问题。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Redis 选择使用单线程模型处理客户端的请求主要还是因为 CPU 不是 Redis 服务器的瓶颈，所以使用多线程模型带来的性能提升并不能抵消它带来的开发成本和维护成本，系统的性能瓶颈也主要在网络 I/O 操作上；而 Redis 引入多线程操作也是出于性能上的考虑，对于一些大键值对的删除操作，通过多线程非阻塞地释放内存空间也能减少对 Redis 主线程阻塞的时间，提高执行的效率。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 线程模型</tag>
      </tags>
  </entry>
  <entry>
    <title>redis 的事物</title>
    <url>/2020/10/27/redis-2020-10-27-redis-%E7%9A%84%E4%BA%8B%E7%89%A9/</url>
    <content><![CDATA[<p>MULTI 、 EXEC 、 DISCARD 和 WATCH 是 Redis 事务的基础。</p>
<span id="more"></span>
<p>事务可以一次执行多个命令， 并且带有以下两个重要的保证：</p>
<ul>
<li>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</li>
<li>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</li>
</ul>
<!--more-->
<p>EXEC 命令负责触发并执行事务中的所有命令：<br>当使用 AOF 方式做持久化的时候， Redis 会使用单个 write(2) 命令将事务写入到磁盘中。<br>然而，如果 Redis 服务器因为某些原因被管理员杀死，或者遇上某种硬件故障，那么可能只有部分事务命令会被成功写入到磁盘中。<br>如果 Redis 在重新启动时发现 AOF 文件出了这样的问题，那么它会退出，并汇报一个错误。<br>使用 redis-check-aof 程序可以修复这一问题：它会移除 AOF 文件中不完整事务的信息，确保服务器可以顺利启动。</p>
<ul>
<li>如果客户端在使用 MULTI 开启了一个事务之后，却因为断线而没有成功执行 EXEC ，那么事务中的所有命令都不会被执行。</li>
<li>另一方面，如果客户端成功在开启事务之后执行 EXEC ，那么事务中的所有命令都会被执行。<br>从 2.2 版本开始，Redis 还可以通过乐观锁（optimistic lock）实现 CAS （check-and-set）操作，具体信息请参考文档的后半部分。</li>
</ul>
<h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>MULTI 命令用于开启一个事务，它总是返回 OK 。</p>
<p>MULTI 执行之后， 客户端可以继续向服务器发送任意多条命令， 这些命令不会立即被执行， 而是被放到一个队列中， 当 EXEC 命令被调用时， 所有队列中的命令才会被执行。</p>
<p>另一方面， 通过调用 DISCARD ， 客户端可以清空事务队列， 并放弃执行事务。</p>
<p>以下是一个事务例子， 它原子地增加了 foo 和 bar 两个键的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">&gt; INCR bar</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">&gt; EXEC</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) (integer) 1</span><br></pre></td></tr></table></figure>
<p>EXEC 命令的回复是一个数组， 数组中的每个元素都是执行事务中的命令所产生的回复。 其中， 回复元素的先后顺序和命令发送的先后顺序一致。</p>
<p>当客户端处于事务状态时， 所有传入的命令都会返回一个内容为 QUEUED 的状态回复（status reply）， 这些被入队的命令将在 EXEC 命令被调用时执行。</p>
<h3 id="事务中的错误"><a href="#事务中的错误" class="headerlink" title="事务中的错误"></a>事务中的错误</h3><p>使用事务时可能会遇上以下两种错误：</p>
<ul>
<li>事务在执行 EXEC 之前，入队的命令可能会出错。比如说，命令可能会产生语法错误（参数数量错误，参数名错误，等等），或者其他更严重的错误，比如内存不足（如果服务器使用 maxmemory 设置了最大内存限制的话）。</li>
<li>命令可能在 EXEC 调用之后失败。举个例子，事务中的命令可能处理了错误类型的键，比如将列表命令用在了字符串键上面，诸如此类。<br>对于发生在 EXEC 执行之前的错误，客户端以前的做法是检查命令入队所得的返回值：如果命令入队时返回 QUEUED ，那么入队成功；否则，就是入队失败。如果有命令在入队时失败，那么大部分客户端都会停止并取消这个事务。</li>
</ul>
<p>不过，从 Redis 2.6.5 开始，服务器会对命令入队失败的情况进行记录，并在客户端调用 EXEC 命令时，拒绝执行并自动放弃这个事务。</p>
<p>在 Redis 2.6.5 以前， Redis 只执行事务中那些入队成功的命令，而忽略那些入队失败的命令。 而新的处理方式则使得在流水线（pipeline）中包含事务变得简单，因为发送事务和读取事务的回复都只需要和服务器进行一次通讯。</p>
<p>至于那些在 EXEC 命令执行之后所产生的错误， 并没有对它们进行特别处理： 即使事务中有某个/某些命令在执行时产生了错误， 事务中的其他命令仍然会继续执行。</p>
<p>从协议的角度来看这个问题，会更容易理解一些。 以下例子中， LPOP 命令的执行将出错， 尽管调用它的语法是正确的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Trying 127.0.0.1...</span><br><span class="line">Connected to localhost.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line"></span><br><span class="line">MULTI</span><br><span class="line">+OK</span><br><span class="line"></span><br><span class="line">SET a 3</span><br><span class="line">abc</span><br><span class="line"></span><br><span class="line">+QUEUED</span><br><span class="line">LPOP a</span><br><span class="line"></span><br><span class="line">+QUEUED</span><br><span class="line">EXEC</span><br><span class="line"></span><br><span class="line">*2</span><br><span class="line">+OK</span><br><span class="line">-ERR Operation against a key holding the wrong kind of value</span><br></pre></td></tr></table></figure>

<p>EXEC 返回两条批量回复（bulk reply）： 第一条是 OK ，而第二条是 -ERR 。 至于怎样用合适的方法来表示事务中的错误， 则是由客户端自己决定的。</p>
<p>最重要的是记住这样一条， 即使事务中有某条/某些命令执行失败了， 事务队列中的其他命令仍然会继续执行 —— Redis 不会停止执行事务中的命令。</p>
<p>以下例子展示的是另一种情况， 当命令在入队时产生错误， 错误会立即被返回给客户端：</p>
<p>MULTI<br>+OK</p>
<p>INCR a b c<br>-ERR wrong number of arguments for ‘incr’ command<br>因为调用 INCR 命令的参数格式不正确， 所以这个 INCR 命令入队失败。</p>
<h3 id="为什么-Redis-不支持回滚（roll-back）"><a href="#为什么-Redis-不支持回滚（roll-back）" class="headerlink" title="为什么 Redis 不支持回滚（roll back）"></a>为什么 Redis 不支持回滚（roll back）</h3><p>如果你有使用关系式数据库的经验， 那么 “Redis 在事务失败时不进行回滚，而是继续执行余下的命令”这种做法可能会让你觉得有点奇怪。</p>
<p>以下是这种做法的优点：</p>
<ul>
<li>Redis 命令只会因为错误的语法而失败（并且这些问题不能在入队时发现），或是命令用在了错误类型的键上面：这也就是说，从实用性的角度来说，失败的命令是由编程错误造成的，而这些错误应该在开发的过程中被发现，而不应该出现在生产环境中。</li>
<li>因为不需要对回滚进行支持，所以 Redis 的内部可以保持简单且快速。<br>有种观点认为 Redis 处理事务的做法会产生 bug ， 然而需要注意的是， 在通常情况下， 回滚并不能解决编程错误带来的问题。 举个例子， 如果你本来想通过 INCR 命令将键的值加上 1 ， 却不小心加上了 2 ， 又或者对错误类型的键执行了 INCR ， 回滚是没有办法处理这些情况的。</li>
</ul>
<p>鉴于没有任何机制能避免程序员自己造成的错误， 并且这类错误通常不会在生产环境中出现， 所以 Redis 选择了更简单、更快速的无回滚方式来处理事务。</p>
<h3 id="放弃事务"><a href="#放弃事务" class="headerlink" title="放弃事务"></a>放弃事务</h3><p>当执行 DISCARD 命令时， 事务会被放弃， 事务队列会被清空， 并且客户端会从事务状态中退出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">redis&gt; SET foo 1</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; MULTI</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; INCR foo</span><br><span class="line">QUEUED</span><br><span class="line"></span><br><span class="line">redis&gt; DISCARD</span><br><span class="line">OK</span><br><span class="line"></span><br><span class="line">redis&gt; GET foo</span><br><span class="line">&quot;1&quot;</span><br></pre></td></tr></table></figure>
<h3 id="使用-check-and-set-操作实现乐观锁"><a href="#使用-check-and-set-操作实现乐观锁" class="headerlink" title="使用 check-and-set 操作实现乐观锁"></a>使用 check-and-set 操作实现乐观锁</h3><p>WATCH 命令可以为 Redis 事务提供 check-and-set （CAS）行为。</p>
<p>被 WATCH 的键会被监视，并会发觉这些键是否被改动过了。 如果有至少一个被监视的键在 EXEC 执行之前被修改了， 那么整个事务都会被取消， EXEC 返回空多条批量回复（null multi-bulk reply）来表示事务已经失败。</p>
<p>举个例子， 假设我们需要原子性地为某个值进行增 1 操作（假设 INCR 不存在）。</p>
<p>首先我们可能会这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">val &#x3D; GET mykey</span><br><span class="line">val &#x3D; val + 1</span><br><span class="line">SET mykey $val</span><br></pre></td></tr></table></figure>
<p>上面的这个实现在只有一个客户端的时候可以执行得很好。 但是， 当多个客户端同时对同一个键进行这样的操作时， 就会产生竞争条件。</p>
<p>举个例子， 如果客户端 A 和 B 都读取了键原来的值， 比如 10 ， 那么两个客户端都会将键的值设为 11 ， 但正确的结果应该是 12 才对。</p>
<p>有了 WATCH ， 我们就可以轻松地解决这类问题了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WATCH mykey</span><br><span class="line"></span><br><span class="line">val &#x3D; GET mykey</span><br><span class="line">val &#x3D; val + 1</span><br><span class="line"></span><br><span class="line">MULTI</span><br><span class="line">SET mykey $val</span><br><span class="line">EXEC</span><br></pre></td></tr></table></figure>
<p>使用上面的代码， 如果在 WATCH 执行之后， EXEC 执行之前， 有其他客户端修改了 mykey 的值， 那么当前客户端的事务就会失败。 程序需要做的， 就是不断重试这个操作， 直到没有发生碰撞为止。</p>
<p>这种形式的锁被称作乐观锁， 它是一种非常强大的锁机制。 并且因为大多数情况下， 不同的客户端会访问不同的键， 碰撞的情况一般都很少， 所以通常并不需要进行重试。</p>
<h3 id="了解-WATCH"><a href="#了解-WATCH" class="headerlink" title="了解 WATCH"></a>了解 WATCH</h3><p>WATCH 使得 EXEC 命令需要有条件地执行： 事务只能在所有被监视键都没有被修改的前提下执行， 如果这个前提不能满足的话，事务就不会被执行。</p>
<p>如果你使用 WATCH 监视了一个带过期时间的键， 那么即使这个键过期了， 事务仍然可以正常执行， 关于这方面的详细情况，请看这个帖子： <a target="_blank" rel="noopener" href="http://code.google.com/p/redis/issues/detail?id=270">http://code.google.com/p/redis/issues/detail?id=270</a></p>
<p>WATCH 命令可以被调用多次。 对键的监视从 WATCH 执行之后开始生效， 直到调用 EXEC 为止。</p>
<p>用户还可以在单个 WATCH 命令中监视任意多个键， 就像这样：</p>
<p>redis&gt; WATCH key1 key2 key3<br>OK<br>当 EXEC 被调用时， 不管事务是否成功执行， 对所有键的监视都会被取消。</p>
<p>另外， 当客户端断开连接时， 该客户端对键的监视也会被取消。</p>
<p>使用无参数的 UNWATCH 命令可以手动取消对所有键的监视。 对于一些需要改动多个键的事务， 有时候程序需要同时对多个键进行加锁， 然后检查这些键的当前值是否符合程序的要求。 当值达不到要求时， 就可以使用 UNWATCH 命令来取消目前对键的监视， 中途放弃这个事务， 并等待事务的下次尝试。</p>
<h3 id="使用-WATCH-实现-ZPOP"><a href="#使用-WATCH-实现-ZPOP" class="headerlink" title="使用 WATCH 实现 ZPOP"></a>使用 WATCH 实现 ZPOP</h3><p>WATCH 可以用于创建 Redis 没有内置的原子操作。</p>
<p>举个例子， 以下代码实现了原创的 ZPOP 命令， 它可以原子地弹出有序集合中分值（score）最小的元素：</p>
<p>WATCH zset<br>element = ZRANGE zset 0 0<br>MULTI<br>    ZREM zset element<br>EXEC<br>程序只要重复执行这段代码， 直到 EXEC 的返回值不是空多条回复（null multi-bulk reply）即可。</p>
<h3 id="Redis-脚本和事务"><a href="#Redis-脚本和事务" class="headerlink" title="Redis 脚本和事务"></a>Redis 脚本和事务</h3><p>从定义上来说， Redis 中的脚本本身就是一种事务， 所以任何在事务里可以完成的事， 在脚本里面也能完成。 并且一般来说， 使用脚本要来得更简单，并且速度更快。</p>
<p>因为脚本功能是 Redis 2.6 才引入的， 而事务功能则更早之前就存在了， 所以 Redis 才会同时存在两种处理事务的方法。</p>
<p>不过我们并不打算在短时间内就移除事务功能， 因为事务提供了一种即使不使用脚本， 也可以避免竞争条件的方法， 而且事务本身的实现并不复杂。</p>
<p>不过在不远的将来， 可能所有用户都会只使用脚本来实现事务也说不定。 如果真的发生这种情况的话， 那么我们将废弃并最终移除事务功能。</p>
<blockquote>
<p>译者：黄健宏<br>原文：<a target="_blank" rel="noopener" href="http://redisdoc.com/topic/transaction.html">http://redisdoc.com/topic/transaction.html</a><br>本文档翻译自： <a target="_blank" rel="noopener" href="http://redis.io/topics/transactions">http://redis.io/topics/transactions</a></p>
</blockquote>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis 事物</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做好监控微服务调⽤?</title>
    <url>/2021/06/16/service-06-16-%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E7%9B%91%E6%8E%A7%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E2%BD%A4/</url>
    <content><![CDATA[<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/%E5%9B%BE%E6%80%AA%E5%85%BD_17f35bc65eed401b374b1b5fcf552d44_83179.png" style="zoom:90%;" />

<h6 id="监控对象"><a href="#监控对象" class="headerlink" title="监控对象"></a>监控对象</h6><ul>
<li><p>⽤户端监控。通常是指业务直接对⽤户提供的功能的监控</p>
</li>
<li><p>接口监控。通常是指业务提供的功能所依赖的接口的监控</p>
</li>
</ul>
<span id="more"></span>

<ul>
<li><p>资源监控。通常是指某个接⼝依赖的资源的监控。比如该接口使用的redis 缓存，对redis 的监控就是资源的</p>
<p>监控</p>
</li>
<li><p>基础监控。通常是指对服务器本身的健康状况的监控。主要包括CPU利⽤率、内存使⽤量、I/O读写量、⽹卡</p>
<p>带宽等</p>
</li>
</ul>
<h6 id="监控指标"><a href="#监控指标" class="headerlink" title="监控指标"></a>监控指标</h6><ul>
<li><p>请求量。请求量监控分为两个维度，⼀个是实时请求量QPS，⼀个是统计请求量PV。QPS（Queries Per</p>
<p>Second） 即每秒查询次数来衡量，它反映了服务调⽤的实时变化情况。统计请求量⼀般⽤PV（Page View）</p>
<p>即⼀段时间内⽤户的访 问量来衡量，⽐如⼀天的PV代表了服务⼀天的请求量，通常⽤来统计报表。</p>
</li>
<li><p>响应时间。⼤多数情况下，可以⽤⼀段时间内所有调⽤的平均耗时来反映请求的响应时间。可以把响应时间划</p>
<p>分为多个区间，⽐如0～10ms、10ms～50ms、50ms～ 100ms、100ms～500ms、500ms以上这五个区</p>
<p>间。除此之外，还可以从P90、P95、P99、P999⻆度来监控请求的响应时间，⽐如P99 = 500ms，意思是</p>
<p>99%的请求响 应时间在500ms以内，它代表了请求的服务质量，即SLA。</p>
</li>
<li><p>错误率。错误率的监控通常⽤⼀段时间内调⽤失败的次数占调⽤总次数的⽐率来衡量，⽐如对于接⼝的错误率</p>
<p>⼀般⽤接⼝ 返回错误码为503的⽐率来表示。</p>
</li>
</ul>
<h6 id="监控维度"><a href="#监控维度" class="headerlink" title="监控维度"></a>监控维度</h6><ul>
<li><p>全局维度。从整体⻆度监控对象的的请求量、平均耗时以及错误率，全局维度的监控⼀般是为了让你对监控对象的调⽤情 况有个整体了解。</p>
</li>
<li><p> 分机房维度。</p>
</li>
<li><p> 时间维度。同⼀个监控对象，在每天的同⼀时刻各种指标通常也不会⼀样</p>
</li>
<li><p>核⼼维度。业务上⼀般会依据重要性程度对监控对象进⾏分级，最简单的是分成核⼼业务和⾮核⼼业务。</p>
<p>核⼼业务和⾮核⼼业务在部署上必须隔离，分开监控，这样才能对核⼼业务做重点保障。</p>
</li>
</ul>
<h6 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h6><blockquote>
<p>主要包括四个环节：数据采集、数据传输、数据处理和数据展示</p>
</blockquote>
<ul>
<li><p>数据采集</p>
<p>通常有两种数据收集⽅式：</p>
<ul>
<li><p><strong>服务主动上报</strong>，这种处理⽅式通过在业务代码或者服务框架⾥加⼊数据收集代码逻辑，在每⼀次服务</p>
<p>调⽤完成后，主动上报服务的调⽤信息。</p>
</li>
<li><p><strong>代理收集</strong>，这种处理⽅式通过服务调⽤后把调⽤的详细信息记录到本地⽇志⽂件中，然后再通过代理去解</p>
<p>析本地⽇志⽂ 件，然后再上报服务的调⽤信息。</p>
</li>
</ul>
</li>
<li><p>数据传输</p>
<ul>
<li><p><strong>UDP传输</strong>，这种处理⽅式是数据处理单元提供服务器的请求地址，数据采集后通过UDP协议与服务器建⽴</p>
<p>连接，然后把数 据发送过去。</p>
</li>
<li><p><strong>Kafka传输</strong>，这种处理⽅式是数据采集后发送到指定的Topic，然后数据处理单元再订阅对应的Topic，就</p>
<p>可以从Kafka消息队列中读取到对应的数据。</p>
<img src="https://cdn.smalltechnologyjun.com//image-20210615200330740.png" alt="image-20210615200330740" style="zoom: 80%;" /></li>
</ul>
</li>
<li><p>数据处理</p>
<p>数据聚合两个维度：接口维度和机器维度</p>
<p>聚合后的数据持久化： 索引数据库(es) 或者 时序数据库influxDB</p>
</li>
<li><p>数据展示</p>
<p>数据展示有多种⽅式，⽐如曲线图、饼状图、格⼦图展示</p>
</li>
</ul>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务治理</tag>
      </tags>
  </entry>
  <entry>
    <title>Optional 的使用会导致性能下降吗？</title>
    <url>/2021/07/26/service-%E4%BD%A0%E9%9C%80%E8%A6%81%E6%8B%85%E5%BF%83Optional%E7%9B%B8%E5%85%B3%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E5%90%97/</url>
    <content><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/%E5%9B%BE%E6%80%AA%E5%85%BD_bb2845fd7f5a4c03fb9adb66715a5e02_14370.png" alt="图怪兽_bb2845fd7f5a4c03fb9adb66715a5e02_14370"></p>
<p>几天前，我在论坛上发了一篇关于<code>Optional</code> 的文章。其中一条评论是一个非常好的问题:</p>
<blockquote>
<p>Optional 的使用会导致性能下降吗？</p>
</blockquote>
<p>答案是: 是的，它会的。但是你应该担心吗？</p>
<span id="more"></span>

<h2 id="使用Optional的好处"><a href="#使用Optional的好处" class="headerlink" title="使用Optional的好处"></a>使用Optional的好处</h2><p>Optional 类使我们这些开发人员的生活更轻松</p>
<ul>
<li>增加代码的可读性</li>
<li>减少代码中的条件数</li>
<li>更不容易出错</li>
</ul>
<p>让我们来看看 Optional 类的一些主要方法是如何实现的。</p>
<!--more-->

<h2 id="Optional-如何实现的？"><a href="#Optional-如何实现的？" class="headerlink" title="Optional 如何实现的？"></a>Optional 如何实现的？</h2><p>这里有一些 <code>Optional</code> 类的主要方法:</p>
<p>基本上，它将值包装到一个新的 <code>Optional</code>对象中，并检查包装的值是否为<code>null</code>。</p>
<p>即使没有使用 Optional，也必须检查值是否为 null。它可能比您做的检查多一些，但我认为您不必担心这一点。</p>
<p>但是您必须知道，将值包装到新对象中将增加 GC 要收集的对象数量。这意味着堆使用量将增加得更快，CPU 使用量将更高(更多 GC 事件)。</p>
<p>好吧，但是有多高呢？同样，这取决于您正在创建的可选对象的数量、堆的大小以及您的应用程序在不使用可选对象的情况下使用的 CPU 数量。</p>
<p>例如，假设您对应用程序进行了基准测试，并得出结论，使用 Optional 将提高 CPU 使用率1个百分点。如果您的应用程序平均使用50% 的 CPU，那么使用51% 的可选 CPU 并不是一个很大的开销，对吧？</p>
<p>但是，如果您的应用程序平均消耗5% 的 CPU，使用6% 意味着20% 的开销，这是相当重要的。</p>
<h2 id="过早优化是万恶之源"><a href="#过早优化是万恶之源" class="headerlink" title="过早优化是万恶之源"></a>过早优化是万恶之源</h2><p>Joshua Bloch 在<a target="_blank" rel="noopener" href="https://www.amazon.com/gp/product/0134685997/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0134685997&linkCode=as2&tag=hbelmiro0f-20&linkId=213790c63c0d57baac2e45b3183a35b2">Effective Java</a> 一书中有整整一章(第67项: Optimize judiciously)谈到了优化。</p>
<p>他在这一章的开头写道:</p>
<blockquote>
<p>关于最优化，有三个关注点是每个人都应该知道的:</p>
<blockquote>
<p>与其他任何单一原因(包括盲目的愚蠢)相比，更多的计算原罪是以效率的名义犯下的(不一定能实现)。</p>
</blockquote>
<p>William A. Wulf</p>
<blockquote>
<p>我们应该忘记小的副作用，比如说97% 的时间: 过早的优化是一切罪恶的根源。</p>
</blockquote>
<p>Donald E. Knuth</p>
<blockquote>
<p>在优化问题上，我们遵循两个规则:</p>
<ul>
<li>规则1. 不要这样做</li>
<li>规则 2（仅适用于专家）。 暂时不要这样做——也就是说，除非你有一个非常清晰且未经优化的解决方案。</li>
</ul>
</blockquote>
<p>M. A. Jackson</p>
</blockquote>
<p>因此，除非您需要一个快速的应用程序并且资源有限，否则不要过早担心性能问题。专注于编写好的代码，这样当你需要它的时候，它就很容易优化。此外，使用分析器查找对性能影响更大的位置。</p>
<h2 id="谁会使用你的-API？"><a href="#谁会使用你的-API？" class="headerlink" title="谁会使用你的 API？"></a>谁会使用你的 API？</h2><p>这也是一个你需要问自己的好问题。如果您正在编写一个内部 API，您可以更自由地决定是否使用它。</p>
<p>但是如果你正在编写一个公共 API，比如一个框架或者库，而你不知道什么样的应用程序在调用它，你可能需要更加灵活，给客户端选择是否使用可选的选项。</p>
<p>您可以提供两个方法，一个返回  <code>Optional</code> ，另一个返回 <code>null</code>。但是，当创建一个可以返回 <code>null</code> 的方法时，尽量让它显式。使用注释  <code>javax.annotation.Nullable</code>。方法的可空性。 (<a target="_blank" rel="noopener" href="https://jcp.org/en/jsr/detail?id=305">JSR 305</a>)</p>
<h2 id="最终，这取决于你"><a href="#最终，这取决于你" class="headerlink" title="最终，这取决于你"></a>最终，这取决于你</h2><p>你可以决定是否使用 Optional。没有一个简单的答案适用于所有情况。软件工程中的大多数事情都是这样的。这一切都是权衡取舍。</p>
<p>所以，要意识到它是如何工作的，并评估替代方案。任何事情都有代价，你是那个可以决定是否承担的人。</p>
<p>您认为为了提高性能而付出不可读且更容易出错的代码的代价是值得的吗？你知道这种进步有多重要吗？</p>
<p>在大多数情况下，使用 <code>Optional</code>  并保持开心！<code>Optional</code>  是不错的!</p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>微服务治理</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Tutorial: IoC Container</title>
    <url>/2021/06/10/spring-06-10-springIoc/</url>
    <content><![CDATA[<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/%E5%9B%BE%E6%80%AA%E5%85%BD_7d43390b66abdbb57cd5a8b2c6ef0169_30946.png" style="zoom:90%;" />

<h4 id="什么是IOC？"><a href="#什么是IOC？" class="headerlink" title="什么是IOC？"></a><strong>什么是IOC？</strong></h4><p>通俗理解就是 POJO 原本是自己需要然后new出来，现在是IOC 容器则是 你告诉我你需要什么，我们直接给你，让别人为你服务！</p>
<p><strong>现实生活</strong>： 1.你出门之前需要穿衣服，之前则是需要自己找对应的衣服，现在则反转成你的妻子把这些衣服找好给你穿上。</p>
<span id="more"></span>

<p>当然为你服务的前提是知道你的需求：</p>
<ul>
<li><p> 第一类似于你是酒吧常客，服务员立马知道你的需求 – 构造函数初始化 ，优点则是对象构造完成之后 对象就已经就绪可以用了</p>
</li>
<li><p> 第二类似于你到酒吧大喊我需要啤酒，服务员知道你的需求 – 对象set/get 方法 对象构造完成之后也不可以立马使用，但是比较解耦，类似于我告诉对应的需求，你来服务我，而不是见到我就无脑服务我</p>
</li>
</ul>
<p>IOC 可以很好的做到解耦，正常来说 我明确我需要什么，具体服务实现你提供给我即可。</p>
<h4 id="看看spring-里的Ioc-容器："><a href="#看看spring-里的Ioc-容器：" class="headerlink" title="看看spring 里的Ioc 容器："></a>看看spring 里的Ioc 容器：</h4><h5 id="beanFactory-amp-ApplicationContext"><a href="#beanFactory-amp-ApplicationContext" class="headerlink" title="beanFactory &amp;  ApplicationContext"></a>beanFactory &amp;  ApplicationContext</h5><p><img src="https://i.loli.net/2021/05/27/fYeCTJqAKmWi1Sz.png" alt="image-20210527161111966"></p>
<p><img src="https://i.loli.net/2021/05/27/N6eX1cO4mdLufng.png" alt="image-20210527160746029"></p>
<p><strong>defaultListableBeanFactory</strong> 是一个比较通用的<strong>beanFactory</strong> ，不仅实现了 beanFactory 的getBean等方法，也实现了</p>
<p><strong>beanDefinitionRegistry</strong>的注册管理的功能。beanDefinitionRegistry 就像图书馆的书架一样，beanFactory 则是整个图书馆，</p>
<p>书架上的书则是beanDefinition 。</p>
<p><img src="https://i.loli.net/2021/05/27/vXPYDwZec9lLBt7.png" alt="image-20210527161035328"></p>
<h5 id="大体流程"><a href="#大体流程" class="headerlink" title="大体流程"></a>大体流程</h5><p>外部配置 xml / properties –&gt; beanDefinitionReader —&gt;beanDefinition —&gt; 将beanDefinition 注册到beanDefinitionRegister，完成</p>
<p>bean的注册和加载 ，从而进行bean的获取。</p>
<p><img src="https://i.loli.net/2021/05/27/VXAExpJmFtdLszO.png" alt="image-20210527164639931"></p>
<p>Ioc 容器 就是在了解你的需求之后 去满足你的需求，而不需要你自己去实现自己的需求。</p>
<p>spring 里的容器则是beanFactory  比较简单只有getBean ，高级一点的则有applicationContext ，里面不仅是getBean</p>
<h5 id="beanFactory-amp-factoryBean"><a href="#beanFactory-amp-factoryBean" class="headerlink" title="beanFactory &amp; factoryBean"></a>beanFactory &amp; factoryBean</h5><p><img src="https://i.loli.net/2021/05/28/yV5xhaAOqISwb8U.png" alt="image-20210528103240843"></p>
<h5 id="容器的整个历程"><a href="#容器的整个历程" class="headerlink" title="容器的整个历程"></a>容器的整个历程</h5><ul>
<li>概览：</li>
</ul>
<p><img src="https://i.loli.net/2021/05/28/jTKN3G4xWy8mibM.png" alt="image-20210528150114956"></p>
<p><strong>容器启动阶段</strong>： BeanDefinitionReader 加载解析 xml 配置信息 成beanDefinition ，并且注册到beanDefinitionRegister。</p>
<p><img src="https://i.loli.net/2021/05/28/Lw1x4iqgyKvH7NX.png" alt="image-20210528150321558"></p>
<p><strong>容器实例化阶段</strong>： getBean 尝试获取对象，如果获取不到，则根据对应注册的beanDefinition 进行实例化返回</p>
<p><strong>ps</strong>：总的来说 第一阶段像装配生产线，酒吧服务知道你的需求，第二阶段则是进行真正的生产，酒吧服务员满足你的需求。</p>
<h5 id="BeanFactoryPostprocessor"><a href="#BeanFactoryPostprocessor" class="headerlink" title="BeanFactoryPostprocessor"></a>BeanFactoryPostprocessor</h5><p><strong>BeanFactoryPostprocessor</strong> 会插手容器启动阶段，可以修改已经加载的beanDefinition信息，常见的如:PropertyPlaceholderConfigurer 和 PropertyOverrideConfigurer.</p>
<ul>
<li><strong>PropertyOverrideConfigurer</strong>:</li>
</ul>
<p><img src="https://i.loli.net/2021/05/28/wZYQyU29e7XMNvm.png" alt="image-20210528165746359"></p>
<ul>
<li><strong>overrideConfig</strong>.properties: 规则 –&gt; beanname+属性</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">testFactoryBeanCore.name</span>=<span class="string">&quot;ckj&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><strong>结果</strong> ：</li>
</ul>
<p><img src="https://i.loli.net/2021/05/28/AfmV5U674OD9qQy.png" alt="image-20210528170019059"></p>
<h5 id="bean-的生命历程"><a href="#bean-的生命历程" class="headerlink" title="bean 的生命历程"></a>bean 的生命历程</h5><p>经过第一阶段的 启动过程 之后，有了bean的 beanDefinitions，进入实例化阶段，这个阶段实在getBean 时 才进行触发。</p>
<p><img src="https://i.loli.net/2021/05/28/9Z4G7NA6mrcUEHO.png" alt="image-20210528172119044"></p>
<h5 id="beanFactoryPostprocessor-amp-beanPostprocessor"><a href="#beanFactoryPostprocessor-amp-beanPostprocessor" class="headerlink" title="beanFactoryPostprocessor &amp; beanPostprocessor"></a>beanFactoryPostprocessor &amp; beanPostprocessor</h5><p>BeanPostProcessor是存在于对象实例化阶段作用于bean，而BeanFactoryPostProcessor则是存在于容器启动阶段，作用于beanFactory 。</p>
<h5 id="自定义beanPostProcessor"><a href="#自定义beanPostProcessor" class="headerlink" title="自定义beanPostProcessor"></a>自定义beanPostProcessor</h5><p><strong>beanPostProcessor：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (bean <span class="keyword">instanceof</span> TestBeanPostProcessorCore) &#123;</span><br><span class="line">            ((TestBeanPostProcessorCore) bean).setAge(<span class="number">100</span>);</span><br><span class="line">            ((TestBeanPostProcessorCore) bean).setName(<span class="string">&quot;ckj&quot;</span>);</span><br><span class="line">            log.info(<span class="string">&quot;=== this custom bean :&#123;&#125;&quot;</span>, JSON.toJSONString(bean));</span><br><span class="line">            <span class="keyword">return</span> bean;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> BeanPostProcessor.<span class="keyword">super</span>.postProcessAfterInitialization(bean, beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBeanPostProcessorCore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">2021</span>-<span class="number">05</span>-<span class="number">31</span> <span class="number">16</span>:<span class="number">50</span>:<span class="number">19.522</span>  INFO <span class="number">12652</span> --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="line"><span class="number">2021</span>-<span class="number">05</span>-<span class="number">31</span> <span class="number">16</span>:<span class="number">50</span>:<span class="number">19.522</span>  INFO <span class="number">12652</span> --- [           main] o.s.web.context.ContextLoader            : Root WebApplicationContext: initialization completed in <span class="number">1641</span> ms</span><br><span class="line"><span class="number">2021</span>-<span class="number">05</span>-<span class="number">31</span> <span class="number">16</span>:<span class="number">50</span>:<span class="number">19.708</span>  INFO <span class="number">12652</span> --- [           main] c.c.base.spring.CustomBeanPostProcessor  : === <span class="keyword">this</span> custom bean :&#123;<span class="string">&quot;age&quot;</span>:<span class="number">100</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;ckj&quot;</span>&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第22篇：整合elk，搭建实时日志平台</title>
    <url>/2017/05/05/springboot-2017-05-05-sprinboot25-elk/</url>
    <content><![CDATA[<p>这篇文章主要介绍springboot整合elk.</p>
<span id="more"></span>

<h2 id="elk-简介"><a href="#elk-简介" class="headerlink" title="elk 简介"></a>elk 简介</h2><ul>
<li><p>Elasticsearch是个开源分布式搜索引擎，它的特点有：分布式，零配置，自动发现，索引自动分片，索引副本机制，restful风格接口，多数据源，自动搜索负载等。</p>
</li>
<li><p>Logstash是一个完全开源的工具，他可以对你的日志进行收集、过滤，并将其存储供以后使用（如，搜索）。</p>
</li>
<li><p>Kibana 也是一个开源和免费的工具，它Kibana可以为 Logstash 和 ElasticSearch 提供的日志分析友好的 Web 界面，可以帮助您汇总、分析和搜索重要数据日志。</p>
</li>
</ul>
<h2 id="elk下载安装"><a href="#elk下载安装" class="headerlink" title="elk下载安装"></a>elk下载安装</h2><p>elk下载地址：<a target="_blank" rel="noopener" href="https://www.elastic.co/downloads/">https://www.elastic.co/downloads/</a></p>
<p>建议在 linux上运行，elk在windows上支持得不好，另外需要jdk1.8 的支持，需要提前安装好jdk.</p>
<p>下载完之后： 安装，以logstash为栗子：</p>
<blockquote>
<p>cd /usr/local/</p>
<p>mkdir logstash</p>
<p>tar -zxvf logstash-5.3.2.tar.gz</p>
<p>mv logstash-5.3.2 /usr/local/logstash</p>
</blockquote>
<h2 id="配置、启动-Elasticsearch"><a href="#配置、启动-Elasticsearch" class="headerlink" title="配置、启动 Elasticsearch"></a>配置、启动 Elasticsearch</h2><p>打开Elasticsearch的配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim config&#x2F;elasticsearch.yml</span><br></pre></td></tr></table></figure>
<p>修改配置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">network.host&#x3D;localhost</span><br><span class="line">network.port&#x3D;9200</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>它默认就是这个配置，没有特殊要求，在本地不需要修改。</p>
<p>启动Elasticsearch</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;elasticsearch</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动成功，访问localhost:9200,网页显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;56IrTCM&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;elasticsearch&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;e4ja7vS2TIKI1BsggEAa6Q&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;5.2.2&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;f9d9b74&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2017-02-24T17:26:45.835Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;6.4.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="配置、启动-logstash"><a href="#配置、启动-logstash" class="headerlink" title="配置、启动 logstash"></a>配置、启动 logstash</h2><p>在 logstash的主目录下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim config&#x2F;log4j_to_es.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改 log4j_to_es.conf 如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">  log4j &#123;</span><br><span class="line">    mode &#x3D;&gt; &quot;server&quot;</span><br><span class="line">    host &#x3D;&gt; &quot;localhost&quot;</span><br><span class="line">    port &#x3D;&gt; 4560</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">filter &#123;</span><br><span class="line">  #Only matched data are send to output.</span><br><span class="line">&#125;</span><br><span class="line">output &#123;</span><br><span class="line">    elasticsearch &#123;</span><br><span class="line">    action &#x3D;&gt; &quot;index&quot;          #The operation on ES</span><br><span class="line">    hosts  &#x3D;&gt; &quot;localhost:9200&quot;   #ElasticSearch host, can be array.</span><br><span class="line">    index  &#x3D;&gt; &quot;applog&quot;         #The index to write data to.</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>修改完配置后启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;logstash -f config&#x2F;log4j_to_es.conf </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>终端显示如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-77bf8e6fba787399.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720" alt="image.png"></p>
<p>访问localhost:9600</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;host&quot;:&quot;Pc-20130412.local&quot;,&quot;version&quot;:&quot;5.3.2&quot;,&quot;http_address&quot;:&quot;127.0.0.1:9600&quot;,&quot;id&quot;:&quot;e6bb985c-c688-49a4-</span><br><span class="line">a55b-4d362bb4136f&quot;,&quot;name&quot;:&quot;Pc-20130412.local&quot;,&quot;build_date&quot;:</span><br><span class="line">&quot;2017-04-24T16:32:22Z&quot;,&quot;build_sha&quot;:&quot;242159a5eea55fe213fe5c8</span><br><span class="line">52d36455e24252c82&quot;,&quot;build_snapshot&quot;:false&#125;</span><br></pre></td></tr></table></figure>

<p>证明logstash启动成功。</p>
<h2 id="配置、启动kibana"><a href="#配置、启动kibana" class="headerlink" title="配置、启动kibana"></a>配置、启动kibana</h2><p>到kibana的安装目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.&#x2F;bin&#x2F;kibana </span><br></pre></td></tr></table></figure>

<p>默认配置即可。</p>
<p>访问localhost:5601，网页显示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-6524e596d53ec119.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/720" alt="image.png"></p>
<p>证明启动成功。</p>
<h2 id="创建springboot工程"><a href="#创建springboot工程" class="headerlink" title="创建springboot工程"></a>创建springboot工程</h2><p>起步依赖如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;exclusions&gt;</span><br><span class="line">				&lt;exclusion&gt;</span><br><span class="line">					&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">					&lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;&#x2F;exclusion&gt;</span><br><span class="line">			&lt;&#x2F;exclusions&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-log4j&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.3.8.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>log4j的配置，／src/resources/log4j.properties如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">log4j.rootLogger&#x3D;INFO,console</span><br><span class="line"></span><br><span class="line"># for package com.demo.elk, log would be sent to socket appender.</span><br><span class="line">log4j.logger.com.forezp&#x3D;DEBUG, socket</span><br><span class="line"></span><br><span class="line"># appender socket</span><br><span class="line">log4j.appender.socket&#x3D;org.apache.log4j.net.SocketAppender</span><br><span class="line">log4j.appender.socket.Port&#x3D;4560</span><br><span class="line">log4j.appender.socket.RemoteHost&#x3D;localhost</span><br><span class="line">log4j.appender.socket.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.socket.layout.ConversionPattern&#x3D;%d [%-5p] [%l] %m%n</span><br><span class="line">log4j.appender.socket.ReconnectionDelay&#x3D;10000</span><br><span class="line"></span><br><span class="line"># appender console</span><br><span class="line">log4j.appender.console&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.console.target&#x3D;System.out</span><br><span class="line">log4j.appender.console.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.console.layout.ConversionPattern&#x3D;%d [%-5p] [%l] %m%n</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打印log测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringbootElkApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void contextLoads() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private Logger logger &#x3D; Logger.getLogger(getClass());</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void test() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">		for(int i&#x3D;0;i&lt;100;i++) &#123;</span><br><span class="line">			logger.info(&quot;输出info  &quot;);</span><br><span class="line">			logger.debug(&quot;输出debug+skkkw嗡嗡嗡kw&quot;);</span><br><span class="line">			logger.error(&quot;输出error  嗡嗡嗡我&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="在kibana-实时监控日志"><a href="#在kibana-实时监控日志" class="headerlink" title="在kibana 实时监控日志"></a>在kibana 实时监控日志</h2><p>打开localhost:5601:</p>
<p>Management=&gt;index pattrns=&gt;add new:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-14a8c8e08d971647.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>点击discovery:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-1f43ebd237e8543e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://my.oschina.net/itblog/blog/547250">https://my.oschina.net/itblog/blog/547250</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot非官方教程 | 终章：文章汇总</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-all/</url>
    <content><![CDATA[<h1 id="SpringBoot非官方教程-终章：文章汇总"><a href="#SpringBoot非官方教程-终章：文章汇总" class="headerlink" title="SpringBoot非官方教程 | 终章：文章汇总"></a>SpringBoot非官方教程 | 终章：文章汇总</h1><p> springboot非官方教程，可能最接近于官方的一个教程，大多数案例都来自于官方文档，为了更好的理解，加入了个人的改造。</p>
<p>码云下载：<a target="_blank" rel="noopener" href="https://git.oschina.net/forezp/SpringBootLearning">https://git.oschina.net/forezp/SpringBootLearning</a></p>
<p> 源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a>,谢谢支持，记得star哦。</p>
 <span id="more"></span>
<p>欢迎关注：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">SpringCloud 系列教程</a></p>
<h2 id="入门篇"><a href="#入门篇" class="headerlink" title="入门篇"></a>入门篇</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341651">SpringBoot非官方教程 | 第一篇：构建第一个SpringBoot工程</a></p>
<h2 id="配置篇"><a href="#配置篇" class="headerlink" title="配置篇"></a>配置篇</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70437576"> SpringBoot非官方教程 | 第二篇：Spring Boot配置文件详解</a></p>
<h2 id="数据库篇"><a href="#数据库篇" class="headerlink" title="数据库篇"></a>数据库篇</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70477821">SpringBoot非官方教程 | 第三篇：SpringBoot用JdbcTemplates访问Mysql</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70545038">SpringBoot非官方教程 |  第四篇：SpringBoot 整合JPA</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70662983">SpringBoot非官方教程 | 第五篇：springboot整合 beatlsql</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70768477">SpringBoot非官方教程 | 第六篇：springboot整合mybatis</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70833629">SpringBoot非官方教程 | 第七篇：springboot开启声明式事务</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70941577">SpringBoot非官方教程 | 第八篇：springboot整合mongodb</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70991675"> SpringBoot非官方教程 | 第九篇： springboot整合Redis</a></p>
<h2 id="构架文档篇"><a href="#构架文档篇" class="headerlink" title="构架文档篇"></a>构架文档篇</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023510">SpringBoot非官方教程 | 第十篇： 用spring Restdocs创建API文档</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023536"> SpringBoot非官方教程 | 第十一篇：springboot集成swagger2，构建优雅的Restful API</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023579">SpringBoot非官方教程 | 第十二篇：springboot集成apidoc</a></p>
<h2 id="缓存篇"><a href="#缓存篇" class="headerlink" title="缓存篇"></a>缓存篇</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023614">SpringBoot非官方教程 | 第十三篇：springboot集成spring cache</a></p>
<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023652">SpringBoot非官方教程 | 第十四篇：在springboot中用redis实现消息队列</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023692"> SpringBoot非官方教程 | 第十五篇：Springboot整合RabbitMQ</a></p>
<h2 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023724">SpringBoot非官方教程 | 第十六篇：用restTemplate消费服务</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023752">SpringBoot非官方教程 | 第十七篇：上传文件</a></p>
<h2 id="任务调度"><a href="#任务调度" class="headerlink" title="任务调度"></a>任务调度</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023783">SpringBoot非官方教程 | 第十八篇： 定时任务（Scheduling Tasks）</a></p>
<h2 id="表单相关"><a href="#表单相关" class="headerlink" title="表单相关"></a>表单相关</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023817">SpringBoot非官方教程 | 第十九篇： 验证表单信息</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71023868">SpringBoot非官方教程 | 第二十篇： 处理表单提交</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71024024"> SpringBoot非官方教程 | 第二十一篇： springboot集成JMS</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71024153">SpringBoot非官方教程 | 第二十二篇： 创建含有多module的springboot工程</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71024169"> SpringBoot非官方教程 | 第二十三篇： 异步方法</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/71024219"> SpringBoot非官方教程 | 第二十四篇： springboot整合docker</a></p>
<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/61472783"> SpringBoot非官方教程 | 第二十五篇： 2小时学会springboot</a></p>
<h2 id="未完结"><a href="#未完结" class="headerlink" title="未完结"></a>未完结</h2><ul>
<li>待续。。。</li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第23篇：异步方法</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-ansy/</url>
    <content><![CDATA[<p>这篇文章主要介绍在springboot 使用异步方法，去请求github api.</p>
<span id="more"></span>


<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>在pom文件引入相关依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.fasterxml.jackson.core&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;jackson-databind&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>创建一个接收数据的实体：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@JsonIgnoreProperties(ignoreUnknown&#x3D;true)</span><br><span class="line">public class User &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private String blog;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getBlog() &#123;</span><br><span class="line">        return blog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setBlog(String blog) &#123;</span><br><span class="line">        this.blog &#x3D; blog;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;User [name&#x3D;&quot; + name + &quot;, blog&#x3D;&quot; + blog + &quot;]&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个请求的　githib的service:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class GitHubLookupService &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(GitHubLookupService.class);</span><br><span class="line"></span><br><span class="line">    private final RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public GitHubLookupService(RestTemplateBuilder restTemplateBuilder) &#123;</span><br><span class="line">        this.restTemplate &#x3D; restTemplateBuilder.build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Async</span><br><span class="line">    public Future&lt;User&gt; findUser(String user) throws InterruptedException &#123;</span><br><span class="line">        logger.info(&quot;Looking up &quot; + user);</span><br><span class="line">        String url &#x3D; String.format(&quot;https:&#x2F;&#x2F;api.github.com&#x2F;users&#x2F;%s&quot;, user);</span><br><span class="line">        User results &#x3D; restTemplate.getForObject(url, User.class);</span><br><span class="line">        &#x2F;&#x2F; Artificial delay of 1s for demonstration purposes</span><br><span class="line">        Thread.sleep(1000L);</span><br><span class="line">        return new AsyncResult&lt;&gt;(results);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过，RestTemplate去请求，另外加上类@Async 表明是一个异步任务。</p>
<p>开启异步任务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableAsync</span><br><span class="line">public class Application extends AsyncConfigurerSupport &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Executor getAsyncExecutor() &#123;</span><br><span class="line">        ThreadPoolTaskExecutor executor &#x3D; new ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(2);</span><br><span class="line">        executor.setMaxPoolSize(2);</span><br><span class="line">        executor.setQueueCapacity(500);</span><br><span class="line">        executor.setThreadNamePrefix(&quot;GithubLookup-&quot;);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        return executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>通过@EnableAsync开启异步任务；并且配置AsyncConfigurerSupport，比如最大的线程池为2.</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AppRunner implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(AppRunner.class);</span><br><span class="line"></span><br><span class="line">    private final GitHubLookupService gitHubLookupService;</span><br><span class="line"></span><br><span class="line">    public AppRunner(GitHubLookupService gitHubLookupService) &#123;</span><br><span class="line">        this.gitHubLookupService &#x3D; gitHubLookupService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        &#x2F;&#x2F; Start the clock</span><br><span class="line">        long start &#x3D; System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Kick of multiple, asynchronous lookups</span><br><span class="line">        Future&lt;User&gt; page1 &#x3D; gitHubLookupService.findUser(&quot;PivotalSoftware&quot;);</span><br><span class="line">        Future&lt;User&gt; page2 &#x3D; gitHubLookupService.findUser(&quot;CloudFoundry&quot;);</span><br><span class="line">        Future&lt;User&gt; page3 &#x3D; gitHubLookupService.findUser(&quot;Spring-Projects&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Wait until they are all done</span><br><span class="line">        while (!(page1.isDone() &amp;&amp; page2.isDone() &amp;&amp; page3.isDone())) &#123;</span><br><span class="line">            Thread.sleep(10); &#x2F;&#x2F;10-millisecond pause between each check</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; Print results, including elapsed time</span><br><span class="line">        logger.info(&quot;Elapsed time: &quot; + (System.currentTimeMillis() - start));</span><br><span class="line">        logger.info(&quot;--&gt; &quot; + page1.get());</span><br><span class="line">        logger.info(&quot;--&gt; &quot; + page2.get());</span><br><span class="line">        logger.info(&quot;--&gt; &quot; + page3.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动程序，控制台会打印：</p>
<blockquote>
<p>2017-04-30 13:11:10.351  INFO 1511 — [ GithubLookup-1] com.forezp.service.GitHubLookupService   : Looking up PivotalSoftware<br>2017-04-30 13:11:10.351  INFO 1511 — [ GithubLookup-2] com.forezp.service.GitHubLookupService   : Looking up CloudFoundry<br>2017-04-30 13:11:13.144  INFO 1511 — [ GithubLookup-2] com.forezp.service.GitHubLookupService   : Looking up Spring-Projects</p>
</blockquote>
<p>耗时：3908</p>
<p>分析：可以卡的前面2个方法分别在GithubLookup-1 和GithubLookup-2执行，第三个在GithubLookup-2执行，注意因为在配置线程池的时候最大线程为2.如果你把线程池的个数为3的时候，耗时减少。</p>
<p>如果去掉@Async，你会发现，执行这三个方法都在main线程中执行。耗时总结，如下：</p>
<blockquote>
<p>2017-04-30 13:13:00.934  INFO 1527 — [           main] com.forezp.service.GitHubLookupService   : Looking up PivotalSoftware<br>2017-04-30 13:13:03.571  INFO 1527 — [           main] com.forezp.service.GitHubLookupService   : Looking up CloudFoundry<br>2017-04-30 13:13:04.865  INFO 1527 — [           main] com.forezp.service.GitHubLookupService   : Looking up Spring-Projects</p>
</blockquote>
<p>耗时：5261</p>
<p>通过这一个小的栗子，你应该对异步任务有了一定的了解。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/async-method/">https://spring.io/guides/gs/async-method/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第12篇：apidoc</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-apidoc/</url>
    <content><![CDATA[<p>首先声明下，apidoc是基于注释来生成文档的，它不基于任何框架，而且支持大多数编程语言，为了springboot系列的完整性，所以标了个题。</p>
<span id="more"></span>

<h2 id="一、apidoc简介"><a href="#一、apidoc简介" class="headerlink" title="一、apidoc简介"></a>一、apidoc简介</h2><p>apidoc通过在你代码的注释来生成api文档的。它对代码没有侵入性，只需要你写好相关的注释即可，并且它仅通过写简单的配置就可以生成高颜值的api接口页面。它基于node.js，所以你需要安装node.js环境。node.js安装，<a target="_blank" rel="noopener" href="http://www.runoob.com/nodejs/nodejs-install-setup.html">点击这里</a>。这里就不介绍。</p>
<h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><p>安装完node.js安装api.doc,它的项目源码：<a target="_blank" rel="noopener" href="https://github.com/apidoc/apidoc">https://github.com/apidoc/apidoc</a> 。</p>
<p>通过命令安装：</p>
<blockquote>
<p>npm install apidoc -g</p>
</blockquote>
<h2 id="三、注释怎么写"><a href="#三、注释怎么写" class="headerlink" title="三、注释怎么写"></a>三、注释怎么写</h2><ul>
<li>@api</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@api &#123;method&#125; path [title]</span><br><span class="line"></span><br><span class="line">method：请求方法，</span><br><span class="line">path：请求路径 </span><br><span class="line">title(可选)：标题</span><br></pre></td></tr></table></figure>

<ul>
<li>@apiDescription </li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@apiDescription text</span><br><span class="line">text说明</span><br></pre></td></tr></table></figure>
<ul>
<li>@apiError</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@apiError [(group)] [&#123;type&#125;] field [description]</span><br><span class="line"></span><br><span class="line">（group）（可选）：参数将以这个名称分组，不设置的话，默认是Error 4xx </span><br><span class="line">&#123;type&#125;（可选）：返回值类型，例如：&#123;Boolean&#125;, &#123;Number&#125;, &#123;String&#125;, &#123;Object&#125;, &#123;String[]&#125; </span><br><span class="line">field：返回值字段名称 </span><br><span class="line">descriptionoptional（可选）：返回值字段说明</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>@apiGroup</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@apiGroup name</span><br><span class="line">name：组名称，也是导航的标题</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>更多注释，参见官方文档：<a target="_blank" rel="noopener" href="http://apidocjs.com/#params">http://apidocjs.com/#params</a></p>
<h2 id="四、写给栗子"><a href="#四、写给栗子" class="headerlink" title="四、写给栗子"></a>四、写给栗子</h2><h3 id="首先写配置文件"><a href="#首先写配置文件" class="headerlink" title="首先写配置文件"></a>首先写配置文件</h3><p>在项目的主目录新建一个apidoc.json文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;example&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.1.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;A basic apiDoc example&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>更多配置参考：<a target="_blank" rel="noopener" href="http://apidocjs.com/#configuration">http://apidocjs.com/#configuration</a></p>
<h3 id="写个注释"><a href="#写个注释" class="headerlink" title="写个注释:"></a>写个注释:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @api &#123;POST&#125; &#x2F;register 注册用户</span><br><span class="line"> * @apiGroup Users</span><br><span class="line"> * @apiVersion 0.0.1</span><br><span class="line"> * @apiDescription 用于注册用户</span><br><span class="line"> * @apiParam &#123;String&#125; account 用户账户名</span><br><span class="line"> * @apiParam &#123;String&#125; password 密码</span><br><span class="line"> * @apiParam &#123;String&#125; mobile 手机号</span><br><span class="line"> * @apiParam &#123;int&#125; vip &#x3D; 0  是否注册Vip身份 0 普通用户 1 Vip用户</span><br><span class="line"> * @apiParam &#123;String&#125; [recommend] 邀请码</span><br><span class="line"> * @apiParamExample &#123;json&#125; 请求样例：</span><br><span class="line"> *                ?account&#x3D;sodlinken&amp;password&#x3D;11223344&amp;mobile&#x3D;13739554137&amp;vip&#x3D;0&amp;recommend&#x3D;</span><br><span class="line"> * @apiSuccess (200) &#123;String&#125; msg 信息</span><br><span class="line"> * @apiSuccess (200) &#123;int&#125; code 0 代表无错误 1代表有错误</span><br><span class="line"> * @apiSuccessExample &#123;json&#125; 返回样例:</span><br><span class="line"> *                &#123;&quot;code&quot;:&quot;0&quot;,&quot;msg&quot;:&quot;注册成功&quot;&#125;</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="用apidoc命令生成文档界面"><a href="#用apidoc命令生成文档界面" class="headerlink" title="用apidoc命令生成文档界面"></a>用apidoc命令生成文档界面</h3><p>先cd到工程的外层目录，并在外层目建个输出文档的目录，我建的是docapi。</p>
<p>输命令：</p>
<blockquote>
<p>apidoc -i chapter4/ -o apidoc/ </p>
</blockquote>
<p>-i 输入目录 -o 输出目录</p>
<p>chapter4是我的工程名。</p>
<p>可以看到在apidoc目录生成了很多文件:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-76fd0f3c5ac1d190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>打开index.html,可以看到文档页面:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-0319025291e1417a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="QQ图片20170417175251.png"></p>
<h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/apidoc/apidoc">apidoc</a></p>
<p><a target="_blank" rel="noopener" href="http://apidocjs.com/">apidocjs.com</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/soslinken/article/details/50468896">使用apidoc 生成Restful web Api文档</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第20篇：表单提交</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-form/</url>
    <content><![CDATA[<p>这篇文件主要介绍通过springboot 去创建和提交一个表单。</p>
<span id="more"></span>


<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><p>涉及了 web，加上spring-boot-starter-web和spring-boot-starter-thymeleaf的起步依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建实体"><a href="#创建实体" class="headerlink" title="创建实体"></a>创建实体</h2><p>代码清单如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Greeting &#123;</span><br><span class="line"></span><br><span class="line">    private long id;</span><br><span class="line">    private String content;</span><br><span class="line"></span><br><span class="line">    public long getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(long id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getContent() &#123;</span><br><span class="line">        return content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setContent(String content) &#123;</span><br><span class="line">        this.content &#x3D; content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="创建Controller"><a href="#创建Controller" class="headerlink" title="创建Controller"></a>创建Controller</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class GreetingController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;greeting&quot;)</span><br><span class="line">    public String greetingForm(Model model) &#123;</span><br><span class="line">        model.addAttribute(&quot;greeting&quot;, new Greeting());</span><br><span class="line">        return &quot;greeting&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;greeting&quot;)</span><br><span class="line">    public String greetingSubmit(@ModelAttribute Greeting greeting) &#123;</span><br><span class="line">        return &quot;result&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="页面展示层"><a href="#页面展示层" class="headerlink" title="页面展示层"></a>页面展示层</h2><p>src/main/resources/templates/greeting.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Handling Form Submission<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Form<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">th:action</span>=<span class="string">&quot;@&#123;/greeting&#125;&quot;</span> <span class="attr">th:object</span>=<span class="string">&quot;$&#123;greeting&#125;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">p</span>&gt;</span>Id: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;id&#125;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>Message: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">th:field</span>=<span class="string">&quot;*&#123;content&#125;&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> /&gt;</span> <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Reset&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>src/main/resources/templates/result.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">&quot;http://www.thymeleaf.org&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Getting Started: Handling Form Submission<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Result<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;id: &#x27; + $&#123;greeting.id&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span> <span class="attr">th:text</span>=<span class="string">&quot;&#x27;content: &#x27; + $&#123;greeting.content&#125;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/greeting&quot;</span>&gt;</span>Submit another message<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>启动工程，访问ttp://localhost:8080/greeting:</p>
<p><img src="https://spring.io/guides/gs/handling-form-submission/images/form.png"></p>
<p>点击submit:</p>
<p><img src="https://spring.io/guides/gs/handling-form-submission/images/result.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/handling-form-submission/">https://spring.io/guides/gs/handling-form-submission/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第6篇：整合mybatis</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-mybatis/</url>
    <content><![CDATA[<p>本文主要讲解如何在springboot下整合mybatis，并访问数据库。由于mybatis这个框架太过于流行，所以我就不讲解了。</p>
<span id="more"></span>

<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><p>在pom文件引入mybatis-spring-boot-starter的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">     &lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;mybatis-spring-boot-starter&lt;artifactId&gt;</span><br><span class="line">	&lt;version&gt;1.3.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>引入数据库连接依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.0.29&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="引入数据源"><a href="#引入数据源" class="headerlink" title="引入数据源"></a>引入数据源</h2><p>application.properties配置文件中引入数据源：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;123456</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>

<p>这样，springboot就可以访问数据了。</p>
<h2 id="创建数据库表"><a href="#创建数据库表" class="headerlink" title="创建数据库表"></a>创建数据库表</h2><p>建表语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- create table &#96;account&#96;</span><br><span class="line"># DROP TABLE &#96;account&#96; IF EXISTS</span><br><span class="line">CREATE TABLE &#96;account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(20) NOT NULL,</span><br><span class="line">  &#96;money&#96; double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;1&#39;, &#39;aaa&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;2&#39;, &#39;bbb&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;3&#39;, &#39;ccc&#39;, &#39;1000&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p> 这篇文篇通过注解的形式实现。</p>
<h3 id="创建实体："><a href="#创建实体：" class="headerlink" title="创建实体："></a>创建实体：</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">   private int id ;</span><br><span class="line">   private String name ;</span><br><span class="line">   private double money;</span><br><span class="line">   </span><br><span class="line"> setter...</span><br><span class="line"> getter...</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mapper</span><br><span class="line">public interface AccountMapper &#123;</span><br><span class="line"></span><br><span class="line">    @Insert(&quot;insert into account(name, money) values(#&#123;name&#125;, #&#123;money&#125;)&quot;)</span><br><span class="line">    int add(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) double money);</span><br><span class="line"></span><br><span class="line">    @Update(&quot;update account set name &#x3D; #&#123;name&#125;, money &#x3D; #&#123;money&#125; where id &#x3D; #&#123;id&#125;&quot;)</span><br><span class="line">    int update(@Param(&quot;name&quot;) String name, @Param(&quot;money&quot;) double money, @Param(&quot;id&quot;) int  id);</span><br><span class="line"></span><br><span class="line">    @Delete(&quot;delete from account where id &#x3D; #&#123;id&#125;&quot;)</span><br><span class="line">    int delete(int id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select id, name as name, money as money from account where id &#x3D; #&#123;id&#125;&quot;)</span><br><span class="line">    Account findAccount(@Param(&quot;id&quot;) int id);</span><br><span class="line"></span><br><span class="line">    @Select(&quot;select id, name as name, money as money from account&quot;)</span><br><span class="line">    List&lt;Account&gt; findAccountList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountMapper accountMapper;</span><br><span class="line"></span><br><span class="line">    public int add(String name, double money) &#123;</span><br><span class="line">        return accountMapper.add(name, money);</span><br><span class="line">    &#125;</span><br><span class="line">    public int update(String name, double money, int id) &#123;</span><br><span class="line">        return accountMapper.update(name, money, id);</span><br><span class="line">    &#125;</span><br><span class="line">    public int delete(int id) &#123;</span><br><span class="line">        return accountMapper.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line">    public Account findAccount(int id) &#123;</span><br><span class="line">        return accountMapper.findAccount(id);</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;Account&gt; findAccountList() &#123;</span><br><span class="line">        return accountMapper.findAccountList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="controller层，构建restful-API"><a href="#controller层，构建restful-API" class="headerlink" title="controller层，构建restful API"></a>controller层，构建restful API</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.forezp.web;</span><br><span class="line"></span><br><span class="line">import com.forezp.entity.Account;</span><br><span class="line">import com.forezp.service.AccountService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;20.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    AccountService accountService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;list&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public List&lt;Account&gt; getAccounts() &#123;</span><br><span class="line">        return accountService.findAccountList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public Account getAccountById(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return accountService.findAccount(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.PUT)</span><br><span class="line">    public String updateAccount(@PathVariable(&quot;id&quot;) int id, @RequestParam(value &#x3D; &quot;name&quot;, required &#x3D; true) String name,</span><br><span class="line">                                @RequestParam(value &#x3D; &quot;money&quot;, required &#x3D; true) double money) &#123;</span><br><span class="line">        int t&#x3D; accountService.update(name,money,id);</span><br><span class="line">        if(t&#x3D;&#x3D;1) &#123;</span><br><span class="line">            return &quot;success&quot;;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.DELETE)</span><br><span class="line">    public String delete(@PathVariable(value &#x3D; &quot;id&quot;)int id) &#123;</span><br><span class="line">        int t&#x3D; accountService.delete(id);</span><br><span class="line">        if(t&#x3D;&#x3D;1) &#123;</span><br><span class="line">            return &quot;success&quot;;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">    public String postAccount(@RequestParam(value &#x3D; &quot;name&quot;) String name,</span><br><span class="line">                              @RequestParam(value &#x3D; &quot;money&quot;) double money) &#123;</span><br><span class="line"></span><br><span class="line">       int t&#x3D; accountService.add(name,money);</span><br><span class="line">       if(t&#x3D;&#x3D;1) &#123;</span><br><span class="line">           return &quot;success&quot;;</span><br><span class="line">       &#125;else &#123;</span><br><span class="line">           return &quot;fail&quot;;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过postman测试通过。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://www.mybatis.org/mybatis-3/zh/configuration.html#properties">mybatis</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.720ui.com/2016/springboot_02_data_mybatis/">MyBatis整合</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第11篇：swagger2</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-swagger2/</url>
    <content><![CDATA[<p>swagger,中文“拽”的意思。它是一个功能强大的api框架，它的集成非常简单，不仅提供了在线文档的查阅，而且还提供了在线文档的测试。另外swagger很容易构建restful风格的api，简单优雅帅气，正如它的名字。</p>
<span id="more"></span>

<p>一、引入依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.6.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;2.6.1&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>二、写配置类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class Swagger2 &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket createRestApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.forezp.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder()</span><br><span class="line">                .title(&quot;springboot利用swagger构建api文档&quot;)</span><br><span class="line">                .description(&quot;简单优雅的restfun风格，http:&#x2F;&#x2F;blog.csdn.net&#x2F;forezp&quot;)</span><br><span class="line">                .termsOfServiceUrl(&quot;http:&#x2F;&#x2F;blog.csdn.net&#x2F;forezp&quot;)</span><br><span class="line">                .version(&quot;1.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过@Configuration注解，表明它是一个配置类，@EnableSwagger2开启swagger2。apiINfo()配置一些基本的信息。apis()指定扫描的包会生成文档。</p>
<p>三、写生产文档的注解</p>
<p>swagger通过注解表明该接口会生成文档，包括接口名、请求方法、参数、返回信息的等等。</p>
<ul>
<li>@Api：修饰整个类，描述Controller的作用</li>
<li>@ApiOperation：描述一个类的一个方法，或者说一个接口</li>
<li>@ApiParam：单个参数描述</li>
<li>@ApiModel：用对象来接收参数</li>
<li>@ApiProperty：用对象接收参数时，描述对象的一个字段</li>
<li>@ApiResponse：HTTP响应其中1个描述</li>
<li>@ApiResponses：HTTP响应整体描述</li>
<li>@ApiIgnore：使用该注解忽略这个API </li>
<li>@ApiError ：发生错误返回的信息</li>
<li>@ApiParamImplicitL：一个请求参数</li>
<li>@ApiParamsImplicit 多个请求参数</li>
</ul>
<p>现在通过一个栗子来说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.forezp.controller;</span><br><span class="line"></span><br><span class="line">import com.forezp.entity.Book;</span><br><span class="line">import io.swagger.annotations.ApiImplicitParam;</span><br><span class="line">import io.swagger.annotations.ApiImplicitParams;</span><br><span class="line">import io.swagger.annotations.ApiOperation;</span><br><span class="line">import org.springframework.ui.ModelMap;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">import springfox.documentation.annotations.ApiIgnore;</span><br><span class="line"></span><br><span class="line">import java.util.*;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 用户创建某本图书	POST	&#x2F;books&#x2F;</span><br><span class="line"> * 用户修改对某本图书	PUT	&#x2F;books&#x2F;:id&#x2F;</span><br><span class="line"> * 用户删除对某本图书	DELETE	&#x2F;books&#x2F;:id&#x2F;</span><br><span class="line"> * 用户获取所有的图书 GET &#x2F;books</span><br><span class="line"> *  用户获取某一图书  GET &#x2F;Books&#x2F;:id</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;17.</span><br><span class="line"> * 官方文档：http:&#x2F;&#x2F;swagger.io&#x2F;docs&#x2F;specification&#x2F;api-host-and-base-path&#x2F;</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(value &#x3D; &quot;&#x2F;books&quot;)</span><br><span class="line">public class BookContrller &#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;Long, Book&gt; books &#x3D; Collections.synchronizedMap(new HashMap&lt;Long, Book&gt;());</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value&#x3D;&quot;获取图书列表&quot;, notes&#x3D;&quot;获取图书列表&quot;)</span><br><span class="line">    @RequestMapping(value&#x3D;&#123;&quot;&quot;&#125;, method&#x3D; RequestMethod.GET)</span><br><span class="line">    public List&lt;Book&gt; getBook() &#123;</span><br><span class="line">        List&lt;Book&gt; book &#x3D; new ArrayList&lt;&gt;(books.values());</span><br><span class="line">        return book;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value&#x3D;&quot;创建图书&quot;, notes&#x3D;&quot;创建图书&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;book&quot;, value &#x3D; &quot;图书详细实体&quot;, required &#x3D; true, dataType &#x3D; &quot;Book&quot;)</span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&quot;, method&#x3D;RequestMethod.POST)</span><br><span class="line">    public String postBook(@RequestBody Book book) &#123;</span><br><span class="line">        books.put(book.getId(), book);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @ApiOperation(value&#x3D;&quot;获图书细信息&quot;, notes&#x3D;&quot;根据url的id来获取详细信息&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;ID&quot;, required &#x3D; true, dataType &#x3D; &quot;Long&quot;,paramType &#x3D; &quot;path&quot;)</span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&#x2F;&#123;id&#125;&quot;, method&#x3D;RequestMethod.GET)</span><br><span class="line">    public Book getBook(@PathVariable Long id) &#123;</span><br><span class="line">        return books.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(value&#x3D;&quot;更新信息&quot;, notes&#x3D;&quot;根据url的id来指定更新图书信息&quot;)</span><br><span class="line">    @ApiImplicitParams(&#123;</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;图书ID&quot;, required &#x3D; true, dataType &#x3D; &quot;Long&quot;,paramType &#x3D; &quot;path&quot;),</span><br><span class="line">            @ApiImplicitParam(name &#x3D; &quot;book&quot;, value &#x3D; &quot;图书实体book&quot;, required &#x3D; true, dataType &#x3D; &quot;Book&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&#x2F;&#123;id&#125;&quot;, method&#x3D; RequestMethod.PUT)</span><br><span class="line">    public String putUser(@PathVariable Long id, @RequestBody Book book) &#123;</span><br><span class="line">        Book book1 &#x3D; books.get(id);</span><br><span class="line">        book1.setName(book.getName());</span><br><span class="line">        book1.setPrice(book.getPrice());</span><br><span class="line">        books.put(id, book1);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    @ApiOperation(value&#x3D;&quot;删除图书&quot;, notes&#x3D;&quot;根据url的id来指定删除图书&quot;)</span><br><span class="line">    @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;图书ID&quot;, required &#x3D; true, dataType &#x3D; &quot;Long&quot;,paramType &#x3D; &quot;path&quot;)</span><br><span class="line">    @RequestMapping(value&#x3D;&quot;&#x2F;&#123;id&#125;&quot;, method&#x3D;RequestMethod.DELETE)</span><br><span class="line">    public String deleteUser(@PathVariable Long id) &#123;</span><br><span class="line">        books.remove(id);</span><br><span class="line">        return &quot;success&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiIgnore&#x2F;&#x2F;使用该注解忽略这个API</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public String  jsonTest() &#123;</span><br><span class="line">        return &quot; hi you!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>通过相关注解，就可以让swagger2生成相应的文档。如果你不需要某接口生成文档，只需要在加@ApiIgnore注解即可。需要说明的是，如果请求参数在url上，@ApiImplicitParam 上加paramType = “path” 。</p>
<p>启动工程，访问：<a target="_blank" rel="noopener" href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a> ，就看到swagger-ui:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-62a6df7cc78d4027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>整个集成过程非常简单，但是我看了相关的资料，swagger没有做安全方面的防护，可能需要我们自己做相关的工作。</p>
<h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p><a target="_blank" rel="noopener" href="http://swagger.io/docs/">swagger.io</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.didispace.com/springbootswagger2/">Spring Boot中使用Swagger2构建强大的RESTful API文档</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第1篇：构建springboot工程</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot1/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p> spring boot 它的设计目的就是为例简化开发，开启了各种自动装配，你不想写各种配置文件，引入相关的依赖就能迅速搭建起一个web工程。它采用的是建立生产就绪的应用程序观点，优先于配置的惯例。</p>
 <span id="more"></span>

<p>可能你有很多理由不放弃SSM,SSH，但是当你一旦使用了springboot ,你会觉得一切变得简单了，配置变的简单了、编码变的简单了，部署变的简单了，感觉自己健步如飞，开发速度大大提高了。就好比，当你用了IDEA，你会觉得再也回不到Eclipse时代一样。另，本系列教程全部用的IDEA作为开发工具。</p>
<h2 id="建构工程"><a href="#建构工程" class="headerlink" title="建构工程"></a>建构工程</h2><p>你需要：</p>
<ul>
<li>15分钟</li>
<li>jdk 1.8或以上</li>
<li>maven 3.0+</li>
<li>Idea</li>
</ul>
<p>打开Idea-&gt; new Project -&gt;Spring Initializr -&gt;填写group、artifact -&gt;钩上web(开启web功能）-&gt;点下一步就行了。</p>
<h2 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h2><p>创建完工程，工程的目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- src</span><br><span class="line">	-main</span><br><span class="line">		-java</span><br><span class="line">			-package</span><br><span class="line">				-SpringbootApplication</span><br><span class="line">		-resouces</span><br><span class="line">			- statics</span><br><span class="line">			- templates</span><br><span class="line">			- application.yml</span><br><span class="line">	-test</span><br><span class="line">- pom</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>pom文件为基本的依赖管理文件</li>
<li>resouces 资源文件<ul>
<li>statics 静态资源</li>
<li>templates 模板资源</li>
<li>application.yml 配置文件</li>
</ul>
</li>
<li>SpringbootApplication程序的入口。</li>
</ul>
<p>pom.xml的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springboot-first-application&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;springboot-first-application&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中spring-boot-starter-web不仅包含spring-boot-starter,还自动开启了web功能。</p>
<h2 id="功能演示"><a href="#功能演示" class="headerlink" title="功能演示"></a>功能演示</h2><p>说了这么多，你可能还体会不到，举个栗子，比如你引入了Thymeleaf的依赖，spring boot 就会自动帮你引入SpringTemplateEngine，当你引入了自己的SpringTemplateEngine，spring boot就不会帮你引入。它让你专注于你的自己的业务开发，而不是各种配置。</p>
<p>再举个栗子,建个controller：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class HelloController &#123;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Greetings from Spring Boot!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动SpringbootFirstApplication的main方法，打开浏览器localhost:8080,浏览器显示：</p>
<blockquote>
<p>Greetings from Spring Boot!</p>
</blockquote>
<h4 id="神奇之处："><a href="#神奇之处：" class="headerlink" title="神奇之处："></a>神奇之处：</h4><ul>
<li>你没有做任何的web.xml配置。</li>
<li>你没有做任何的sping mvc的配置; springboot为你做了。</li>
<li>你没有配置tomcat ;springboot内嵌tomcat.</li>
</ul>
<h4 id="启动springboot-方式"><a href="#启动springboot-方式" class="headerlink" title="启动springboot 方式"></a>启动springboot 方式</h4><p>cd到项目主目录:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean  </span><br><span class="line">mvn package  编译项目的jar</span><br></pre></td></tr></table></figure>

<ul>
<li>mvn spring-boot: run  启动</li>
<li>cd 到target目录，java -jar  项目.jar</li>
</ul>
<h2 id="来看看springboot在启动的时候为我们注入了哪些bean"><a href="#来看看springboot在启动的时候为我们注入了哪些bean" class="headerlink" title="来看看springboot在启动的时候为我们注入了哪些bean"></a>来看看springboot在启动的时候为我们注入了哪些bean</h2><p>在程序入口加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootFirstApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringbootFirstApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public CommandLineRunner commandLineRunner(ApplicationContext ctx) &#123;</span><br><span class="line">		return args -&gt; &#123;</span><br><span class="line"></span><br><span class="line">			System.out.println(&quot;Let&#39;s inspect the beans provided by Spring Boot:&quot;);</span><br><span class="line"></span><br><span class="line">			String[] beanNames &#x3D; ctx.getBeanDefinitionNames();</span><br><span class="line">			Arrays.sort(beanNames);</span><br><span class="line">			for (String beanName : beanNames) &#123;</span><br><span class="line">				System.out.println(beanName);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序输出：</p>
<blockquote>
<p>Let’s inspect the beans provided by Spring Boot:<br>basicErrorController<br>beanNameHandlerMapping<br>beanNameViewResolver<br>characterEncodingFilter<br>commandLineRunner<br>conventionErrorViewResolver<br>defaultServletHandlerMapping<br>defaultViewResolver<br>dispatcherServlet<br>dispatcherServletRegistration<br>duplicateServerPropertiesDetector<br>embeddedServletContainerCustomizerBeanPostProcessor<br>error<br>errorAttributes<br>errorPageCustomizer<br>errorPageRegistrarBeanPostProcessor</p>
</blockquote>
<blockquote>
<p>….<br> ….</p>
</blockquote>
<p> 在程序启动的时候，springboot自动诸如注入了40-50个bean.</p>
<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><p>通过@RunWith() @SpringBootTest开启注解：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest(webEnvironment &#x3D; SpringBootTest.WebEnvironment.RANDOM_PORT)</span><br><span class="line">public class HelloControllerIT &#123;</span><br><span class="line"></span><br><span class="line">    @LocalServerPort</span><br><span class="line">    private int port;</span><br><span class="line"></span><br><span class="line">    private URL base;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private TestRestTemplate template;</span><br><span class="line"></span><br><span class="line">    @Before</span><br><span class="line">    public void setUp() throws Exception &#123;</span><br><span class="line">        this.base &#x3D; new URL(&quot;http:&#x2F;&#x2F;localhost:&quot; + port + &quot;&#x2F;&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void getHello() throws Exception &#123;</span><br><span class="line">        ResponseEntity&lt;String&gt; response &#x3D; template.getForEntity(base.toString(),</span><br><span class="line">                String.class);</span><br><span class="line">        assertThat(response.getBody(), equalTo(&quot;Greetings from Spring Boot!&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 运行它会先开启sprigboot工程，然后再测试，测试通过 ^.^</p>
<p> 源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>市面上有很多springboot的书，有很多springboot的博客，为什么我还要写这样一个系列？到目前为止，我没有看过一本springboot的书，因为还没来得及看，看的都是官方指南，当然也参考了很多的博客，他们都写的非常的棒！在看官方指南和博客的时候，发现他们有很多不同之处，所以我打算写一个来源于官方，通过自己理解加整合写一个系列，所以取名叫《springboot 非官方教程》。我相信我写的可能跟其他人的写的会不太一样。另外，最主要的原因还是提高自己，怀着一个乐于分享的心，将自己的理解分享给更多需要的人。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/spring-boot/">Building an Application with Spring Boot</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 终章：文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章: 文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第16篇：ResrTemplate</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot11-restTemplate/</url>
    <content><![CDATA[<p>这篇文章主要介绍怎么用消费一个 Restful的web服务。我将用restTemplate去消费一个服务： <a target="_blank" rel="noopener" href="http://gturnquist-quoters.cfapps.io/api/random">http://gturnquist-quoters.cfapps.io/api/random</a>.</p>
<span id="more"></span>

<h2 id="构架工程"><a href="#构架工程" class="headerlink" title="构架工程"></a>构架工程</h2><p>创建一个springboot工程，去消费RESTFUL的服务。这个服务是 http:///gturnquist-quoters.cfapps.io/api/random ，它会随机返回Json字符串。<br>在Spring项目中，它提供了一个非常简便的类，叫RestTemplate，它可以很简便的消费服务。</p>
<h2 id="消费服务"><a href="#消费服务" class="headerlink" title="消费服务"></a>消费服务</h2><p>通过RestTemplate消费服务，需要先context中注册一个RestTemplate bean。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">	public RestTemplate restTemplate(RestTemplateBuilder builder) &#123;</span><br><span class="line">		return builder.build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public CommandLineRunner run(RestTemplate restTemplate) throws Exception &#123;</span><br><span class="line">		return args -&gt; &#123;</span><br><span class="line">			String quote &#x3D; restTemplate.getForObject(</span><br><span class="line">					&quot;http:&#x2F;&#x2F;gturnquist-quoters.cfapps.io&#x2F;api&#x2F;random&quot;, String.class);</span><br><span class="line">			log.info(quote.toString());</span><br><span class="line">		&#125;;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，控制台打印：</p>
<blockquote>
<p>{<br>    “type”: “success”,<br>    “value”: {<br>        “id”: 6,<br>        “quote”: “It embraces convention over configuration, providing an experience on par with frameworks that excel at early stage development, such as Ruby on Rails.”<br>    }<br>}</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/consuming-rest/">https://spring.io/guides/gs/consuming-rest/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第10篇：restdoc</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot10-springrestdocs/</url>
    <content><![CDATA[<p>这篇文章将带你了解如何用spring官方推荐的restdoc去生成api文档。本文创建一个简单的springboot工程，将http接口通过Api文档暴露出来。只需要通过 JUnit单元测试和Spring的MockMVC就可以生成文档。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>你需要15min</li>
<li>Jdk 1.8</li>
<li>maven 3.0+</li>
<li>idea</li>
</ul>
<h4 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h4><p>引入依赖，其pom文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.restdocs&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-restdocs-mockmvc&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
<p>通过@SpringBootApplication,开启springboot</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在springboot通常创建一个controller:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HomeController &#123;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public Map&lt;String, Object&gt; greeting() &#123;</span><br><span class="line">        return Collections.singletonMap(&quot;message&quot;, &quot;Hello World&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动工程，访问localhost:8080，浏览器显示：</p>
<blockquote>
<p>{“message”:”Hello World”}</p>
</blockquote>
<p>证明接口已经写好了，但是如何通过restdoc生存api文档呢</p>
<h2 id="Restdoc-通过单元测试生成api文档"><a href="#Restdoc-通过单元测试生成api文档" class="headerlink" title="Restdoc,通过单元测试生成api文档"></a>Restdoc,通过单元测试生成api文档</h2><p>restdocs是通过单元测试生存snippets文件，然后snippets根据插件生成htm文档的。</p>
<p>建一个单元测试类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@WebMvcTest(HomeController.class)</span><br><span class="line">@AutoConfigureRestDocs(outputDir &#x3D; &quot;target&#x2F;snippets&quot;)</span><br><span class="line">public class WebLayerTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private MockMvc mockMvc;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void shouldReturnDefaultMessage() throws Exception &#123;</span><br><span class="line">        this.mockMvc.perform(get(&quot;&#x2F;&quot;)).andDo(print()).andExpect(status().isOk())</span><br><span class="line">                .andExpect(content().string(containsString(&quot;Hello World&quot;)))</span><br><span class="line">                .andDo(document(&quot;home&quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>其中，@ AutoConfigureRestDocs注解开启了生成snippets文件，并指定了存放位置。</p>
<p>启动单元测试，测试通过，你会发现在target文件下生成了一个snippets文件夹，其目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">└── target</span><br><span class="line">    └── snippets</span><br><span class="line">        └── home</span><br><span class="line">            └── httpie-request.adoc</span><br><span class="line">            └── curl-request.adoc</span><br><span class="line">            └── http-request.adoc</span><br><span class="line">            └── http-response.adoc</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>默认情况下，snippets是Asciidoctor格式的文件，包括request和reponse，另外其他两种httpie和curl两种流行的命令行的http请求模式。</p>
<p>到目前为止，只生成了Snippets文件，需要用Snippets文件生成文档。</p>
<h4 id="怎么用Snippets"><a href="#怎么用Snippets" class="headerlink" title="怎么用Snippets"></a>怎么用Snippets</h4><p>创建一个新文件src/main/asciidoc/index.adoc ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D; 用 Spring REST Docs 构建文档</span><br><span class="line"></span><br><span class="line">This is an example output for a service running at http:&#x2F;&#x2F;localhost:8080:</span><br><span class="line"></span><br><span class="line">.request</span><br><span class="line">include::&#123;snippets&#125;&#x2F;home&#x2F;http-request.adoc[]</span><br><span class="line"></span><br><span class="line">.response</span><br><span class="line">include::&#123;snippets&#125;&#x2F;home&#x2F;http-response.adoc[]</span><br><span class="line"></span><br><span class="line">这个例子非常简单，通过单元测试和一些简单的配置就能够得到api文档了。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>adoc的书写格式，参考:<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-restdocs/docs/current/reference/html5/">http://docs.spring.io/spring-restdocs/docs/current/reference/html5/</a>，这里不多讲解。</p>
<p>需要使用asciidoctor-maven-plugin插件，在其pom文件加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.asciidoctor&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;asciidoctor-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;executions&gt;</span><br><span class="line">        &lt;execution&gt;</span><br><span class="line">            &lt;id&gt;generate-docs&lt;&#x2F;id&gt;</span><br><span class="line">            &lt;phase&gt;prepare-package&lt;&#x2F;phase&gt;</span><br><span class="line">            &lt;goals&gt;</span><br><span class="line">                &lt;goal&gt;process-asciidoc&lt;&#x2F;goal&gt;</span><br><span class="line">            &lt;&#x2F;goals&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;sourceDocumentName&gt;index.adoc&lt;&#x2F;sourceDocumentName&gt;</span><br><span class="line">                &lt;backend&gt;html&lt;&#x2F;backend&gt;</span><br><span class="line">                &lt;attributes&gt;</span><br><span class="line">                    &lt;snippets&gt;$&#123;project.build.directory&#125;&#x2F;snippets&lt;&#x2F;snippets&gt;</span><br><span class="line">                &lt;&#x2F;attributes&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;execution&gt;</span><br><span class="line">    &lt;&#x2F;executions&gt;</span><br><span class="line">&lt;&#x2F;plugin&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时只需要通过mvnw package命令就可以生成文档了。<br>在/target/generated-docs下有个index.html，打开这个html,显示如下，界面还算简洁：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-33d12bf68b964711.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>通过单元测试，生存adoc文件，再用adoc文件生存html，只需要简单的几步就可以生成一个api文档的html文件，这个html文件你可以通网站发布出去。整个过程很简单，对代码无任何影响。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/testing-restdocs/">restdocs</a></p>
<p><a target="_blank" rel="noopener" href="http://docs.spring.io/spring-restdocs/docs/current/reference/html5/">http://docs.spring.io/spring-restdocs/docs/current/reference/html5/</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第13篇：spring cache</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot13-springcache/</url>
    <content><![CDATA[<p>本文介绍如何在springboot中使用默认的spring cache，</p>
<span id="more"></span>

<h2 id="声明式缓存"><a href="#声明式缓存" class="headerlink" title="声明式缓存"></a>声明式缓存</h2><p>Spring 定义 CacheManager 和 Cache 接口用来统一不同的缓存技术。例如 JCache、 EhCache、 Hazelcast、 Guava、 Redis 等。在使用 Spring 集成 Cache 的时候，我们需要注册实现的 CacheManager 的 Bean。</p>
<p>Spring Boot 为我们自动配置了 JcacheCacheConfiguration、 EhCacheCacheConfiguration、HazelcastCacheConfiguration、GuavaCacheConfiguration、RedisCacheConfiguration、SimpleCacheConfiguration 等。</p>
<h2 id="默认使用-ConcurrenMapCacheManager"><a href="#默认使用-ConcurrenMapCacheManager" class="headerlink" title="默认使用 ConcurrenMapCacheManager"></a>默认使用 ConcurrenMapCacheManager</h2><p>在我们不使用其他第三方缓存依赖的时候，springboot自动采用ConcurrenMapCacheManager作为缓存管理器。</p>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><p>在pom文件引入spring-boot-starter-cache环境依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-cache&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建一个book数据访问层"><a href="#创建一个book数据访问层" class="headerlink" title="创建一个book数据访问层"></a>创建一个book数据访问层</h2><h3 id="先创建一个实体类"><a href="#先创建一个实体类" class="headerlink" title="先创建一个实体类"></a>先创建一个实体类</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Book &#123;</span><br><span class="line"></span><br><span class="line">   private String isbn;</span><br><span class="line">   private String title;</span><br><span class="line"></span><br><span class="line">   public Book(String isbn, String title) &#123;</span><br><span class="line">       this.isbn &#x3D; isbn;</span><br><span class="line">       this.title &#x3D; title;</span><br><span class="line">   &#125;</span><br><span class="line"> ....getter</span><br><span class="line"> ....setter  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="创建一个数据访问接口"><a href="#创建一个数据访问接口" class="headerlink" title="创建一个数据访问接口"></a>创建一个数据访问接口</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public interface BookRepository &#123;</span><br><span class="line"></span><br><span class="line">    Book getByIsbn(String isbn);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个你可以写一个很复杂的数据查询操作，比如操作mysql、nosql等等。为了演示这个栗子，我只做了一下线程的延迟操作，当作是查询数据库的时间。</p>
<p>实现接口类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SimpleBookRepository implements BookRepository &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    </span><br><span class="line">    public Book getByIsbn(String isbn) &#123;</span><br><span class="line">        simulateSlowService();</span><br><span class="line">        return new Book(isbn, &quot;Some book&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Don&#39;t do this at home</span><br><span class="line">    private void simulateSlowService() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            long time &#x3D; 3000L;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class AppRunner implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger logger &#x3D; LoggerFactory.getLogger(AppRunner.class);</span><br><span class="line"></span><br><span class="line">    private final BookRepository bookRepository;</span><br><span class="line"></span><br><span class="line">    public AppRunner(BookRepository bookRepository) &#123;</span><br><span class="line">        this.bookRepository &#x3D; bookRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        logger.info(&quot;.... Fetching books&quot;);</span><br><span class="line">        logger.info(&quot;isbn-1234 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-1234&quot;));</span><br><span class="line">        logger.info(&quot;isbn-4567 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-4567&quot;));</span><br><span class="line">        logger.info(&quot;isbn-1234 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-1234&quot;));</span><br><span class="line">        logger.info(&quot;isbn-4567 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-4567&quot;));</span><br><span class="line">        logger.info(&quot;isbn-1234 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-1234&quot;));</span><br><span class="line">        logger.info(&quot;isbn-1234 --&gt;&quot; + bookRepository.getByIsbn(&quot;isbn-1234&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动程序，你会发现程序在控制台依次打印了：</p>
<blockquote>
<p>2014-06-05 12:15:35.783  … : …. Fetching books</p>
<p>2014-06-05 12:15:40.783  … : isbn-1234 –&gt; &gt;Book{isbn=’isbn-1234’, title=’Some book’}</p>
</blockquote>
<p>2014-06-05 12:15:43.784  … : isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}</p>
<blockquote>
</blockquote>
<p>2014-06-05 12:15:46.786  … : isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}</p>
<p>你会发现程序依次3s打印一行日志。这时还没开启缓存技术。</p>
<h2 id="开启缓存技术"><a href="#开启缓存技术" class="headerlink" title="开启缓存技术"></a>开启缓存技术</h2><p>在程序的入口中加入@ EnableCaching开启缓存技术：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableCaching</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在需要缓存的地方加入@Cacheable注解，比如在getByIsbn（）方法上加入@Cacheable(“books”)，这个方法就开启了缓存策略，当缓存有这个数据的时候，会直接返回数据，不会等待去查询数据库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SimpleBookRepository implements BookRepository &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    @Cacheable(&quot;books&quot;)</span><br><span class="line">    public Book getByIsbn(String isbn) &#123;</span><br><span class="line">        simulateSlowService();</span><br><span class="line">        return new Book(isbn, &quot;Some book&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Don&#39;t do this at home</span><br><span class="line">    private void simulateSlowService() &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            long time &#x3D; 3000L;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            throw new IllegalStateException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时再启动程序，你会发现程序打印：</p>
<blockquote>
<p>isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}<br>2017-04-23 18:17:09.479  INFO 8054 — [           main] forezp.AppRunner                         : isbn-4567 –&gt;Book{isbn=’isbn-4567’, title=’Some book’}<br>2017-04-23 18:17:09.480  INFO 8054 — [           main] forezp.AppRunner                         : isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}<br>2017-04-23 18:17:09.480  INFO 8054 — [           main] forezp.AppRunner                         : isbn-4567 –&gt;Book{isbn=’isbn-4567’, title=’Some book’}<br>2017-04-23 18:17:09.481  INFO 8054 — [           main] forezp.AppRunner                         : isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}<br>2017-04-23 18:17:09.481  INFO 8054 — [           main] forezp.AppRunner                         : isbn-1234 –&gt;Book{isbn=’isbn-1234’, title=’Some book’}</p>
</blockquote>
<p>只有打印前面2个数据，程序等了3s，之后的数据瞬间打印在控制台上了，这说明缓存起了作用。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/caching/">caching</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.720ui.com/2017/springboot_02_data_cache_concurrenmapcache/">Spring Boot 揭秘与实战（二） 数据缓存篇 - 快速入门</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第9篇：声明式事务</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot-tracstion/</url>
    <content><![CDATA[<p>springboot开启事务很简单，只需要一个注解@Transactional 就可以了。因为在springboot中已经默认对jpa、jdbc、mybatis开启了事事务，引入它们依赖的时候，事物就默认开启。当然，如果你需要用其他的orm，比如beatlsql，就需要自己配置相关的事物管理器。</p>
<span id="more"></span>

<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>以上一篇文章的代码为例子，即springboot整合mybatis，上一篇文章是基于注解来实现mybatis的数据访问层，这篇文章基于xml的来实现，并开启声明式事务。</p>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><p>在pom文件中引入mybatis启动依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.3.0&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>引入mysql 依赖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.0.29&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="初始化数据库脚本"><a href="#初始化数据库脚本" class="headerlink" title="初始化数据库脚本"></a>初始化数据库脚本</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- create table &#96;account&#96;</span><br><span class="line"># DROP TABLE &#96;account&#96; IF EXISTS</span><br><span class="line">CREATE TABLE &#96;account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(20) NOT NULL,</span><br><span class="line">  &#96;money&#96; double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;1&#39;, &#39;aaa&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;2&#39;, &#39;bbb&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;3&#39;, &#39;ccc&#39;, &#39;1000&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;123456</span><br><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">mybatis.mapper-locations&#x3D;classpath*:mybatis&#x2F;*Mapper.xml</span><br><span class="line">mybatis.type-aliases-package&#x3D;com.forezp.entity</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过配置mybatis.mapper-locations来指明mapper的xml文件存放位置，我是放在resources/mybatis文件下的。mybatis.type-aliases-package来指明和数据库映射的实体的所在包。</p>
<p>经过以上步骤，springboot就可以通过mybatis访问数据库来。</p>
<h2 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">public class Account &#123;</span><br><span class="line">    private int id ;</span><br><span class="line">    private String name ;</span><br><span class="line">    private double money;</span><br><span class="line">    </span><br><span class="line">    getter..</span><br><span class="line">    setter..</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h2 id="数据访问dao-层"><a href="#数据访问dao-层" class="headerlink" title="数据访问dao 层"></a>数据访问dao 层</h2><p>接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AccountMapper2 &#123;</span><br><span class="line">   int update( @Param(&quot;money&quot;) double money, @Param(&quot;id&quot;) int  id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mapper:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.forezp.dao.AccountMapper2&quot;&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;update id&#x3D;&quot;update&quot;&gt;</span><br><span class="line">        UPDATE account set money&#x3D;#&#123;money&#125; WHERE id&#x3D;#&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;update&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountService2 &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    AccountMapper2 accountMapper2;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public void transfer() throws RuntimeException&#123;</span><br><span class="line">        accountMapper2.update(90,1);&#x2F;&#x2F;用户1减10块 用户2加10块</span><br><span class="line">        int i&#x3D;1&#x2F;0;</span><br><span class="line">        accountMapper2.update(110,2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>@Transactional，声明事务，并设计一个转账方法，用户1减10块，用户2加10块。在用户1减10 ，之后，抛出异常，即用户2加10块钱不能执行，当加注解@Transactional之后，两个人的钱都没有增减。当不加@Transactional，用户1减了10，用户2没有增加，即没有操作用户2 的数据。可见@Transactional注解开启了事物。</p>
<h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>springboot 开启事物很简单，只需要加一行注解就可以了，前提你用的是jdbctemplate, jpa, mybatis，这种常见的orm。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/managing-transactions/">managing-transactions/</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第14篇：Redis消息队列</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot14-redis-mq%E5%88%97/</url>
    <content><![CDATA[<p>这篇文章主要讲述如何在springboot中用reids实现消息队列。</p>
<span id="more"></span>

<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><ul>
<li>安装redis,可参考我的另一篇文章，<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/61471712">5分钟带你入门Redis</a>。</li>
<li>java 1.8</li>
<li>maven 3.0</li>
<li>idea</li>
</ul>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><p>创建一个新的springboot工程，在其pom文件,加入spring-boot-starter-data-redis依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建一个消息接收者"><a href="#创建一个消息接收者" class="headerlink" title="创建一个消息接收者"></a>创建一个消息接收者</h2><p>REcevier类，它是一个普通的类，需要注入到springboot中。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Receiver &#123;</span><br><span class="line">    private static final Logger LOGGER &#x3D; LoggerFactory.getLogger(Receiver.class);</span><br><span class="line"></span><br><span class="line">    private CountDownLatch latch;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public Receiver(CountDownLatch latch) &#123;</span><br><span class="line">        this.latch &#x3D; latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void receiveMessage(String message) &#123;</span><br><span class="line">        LOGGER.info(&quot;Received &lt;&quot; + message + &quot;&gt;&quot;);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注入消息接收者"><a href="#注入消息接收者" class="headerlink" title="注入消息接收者"></a>注入消息接收者</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">	Receiver receiver(CountDownLatch latch) &#123;</span><br><span class="line">		return new Receiver(latch);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	CountDownLatch latch() &#123;</span><br><span class="line">		return new CountDownLatch(1);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	StringRedisTemplate template(RedisConnectionFactory connectionFactory) &#123;</span><br><span class="line">		return new StringRedisTemplate(connectionFactory);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="注入消息监听容器"><a href="#注入消息监听容器" class="headerlink" title="注入消息监听容器"></a>注入消息监听容器</h2><p>在spring data redis中，利用redis发送一条消息和接受一条消息，需要三样东西：</p>
<ul>
<li>一个连接工厂 </li>
<li>一个消息监听容器</li>
<li>Redis template</li>
</ul>
<p>上述1、3步已经完成，所以只需注入消息监听容器即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">	RedisMessageListenerContainer container(RedisConnectionFactory connectionFactory,</span><br><span class="line">											MessageListenerAdapter listenerAdapter) &#123;</span><br><span class="line"></span><br><span class="line">		RedisMessageListenerContainer container &#x3D; new RedisMessageListenerContainer();</span><br><span class="line">		container.setConnectionFactory(connectionFactory);</span><br><span class="line">		container.addMessageListener(listenerAdapter, new PatternTopic(&quot;chat&quot;));</span><br><span class="line"></span><br><span class="line">		return container;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	MessageListenerAdapter listenerAdapter(Receiver receiver) &#123;</span><br><span class="line">		return new MessageListenerAdapter(receiver, &quot;receiveMessage&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>在springboot入口的main方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		ApplicationContext ctx &#x3D;  SpringApplication.run(SpringbootRedisApplication.class, args);</span><br><span class="line"></span><br><span class="line">		StringRedisTemplate template &#x3D; ctx.getBean(StringRedisTemplate.class);</span><br><span class="line">		CountDownLatch latch &#x3D; ctx.getBean(CountDownLatch.class);</span><br><span class="line"></span><br><span class="line">		LOGGER.info(&quot;Sending message...&quot;);</span><br><span class="line">		template.convertAndSend(&quot;chat&quot;, &quot;Hello from Redis!&quot;);</span><br><span class="line"></span><br><span class="line">		latch.await();</span><br><span class="line"></span><br><span class="line">		System.exit(0);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>先用redisTemplate发送一条消息，接收者接收到后，打印出来。启动springboot程序，控制台打印：</p>
<blockquote>
<p>2017-04-20 17:25:15.536  INFO 39148 — [           main] com.forezp.SpringbootRedisApplication    : Sending message…<br>      2017-04-20 17:25:15.544  INFO 39148 — [    container-2] com.forezp.message.Receiver              : 》Received &lt;Hello from Redis!&gt;</p>
</blockquote>
<p>测试通过，接收者确实接收到了发送者的消息。</p>
<h2 id="源码下载："><a href="#源码下载：" class="headerlink" title="源码下载："></a>源码下载：</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/messaging-redis/">messaging-redis</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第17篇：上传文件</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot14-upload/</url>
    <content><![CDATA[<p>这篇文章主要介绍，如何在springboot工程作为服务器，去接收通过http 上传的multi-file的文件。</p>
<span id="more"></span>


<h2 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h2><p>为例创建一个springmvc工程你需要spring-boot-starter-thymeleaf和 spring-boot-starter-web的起步依赖。为例能够上传文件在服务器，你需要在web.xml中加入<multipart-config>标签做相关的配置，但在sringboot 工程中，它已经为你自动做了，所以不需要你做任何的配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt;</span><br><span class="line">&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建文件上传controller"><a href="#创建文件上传controller" class="headerlink" title="创建文件上传controller"></a>创建文件上传controller</h2><p>直接贴代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Controller</span><br><span class="line">public class FileUploadController &#123;</span><br><span class="line"></span><br><span class="line">    private final StorageService storageService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public FileUploadController(StorageService storageService) &#123;</span><br><span class="line">        this.storageService &#x3D; storageService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String listUploadedFiles(Model model) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        model.addAttribute(&quot;files&quot;, storageService</span><br><span class="line">                .loadAll()</span><br><span class="line">                .map(path -&gt;</span><br><span class="line">                        MvcUriComponentsBuilder</span><br><span class="line">                                .fromMethodName(FileUploadController.class, &quot;serveFile&quot;, path.getFileName().toString())</span><br><span class="line">                                .build().toString())</span><br><span class="line">                .collect(Collectors.toList()));</span><br><span class="line"></span><br><span class="line">        return &quot;uploadForm&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;files&#x2F;&#123;filename:.+&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public ResponseEntity&lt;Resource&gt; serveFile(@PathVariable String filename) &#123;</span><br><span class="line"></span><br><span class="line">        Resource file &#x3D; storageService.loadAsResource(filename);</span><br><span class="line">        return ResponseEntity</span><br><span class="line">                .ok()</span><br><span class="line">                .header(HttpHeaders.CONTENT_DISPOSITION, &quot;attachment; filename&#x3D;\&quot;&quot;+file.getFilename()+&quot;\&quot;&quot;)</span><br><span class="line">                .body(file);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String handleFileUpload(@RequestParam(&quot;file&quot;) MultipartFile file,</span><br><span class="line">                                   RedirectAttributes redirectAttributes) &#123;</span><br><span class="line"></span><br><span class="line">        storageService.store(file);</span><br><span class="line">        redirectAttributes.addFlashAttribute(&quot;message&quot;,</span><br><span class="line">                &quot;You successfully uploaded &quot; + file.getOriginalFilename() + &quot;!&quot;);</span><br><span class="line"></span><br><span class="line">        return &quot;redirect:&#x2F;&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(StorageFileNotFoundException.class)</span><br><span class="line">    public ResponseEntity handleStorageFileNotFound(StorageFileNotFoundException exc) &#123;</span><br><span class="line">        return ResponseEntity.notFound().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个类通过@Controller注解，表明自己上一个Spring mvc的c。每个方法通过<br>@GetMapping 或者@PostMapping注解表明自己的 http方法。</p>
<ul>
<li>GET / 获取已经上传的文件列表</li>
<li>GET /files/{filename}  下载已经存在于服务器的文件</li>
<li>POST / 上传文件给服务器</li>
</ul>
<h2 id="创建一个简单的-html模板"><a href="#创建一个简单的-html模板" class="headerlink" title="创建一个简单的 html模板"></a>创建一个简单的 html模板</h2><p>为了展示上传文件的过程，我们做一个界面：<br>在src/main/resources/templates/uploadForm.html</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html xmlns:th&#x3D;&quot;http:&#x2F;&#x2F;www.thymeleaf.org&quot;&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">	&lt;div th:if&#x3D;&quot;$&#123;message&#125;&quot;&gt;</span><br><span class="line">		&lt;h2 th:text&#x3D;&quot;$&#123;message&#125;&quot;&#x2F;&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;form method&#x3D;&quot;POST&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot; action&#x3D;&quot;&#x2F;&quot;&gt;</span><br><span class="line">			&lt;table&gt;</span><br><span class="line">				&lt;tr&gt;&lt;td&gt;File to upload:&lt;&#x2F;td&gt;&lt;td&gt;&lt;input type&#x3D;&quot;file&quot; name&#x3D;&quot;file&quot; &#x2F;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">				&lt;tr&gt;&lt;td&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Upload&quot; &#x2F;&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;</span><br><span class="line">			&lt;&#x2F;table&gt;</span><br><span class="line">		&lt;&#x2F;form&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">	&lt;div&gt;</span><br><span class="line">		&lt;ul&gt;</span><br><span class="line">			&lt;li th:each&#x3D;&quot;file : $&#123;files&#125;&quot;&gt;</span><br><span class="line">				&lt;a th:href&#x3D;&quot;$&#123;file&#125;&quot; th:text&#x3D;&quot;$&#123;file&#125;&quot; &#x2F;&gt;</span><br><span class="line">			&lt;&#x2F;li&gt;</span><br><span class="line">		&lt;&#x2F;ul&gt;</span><br><span class="line">	&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="上传文件大小限制"><a href="#上传文件大小限制" class="headerlink" title="上传文件大小限制"></a>上传文件大小限制</h2><p>如果需要限制上传文件的大小也很简单，只需要在springboot 工程的src/main/resources/application.properties 加入以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.http.multipart.max-file-size&#x3D;128KB</span><br><span class="line">spring.http.multipart.max-request-size&#x3D;128KB</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>测试情况如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-5f398faeb076e37e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/uploading-files/">https://spring.io/guides/gs/uploading-files/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第15篇：Rabbitmq</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot15-rabbitmq/</url>
    <content><![CDATA[<p>这篇文章带你了解怎么整合RabbitMQ服务器，并且通过它怎么去发送和接收消息。我将构建一个springboot工程，通过RabbitTemplate去通过MessageListenerAdapter去订阅一个POJO类型的消息。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>15min</li>
<li>IDEA</li>
<li>maven 3.0</li>
</ul>
<p>在开始构建项目之前，机器需要安装rabbitmq，你可以去官网下载，<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/download.html">http://www.rabbitmq.com/download.html</a> ，如果你是用的Mac（程序员都应该用mac吧），你可以这样下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brew install rabbitmq</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>安装完成后开启服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rabbitmq-server</span><br></pre></td></tr></table></figure>

<p>开启服务器成功，你可以看到以下信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">            RabbitMQ 3.1.3. Copyright (C) 2007-2013 VMware, Inc.</span><br><span class="line">##  ##      Licensed under the MPL.  See http:&#x2F;&#x2F;www.rabbitmq.com&#x2F;</span><br><span class="line">##  ##</span><br><span class="line">##########  Logs: &#x2F;usr&#x2F;local&#x2F;var&#x2F;log&#x2F;rabbitmq&#x2F;rabbit@localhost.log</span><br><span class="line">######  ##        &#x2F;usr&#x2F;local&#x2F;var&#x2F;log&#x2F;rabbitmq&#x2F;rabbit@localhost-sasl.log</span><br><span class="line">##########</span><br><span class="line">            Starting broker... completed with 6 plugins.</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h2><p>构架一个SpringBoot工程，其pom文件依赖加上spring-boot-starter-amqp的起步依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建消息接收者"><a href="#创建消息接收者" class="headerlink" title="创建消息接收者"></a>创建消息接收者</h2><p>在任何的消息队列程序中，你需要创建一个消息接收者，用于响应发送的消息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class Receiver &#123;</span><br><span class="line"></span><br><span class="line">    private CountDownLatch latch &#x3D; new CountDownLatch(1);</span><br><span class="line"></span><br><span class="line">    public void receiveMessage(String message) &#123;</span><br><span class="line">        System.out.println(&quot;Received &lt;&quot; + message + &quot;&gt;&quot;);</span><br><span class="line">        latch.countDown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public CountDownLatch getLatch() &#123;</span><br><span class="line">        return latch;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>消息接收者是一个简单的POJO类，它定义了一个方法去接收消息，当你注册它去接收消息，你可以给它取任何的名字。其中，它有CountDownLatch这样的一个类，它是用于告诉发送者消息已经收到了，你不需要在应用程序中具体实现它，只需要latch.countDown()就行了。</p>
<h2 id="创建消息监听，并发送一条消息"><a href="#创建消息监听，并发送一条消息" class="headerlink" title="创建消息监听，并发送一条消息"></a>创建消息监听，并发送一条消息</h2><p>在spring程序中，RabbitTemplate提供了发送消息和接收消息的所有方法。你只需简单的配置下就行了：</p>
<ul>
<li>需要一个消息监听容器</li>
<li>声明一个quene,一个exchange,并且绑定它们</li>
<li>一个组件去发送消息</li>
</ul>
<p>代码清单如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.forezp;</span><br><span class="line"></span><br><span class="line">import com.forezp.message.Receiver;</span><br><span class="line">import org.springframework.amqp.core.Binding;</span><br><span class="line">import org.springframework.amqp.core.BindingBuilder;</span><br><span class="line">import org.springframework.amqp.core.Queue;</span><br><span class="line">import org.springframework.amqp.core.TopicExchange;</span><br><span class="line">import org.springframework.amqp.rabbit.connection.ConnectionFactory;</span><br><span class="line">import org.springframework.amqp.rabbit.listener.SimpleMessageListenerContainer;</span><br><span class="line">import org.springframework.amqp.rabbit.listener.adapter.MessageListenerAdapter;</span><br><span class="line">import org.springframework.boot.SpringApplication;</span><br><span class="line">import org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootRabbitmqApplication &#123;</span><br><span class="line"></span><br><span class="line">	 final static String queueName &#x3D; &quot;spring-boot&quot;;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	Queue queue() &#123;</span><br><span class="line">		return new Queue(queueName, false);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	TopicExchange exchange() &#123;</span><br><span class="line">		return new TopicExchange(&quot;spring-boot-exchange&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	Binding binding(Queue queue, TopicExchange exchange) &#123;</span><br><span class="line">		return BindingBuilder.bind(queue).to(exchange).with(queueName);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	SimpleMessageListenerContainer container(ConnectionFactory connectionFactory,</span><br><span class="line">											 MessageListenerAdapter listenerAdapter) &#123;</span><br><span class="line">		SimpleMessageListenerContainer container &#x3D; new SimpleMessageListenerContainer();</span><br><span class="line">		container.setConnectionFactory(connectionFactory);</span><br><span class="line">		container.setQueueNames(queueName);</span><br><span class="line">		container.setMessageListener(listenerAdapter);</span><br><span class="line">		return container;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	MessageListenerAdapter listenerAdapter(Receiver receiver) &#123;</span><br><span class="line">		return new MessageListenerAdapter(receiver, &quot;receiveMessage&quot;);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringbootRabbitmqApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>创建一个测试方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Component</span><br><span class="line">public class Runner implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line">    private final RabbitTemplate rabbitTemplate;</span><br><span class="line">    private final Receiver receiver;</span><br><span class="line">    private final ConfigurableApplicationContext context;</span><br><span class="line"></span><br><span class="line">    public Runner(Receiver receiver, RabbitTemplate rabbitTemplate,</span><br><span class="line">            ConfigurableApplicationContext context) &#123;</span><br><span class="line">        this.receiver &#x3D; receiver;</span><br><span class="line">        this.rabbitTemplate &#x3D; rabbitTemplate;</span><br><span class="line">        this.context &#x3D; context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void run(String... args) throws Exception &#123;</span><br><span class="line">        System.out.println(&quot;Sending message...&quot;);</span><br><span class="line">        rabbitTemplate.convertAndSend(Application.queueName, &quot;Hello from RabbitMQ!&quot;);</span><br><span class="line">        receiver.getLatch().await(10000, TimeUnit.MILLISECONDS);</span><br><span class="line">        context.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动程序，你会发现控制台打印：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Sending message...</span><br><span class="line">Received &lt;Hello from RabbitMQ!&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>恭喜！你刚才已经学会了如何通过spring raabitmq去构建一个消息发送和订阅的程序。 这仅仅是一个好的开始，你可以通过spring-rabbitmq做更多的事，<a target="_blank" rel="noopener" href="http://docs.spring.io/spring-amqp/reference/html/_introduction.html#quick-tour">点击这里</a>。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/messaging-rabbitmq/">https://spring.io/guides/gs/messaging-rabbitmq/</a></p>
<h2 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h2><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第18篇：定时任务</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot18-scheduling/</url>
    <content><![CDATA[<p>这篇文章将介绍怎么通过spring去做调度任务。</p>
<span id="more"></span>

<h2 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h2><p>创建一个Springboot工程，在它的程序入口加上@EnableScheduling,开启调度任务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableScheduling</span><br><span class="line">public class SpringbootSchedulingTasksApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringbootSchedulingTasksApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建定时任务"><a href="#创建定时任务" class="headerlink" title="创建定时任务"></a>创建定时任务</h2><p>创建一个定时任务，每过5s在控制台打印当前时间。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class ScheduledTasks &#123;</span><br><span class="line"></span><br><span class="line">    private static final Logger log &#x3D; LoggerFactory.getLogger(ScheduledTasks.class);</span><br><span class="line"></span><br><span class="line">    private static final SimpleDateFormat dateFormat &#x3D; new SimpleDateFormat(&quot;HH:mm:ss&quot;);</span><br><span class="line"></span><br><span class="line">    @Scheduled(fixedRate &#x3D; 5000)</span><br><span class="line">    public void reportCurrentTime() &#123;</span><br><span class="line">        log.info(&quot;The time is now &#123;&#125;&quot;, dateFormat.format(new Date()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过在方法上加@Scheduled注解，表明该方法是一个调度任务。</p>
<ul>
<li>@Scheduled(fixedRate = 5000) ：上一次开始执行时间点之后5秒再执行</li>
<li>@Scheduled(fixedDelay = 5000) ：上一次执行完毕时间点之后5秒再执行</li>
<li>@Scheduled(initialDelay=1000, fixedRate=5000) ：第一次延迟1秒后执行，之后按fixedRate的规则每5秒执行一次</li>
<li>@Scheduled(cron=”  /5   “) ：通过cron表达式定义规则，什么是cro表达式，自行搜索引擎。</li>
</ul>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>启动springboot工程，控制台没过5s就打印出了当前的时间。</p>
<blockquote>
<p>2017-04-29 17:39:37.672  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:37<br>2017-04-29 17:39:42.671  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:42<br>2017-04-29 17:39:47.672  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:47<br>2017-04-29 17:39:52.675  INFO 677 — [pool-1-thread-1] com.forezp.task.ScheduledTasks           : The time is now 17:39:52</p>
</blockquote>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在springboot创建定时任务比较简单，只需2步：</p>
<ul>
<li>1.在程序的入口加上@EnableScheduling注解。</li>
<li>2.在定时方法上加@Scheduled注解。</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/scheduling-tasks/">https://spring.io/guides/gs/scheduling-tasks/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第19篇：验证表单信息</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot19/</url>
    <content><![CDATA[<p>这篇文篇主要简述如何在springboot中验证表单信息。在springmvc工程中，需要检查表单信息，表单信息验证主要通过注解的形式。</p>
<span id="more"></span>

<h2 id="构建工程"><a href="#构建工程" class="headerlink" title="构建工程"></a>构建工程</h2><p>创建一个springboot工程，由于用到了 web 、thymeleaf、validator、el，引入相应的起步依赖和依赖，代码清单如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependencies&gt; </span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.hibernate&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;hibernate-validator&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;tomcat-embed-el&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建一个PresonForm的Object类"><a href="#创建一个PresonForm的Object类" class="headerlink" title="创建一个PresonForm的Object类"></a>创建一个PresonForm的Object类</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.forezp.entity;</span><br><span class="line"></span><br><span class="line">import javax.validation.constraints.Min;</span><br><span class="line">import javax.validation.constraints.NotNull;</span><br><span class="line">import javax.validation.constraints.Size;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;19.</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class PersonForm &#123;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    @Size(min&#x3D;2, max&#x3D;30)</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    @NotNull</span><br><span class="line">    @Min(18)</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return this.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return &quot;Person(Name: &quot; + this.name + &quot;, Age: &quot; + this.age + &quot;)&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个实体类，在2个属性:name,age.它们各自有验证的注解：</p>
<ul>
<li>@Size(min=2, max=30) name的长度为2-30个字符</li>
<li>@NotNull 不为空</li>
<li>@Min(18)age不能小于18</li>
</ul>
<h2 id="创建-web-Controller"><a href="#创建-web-Controller" class="headerlink" title="创建 web Controller"></a>创建 web Controller</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Controller</span><br><span class="line">public class WebController extends WebMvcConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void addViewControllers(ViewControllerRegistry registry) &#123;</span><br><span class="line">        registry.addViewController(&quot;&#x2F;results&quot;).setViewName(&quot;results&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String showForm(PersonForm personForm) &#123;</span><br><span class="line">        return &quot;form&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @PostMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String checkPersonInfo(@Valid PersonForm personForm, BindingResult bindingResult) &#123;</span><br><span class="line"></span><br><span class="line">        if (bindingResult.hasErrors()) &#123;</span><br><span class="line">            return &quot;form&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return &quot;redirect:&#x2F;results&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建form表单"><a href="#创建form表单" class="headerlink" title="创建form表单"></a>创建form表单</h2><p>src/main/resources/templates/form.html:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;form action&#x3D;&quot;#&quot; th:action&#x3D;&quot;@&#123;&#x2F;&#125;&quot; th:object&#x3D;&quot;$&#123;personForm&#125;&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">            &lt;table&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;Name:&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; th:field&#x3D;&quot;*&#123;name&#125;&quot; &#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td th:if&#x3D;&quot;$&#123;#fields.hasErrors(&#39;name&#39;)&#125;&quot; th:errors&#x3D;&quot;*&#123;name&#125;&quot;&gt;Name Error&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;Age:&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td&gt;&lt;input type&#x3D;&quot;text&quot; th:field&#x3D;&quot;*&#123;age&#125;&quot; &#x2F;&gt;&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td th:if&#x3D;&quot;$&#123;#fields.hasErrors(&#39;age&#39;)&#125;&quot; th:errors&#x3D;&quot;*&#123;age&#125;&quot;&gt;Age Error&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;&lt;button type&#x3D;&quot;submit&quot;&gt;Submit&lt;&#x2F;button&gt;&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">            &lt;&#x2F;table&gt;</span><br><span class="line">        &lt;&#x2F;form&gt;</span><br><span class="line">    &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="注册成功的页面"><a href="#注册成功的页面" class="headerlink" title="注册成功的页面"></a>注册成功的页面</h2><p>src/main/resources/templates/results.html:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">html&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		Congratulations! You are old enough to sign up for this site.</span><br><span class="line">	&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h2><p>启动工程，访问<a target="_blank" rel="noopener" href="http://localhost:8080/%EF%BC%9A">http://localhost:8080/：</a></p>
<p><img src="https://spring.io/guides/gs/validating-form-input/images/valid-01.png"></p>
<p>如果你输入A和15，点击 submit:</p>
<p><img src="https://spring.io/guides/gs/validating-form-input/images/valid-02.png"></p>
<p><img src="https://spring.io/guides/gs/validating-form-input/images/valid-03.png"></p>
<p>如果name 输入N, age为空：</p>
<p><img src="https://spring.io/guides/gs/validating-form-input/images/valid-04.png"></p>
<p>如果输入：forezp. 18</p>
<p><img src="https://spring.io/guides/gs/validating-form-input/images/valid-05.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/validating-form-input/">https://spring.io/guides/gs/validating-form-input/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第2篇：配置文件详解</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot2-config-file/</url>
    <content><![CDATA[<p>springboot采纳了建立生产就绪Spring应用程序的观点。 Spring Boot优先于配置的惯例，旨在让您尽快启动和运行。在一般情况下，我们不需要做太多的配置就能够让spring boot正常运行。在一些特殊的情况下，我们需要做修改一些配置，或者需要有自己的配置属性。</p>
<span id="more"></span>

<h2 id="一、自定义属性"><a href="#一、自定义属性" class="headerlink" title="一、自定义属性"></a>一、自定义属性</h2><p>当我们创建一个springboot项目的时候，系统默认会为我们在src/main/java/resources目录下创建一个application.properties。个人习惯，我会将application.properties改为application.yml文件，两种文件格式都支持。</p>
<p>在application.yml自定义一组属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my:</span><br><span class="line"> name: forezp</span><br><span class="line"> age: 12</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果你需要读取配置文件的值只需要加@Value(“${属性名}”)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class MiyaController &#123;</span><br><span class="line"></span><br><span class="line">    @Value(&quot;$&#123;my.name&#125;&quot;)</span><br><span class="line">    private String name;</span><br><span class="line">    @Value(&quot;$&#123;my.age&#125;&quot;)</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;miya&quot;)</span><br><span class="line">    public String miya()&#123;</span><br><span class="line">        return name+&quot;:&quot;+age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>启动工程，访问：localhost:8080/miya,浏览器显示：</p>
<blockquote>
<p>forezp:12</p>
</blockquote>
<h2 id="二、将配置文件的属性赋给实体类"><a href="#二、将配置文件的属性赋给实体类" class="headerlink" title="二、将配置文件的属性赋给实体类"></a>二、将配置文件的属性赋给实体类</h2><p>当我们有很多配置属性的时候，这时我们会把这些属性作为字段来创建一个javabean，并将属性值赋予给他们,比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">my:</span><br><span class="line"> name: forezp</span><br><span class="line"> age: 12</span><br><span class="line"> number:  $&#123;random.int&#125;</span><br><span class="line"> uuid : $&#123;random.uuid&#125;</span><br><span class="line"> max: $&#123;random.int(10)&#125;</span><br><span class="line"> value: $&#123;random.value&#125;</span><br><span class="line"> greeting: hi,i&#39;m  $&#123;my.name&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其中配置文件中用到了${random} ，它可以用来生成各种不同类型的随机值。</p>
<p>怎么讲这些属性赋于给一个javabean 呢，首先创建一个javabean ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;my&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class ConfigBean &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line">    private int number;</span><br><span class="line">    private String uuid;</span><br><span class="line">    private int max;</span><br><span class="line">    private String value;</span><br><span class="line">    private String greeting;</span><br><span class="line">    </span><br><span class="line">    省略了getter setter....</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要加个注解@ConfigurationProperties，并加上它的prrfix。另外@Component可加可不加。另外spring-boot-configuration-processor依赖可加可不加，具体原因不详。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-configuration-processor&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外需要在应用类或者application类，加EnableConfigurationProperties注解。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@EnableConfigurationProperties(&#123;ConfigBean.class&#125;)</span><br><span class="line">public class LucyController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    ConfigBean configBean;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;lucy&quot;)</span><br><span class="line">    public String miya()&#123;</span><br><span class="line">        return configBean.getGreeting()+&quot; &gt;&gt;&gt;&gt;&quot;+configBean.getName()+&quot; &gt;&gt;&gt;&gt;&quot;+ configBean.getUuid()+&quot; &gt;&gt;&gt;&gt;&quot;+configBean.getMax();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动工程，访问localhost:8080/lucy,我们会发现配置文件信息读到了。</p>
<h2 id="三、自定义配置文件"><a href="#三、自定义配置文件" class="headerlink" title="三、自定义配置文件"></a>三、自定义配置文件</h2><p>上面介绍的是我们都把配置文件写到application.yml中。有时我们不愿意把配置都写到application配置文件中，这时需要我们自定义配置文件，比如test.properties:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.forezp.name&#x3D;forezp</span><br><span class="line">com.forezp.age&#x3D;12</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>怎么将这个配置文件信息赋予给一个javabean呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@PropertySource(value &#x3D; &quot;classpath:test.properties&quot;)</span><br><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;com.forezp&quot;)</span><br><span class="line">public class User &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在最新版本的springboot，需要加这三个注解。@Configuration<br>@PropertySource(value = “classpath:test.properties”)<br>@ConfigurationProperties(prefix = “com.forezp”);在1.4版本需要<br>PropertySource加上location。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@EnableConfigurationProperties(&#123;ConfigBean.class,User.class&#125;)</span><br><span class="line">public class LucyController &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    ConfigBean configBean;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;lucy&quot;)</span><br><span class="line">    public String miya()&#123;</span><br><span class="line">        return configBean.getGreeting()+&quot; &gt;&gt;&gt;&gt;&quot;+configBean.getName()+&quot; &gt;&gt;&gt;&gt;&quot;+ configBean.getUuid()+&quot; &gt;&gt;&gt;&gt;&quot;+configBean.getMax();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    User user;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;user&quot;)</span><br><span class="line">    public String user()&#123;</span><br><span class="line">        return user.getName()+user.getAge();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动工程，打开localhost:8080/user;浏览器会显示：</p>
<blockquote>
<p>forezp12</p>
</blockquote>
<h2 id="四、多个环境配置文件"><a href="#四、多个环境配置文件" class="headerlink" title="四、多个环境配置文件"></a>四、多个环境配置文件</h2><p>在现实的开发环境中，我们需要不同的配置环境；格式为application-{profile}.properties，其中{profile}对应你的环境标识，比如：</p>
<ul>
<li>application-test.properties：测试环境</li>
<li>application-dev.properties：开发环境</li>
<li>application-prod.properties：生产环境</li>
</ul>
<p>怎么使用？只需要我们在application.yml中加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line"> profiles:</span><br><span class="line">   active: dev</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 其中application-dev.yml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line"> port: 8082</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  启动工程，发现程序的端口不再是8080,而是8082。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p>  <a target="_blank" rel="noopener" href="https://www.gitbook.com/book/qbgbook/spring-boot-reference-guide-zh/details">spring-boot-reference-guide-zh</a></p>
<p>  <a target="_blank" rel="noopener" href="http://tengj.top/2017/02/28/springboot2/">pring Boot干货系列：（二）配置文件解析</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.didispace.com/springbootproperties/">Spring Boot属性配置文件详解</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第24篇：整合docker</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot24-docker/</url>
    <content><![CDATA[<p>这篇文篇介绍，怎么为 springboot程序构建一个docker镜像。docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从Apache2.0协议开源。Docker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。</p>
<span id="more"></span>
<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>环境：</p>
<ul>
<li>linux环境或mac,不要用windows</li>
<li>jdk 8</li>
<li>maven 3.0</li>
<li>docker</li>
</ul>
<p>对docker一无所知的看<a target="_blank" rel="noopener" href="http://www.runoob.com/docker/docker-tutorial.html">docker教程</a>。</p>
<h2 id="创建一个springboot工程"><a href="#创建一个springboot工程" class="headerlink" title="创建一个springboot工程"></a>创建一个springboot工程</h2><p>引入web的起步依赖，创建一个 Controler:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line">public class SpringbootWithDockerApplication &#123;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;&#x2F;&quot;)</span><br><span class="line">	public String home() &#123;</span><br><span class="line">		return &quot;Hello Docker World&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringbootWithDockerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="将springboot工程容器化"><a href="#将springboot工程容器化" class="headerlink" title="将springboot工程容器化"></a>将springboot工程容器化</h2><p>Docker有一个简单的<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">dockerfile</a>文件作为指定镜像的图层。让我们先创建一个 dockerFile文件：</p>
<p>src/main/docker/Dockerfile:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM frolvlad&#x2F;alpine-oraclejdk8:slim</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD springboot-with-docker-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">RUN sh -c &#39;touch &#x2F;app.jar&#39;</span><br><span class="line">ENV JAVA_OPTS&#x3D;&quot;&quot;</span><br><span class="line">ENTRYPOINT [ &quot;sh&quot;, &quot;-c&quot;, &quot;java $JAVA_OPTS -Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom -jar &#x2F;app.jar&quot; ]</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>我们通过maven 构建docker镜像。</p>
<p>在maven的pom目录，加上docker镜像构建的插件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span><br><span class="line">   &lt;docker.image.prefix&gt;springio&lt;&#x2F;docker.image.prefix&gt;</span><br><span class="line">&lt;&#x2F;properties&gt;</span><br><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;docker-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">            &lt;version&gt;0.4.11&lt;&#x2F;version&gt;</span><br><span class="line">            &lt;configuration&gt;</span><br><span class="line">                &lt;imageName&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;imageName&gt;</span><br><span class="line">                &lt;dockerDirectory&gt;src&#x2F;main&#x2F;docker&lt;&#x2F;dockerDirectory&gt;</span><br><span class="line">                &lt;resources&gt;</span><br><span class="line">                    &lt;resource&gt;</span><br><span class="line">                        &lt;targetPath&gt;&#x2F;&lt;&#x2F;targetPath&gt;</span><br><span class="line">                        &lt;directory&gt;$&#123;project.build.directory&#125;&lt;&#x2F;directory&gt;</span><br><span class="line">                        &lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;include&gt;</span><br><span class="line">                    &lt;&#x2F;resource&gt;</span><br><span class="line">                &lt;&#x2F;resources&gt;</span><br><span class="line">            &lt;&#x2F;configuration&gt;</span><br><span class="line">        &lt;&#x2F;plugin&gt;</span><br><span class="line">    &lt;&#x2F;plugins&gt;</span><br><span class="line">&lt;&#x2F;build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意：${docker.image.prefix} 为你在 docker官方仓库的用户名，如果你不需要上传镜像，随便填。</p>
<p>通过maven 命令：</p>
<p>第一步：mvn clean</p>
<p>第二步： mvn package docker:bulid ,如下：</p>
<blockquote>
<p>Step 2/6 : VOLUME /tmp<br> —&gt; Running in a98be3878053<br> —&gt; 8286e98b54c5<br>Removing intermediate container a98be3878053<br>Step 3/6 : ADD springboot-with-docker-0.0.1-SNAPSHOT.jar app.jar<br> —&gt; c6ce13e50bbd<br>Removing intermediate container a303a3058869<br>Step 4/6 : RUN sh -c ‘touch /app.jar’<br> —&gt; Running in cf231afe700e<br> —&gt; 9a0ec8936c00<br>Removing intermediate container cf231afe700e<br>Step 5/6 : ENV JAVA_OPTS “”<br> —&gt; Running in e192597fc881<br> —&gt; 2cb0d73bbdb0<br>Removing intermediate container e192597fc881<br>Step 6/6 : ENTRYPOINT sh -c java $JAVA_OPTS -Djava.security.egd=file:/dev/./urandom -jar /app.jar<br> —&gt; Running in ab85f53fcdd8<br> —&gt; 60fdb5c61692<br>Removing intermediate container ab85f53fcdd8<br>Successfully built 60fdb5c61692<br>[INFO] Built forezp/springboot-with-docker<br>[INFO] ————————————————————————<br>[INFO] BUILD SUCCESS<br>[INFO] ————————————————————————<br>[INFO] Total time: 01:45 min<br>[INFO] Finished at: 2017-04-19T05:37:44-07:00<br>[INFO] Final Memory: 19M/48M<br>[INFO] ————————————————————————</p>
</blockquote>
<p>镜像构建成功。查看镜像：</p>
<blockquote>
<p>docker images</p>
</blockquote>
<p>显示：</p>
<blockquote>
<p>forezp/springboot-with-docker   latest              60fdb5c61692        About a minute ago   195 MB</p>
</blockquote>
<p>启动镜像：</p>
<blockquote>
<p>$ docker run -p 8080:8080 -t forezp/springboot-with-docker</p>
</blockquote>
<p>打开浏览器访问  localhost:8080;浏览器显示：Hello Docker World。<br>说明docker 的springboot工程已部署。</p>
<p>停止镜像：</p>
<blockquote>
<p>docker stop 60fdb5c61692</p>
</blockquote>
<p>删除镜像：</p>
<blockquote>
<p>docker rm 60fdb5c61692</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/)</a>)</p>
<p><a target="_blank" rel="noopener" href="http://www.runoob.com/docker/docker-tutorial.html">http://www.runoob.com/docker/docker-tutorial.html</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第25篇：2小时学会spring boot</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot25-2hour/</url>
    <content><![CDATA[<h3 id="一-什么是spring-boot"><a href="#一-什么是spring-boot" class="headerlink" title="一.什么是spring boot"></a>一.什么是spring boot</h3><blockquote>
<p>Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible.</p>
<p>  摘自官网</p>
<p>翻译：采纳了建立生产就绪Spring应用程序的观点。 Spring Boot优先于配置的惯例，旨在让您尽快启动和运行。</p>
</blockquote>
<span id="more"></span>


<p>spring boot 致力于简洁，让开发者写更少的配置，程序能够更快的运行和启动。它是下一代javaweb框架，并且它是spring cloud（微服务）的基础。</p>
<h3 id="二、搭建第一个sping-boot-程序"><a href="#二、搭建第一个sping-boot-程序" class="headerlink" title="二、搭建第一个sping  boot 程序"></a>二、搭建第一个sping  boot 程序</h3><p>可以在start.spring.io上建项目，也可以用idea构建。本案列采用idea.</p>
<p>具体步骤：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new prpject -&gt; spring initializr -&gt;&#123;name :firstspringboot , type: mavenproject,packaging:jar ,..&#125;  -&gt;&#123;spring version :1.5.2  web: web &#125; -&gt; ....</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>应用创建成功后，会生成相应的目录和文件。</p>
<p>其中有一个Application类,它是程序的入口:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class FirstspringbootApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(FirstspringbootApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在resources文件下下又一个application.yml文件，它是程序的配置文件。默认为空，写点配置 ,程序的端口为8080,context-path为  /springboot：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">  context-path: &#x2F;springboot</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写一个HelloController：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController     &#x2F;&#x2F;等同于同时加上了@Controller和@ResponseBody</span><br><span class="line">public class HelloController &#123;</span><br><span class="line">   </span><br><span class="line">    &#x2F;&#x2F;访问&#x2F;hello或者&#x2F;hi任何一个地址，都会返回一样的结果</span><br><span class="line">    @RequestMapping(value &#x3D; &#123;&quot;&#x2F;hello&quot;,&quot;&#x2F;hi&quot;&#125;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public String say()&#123;</span><br><span class="line">        return &quot;hi you!!!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行 Application的main(),呈现会启动，由于springboot自动内置了servlet容器，所以不需要类似传统的方式，先部署到容器再启动容器。只需要运行main()即可，这时打开浏览器输入网址：localhost:8080/springboot/hi  ，就可以在浏览器上看到: <em>hi you!!!</em></p>
<h3 id="三-属性配置"><a href="#三-属性配置" class="headerlink" title="三.属性配置"></a>三.属性配置</h3><p>在appliction.yml文件添加属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8080</span><br><span class="line">  context-path: &#x2F;springboot</span><br><span class="line"></span><br><span class="line">girl:</span><br><span class="line">  name: B</span><br><span class="line">  age: 18</span><br><span class="line">  content: content:$&#123;name&#125;,age:$&#123;age&#125;</span><br><span class="line">  </span><br></pre></td></tr></table></figure>
<p>在java文件中，获取name属性，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Value(&quot;$&#123;name&#125;&quot;)</span><br><span class="line"> private String name;</span><br></pre></td></tr></table></figure>

<p>也可以通过ConfigurationProperties注解，将属性注入到bean中，通过Component注解将bean注解到spring容器中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix&#x3D;&quot;girl&quot;)</span><br><span class="line">@Component</span><br><span class="line">public class GirlProperties &#123;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    public String getName() &#123;</span><br><span class="line">        return name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name &#x3D; name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(int age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>另外可以通过配置文件制定不同环境的配置文，具体见源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="四-通过jpa方式操作数据库"><a href="#四-通过jpa方式操作数据库" class="headerlink" title="四.通过jpa方式操作数据库"></a>四.通过jpa方式操作数据库</h3><p>导入jar ，在pom.xml中添加依赖:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在appilication.yml中添加数据库配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  profiles:</span><br><span class="line">    active: prod</span><br><span class="line">    </span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;dbgirl?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;characterSetResults&#x3D;utf8</span><br><span class="line">    username: root</span><br><span class="line">    password: 123</span><br><span class="line"></span><br><span class="line">  jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: create</span><br><span class="line">    show-sql: true</span><br></pre></td></tr></table></figure>

<p>这些都是数据库常见的一些配置没什么可说的，其中ddl_auto: create 代表在数据库创建表，update 代表更新，首次启动需要create ,如果你想通过hibernate 注解的方式创建数据库的表的话，之后需要改为 update.</p>
<p>创建一个实体girl，这是基于hibernate的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Girl &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private Integer id;</span><br><span class="line">    private String cupSize;</span><br><span class="line">    private Integer age;</span><br><span class="line"></span><br><span class="line">    public Girl() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getId() &#123;</span><br><span class="line">        return id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setId(Integer id) &#123;</span><br><span class="line">        this.id &#x3D; id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Integer getAge() &#123;</span><br><span class="line">        return age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setAge(Integer age) &#123;</span><br><span class="line">        this.age &#x3D; age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getCupSize() &#123;</span><br><span class="line">        return cupSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setCupSize(String cupSize) &#123;</span><br><span class="line">        this.cupSize &#x3D; cupSize;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建Dao接口, springboot 将接口类会自动注解到spring容器中，不需要我吗做任何配置，只需要继承JpaRepository 即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;其中第二个参数为Id的类型</span><br><span class="line">public interface GirlRep extends JpaRepository&lt;Girl,Integer&gt;&#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<p>创建一个GirlController，写一个获取所有girl的api和添加girl的api ，自己跑一下就可以了:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">public class GirlController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private GirlRep girlRep;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 查询所有女生列表</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;girls&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public List&lt;Girl&gt; getGirlList()&#123;</span><br><span class="line">        return girlRep.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 添加一个女生</span><br><span class="line">     * @param cupSize</span><br><span class="line">     * @param age</span><br><span class="line">     * @return</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;girls&quot;,method &#x3D; RequestMethod.POST)</span><br><span class="line">    public Girl addGirl(@RequestParam(&quot;cupSize&quot;) String cupSize,</span><br><span class="line">                        @RequestParam(&quot;age&quot;) Integer age)&#123;</span><br><span class="line">        Girl girl &#x3D; new Girl();</span><br><span class="line">        girl.setAge(age);</span><br><span class="line">        girl.setCupSize(cupSize);</span><br><span class="line">        return girlRep.save(girl);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>

<p>如果需要事务的话，在service层加@Transaction注解即可。已经凌晨了，我要睡了.</p>
<p>源码；<a target="_blank" rel="noopener" href="http://download.csdn.net/detail/forezp/9778235">http://download.csdn.net/detail/forezp/9778235</a></p>
<p>关注我的专栏《史上最简单的 SpringCloud 教程 》<a target="_blank" rel="noopener" href="http://blog.csdn.net/column/details/15197.html">http://blog.csdn.net/column/details/15197.html</a></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第3篇：JDBCTemplate</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot3-JdbcTemplates-Mysql/</url>
    <content><![CDATA[<p>本文介绍springboot通过jdbc访问关系型mysql,通过spring的JdbcTemplate去访问。</p>
<span id="more"></span>


<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li>jdk 1.8</li>
<li>maven 3.0</li>
<li>idea</li>
<li>mysql</li>
</ul>
<p>初始化mysql:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- create table &#96;account&#96;</span><br><span class="line">DROP TABLE &#96;account&#96; IF EXISTS</span><br><span class="line">CREATE TABLE &#96;account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(20) NOT NULL,</span><br><span class="line">  &#96;money&#96; double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;1&#39;, &#39;aaa&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;2&#39;, &#39;bbb&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;3&#39;, &#39;ccc&#39;, &#39;1000&#39;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="创建工程"><a href="#创建工程" class="headerlink" title="创建工程"></a>创建工程</h2><h3 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h3><p>在pom文件引入spring-boot-starter-jdbc的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>引入mysql连接类和连接池：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;1.0.29&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>开启web:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="配置相关文件"><a href="#配置相关文件" class="headerlink" title="配置相关文件"></a>配置相关文件</h3><p>在application.properties文件配置mysql的驱动类，数据库地址，数据库账号、密码信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.jdbc.Driver</span><br><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test</span><br><span class="line">spring.datasource.username&#x3D;root</span><br><span class="line">spring.datasource.password&#x3D;123456</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过引入这些依赖和配置一些基本信息，springboot就可以访问数据库类。</p>
<h2 id="具体编码"><a href="#具体编码" class="headerlink" title="具体编码"></a>具体编码</h2><h3 id="实体类"><a href="#实体类" class="headerlink" title="实体类"></a>实体类</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">    private int id ;</span><br><span class="line">    private String name ;</span><br><span class="line">    private double money;</span><br><span class="line"></span><br><span class="line">....省略了getter. setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="dao层"><a href="#dao层" class="headerlink" title="dao层"></a>dao层</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountDAO &#123;</span><br><span class="line">    int add(Account account);</span><br><span class="line"></span><br><span class="line">    int update(Account account);</span><br><span class="line"></span><br><span class="line">    int delete(int id);</span><br><span class="line"></span><br><span class="line">    Account findAccountById(int id);</span><br><span class="line"></span><br><span class="line">    List&lt;Account&gt; findAccountList();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体的实现类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.forezp.dao.impl;</span><br><span class="line"></span><br><span class="line">import com.forezp.dao.IAccountDAO;</span><br><span class="line">import com.forezp.entity.Account;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.jdbc.core.BeanPropertyRowMapper;</span><br><span class="line">import org.springframework.jdbc.core.JdbcTemplate;</span><br><span class="line">import org.springframework.stereotype.Repository;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;20.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Repository</span><br><span class="line">public class AccountDaoImpl implements IAccountDAO &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private JdbcTemplate jdbcTemplate;</span><br><span class="line">    @Override</span><br><span class="line">    public int add(Account account) &#123;</span><br><span class="line">        return jdbcTemplate.update(&quot;insert into account(name, money) values(?, ?)&quot;,</span><br><span class="line">              account.getName(),account.getMoney());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int update(Account account) &#123;</span><br><span class="line">        return jdbcTemplate.update(&quot;UPDATE  account SET NAME&#x3D;? ,money&#x3D;? WHERE id&#x3D;?&quot;,</span><br><span class="line">                account.getName(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int delete(int id) &#123;</span><br><span class="line">        return jdbcTemplate.update(&quot;DELETE from TABLE account where id&#x3D;?&quot;,id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Account findAccountById(int id) &#123;</span><br><span class="line">        List&lt;Account&gt; list &#x3D; jdbcTemplate.query(&quot;select * from account where id &#x3D; ?&quot;, new Object[]&#123;id&#125;, new BeanPropertyRowMapper(Account.class));</span><br><span class="line">        if(list!&#x3D;null &amp;&amp; list.size()&gt;0)&#123;</span><br><span class="line">            Account account &#x3D; list.get(0);</span><br><span class="line">            return account;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Account&gt; findAccountList() &#123;</span><br><span class="line">        List&lt;Account&gt; list &#x3D; jdbcTemplate.query(&quot;select * from account&quot;, new Object[]&#123;&#125;, new BeanPropertyRowMapper(Account.class));</span><br><span class="line">        if(list!&#x3D;null &amp;&amp; list.size()&gt;0)&#123;</span><br><span class="line">            return list;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="service层"><a href="#service层" class="headerlink" title="service层"></a>service层</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IAccountService &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    int add(Account account);</span><br><span class="line"></span><br><span class="line">    int update(Account account);</span><br><span class="line"></span><br><span class="line">    int delete(int id);</span><br><span class="line"></span><br><span class="line">    Account findAccountById(int id);</span><br><span class="line"></span><br><span class="line">    List&lt;Account&gt; findAccountList();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>具体实现类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class AccountService implements IAccountService &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    IAccountDAO accountDAO;</span><br><span class="line">    @Override</span><br><span class="line">    public int add(Account account) &#123;</span><br><span class="line">        return accountDAO.add(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int update(Account account) &#123;</span><br><span class="line">        return accountDAO.update(account);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int delete(int id) &#123;</span><br><span class="line">        return accountDAO.delete(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Account findAccountById(int id) &#123;</span><br><span class="line">        return accountDAO.findAccountById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public List&lt;Account&gt; findAccountList() &#123;</span><br><span class="line">        return accountDAO.findAccountList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="构建一组restful-api来展示"><a href="#构建一组restful-api来展示" class="headerlink" title="构建一组restful api来展示"></a>构建一组restful api来展示</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.forezp.web;</span><br><span class="line"></span><br><span class="line">import com.forezp.entity.Account;</span><br><span class="line">import com.forezp.service.IAccountService;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line"></span><br><span class="line">import java.util.List;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;20.</span><br><span class="line"> *&#x2F;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    IAccountService accountService;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;list&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public  List&lt;Account&gt; getAccounts()&#123;</span><br><span class="line">       return accountService.findAccountList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public  Account getAccountById(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">        return accountService.findAccountById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;,method &#x3D; RequestMethod.PUT)</span><br><span class="line">    public  String updateAccount(@PathVariable(&quot;id&quot;)int id , @RequestParam(value &#x3D; &quot;name&quot;,required &#x3D; true)String name,</span><br><span class="line">    @RequestParam(value &#x3D; &quot;money&quot; ,required &#x3D; true)double money)&#123;</span><br><span class="line">        Account account&#x3D;new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        account.setId(id);</span><br><span class="line">        int t&#x3D;accountService.update(account);</span><br><span class="line">        if(t&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return account.toString();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&quot;,method &#x3D; RequestMethod.POST)</span><br><span class="line">    public  String postAccount( @RequestParam(value &#x3D; &quot;name&quot;)String name,</span><br><span class="line">                                 @RequestParam(value &#x3D; &quot;money&quot; )double money)&#123;</span><br><span class="line">        Account account&#x3D;new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        int t&#x3D; accountService.add(account);</span><br><span class="line">        if(t&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return account.toString();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>可以通过postman来测试，具体的我已经全部测试通过，没有任何问题。注意restful构建api的风格。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/relational-data-access/">relational-data-access</a></p>
<h2 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h2><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第4篇：JPA</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot4-jpaJ/</url>
    <content><![CDATA[<p>JPA全称Java Persistence API.JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。</p>
<p>JPA 的目标之一是制定一个可以由很多供应商实现的API，并且开发人员可以编码来实现该API，而不是使用私有供应商特有的API。</p>
<span id="more"></span>

<p>JPA是需要Provider来实现其功能的，Hibernate就是JPA Provider中很强的一个，应该说无人能出其右。从功能上来说，JPA就是Hibernate功能的一个子集。</p>
<h2 id="添加相关依赖"><a href="#添加相关依赖" class="headerlink" title="添加相关依赖"></a>添加相关依赖</h2><p>添加spring-boot-starter-jdbc依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-jpa</span><br><span class="line">			&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>添加mysql连接类和连接池类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">		&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;scope&gt;runtime&lt;&#x2F;scope&gt;</span><br><span class="line">	&lt;&#x2F;dependency&gt; </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置数据源，在application-properties文件配置："><a href="#配置数据源，在application-properties文件配置：" class="headerlink" title="配置数据源，在application.properties文件配置："></a>配置数据源，在application.properties文件配置：</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    driver-class-name: com.mysql.jdbc.Driver</span><br><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;test?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;characterSetResults&#x3D;utf8</span><br><span class="line">    username: root</span><br><span class="line">    password: 123456</span><br><span class="line"></span><br><span class="line">  jpa:</span><br><span class="line">    hibernate:</span><br><span class="line">      ddl-auto: update  # 第一次简表create  后面用update</span><br><span class="line">    show-sql: true</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>注意，如果通过jpa在数据库中建表，将jpa.hibernate,ddl-auto改为create，建完表之后，要改为update,要不然每次重启工程会删除表并新建。</p>
<h2 id="创建实体类"><a href="#创建实体类" class="headerlink" title="创建实体类"></a>创建实体类</h2><p>通过@Entity 表明是一个映射的实体类，  @Id表明id， @GeneratedValue 字段自动生成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Entity</span><br><span class="line">public class Account &#123;</span><br><span class="line">    @Id</span><br><span class="line">    @GeneratedValue</span><br><span class="line">    private int id ;</span><br><span class="line">    private String name ;</span><br><span class="line">    private double money;</span><br><span class="line"></span><br><span class="line">...  省略getter setter</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Dao层"><a href="#Dao层" class="headerlink" title="Dao层"></a>Dao层</h2><p>数据访问层，通过编写一个继承自 JpaRepository 的接口就能完成数据访问,其中包含了几本的单表查询的方法，非常的方便。值得注意的是，这个Account 对象名，而不是具体的表名，另外Interger是主键的类型，一般为Integer或者Long</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AccountDao  extends JpaRepository&lt;Account,Integer&gt; &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Web层"><a href="#Web层" class="headerlink" title="Web层"></a>Web层</h2><p>在这个栗子中我简略了service层的书写，在实际开发中，不可省略。新写一个controller，写几个restful api来测试数据的访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;list&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public List&lt;Account&gt; getAccounts() &#123;</span><br><span class="line">        return accountDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.GET)</span><br><span class="line">    public Account getAccountById(@PathVariable(&quot;id&quot;) int id) &#123;</span><br><span class="line">        return accountDao.findOne(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;, method &#x3D; RequestMethod.PUT)</span><br><span class="line">    public String updateAccount(@PathVariable(&quot;id&quot;) int id, @RequestParam(value &#x3D; &quot;name&quot;, required &#x3D; true) String name,</span><br><span class="line">                                @RequestParam(value &#x3D; &quot;money&quot;, required &#x3D; true) double money) &#123;</span><br><span class="line">        Account account &#x3D; new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        account.setId(id);</span><br><span class="line">        Account account1 &#x3D; accountDao.saveAndFlush(account);</span><br><span class="line"></span><br><span class="line">        return account1.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&quot;, method &#x3D; RequestMethod.POST)</span><br><span class="line">    public String postAccount(@RequestParam(value &#x3D; &quot;name&quot;) String name,</span><br><span class="line">                              @RequestParam(value &#x3D; &quot;money&quot;) double money) &#123;</span><br><span class="line">        Account account &#x3D; new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        Account account1 &#x3D; accountDao.save(account);</span><br><span class="line">        return account1.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过postman请求测试，代码已经全部通过测试。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/accessing-data-jpa/">accessing-data-jpa</a></p>
<h2 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h2><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第5篇：beatsql</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot5-beatlsql/</url>
    <content><![CDATA[<p>BeetSql是一个全功能DAO工具， 同时具有Hibernate 优点 &amp; Mybatis优点功能，适用于承认以SQL为中心，同时又需求工具能自动能生成大量常用的SQL的应用。</p>
<span id="more"></span>


<h2 id="beatlsql-优点"><a href="#beatlsql-优点" class="headerlink" title="beatlsql 优点"></a>beatlsql 优点</h2><ul>
<li><p>开发效率</p>
<ul>
<li>无需注解，自动使用大量内置SQL，轻易完成增删改查功能，节省50%的开发工作量</li>
<li>数据模型支持Pojo，也支持Map/List这种快速模型，也支持混合模型</li>
<li>SQL 模板基于Beetl实现，更容易写和调试，以及扩展</li>
</ul>
</li>
<li><p>维护性</p>
<ul>
<li>SQL 以更简洁的方式，Markdown方式集中管理，同时方便程序开发和数据库SQL调试。</li>
<li>可以自动将sql文件映射为dao接口类</li>
<li>灵活直观的支持支持一对一，一对多，多对多关系映射而不引入复杂的OR Mapping概念和技术。</li>
<li>具备Interceptor功能，可以调试，性能诊断SQL，以及扩展其他功能</li>
</ul>
</li>
<li><p>其他</p>
<ul>
<li>内置支持主从数据库支持的开源工具</li>
<li>支持跨数据库平台，开发者所需工作减少到最小，目前跨数据库支持mysql,postgres,oracle,sqlserver,h2,sqllite,DB2.</li>
</ul>
</li>
</ul>
<h2 id="引入依赖"><a href="#引入依赖" class="headerlink" title="引入依赖"></a>引入依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;optional&gt;true&lt;&#x2F;optional&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.ibeetl&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;beetl&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.3.2&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;com.ibeetl&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;beetlsql&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;2.3.1&lt;&#x2F;version&gt;</span><br><span class="line"></span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;version&gt;5.0.5&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>这几个依赖都是必须的。</p>
<h2 id="整合阶段"><a href="#整合阶段" class="headerlink" title="整合阶段"></a>整合阶段</h2><p>由于springboot没有对 beatlsql的快速启动装配，所以需要我自己导入相关的bean，包括数据源，包扫描，事物管理器等。</p>
<p>在application加入以下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@Bean(initMethod &#x3D; &quot;init&quot;, name &#x3D; &quot;beetlConfig&quot;)</span><br><span class="line">	public BeetlGroupUtilConfiguration getBeetlGroupUtilConfiguration() &#123;</span><br><span class="line">		BeetlGroupUtilConfiguration beetlGroupUtilConfiguration &#x3D; new BeetlGroupUtilConfiguration();</span><br><span class="line">		ResourcePatternResolver patternResolver &#x3D; ResourcePatternUtils.getResourcePatternResolver(new DefaultResourceLoader());</span><br><span class="line">		try &#123;</span><br><span class="line">			&#x2F;&#x2F; WebAppResourceLoader 配置root路径是关键</span><br><span class="line">			WebAppResourceLoader webAppResourceLoader &#x3D; new WebAppResourceLoader(patternResolver.getResource(&quot;classpath:&#x2F;templates&quot;).getFile().getPath());</span><br><span class="line">			beetlGroupUtilConfiguration.setResourceLoader(webAppResourceLoader);</span><br><span class="line">		&#125; catch (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">		&#x2F;&#x2F;读取配置文件信息</span><br><span class="line">		return beetlGroupUtilConfiguration;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean(name &#x3D; &quot;beetlViewResolver&quot;)</span><br><span class="line">	public BeetlSpringViewResolver getBeetlSpringViewResolver(@Qualifier(&quot;beetlConfig&quot;) BeetlGroupUtilConfiguration beetlGroupUtilConfiguration) &#123;</span><br><span class="line">		BeetlSpringViewResolver beetlSpringViewResolver &#x3D; new BeetlSpringViewResolver();</span><br><span class="line">		beetlSpringViewResolver.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br><span class="line">		beetlSpringViewResolver.setOrder(0);</span><br><span class="line">		beetlSpringViewResolver.setConfig(beetlGroupUtilConfiguration);</span><br><span class="line">		return beetlSpringViewResolver;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;配置包扫描</span><br><span class="line">	@Bean(name &#x3D; &quot;beetlSqlScannerConfigurer&quot;)</span><br><span class="line">	public BeetlSqlScannerConfigurer getBeetlSqlScannerConfigurer() &#123;</span><br><span class="line">		BeetlSqlScannerConfigurer conf &#x3D; new BeetlSqlScannerConfigurer();</span><br><span class="line">		conf.setBasePackage(&quot;com.forezp.dao&quot;);</span><br><span class="line">		conf.setDaoSuffix(&quot;Dao&quot;);</span><br><span class="line">		conf.setSqlManagerFactoryBeanName(&quot;sqlManagerFactoryBean&quot;);</span><br><span class="line">		return conf;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean(name &#x3D; &quot;sqlManagerFactoryBean&quot;)</span><br><span class="line">	@Primary</span><br><span class="line">	public SqlManagerFactoryBean getSqlManagerFactoryBean(@Qualifier(&quot;datasource&quot;) DataSource datasource) &#123;</span><br><span class="line">		SqlManagerFactoryBean factory &#x3D; new SqlManagerFactoryBean();</span><br><span class="line"></span><br><span class="line">		BeetlSqlDataSource source &#x3D; new BeetlSqlDataSource();</span><br><span class="line">		source.setMasterSource(datasource);</span><br><span class="line">		factory.setCs(source);</span><br><span class="line">		factory.setDbStyle(new MySqlStyle());</span><br><span class="line">		factory.setInterceptors(new Interceptor[]&#123;new DebugInterceptor()&#125;);</span><br><span class="line">		factory.setNc(new UnderlinedNameConversion());&#x2F;&#x2F;开启驼峰</span><br><span class="line">		factory.setSqlLoader(new ClasspathLoader(&quot;&#x2F;sql&quot;));&#x2F;&#x2F;sql文件路径</span><br><span class="line">		return factory;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;配置数据库</span><br><span class="line">	@Bean(name &#x3D; &quot;datasource&quot;)</span><br><span class="line">	public DataSource getDataSource() &#123;</span><br><span class="line">		return DataSourceBuilder.create().url(&quot;jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;test&quot;).username(&quot;root&quot;).password(&quot;123456&quot;).build();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	&#x2F;&#x2F;开启事务</span><br><span class="line">	@Bean(name &#x3D; &quot;txManager&quot;)</span><br><span class="line">	public DataSourceTransactionManager getDataSourceTransactionManager(@Qualifier(&quot;datasource&quot;) DataSource datasource) &#123;</span><br><span class="line">		DataSourceTransactionManager dsm &#x3D; new DataSourceTransactionManager();</span><br><span class="line">		dsm.setDataSource(datasource);</span><br><span class="line">		return dsm;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>在resouces包下，加META_INF文件夹，文件夹中加入spring-devtools.properties:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">restart.include.beetl&#x3D;&#x2F;beetl-2.3.2.jar</span><br><span class="line">restart.include.beetlsql&#x3D;&#x2F;beetlsql-2.3.1.jar</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在templates下加一个index.btl文件。</p>
<p>加入jar和配置beatlsql的这些bean，以及resources这些配置之后，springboot就能够访问到数据库类。</p>
<h2 id="举个restful的栗子"><a href="#举个restful的栗子" class="headerlink" title="举个restful的栗子"></a>举个restful的栗子</h2><h3 id="初始化数据库的表"><a href="#初始化数据库的表" class="headerlink" title="初始化数据库的表"></a>初始化数据库的表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># DROP TABLE &#96;account&#96; IF EXISTS</span><br><span class="line">CREATE TABLE &#96;account&#96; (</span><br><span class="line">  &#96;id&#96; int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  &#96;name&#96; varchar(20) NOT NULL,</span><br><span class="line">  &#96;money&#96; double DEFAULT NULL,</span><br><span class="line">  PRIMARY KEY (&#96;id&#96;)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;4 DEFAULT CHARSET&#x3D;utf8;</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;1&#39;, &#39;aaa&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;2&#39;, &#39;bbb&#39;, &#39;1000&#39;);</span><br><span class="line">INSERT INTO &#96;account&#96; VALUES (&#39;3&#39;, &#39;ccc&#39;, &#39;1000&#39;);</span><br></pre></td></tr></table></figure>

<h3 id="bean"><a href="#bean" class="headerlink" title="bean"></a>bean</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Account &#123;</span><br><span class="line">    private int id ;</span><br><span class="line">    private String name ;</span><br><span class="line">    private double money;</span><br><span class="line"></span><br><span class="line">    getter...</span><br><span class="line">    </span><br><span class="line">    setter...</span><br><span class="line">    </span><br><span class="line">  &#125;  </span><br></pre></td></tr></table></figure>

<h3 id="数据访问dao层"><a href="#数据访问dao层" class="headerlink" title="数据访问dao层"></a>数据访问dao层</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AccountDao extends BaseMapper&lt;Account&gt; &#123;</span><br><span class="line"></span><br><span class="line">    @SqlStatement(params &#x3D; &quot;name&quot;)</span><br><span class="line">    Account selectAccountByName(String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>接口继承BaseMapper，就能获取单表查询的一些性质，当你需要自定义sql的时候，只需要在resouses/sql/account.md文件下书写文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">selectAccountByName</span><br><span class="line">&#x3D;&#x3D;&#x3D;</span><br><span class="line">*根据name获account</span><br><span class="line"></span><br><span class="line">    select * from account where name&#x3D; #name#</span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure>

<p>其中“=== ”上面是唯一标识，对应于接口的方法名，“* ”后面是注释，在下面就是自定义的sql语句，具体的见官方文档。</p>
<h3 id="web层"><a href="#web层" class="headerlink" title="web层"></a>web层</h3><p>这里省略了service层，实际开发补上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;&#x2F;account&quot;)</span><br><span class="line">public class AccountController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;list&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public  List&lt;Account&gt; getAccounts()&#123;</span><br><span class="line">       return accountDao.all();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public  Account getAccountById(@PathVariable(&quot;id&quot;) int id)&#123;</span><br><span class="line">        return accountDao.unique(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public  Account getAccountById(@RequestParam(&quot;name&quot;) String name)&#123;</span><br><span class="line">        return accountDao.selectAccountByName(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;&#123;id&#125;&quot;,method &#x3D; RequestMethod.PUT)</span><br><span class="line">    public  String updateAccount(@PathVariable(&quot;id&quot;)int id , @RequestParam(value &#x3D; &quot;name&quot;,required &#x3D; true)String name,</span><br><span class="line">    @RequestParam(value &#x3D; &quot;money&quot; ,required &#x3D; true)double money)&#123;</span><br><span class="line">        Account account&#x3D;new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        account.setId(id);</span><br><span class="line">        int t&#x3D;accountDao.updateById(account);</span><br><span class="line">        if(t&#x3D;&#x3D;1)&#123;</span><br><span class="line">            return account.toString();</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&quot;,method &#x3D; RequestMethod.POST)</span><br><span class="line">    public  String postAccount( @RequestParam(value &#x3D; &quot;name&quot;)String name,</span><br><span class="line">                                 @RequestParam(value &#x3D; &quot;money&quot; )double money) &#123;</span><br><span class="line">        Account account &#x3D; new Account();</span><br><span class="line">        account.setMoney(money);</span><br><span class="line">        account.setName(name);</span><br><span class="line">        KeyHolder t &#x3D; accountDao.insertReturnKey(account);</span><br><span class="line">        if (t.getInt() &gt; 0) &#123;</span><br><span class="line">            return account.toString();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return &quot;fail&quot;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过postman 测试，代码已全部通过。</p>
<p>个人使用感受，使用bealsql做了一些项目的试验，但是没有真正用于真正的生产环境，用起来非常的爽。但是springboot没有提供自动装配的直接支持，需要自己注解bean。另外使用这个orm的人不太多，有木有坑不知道，在我使用的过程中没有遇到什么问题。另外它的中文文档比较友好。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="http://www.ibeetl.com/guide/#beetlsql">BeetlSQL2.8中文文档</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第8篇：整合mongodb</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot8-mongodb/</url>
    <content><![CDATA[<p>这篇文章主要介绍springboot如何整合mongodb。</p>
<span id="more"></span>

<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul>
<li><a target="_blank" rel="noopener" href="http://www.runoob.com/mongodb/mongodb-window-install.html">安装 MongoDB</a></li>
<li>jdk 1.8</li>
<li>maven 3.0</li>
<li>idea</li>
</ul>
<h2 id="环境依赖"><a href="#环境依赖" class="headerlink" title="环境依赖"></a>环境依赖</h2><p>在pom文件引入spring-boot-starter-data-mongodb依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>##数据源配置</p>
<p>如果mongodb端口是默认端口，并且没有设置密码，可不配置，sprinboot会开启默认的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.data.mongodb.uri&#x3D;mongodb:&#x2F;&#x2F;localhost:27017&#x2F;springboot-db</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>mongodb设置了密码，这样配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.data.mongodb.uri&#x3D;mongodb:&#x2F;&#x2F;name:pass@localhost:27017&#x2F;dbname</span><br></pre></td></tr></table></figure>

<h2 id="定义一个简单的实体"><a href="#定义一个简单的实体" class="headerlink" title="定义一个简单的实体"></a>定义一个简单的实体</h2><p>mongodb</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.forezp.entity;</span><br><span class="line"></span><br><span class="line">import org.springframework.data.annotation.Id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Customer &#123;</span><br><span class="line"></span><br><span class="line">    @Id</span><br><span class="line">    public String id;</span><br><span class="line"></span><br><span class="line">    public String firstName;</span><br><span class="line">    public String lastName;</span><br><span class="line"></span><br><span class="line">    public Customer() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    public Customer(String firstName, String lastName) &#123;</span><br><span class="line">        this.firstName &#x3D; firstName;</span><br><span class="line">        this.lastName &#x3D; lastName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(</span><br><span class="line">                &quot;Customer[id&#x3D;%s, firstName&#x3D;&#39;%s&#39;, lastName&#x3D;&#39;%s&#39;]&quot;,</span><br><span class="line">                id, firstName, lastName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="数据操作dao层"><a href="#数据操作dao层" class="headerlink" title="数据操作dao层"></a>数据操作dao层</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface CustomerRepository extends MongoRepository&lt;Customer, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public Customer findByFirstName(String firstName);</span><br><span class="line">    public List&lt;Customer&gt; findByLastName(String lastName);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写一个接口，继承MongoRepository，这个接口有了几本的CURD的功能。如果你想自定义一些查询，比如根据firstName来查询，获取根据lastName来查询，只需要定义一个方法即可。注意firstName严格按照存入的mongodb的字段对应。在典型的java的应用程序，写这样一个接口的方法，需要自己实现，但是在springboot中，你只需要按照格式写一个接口名和对应的参数就可以了，因为springboot已经帮你实现了。</p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootMongodbApplication  implements CommandLineRunner &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private CustomerRepository repository;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(SpringbootMongodbApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void run(String... args) throws Exception &#123;</span><br><span class="line">		repository.deleteAll();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; save a couple of customers</span><br><span class="line">		repository.save(new Customer(&quot;Alice&quot;, &quot;Smith&quot;));</span><br><span class="line">		repository.save(new Customer(&quot;Bob&quot;, &quot;Smith&quot;));</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; fetch all customers</span><br><span class="line">		System.out.println(&quot;Customers found with findAll():&quot;);</span><br><span class="line">		System.out.println(&quot;-------------------------------&quot;);</span><br><span class="line">		for (Customer customer : repository.findAll()) &#123;</span><br><span class="line">			System.out.println(customer);</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println();</span><br><span class="line"></span><br><span class="line">		&#x2F;&#x2F; fetch an individual customer</span><br><span class="line">		System.out.println(&quot;Customer found with findByFirstName(&#39;Alice&#39;):&quot;);</span><br><span class="line">		System.out.println(&quot;--------------------------------&quot;);</span><br><span class="line">		System.out.println(repository.findByFirstName(&quot;Alice&quot;));</span><br><span class="line"></span><br><span class="line">		System.out.println(&quot;Customers found with findByLastName(&#39;Smith&#39;):&quot;);</span><br><span class="line">		System.out.println(&quot;--------------------------------&quot;);</span><br><span class="line">		for (Customer customer : repository.findByLastName(&quot;Smith&quot;)) &#123;</span><br><span class="line">			System.out.println(customer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>在springboot的应用程序，加入测试代码。启动程序，控制台打印了：</p>
<blockquote>
<p>Customers found with findAll():<br>     ——————————-<br>     Customer[id=58f880f589ffb696b8a6077e, firstName=’Alice’, lastName=’Smith’]<br>     Customer[id=58f880f589ffb696b8a6077f, firstName=’Bob’, lastName=’Smith’]<br>     Customer found with findByFirstName(‘Alice’):<br>     ——————————–<br>     Customer[id=58f880f589ffb696b8a6077e, firstName=’Alice’, lastName=’Smith’]<br>     Customers found with findByLastName(‘Smith’):<br>     ——————————–<br>     Customer[id=58f880f589ffb696b8a6077e, firstName=’Alice’, lastName=’Smith’]<br>     Customer[id=58f880f589ffb696b8a6077f, firstName=’Bob’, lastName=’Smith’]</p>
</blockquote>
<p>测试通过。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/accessing-data-mongodb/">accessing-data-mongodb</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第9篇：整合Redis</title>
    <url>/2017/05/05/springboot-2017-05-05-springboot9-redis/</url>
    <content><![CDATA[<p>这篇文章主要介绍springboot整合redis，至于没有接触过redis的同学可以看下这篇文章：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/61471712">5分钟带你入门Redis</a>。</p>
<span id="more"></span> 

<h2 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h2><p>在pom文件中添加redis依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-data-redis&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="配置数据源"><a href="#配置数据源" class="headerlink" title="配置数据源"></a>配置数据源</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.redis.host&#x3D;localhost</span><br><span class="line">spring.redis.port&#x3D;6379</span><br><span class="line">#spring.redis.password&#x3D;</span><br><span class="line">spring.redis.database&#x3D;1</span><br><span class="line">spring.redis.pool.max-active&#x3D;8</span><br><span class="line">spring.redis.pool.max-wait&#x3D;-1</span><br><span class="line">spring.redis.pool.max-idle&#x3D;500</span><br><span class="line">spring.redis.pool.min-idle&#x3D;0</span><br><span class="line">spring.redis.timeout&#x3D;0</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 如果你的redis有密码，配置下即可。经过上述两步的操作，你可以访问redis数据了。</p>
<h2 id="数据访问层dao"><a href="#数据访问层dao" class="headerlink" title="数据访问层dao"></a>数据访问层dao</h2><p>通过redisTemplate来访问redis.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class RedisDao &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private StringRedisTemplate template;</span><br><span class="line"></span><br><span class="line">    public  void setKey(String key,String value)&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops &#x3D; template.opsForValue();</span><br><span class="line">        ops.set(key,value,1, TimeUnit.MINUTES);&#x2F;&#x2F;1分钟过期</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getValue(String key)&#123;</span><br><span class="line">        ValueOperations&lt;String, String&gt; ops &#x3D; this.template.opsForValue();</span><br><span class="line">        return ops.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">public class SpringbootRedisApplicationTests &#123;</span><br><span class="line"></span><br><span class="line">	public static Logger logger&#x3D; LoggerFactory.getLogger(SpringbootRedisApplicationTests.class);</span><br><span class="line">	@Test</span><br><span class="line">	public void contextLoads() &#123;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	RedisDao redisDao;</span><br><span class="line">	@Test</span><br><span class="line">	public void testRedis()&#123;</span><br><span class="line">		redisDao.setKey(&quot;name&quot;,&quot;forezp&quot;);</span><br><span class="line">		redisDao.setKey(&quot;age&quot;,&quot;11&quot;);</span><br><span class="line">		logger.info(redisDao.getValue(&quot;name&quot;));</span><br><span class="line">		logger.info(redisDao.getValue(&quot;age&quot;));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动单元测试，你发现控制台打印了：</p>
<blockquote>
<p>forezp</p>
<p>11</p>
</blockquote>
<p>单元测试通过；</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/messaging-redis/">messaging-redis</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot教程第22篇：多Module工程</title>
    <url>/2017/05/05/springboot-2017-05-05-springbot22-modules/</url>
    <content><![CDATA[<p>这篇文章主要介绍如何在springboot中如何创建含有多个module的工程，栗子中含有两个 module，一个作为libarary. 工程，另外一个是主工程，调用libary .其中libary jar有一个服务，main工程调用这个服务。</p>
<span id="more"></span>

<h2 id="创建根工程"><a href="#创建根工程" class="headerlink" title="创建根工程"></a>创建根工程</h2><p>创建一个maven 工程,其pom文件为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;springboot-multi-module&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;pom&lt;&#x2F;packaging&gt;</span><br><span class="line">	&lt;name&gt;springboot-multi-module&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是packaging标签为pom 属性。</p>
<h2 id="创建libary工程"><a href="#创建libary工程" class="headerlink" title="创建libary工程"></a>创建libary工程</h2><p>libary工程为maven工程，其pom文件的packaging标签为jar 属性。创建一个service组件,它读取配置文件的 service.message属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(&quot;service&quot;)</span><br><span class="line">public class ServiceProperties &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * A message for the service.</span><br><span class="line">     *&#x2F;</span><br><span class="line">    private String message;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setMessage(String message) &#123;</span><br><span class="line">        this.message &#x3D; message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>提供一个对外暴露的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(ServiceProperties.class)</span><br><span class="line">public class ServiceConfiguration &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Service service(ServiceProperties properties) &#123;</span><br><span class="line">        return new Service(properties.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="创建一个springbot工程"><a href="#创建一个springbot工程" class="headerlink" title="创建一个springbot工程"></a>创建一个springbot工程</h2><p>引入相应的依赖,创建一个web服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@Import(ServiceConfiguration.class)</span><br><span class="line">@RestController</span><br><span class="line">public class DemoApplication &#123;</span><br><span class="line"></span><br><span class="line">    private final Service service;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public DemoApplication(Service service) &#123;</span><br><span class="line">        this.service &#x3D; service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;&#x2F;&quot;)</span><br><span class="line">    public String home() &#123;</span><br><span class="line">        return service.message();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(DemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在配置文件application.properties中加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service.message&#x3D;Hello World</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p>打开浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8080/;%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8080/;浏览器显示：</a></p>
<blockquote>
<p>Hello World</p>
</blockquote>
<p>说明确实引用了libary中的方法。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a target="_blank" rel="noopener" href="https://spring.io/guides/gs/multi-module/">https://spring.io/guides/gs/multi-module/</a></p>
<h2 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h2><p><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringBootLearning">https://github.com/forezp/SpringBootLearning</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li>更多springboot 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70341818">springBoot非官方教程 | 文章汇总</a></li>
<li>更多springcoud 教程：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 |  文章汇总</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Diagram as Code</title>
    <url>/2023/03/31/springboot-diagram/</url>
    <content><![CDATA[<p>将图表定义为代码，并使用特定的工具或库将其转换为实际的图表。这种方法可以使图表和代码保持同步，并且可以轻松地与代码一起管理。常见的“Diagram as Code”工具包括Mermaid、PlantUML和Go Diagrams等</p>
<h4 id="1-Diagrams"><a href="#1-Diagrams" class="headerlink" title="1. Diagrams"></a><strong>1. Diagrams</strong></h4><p>将Python代码转换为云系统架构图。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://github.com/mingrammer/diagrams">https://github.com/mingrammer/diagrams</a></p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe94ac2ab-b131-4a4c-a03e-b418e68e6447_3084x1503.png" alt="e94ac2ab-b131-4a4c-a03e-b418e68e6447_3084x1503.jpeg"></p>
<h4 id="2-Mermaid"><a href="#2-Mermaid" class="headerlink" title="2. Mermaid"></a><strong>2. Mermaid</strong></h4><span id="more"></span>

<p>通过类似于Markdown的方式从文本中生成图表和流程图。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://github.com/mermaid-js/mermaid">https://github.com/mermaid-js/mermaid</a></p>
<p>示例：</p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2F47b05da5-bebc-4587-9d09-f39777bd2ff5_1538x1522.png" alt="47b05da5-bebc-4587-9d09-f39777bd2ff5_1538x1522.jpeg"></p>
<h4 id="3-ASCII编辑器"><a href="#3-ASCII编辑器" class="headerlink" title="3. ASCII编辑器"></a><strong>3. ASCII编辑器</strong></h4><p>免费编辑器：</p>
<p><a target="_blank" rel="noopener" href="https://asciiflow.com/#/">https://asciiflow.com/#/</a></p>
<p>免费：</p>
<p><a target="_blank" rel="noopener" href="https://dot-to-ascii.ggerganov.com/">https://dot-to-ascii.ggerganov.com/</a></p>
<p>付费编辑器：</p>
<p><a target="_blank" rel="noopener" href="https://monodraw.helftone.com/">https://monodraw.helftone.com/</a></p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fe71f0951-d05a-491a-ba19-cd86c8498636_1536x1344.png" alt="e71f0951-d05a-491a-ba19-cd86c8498636_1536x1344.jpeg"></p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fc362b244-3868-482d-8c97-8ff1abfcb95c_1600x792.png" alt="c362b244-3868-482d-8c97-8ff1abfcb95c_1600x792.jpeg"></p>
<h4 id="4-PlantUML"><a href="#4-PlantUML" class="headerlink" title="4. PlantUML"></a><strong>4. PlantUML</strong></h4><p>PlantUML是一种开源工具，允许用户使用纯文本语言创建图表。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://github.com/plantuml/plantuml">https://github.com/plantuml/plantuml</a></p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fb3dbb83f-ee69-4ec7-a712-0c85d78690d0_1585x1551.png" alt="b3dbb83f-ee69-4ec7-a712-0c85d78690d0_1585x1551.jpeg"></p>
<p>图表的源代码：<a target="_blank" rel="noopener" href="https://raw.githubusercontent.com/bmpi-dev/bmpi.dev/master/content/dev/guide-to-serverless/arch_aws.plantuml">https://raw.githubusercontent.com/bmpi-dev/bmpi.dev/master/content/dev/guide-to-serverless/arch_aws.plantuml</a></p>
<h4 id="5-Markmap"><a href="#5-Markmap" class="headerlink" title="5. Markmap"></a><strong>5. Markmap</strong></h4><p>将Markdown转换为思维导图。它支持VS代码插件。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://markmap.js.org/repl">https://markmap.js.org/rep</a></p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fa3f114c8-2369-4745-9fa5-f9c01c694541_1956x2412.jpeg" alt="a3f114c8-2369-4745-9fa5-f9c01c694541_1956x2412.jpeg"></p>
<h4 id="6-Go-diagrams"><a href="#6-Go-diagrams" class="headerlink" title="6. Go diagrams"></a><strong>6. Go diagrams</strong></h4><p>使用Go创建漂亮的系统图表。</p>
<p>链接：<a target="_blank" rel="noopener" href="https://github.com/blushft/go-diagrams">https://github.com/blushft/go-diagrams</a></p>
<p><img src="https://substackcdn.com/image/fetch/w_1456,c_limit,f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fbucketeer-e05bbc84-baa3-437e-9518-adb32be77984.s3.amazonaws.com%2Fpublic%2Fimages%2Fffb9cb3d-3559-46e9-b207-8e36c34405f6_1935x2895.jpeg" alt="ffb9cb3d-3559-46e9-b207-8e36c34405f6_1935x2895.jpeg"></p>
]]></content>
      <categories>
        <category>设计</category>
      </categories>
      <tags>
        <tag>设计</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第1篇：Eureka</title>
    <url>/2017/06/01/springcloud-2017-06-01-sc01-eureka/</url>
    <content><![CDATA[<p>__</p>
<h3 id="一、spring-cloud简介"><a href="#一、spring-cloud简介" class="headerlink" title="一、spring cloud简介"></a>一、spring cloud简介</h3><p>spring cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等。它运行环境简单，可以在开发人员的电脑上跑。另外说明spring cloud是基于springboot的，所以需要开发中对springboot有一定的了解，如果不了解的话可以看这篇文章：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/61472783">2小时学会springboot</a>。另外对于“微服务架构” 不了解的话，可以通过搜索引擎搜索“微服务架构”了解下。</p>
<span id="more"></span>

<h3 id="二、创建服务注册中心"><a href="#二、创建服务注册中心" class="headerlink" title="二、创建服务注册中心"></a>二、创建服务注册中心</h3><p>在这里，我们需要用的的组件上Spring Cloud Netflix的Eureka ,eureka是一个服务注册和发现模块。</p>
<p><strong>2.1 首先创建一个maven主工程。</strong></p>
<p>**2.2 然后创建2个model工程:**一个model工程作为服务注册中心，即Eureka Server,另一个作为Eureka Client。</p>
<p>下面以创建server为例子，详细说明创建过程：</p>
<p>右键工程-&gt;创建model-&gt; 选择spring initialir 如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-de33b84a79858106.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>下一步-&gt;选择cloud discovery-&gt;eureka server ,然后一直下一步就行了。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-3addb73d569a58e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>创建完后的工程的pom.xml文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;eurekaserver&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;eurekaserver&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;!--eureka server --&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;!-- spring boot test--&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>2.3  启动一个服务注册中心</strong>，只需要一个注解@EnableEurekaServer，这个注解需要在springboot工程的启动application类上加：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@EnableEurekaServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class EurekaserverApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(EurekaserverApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>**2.4 **eureka是一个高可用的组件，它没有后端缓存，每一个实例注册之后需要向注册中心发送心跳（因此可以在内存中完成），在默认情况下erureka server也是一个eureka client ,必须要指定一个 server。eureka server的配置文件appication.yml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    fetchRegistry: false</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br><span class="line">      </span><br></pre></td></tr></table></figure>

<p>通过eureka.client.registerWithEureka：false和fetchRegistry：false来表明自己是一个eureka server.</p>
<p><strong>2.5</strong> eureka server 是有界面的，启动工程,打开浏览器访问：<br><a target="_blank" rel="noopener" href="http://localhost:8761/">http://localhost:8761</a> ,界面如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-8c954deeb3a3a01c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<blockquote>
<p>No application available 没有服务被发现 ……^_^<br>因为没有注册服务当然不可能有服务被发现了。</p>
</blockquote>
<h3 id="三、创建一个服务提供者-eureka-client"><a href="#三、创建一个服务提供者-eureka-client" class="headerlink" title="三、创建一个服务提供者 (eureka client)"></a>三、创建一个服务提供者 (eureka client)</h3><p>当client向server注册时，它会提供一些元数据，例如主机和端口，URL，主页等。Eureka server 从每个client实例接收心跳消息。 如果心跳超时，则通常将该实例从注册server中删除。</p>
<p>创建过程同server类似,创建完pom.xml如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;service-hi&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;service-hi&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过注解@EnableEurekaClient 表明自己是一个eurekaclient.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@RestController</span><br><span class="line">public class ServiceHiApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceHiApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">	String port;</span><br><span class="line">	@RequestMapping(&quot;&#x2F;hi&quot;)</span><br><span class="line">	public String home(@RequestParam String name) &#123;</span><br><span class="line">		return &quot;hi &quot;+name+&quot;,i am from port:&quot; +port;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>仅仅@EnableEurekaClient是不够的，还需要在配置文件中注明自己的服务注册中心的地址，application.yml配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">  port: 8762</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-hi</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>需要指明spring.application.name,这个很重要，这在以后的服务与服务之间相互调用一般都是根据这个name 。<br>启动工程，打开<a target="_blank" rel="noopener" href="http://localhost:8761/">http://localhost:8761</a> ，即eureka server 的网址：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-d830f93f1e56f6a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>你会发现一个服务已经注册在服务中了，服务名为SERVICE-HI ,端口为7862</p>
<p>这时打开 <a target="_blank" rel="noopener" href="http://localhost:8762/hi?name=forezp">http://localhost:8762/hi?name=forezp</a> ，你会在浏览器上看到 :</p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter1">https://github.com/forezp/SpringCloudLearning/tree/master/chapter1</a></p>
<h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-eureka-server">springcloud eureka server 官方文档</a></p>
<p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_service_discovery_eureka_clients">springcloud eureka client 官方文档</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第2篇：Ribbon</title>
    <url>/2017/06/02/springcloud-2017-06-02-sc02-rest-ribbon/</url>
    <content><![CDATA[<p>在上一篇文章，讲了服务的注册和发现。在微服务架构中，业务都会被拆分成一个独立的服务，服务与服务的通讯是基于http restful的。Spring cloud有两种服务调用方式，一种是ribbon+restTemplate，另一种是feign。在这一篇文章首先讲解下基于ribbon+rest。</p>
<span id="more"></span>

<h3 id="一、ribbon简介"><a href="#一、ribbon简介" class="headerlink" title="一、ribbon简介"></a>一、ribbon简介</h3><blockquote>
<p>Ribbon is a client side load balancer which gives you a lot of control over the behaviour of HTTP and TCP clients. Feign already uses Ribbon, so if you are using @FeignClient then this section also applies.</p>
<p>  —–摘自官网</p>
</blockquote>
<p>ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。Feign默认集成了ribbon。</p>
<p>ribbon 已经默认实现了这些配置bean：</p>
<ul>
<li><p>IClientConfig ribbonClientConfig: DefaultClientConfigImpl</p>
</li>
<li><p>IRule ribbonRule: ZoneAvoidanceRule</p>
</li>
<li><p>IPing ribbonPing: NoOpPing</p>
</li>
<li><p>ServerList<Server> ribbonServerList: ConfigurationBasedServerList</p>
</li>
<li><p>ServerListFilter<Server> ribbonServerListFilter: ZonePreferenceServerListFilter</p>
</li>
<li><p>ILoadBalancer ribbonLoadBalancer: ZoneAwareLoadBalancer</p>
</li>
</ul>
<h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><p>这一篇文章基于上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762；将service-hi的配置文件的端口改为8763,并启动，这时你会发现：service-hi在eureka-server注册了2个实例，这就相当于一个小的集群。访问localhost:8761如图所示：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-862f68c48735d126.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p>
<h4 id="三、建一个服务消费者"><a href="#三、建一个服务消费者" class="headerlink" title="三、建一个服务消费者"></a>三、建一个服务消费者</h4><p>重新新建一个spring-boot工程，取名为：service-ribbon;<br>在它的pom.xml文件分别引入起步依赖spring-cloud-starter-eureka、spring-cloud-starter-ribbon、spring-boot-starter-web，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;service-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;service-ribbon&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-ribbon&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在工程的配置文件指定服务的注册中心地址为<a target="_blank" rel="noopener" href="http://localhost:8761/eureka/%EF%BC%8C%E7%A8%8B%E5%BA%8F%E5%90%8D%E7%A7%B0%E4%B8%BA">http://localhost:8761/eureka/，程序名称为</a> service-ribbon，程序端口为8764。配置文件application.yml如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">  port: 8764</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-ribbon</span><br></pre></td></tr></table></figure>

<p>在工程的启动类中,通过@EnableDiscoveryClient向服务中心注册；并且向程序的ioc注入一个bean: restTemplate;并通过@LoadBalanced注解表明这个restRemplate开启负载均衡的功能。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">public class ServiceRibbonApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceRibbonApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@LoadBalanced</span><br><span class="line">	RestTemplate restTemplate() &#123;</span><br><span class="line">		return new RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写一个测试类HelloService，通过之前注入ioc容器的restTemplate来消费service-hi服务的“/hi”接口，在这里我们直接用的程序名替代了具体的url地址，在ribbon中它会根据服务名来选择具体的服务实例，根据服务实例在请求的时候会用具体的url替换掉服务名，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    public String hiService(String name) &#123;</span><br><span class="line">        return restTemplate.getForObject(&quot;http:&#x2F;&#x2F;SERVICE-HI&#x2F;hi?name&#x3D;&quot;+name,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>写一个controller，在controller中用调用HelloService 的方法，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;6.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RestController</span><br><span class="line">public class HelloControler &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    HelloService helloService;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;)</span><br><span class="line">    public String hi(@RequestParam String name)&#123;</span><br><span class="line">        return helloService.hiService(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在浏览器上多次访问<a target="_blank" rel="noopener" href="http://localhost:8764/hi?name=forezp%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%A4%E6%9B%BF%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8764/hi?name=forezp，浏览器交替显示：</a></p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
<p>hi forezp,i am from port:8763</p>
</blockquote>
<p>这说明当我们通过调用restTemplate.getForObject(“<a target="_blank" rel="noopener" href="http://service-hi/hi?name=&quot;+name,String.class)%E6%96%B9%E6%B3%95%E6%97%B6%EF%BC%8C%E5%B7%B2%E7%BB%8F%E5%81%9A%E4%BA%86%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%8C%E8%AE%BF%E9%97%AE%E4%BA%86%E4%B8%8D%E5%90%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%AE%9E%E4%BE%8B%E3%80%82">http://SERVICE-HI/hi?name=&quot;+name,String.class)方法时，已经做了负载均衡，访问了不同的端口的服务实例。</a></p>
<h3 id="四、此时的架构"><a href="#四、此时的架构" class="headerlink" title="四、此时的架构"></a>四、此时的架构</h3><p><img src="http://upload-images.jianshu.io/upload_images/2279594-9f10b702188a129d.png" alt="此时架构图.png"></p>
<ul>
<li>一个服务注册中心，eureka server,端口为8761</li>
<li>service-hi工程跑了两个实例，端口分别为8762,8763，分别向服务注册中心注册</li>
<li>sercvice-ribbon端口为8764,向服务注册中心注册</li>
<li>当sercvice-ribbon通过restTemplate调用service-hi的hi接口时，因为用ribbon进行了负载均衡，会轮流的调用service-hi：8762和8763 两个端口的hi接口；</li>
</ul>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter2">https://github.com/forezp/SpringCloudLearning/tree/master/chapter2</a></p>
<h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p>本文参考了以下：</p>
<p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-ribbon">spring-cloud-ribbon</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/liaokailin/article/details/51469834">springcloud ribbon with eureka</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.didispace.com/springcloud2/">服务消费者</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Ribbon</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第3篇：feign</title>
    <url>/2017/06/03/springcloud-2017-06-03-sc03-feign/</url>
    <content><![CDATA[<p>上一篇文章，讲述了如何通过RestTemplate+Ribbon去消费服务，这篇文章主要讲述如何通过Feign去消费服务。</p>
<span id="more"></span>

<h3 id="一、Feign简介"><a href="#一、Feign简介" class="headerlink" title="一、Feign简介"></a>一、Feign简介</h3><p>Feign是一个声明式的伪Http客户端，它使得写Http客户端变得更简单。使用Feign，只需要创建一个接口并注解。它具有可插拔的注解特性，可使用Feign 注解和JAX-RS注解。Feign支持可插拔的编码器和解码器。Feign默认集成了Ribbon，并和Eureka结合，默认实现了负载均衡的效果。</p>
<p>简而言之：</p>
<ul>
<li>Feign 采用的是基于接口的注解</li>
<li>Feign 整合了ribbon</li>
</ul>
<h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><p>继续用上一节的工程， 启动eureka-server，端口为8761; 启动service-hi 两次，端口分别为8762 、8773.</p>
<h3 id="三、创建一个feign的服务"><a href="#三、创建一个feign的服务" class="headerlink" title="三、创建一个feign的服务"></a>三、创建一个feign的服务</h3><p>新建一个spring-boot工程，取名为serice-feign，在它的pom文件引入Feign的起步依赖spring-cloud-starter-feign、Eureka的起步依赖spring-cloud-starter-eureka、Web的起步依赖spring-boot-starter-web，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;service-feign&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;service-feign&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-feign&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在工程的配置文件application.yml文件，指定程序名为service-feign，端口号为8765，服务注册地址为<a target="_blank" rel="noopener" href="http://localhost:8761/eureka/">http://localhost:8761/eureka/</a> ，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">  port: 8765</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-feign</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在程序的启动类ServiceFeignApplication ，加上@EnableFeignClients注解开启Feign的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableFeignClients</span><br><span class="line">public class ServiceFeignApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceFeignApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>定义一个feign接口，通过@ FeignClient（“服务名”），来指定调用哪个服务。比如在代码中调用了service-hi服务的“/hi”接口，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * Created by chris  on 2017&#x2F;4&#x2F;6.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@FeignClient(value &#x3D; &quot;service-hi&quot;)</span><br><span class="line">public interface SchedualServiceHi &#123;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    String sayHiFromClientOne(@RequestParam(value &#x3D; &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在Web层的controller层，对外暴露一个”/hi”的API接口，通过上面定义的Feign客户端SchedualServiceHi 来消费服务。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HiController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    SchedualServiceHi schedualServiceHi;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    public String sayHi(@RequestParam String name)&#123;</span><br><span class="line">        return schedualServiceHi.sayHiFromClientOne(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>启动程序，多次访问<a target="_blank" rel="noopener" href="http://localhost:8765/hi?name=forezp,%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BA%A4%E6%9B%BF%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8765/hi?name=forezp,浏览器交替显示：</a></p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
<p>hi forezp,i am from port:8763</p>
</blockquote>
<p>Feign源码解析：<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/73480304">http://blog.csdn.net/forezp/article/details/73480304</a></p>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter3">https://github.com/forezp/SpringCloudLearning/tree/master/chapter3</a></p>
<h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-feign">spring-cloud-feign</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud feign</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第4篇：Hystrix</title>
    <url>/2017/06/04/springcloud-2017-06-04-sc04-hystrix/</url>
    <content><![CDATA[<p>在微服务架构中，根据业务来拆分成一个个的服务，服务与服务之间可以相互调用（RPC），在Spring Cloud可以用RestTemplate+Ribbon和Feign来调用。为了保证其高可用，单个服务通常会集群部署。由于网络原因或者自身的原因，服务并不能保证100%可用，如果单个服务出现问题，调用这个服务就会出现线程阻塞，此时若有大量的请求涌入，Servlet容器的线程资源会被消耗完毕，导致服务瘫痪。服务与服务之间的依赖性，故障会传播，会对整个微服务系统造成灾难性的严重后果，这就是服务故障的“雪崩”效应。</p>
<p>为了解决这个问题，业界提出了断路器模型。</p>
<span id="more"></span>

<h3 id="一、断路器简介"><a href="#一、断路器简介" class="headerlink" title="一、断路器简介"></a>一、断路器简介</h3><blockquote>
<p>Netflix has created a library called Hystrix that implements the circuit breaker pattern. In a microservice architecture it is common to have multiple layers of service calls.</p>
<p>. —-摘自官网 </p>
</blockquote>
<p>Netflix开源了Hystrix组件，实现了断路器模式，SpringCloud对这一组件进行了整合。 在微服务架构中，一个请求需要调用多个服务是非常常见的，如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-08d8d524c312c27d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="HystrixGraph.png"></p>
<p>较底层的服务如果出现故障，会导致连锁故障。当对特定的服务的调用的不可用达到一个阀值（Hystric 是5秒20次） 断路器将会被打开。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-8dcb1f208d62046f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="HystrixFallback.png"></p>
<p>断路打开后，可用避免连锁故障，fallback方法可以直接返回一个固定值。</p>
<h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><p>这篇文章基于上一篇文章的工程，首先启动上一篇文章的工程，启动eureka-server 工程；启动service-hi工程，它的端口为8762。</p>
<h3 id="三、在ribbon使用断路器"><a href="#三、在ribbon使用断路器" class="headerlink" title="三、在ribbon使用断路器"></a>三、在ribbon使用断路器</h3><p>改造serice-ribbon 工程的代码，首先在pox.xml文件中加入spring-cloud-starter-hystrix的起步依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在程序的启动类ServiceRibbonApplication 加@EnableHystrix注解开启Hystrix：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableHystrix</span><br><span class="line">public class ServiceRibbonApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceRibbonApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@LoadBalanced</span><br><span class="line">	RestTemplate restTemplate() &#123;</span><br><span class="line">		return new RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>改造HelloService类，在hiService方法上加上@HystrixCommand注解。该注解对该方法创建了熔断器的功能，并指定了fallbackMethod熔断方法，熔断方法直接返回了一个字符串，字符串为”hi,”+name+”,sorry,error!”，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class HelloService &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    @HystrixCommand(fallbackMethod &#x3D; &quot;hiError&quot;)</span><br><span class="line">    public String hiService(String name) &#123;</span><br><span class="line">        return restTemplate.getForObject(&quot;http:&#x2F;&#x2F;SERVICE-HI&#x2F;hi?name&#x3D;&quot;+name,String.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String hiError(String name) &#123;</span><br><span class="line">        return &quot;hi,&quot;+name+&quot;,sorry,error!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动：service-ribbon 工程，当我们访问<a target="_blank" rel="noopener" href="http://localhost:8764/hi?name=forezp,%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8764/hi?name=forezp,浏览器显示：</a></p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>此时关闭 service-hi 工程，当我们再访问<a target="_blank" rel="noopener" href="http://localhost:8764/hi?name=forezp%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BC%9A%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8764/hi?name=forezp，浏览器会显示：</a></p>
<blockquote>
<p>hi ,forezp,orry,error!</p>
</blockquote>
<p>这就说明当 service-hi 工程不可用的时候，service-ribbon调用 service-hi的API接口时，会执行快速失败，直接返回一组字符串，而不是等待响应超时，这很好的控制了容器的线程阻塞。</p>
<h3 id="四、Feign中使用断路器"><a href="#四、Feign中使用断路器" class="headerlink" title="四、Feign中使用断路器"></a>四、Feign中使用断路器</h3><p>Feign是自带断路器的，在D版本的Spring Cloud中，它没有默认打开。需要在配置文件中配置打开它，在配置文件加以下代码：</p>
<blockquote>
<p>feign.hystrix.enabled=true</p>
</blockquote>
<p>基于service-feign工程进行改造，只需要在FeignClient的SchedualServiceHi接口的注解中加上fallback的指定类就行了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FeignClient(value &#x3D; &quot;service-hi&quot;,fallback &#x3D; SchedualServiceHiHystric.class)</span><br><span class="line">public interface SchedualServiceHi &#123;</span><br><span class="line">    @RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;,method &#x3D; RequestMethod.GET)</span><br><span class="line">    String sayHiFromClientOne(@RequestParam(value &#x3D; &quot;name&quot;) String name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>SchedualServiceHiHystric需要实现SchedualServiceHi 接口，并注入到Ioc容器中，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class SchedualServiceHiHystric implements SchedualServiceHi &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public String sayHiFromClientOne(String name) &#123;</span><br><span class="line">        return &quot;sorry &quot;+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动四servcie-feign工程，浏览器打开<a target="_blank" rel="noopener" href="http://localhost:8765/hi?name=forezp,%E6%B3%A8%E6%84%8F%E6%AD%A4%E6%97%B6service-hi%E5%B7%A5%E7%A8%8B%E6%B2%A1%E6%9C%89%E5%90%AF%E5%8A%A8%EF%BC%8C%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8765/hi?name=forezp,注意此时service-hi工程没有启动，网页显示：</a></p>
<blockquote>
<p>sorry forezp</p>
</blockquote>
<p>打开service-hi工程，再次访问，浏览器显示：</p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>这证明断路器起到作用了。</p>
<p>五、Hystrix Dashboard (断路器：Hystrix 仪表盘)</p>
<p>基于service-ribbon 改造，Feign的改造和这一样。</p>
<p>首选在pom.xml引入spring-cloud-starter-hystrix-dashboard的起步依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在主程序启动类中加入@EnableHystrixDashboard注解，开启hystrixDashboard：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@EnableHystrix</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">public class ServiceRibbonApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceRibbonApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	@LoadBalanced</span><br><span class="line">	RestTemplate restTemplate() &#123;</span><br><span class="line">		return new RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打开浏览器：访问<a target="_blank" rel="noopener" href="http://localhost:8764/hystrix,%E7%95%8C%E9%9D%A2%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8764/hystrix,界面如下：</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-64f5fa9d0d96ee21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>点击monitor stream，进入下一个界面，访问：<a target="_blank" rel="noopener" href="http://localhost:8764/hi?name=forezp">http://localhost:8764/hi?name=forezp</a></p>
<p>此时会出现监控界面：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-755cd7ce5c066649.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter4">https://github.com/forezp/SpringCloudLearning/tree/master/chapter4</a></p>
<h3 id="六、参考资料"><a href="#六、参考资料" class="headerlink" title="六、参考资料"></a>六、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_clients">circuit_breaker_hystrix</a></p>
<p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#spring-cloud-feign-hystrix">feign-hystrix</a></p>
<p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_dashboard">hystrix_dashboard</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第5篇：Zuul</title>
    <url>/2017/06/05/springcloud-2017-06-05-sc05-zuul/</url>
    <content><![CDATA[<p>在微服务架构中，需要几个基础的服务治理组件，包括服务注册与发现、服务消费、负载均衡、断路器、智能路由、配置管理等，由这几个基础组件相互协作，共同组建了一个简单的微服务系统。一个简答的微服务系统如下图：</p>
<span id="more"></span>

<p><img src="http://upload-images.jianshu.io/upload_images/2279594-6b7c148110ebc56e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Azure (1).png"><br><strong>注意：A服务和B服务是可以相互调用的，作图的时候忘记了。并且配置服务也是注册到服务注册中心的。</strong></p>
<p>在Spring Cloud微服务系统中，一种常见的负载均衡方式是，客户端的请求首先经过负载均衡（zuul、Ngnix），再到达服务网关（zuul集群），然后再到具体的服。，服务统一注册到高可用的服务注册中心集群，服务的所有的配置文件由配置服务管理（下一篇文章讲述），配置服务的配置文件放在git仓库，方便开发人员随时改配置。</p>
<h3 id="一、Zuul简介"><a href="#一、Zuul简介" class="headerlink" title="一、Zuul简介"></a>一、Zuul简介</h3><p>Zuul的主要功能是路由转发和过滤器。路由功能是微服务的一部分，比如／api/user转发到到user服务，/api/shop转发到到shop服务。zuul默认和Ribbon结合实现了负载均衡的功能。</p>
<p>zuul有以下功能：</p>
<ul>
<li>Authentication</li>
<li>Insights</li>
<li>Stress Testing</li>
<li>Canary Testing</li>
<li>Dynamic Routing</li>
<li>Service Migration</li>
<li>Load Shedding</li>
<li>Security</li>
<li>Static Response handling</li>
<li>Active/Active traffic management</li>
</ul>
<h3 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h3><p>继续使用上一节的工程。在原有的工程上，创建一个新的工程。</p>
<h3 id="三、创建service-zuul工程"><a href="#三、创建service-zuul工程" class="headerlink" title="三、创建service-zuul工程"></a>三、创建service-zuul工程</h3><p>其pom.xml文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;service-zuul&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;service-zuul&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-zuul&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其入口applicaton类加上注解@EnableZuulProxy，开启zuul的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableZuulProxy</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class ServiceZuulApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceZuulApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>加上配置文件application.yml加上以下的配置代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">  port: 8769</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-zuul</span><br><span class="line">zuul:</span><br><span class="line">  routes:</span><br><span class="line">    api-a:</span><br><span class="line">      path: &#x2F;api-a&#x2F;**</span><br><span class="line">      serviceId: service-ribbon</span><br><span class="line">    api-b:</span><br><span class="line">      path: &#x2F;api-b&#x2F;**</span><br><span class="line">      serviceId: service-feign</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>首先指定服务注册中心的地址为<a target="_blank" rel="noopener" href="http://localhost:8761/eureka/%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%9A%84%E7%AB%AF%E5%8F%A3%E4%B8%BA8769%EF%BC%8C%E6%9C%8D%E5%8A%A1%E5%90%8D%E4%B8%BAservice-zuul%EF%BC%9B%E4%BB%A5/api-a/">http://localhost:8761/eureka/，服务的端口为8769，服务名为service-zuul；以/api-a/</a> 开头的请求都转发给service-ribbon服务；以/api-b/开头的请求都转发给service-feign服务；</p>
<p>依次运行这五个工程;打开浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8769/api-a/hi?name=forezp">http://localhost:8769/api-a/hi?name=forezp</a> ;浏览器显示：</p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>打开浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:8769/api-b/hi?name=forezp">http://localhost:8769/api-b/hi?name=forezp</a> ;浏览器显示：</p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>这说明zuul起到了路由的作用</p>
<h3 id="四、服务过滤"><a href="#四、服务过滤" class="headerlink" title="四、服务过滤"></a>四、服务过滤</h3><p>zuul不仅只是路由，并且还能过滤，做一些安全验证。继续改造工程；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span><br><span class="line">public class MyFilter extends ZuulFilter&#123;</span><br><span class="line"></span><br><span class="line">    private static Logger log &#x3D; LoggerFactory.getLogger(MyFilter.class);</span><br><span class="line">    @Override</span><br><span class="line">    public String filterType() &#123;</span><br><span class="line">        return &quot;pre&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int filterOrder() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldFilter() &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object run() &#123;</span><br><span class="line">        RequestContext ctx &#x3D; RequestContext.getCurrentContext();</span><br><span class="line">        HttpServletRequest request &#x3D; ctx.getRequest();</span><br><span class="line">        log.info(String.format(&quot;%s &gt;&gt;&gt; %s&quot;, request.getMethod(), request.getRequestURL().toString()));</span><br><span class="line">        Object accessToken &#x3D; request.getParameter(&quot;token&quot;);</span><br><span class="line">        if(accessToken &#x3D;&#x3D; null) &#123;</span><br><span class="line">            log.warn(&quot;token is empty&quot;);</span><br><span class="line">            ctx.setSendZuulResponse(false);</span><br><span class="line">            ctx.setResponseStatusCode(401);</span><br><span class="line">            try &#123;</span><br><span class="line">                ctx.getResponse().getWriter().write(&quot;token is empty&quot;);</span><br><span class="line">            &#125;catch (Exception e)&#123;&#125;</span><br><span class="line"></span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        log.info(&quot;ok&quot;);</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>filterType：返回一个字符串代表过滤器的类型，在zuul中定义了四种不同生命周期的过滤器类型，具体如下：<ul>
<li>pre：路由之前</li>
<li>routing：路由之时</li>
<li>post： 路由之后</li>
<li>error：发送错误调用</li>
</ul>
</li>
<li>filterOrder：过滤的顺序</li>
<li>shouldFilter：这里可以写逻辑判断，是否要过滤，本文true,永远过滤。</li>
<li>run：过滤器的具体逻辑。可用很复杂，包括查sql，nosql去判断该请求到底有没有权限访问。</li>
</ul>
<p>这时访问：<a target="_blank" rel="noopener" href="http://localhost:8769/api-a/hi?name=forezp">http://localhost:8769/api-a/hi?name=forezp</a> ；网页显示：</p>
<blockquote>
<p>token is empty</p>
</blockquote>
<p>访问 <a target="_blank" rel="noopener" href="http://localhost:8769/api-a/hi?name=forezp&amp;token=22">http://localhost:8769/api-a/hi?name=forezp&amp;token=22</a> ；<br>网页显示：</p>
<blockquote>
<p>hi forezp,i am from port:8762</p>
</blockquote>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter5">https://github.com/forezp/SpringCloudLearning/tree/master/chapter5</a></p>
<h3 id="五、参考资料："><a href="#五、参考资料：" class="headerlink" title="五、参考资料："></a>五、参考资料：</h3><p> <a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_router_and_filter_zuul">router_and_filter_zuul</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud_Zuul</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第6篇：config</title>
    <url>/2017/06/06/springcloud-2017-06-06-sc06-config/</url>
    <content><![CDATA[<p>在上一篇文章讲述zuul的时候，已经提到过，使用配置服务来保存各个服务的配置文件。它就是Spring Cloud Config。</p>
<span id="more"></span>

<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。</p>
<h3 id="二、构建Config-Server"><a href="#二、构建Config-Server" class="headerlink" title="二、构建Config Server"></a>二、构建Config Server</h3><p>创建一个spring-boot项目，取名为config-server,其pom.xml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;config-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;config-server&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-config-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Camden.SR6&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在程序的入口Application类加上@EnableConfigServer注解开启配置服务器的功能，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableConfigServer</span><br><span class="line">public class ConfigServerApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ConfigServerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要在程序的配置文件application.properties文件配置以下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name&#x3D;config-server</span><br><span class="line">server.port&#x3D;8888</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">spring.cloud.config.server.git.uri&#x3D;https:&#x2F;&#x2F;github.com&#x2F;forezp&#x2F;SpringcloudConfig&#x2F;</span><br><span class="line">spring.cloud.config.server.git.searchPaths&#x3D;respo</span><br><span class="line">spring.cloud.config.label&#x3D;master</span><br><span class="line">spring.cloud.config.server.git.username&#x3D;your username</span><br><span class="line">spring.cloud.config.server.git.password&#x3D;your password</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>spring.cloud.config.server.git.uri：配置git仓库地址</li>
<li>spring.cloud.config.server.git.searchPaths：配置仓库路径</li>
<li>spring.cloud.config.label：配置仓库的分支</li>
<li>spring.cloud.config.server.git.username：访问git仓库的用户名</li>
<li>spring.cloud.config.server.git.password：访问git仓库的用户密码</li>
</ul>
<p>如果Git仓库为公开仓库，可以不填写用户名和密码，如果是私有仓库需要填写，本例子是公开仓库，放心使用。</p>
<p>远程仓库<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringcloudConfig/">https://github.com/forezp/SpringcloudConfig/</a> 中有个文件config-client-dev.properties文件中有一个属性：</p>
<blockquote>
<p>foo = foo version 3</p>
</blockquote>
<p>启动程序：访问<a target="_blank" rel="noopener" href="http://localhost:8888/foo/dev">http://localhost:8888/foo/dev</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;foo&quot;,&quot;profiles&quot;:[&quot;dev&quot;],&quot;label&quot;:&quot;master&quot;,</span><br><span class="line">&quot;version&quot;:&quot;792ffc77c03f4b138d28e89b576900ac5e01a44b&quot;,&quot;state&quot;:null,&quot;propertySources&quot;:[]&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>证明配置服务中心可以从远程程序获取配置信息。</p>
<p>http请求地址和资源文件映射如下:</p>
<ul>
<li>/{application}/{profile}[/{label}]</li>
<li>/{application}-{profile}.yml</li>
<li>/{label}/{application}-{profile}.yml</li>
<li>/{application}-{profile}.properties</li>
<li>/{label}/{application}-{profile}.properties</li>
</ul>
<h3 id="三、构建一个config-client"><a href="#三、构建一个config-client" class="headerlink" title="三、构建一个config client"></a>三、构建一个config client</h3><p>重新创建一个springboot项目，取名为config-client,其pom文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;config-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;config-client&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>其配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name&#x3D;config-client</span><br><span class="line">spring.cloud.config.label&#x3D;master</span><br><span class="line">spring.cloud.config.profile&#x3D;dev</span><br><span class="line">spring.cloud.config.uri&#x3D; http:&#x2F;&#x2F;localhost:8888&#x2F;</span><br><span class="line">server.port&#x3D;8881</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>spring.cloud.config.label 指明远程仓库的分支</li>
<li>spring.cloud.config.profile <ul>
<li>dev开发环境配置文件</li>
<li>test测试环境</li>
<li>pro正式环境</li>
</ul>
</li>
<li>spring.cloud.config.uri= <a target="_blank" rel="noopener" href="http://localhost:8888/">http://localhost:8888/</a> 指明配置服务中心的网址。</li>
</ul>
<p>程序的入口类，写一个API接口“／hi”，返回从配置中心读取的foo变量的值，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line">public class ConfigClientApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ConfigClientApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;$&#123;foo&#125;&quot;)</span><br><span class="line">	String foo;</span><br><span class="line">	@RequestMapping(value &#x3D; &quot;&#x2F;hi&quot;)</span><br><span class="line">	public String hi()&#123;</span><br><span class="line">		return foo;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开网址访问：<a target="_blank" rel="noopener" href="http://localhost:8881/hi%EF%BC%8C%E7%BD%91%E9%A1%B5%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8881/hi，网页显示：</a></p>
<blockquote>
<p>foo version 3</p>
</blockquote>
<p>这就说明，config-client从config-server获取了foo的属性，而config-server是从git仓库读取的,如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-40ecbed6d38573d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Azure (2).png"></p>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter6">https://github.com/forezp/SpringCloudLearning/tree/master/chapter6</a></p>
<h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_spring_cloud_config">spring_cloud_config</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud config</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第8篇：Spring Cloud Bus</title>
    <url>/2017/06/08/springcloud-2017-06-08-sc08-bus/</url>
    <content><![CDATA[<p>Spring Cloud Bus 将分布式的节点用轻量的消息代理连接起来。它可以用于广播配置文件的更改或者服务之间的通讯，也可以用于监控。本文要讲述的是用Spring Cloud Bus实现通知微服务架构的配置文件的更改。</p>
<span id="more"></span>

<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><p>本文还是基于上一篇文章来实现。按照官方文档，我们只需要在配置文件中配置 spring-cloud-starter-bus-amqp ；这就是说我们需要装rabbitMq，点击<a target="_blank" rel="noopener" href="http://www.rabbitmq.com/">rabbitmq</a>下载。至于怎么使用 rabbitmq，搜索引擎下。</p>
<h3 id="二、改造config-client"><a href="#二、改造config-client" class="headerlink" title="二、改造config-client"></a>二、改造config-client</h3><p>在pom文件加上起步依赖spring-cloud-starter-bus-amqp，完整的配置文件如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;config-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;config-client&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.retry&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-retry&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-aop&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-bus-amqp&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在配置文件application.properties中加上RabbitMq的配置，包括RabbitMq的地址、端口，用户名、密码，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">spring.rabbitmq.host&#x3D;localhost</span><br><span class="line">spring.rabbitmq.port&#x3D;5672</span><br><span class="line"># spring.rabbitmq.username&#x3D;</span><br><span class="line"># spring.rabbitmq.password&#x3D;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>如果rabbitmq有用户名密码，输入即可。</p>
<p>依次启动eureka-server、confg-cserver,启动两个config-client，端口为：8881、8882。</p>
<p>访问<a target="_blank" rel="noopener" href="http://localhost:8881/hi">http://localhost:8881/hi</a>  或者<a target="_blank" rel="noopener" href="http://localhost:8882/hi">http://localhost:8882/hi</a> 浏览器显示：</p>
<blockquote>
<p>foo version 3</p>
</blockquote>
<p>这时我们去<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringcloudConfig/blob/master/respo/config-client-dev.properties">代码仓库</a>将foo的值改为“foo version 4”，即改变配置文件foo的值。如果是传统的做法，需要重启服务，才能达到配置文件的更新。此时，我们只需要发送post请求：<a target="_blank" rel="noopener" href="http://localhost:8881/bus/refresh%EF%BC%8C%E4%BD%A0%E4%BC%9A%E5%8F%91%E7%8E%B0config-client%E4%BC%9A%E9%87%8D%E7%8E%B0%E8%82%9A%E8%84%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6">http://localhost:8881/bus/refresh，你会发现config-client会重现肚脐配置文件</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-c1fe748f1d25af70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>重新读取配置文件：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-57874b46c40c9916.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>这时我们再访问<a target="_blank" rel="noopener" href="http://localhost:8881/hi">http://localhost:8881/hi</a>  或者<a target="_blank" rel="noopener" href="http://localhost:8882/hi">http://localhost:8882/hi</a> 浏览器显示：</p>
<blockquote>
<p>foo version 4</p>
</blockquote>
<p>另外，/bus/refresh接口可以指定服务，即使用”destination”参数，比如 “/bus/refresh?destination=customers:**” 即刷新服务名为customers的所有服务，不管ip。</p>
<h3 id="三、分析"><a href="#三、分析" class="headerlink" title="三、分析"></a>三、分析</h3><p>此时的架构图：<br><img src="http://upload-images.jianshu.io/upload_images/2279594-9a119d83cf90069f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>当git文件更改的时候，通过pc端用post 向端口为8882的config-client发送请求/bus/refresh／；此时8882端口会发送一个消息，由消息总线向其他服务传递，从而使整个微服务集群都达到更新配置文件。</p>
<h3 id="四、其他扩展（可忽视）"><a href="#四、其他扩展（可忽视）" class="headerlink" title="四、其他扩展（可忽视）"></a>四、其他扩展（可忽视）</h3><p>可以用作自定义的Message Broker,只需要spring-cloud-starter-bus-amqp, 然后再配置文件写上配置即可，同上。</p>
<p>Tracing Bus Events：<br>需要设置：spring.cloud.bus.trace.enabled=true，如果那样做的话，那么Spring Boot TraceRepository（如果存在）将显示每个服务实例发送的所有事件和所有的ack,比如：（来自官网）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2015-11-26T10:24:44.411+0000&quot;,</span><br><span class="line">  &quot;info&quot;: &#123;</span><br><span class="line">    &quot;signal&quot;: &quot;spring.cloud.bus.ack&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;RefreshRemoteApplicationEvent&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;c4d374b7-58ea-4928-a312-31984def293b&quot;,</span><br><span class="line">    &quot;origin&quot;: &quot;stores:8081&quot;,</span><br><span class="line">    &quot;destination&quot;: &quot;*:**&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2015-11-26T10:24:41.864+0000&quot;,</span><br><span class="line">  &quot;info&quot;: &#123;</span><br><span class="line">    &quot;signal&quot;: &quot;spring.cloud.bus.sent&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;RefreshRemoteApplicationEvent&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;c4d374b7-58ea-4928-a312-31984def293b&quot;,</span><br><span class="line">    &quot;origin&quot;: &quot;customers:9000&quot;,</span><br><span class="line">    &quot;destination&quot;: &quot;*:**&quot;</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">  &quot;timestamp&quot;: &quot;2015-11-26T10:24:41.862+0000&quot;,</span><br><span class="line">  &quot;info&quot;: &#123;</span><br><span class="line">    &quot;signal&quot;: &quot;spring.cloud.bus.ack&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;RefreshRemoteApplicationEvent&quot;,</span><br><span class="line">    &quot;id&quot;: &quot;c4d374b7-58ea-4928-a312-31984def293b&quot;,</span><br><span class="line">    &quot;origin&quot;: &quot;customers:9000&quot;,</span><br><span class="line">    &quot;destination&quot;: &quot;*:**&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter8">https://github.com/forezp/SpringCloudLearning/tree/master/chapter8</a></p>
<h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_spring_cloud_bus">spring_cloud_bus</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud SpringCloudBus</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第7篇：高可用的分布式配置中心</title>
    <url>/2017/06/07/springcloud-2017-06-07-sc07-config/</url>
    <content><![CDATA[<p>上一篇文章讲述了一个服务如何从配置中心读取文件，配置中心如何从远程git读取配置文件，当服务实例很多时，都从配置中心读取文件，这时可以考虑将配置中心做成一个微服务，将其集群化，从而达到高可用，架构图如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-babe706075d72c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Azure (3).png"></p>
<span id="more"></span>

<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><p>继续使用上一篇文章的工程，创建一个eureka-server工程，用作服务注册中心。</p>
<p>在其pom.xml文件引入Eureka的起步依赖spring-cloud-starter-eureka-server，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;eureka-server&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line">	&lt;repositories&gt;</span><br><span class="line">		&lt;repository&gt;</span><br><span class="line">			&lt;id&gt;spring-milestones&lt;&#x2F;id&gt;</span><br><span class="line">			&lt;name&gt;Spring Milestones&lt;&#x2F;name&gt;</span><br><span class="line">			&lt;url&gt;https:&#x2F;&#x2F;repo.spring.io&#x2F;milestone&lt;&#x2F;url&gt;</span><br><span class="line">			&lt;snapshots&gt;</span><br><span class="line">				&lt;enabled&gt;false&lt;&#x2F;enabled&gt;</span><br><span class="line">			&lt;&#x2F;snapshots&gt;</span><br><span class="line">		&lt;&#x2F;repository&gt;</span><br><span class="line">	&lt;&#x2F;repositories&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在配置文件application.yml上，指定服务端口为8889，加上作为服务注册中心的基本配置，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8889</span><br><span class="line"></span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: localhost</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    fetchRegistry: false</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<p>入口类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@EnableEurekaServer</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class EurekaServerApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(EurekaServerApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="二、改造config-server"><a href="#二、改造config-server" class="headerlink" title="二、改造config-server"></a>二、改造config-server</h3><p>在其pom.xml文件加上EurekaClient的起步依赖spring-cloud-starter-eureka，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-config-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置文件application.yml，指定服务注册地址为<a target="_blank" rel="noopener" href="http://localhost:8889/eureka/%EF%BC%8C%E5%85%B6%E4%BB%96%E9%85%8D%E7%BD%AE%E5%90%8C%E4%B8%8A%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%8C%E5%AE%8C%E6%95%B4%E7%9A%84%E9%85%8D%E7%BD%AE%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8889/eureka/，其他配置同上一篇文章，完整的配置如下：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name&#x3D;config-server</span><br><span class="line">server.port&#x3D;8888</span><br><span class="line"></span><br><span class="line">spring.cloud.config.server.git.uri&#x3D;https:&#x2F;&#x2F;github.com&#x2F;forezp&#x2F;SpringcloudConfig&#x2F;</span><br><span class="line">spring.cloud.config.server.git.searchPaths&#x3D;respo</span><br><span class="line">spring.cloud.config.label&#x3D;master</span><br><span class="line">spring.cloud.config.server.git.username&#x3D; your username</span><br><span class="line">spring.cloud.config.server.git.password&#x3D; your password</span><br><span class="line">eureka.client.serviceUrl.defaultZone&#x3D;http:&#x2F;&#x2F;localhost:8889&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>
<p>最后需要在程序的启动类Application加上@EnableEureka的注解。</p>
<h3 id="三、改造config-client"><a href="#三、改造config-client" class="headerlink" title="三、改造config-client"></a>三、改造config-client</h3><p>将其注册微到服务注册中心，作为Eureka客户端，需要pom文件加上起步依赖spring-cloud-starter-eureka，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>配置文件bootstrap.properties，注意是bootstrap。加上服务注册地址为<a target="_blank" rel="noopener" href="http://localhost:8889/eureka/">http://localhost:8889/eureka/</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.application.name&#x3D;config-client</span><br><span class="line">spring.cloud.config.label&#x3D;master</span><br><span class="line">spring.cloud.config.profile&#x3D;dev</span><br><span class="line">#spring.cloud.config.uri&#x3D; http:&#x2F;&#x2F;localhost:8888&#x2F;</span><br><span class="line"></span><br><span class="line">eureka.client.serviceUrl.defaultZone&#x3D;http:&#x2F;&#x2F;localhost:8889&#x2F;eureka&#x2F;</span><br><span class="line">spring.cloud.config.discovery.enabled&#x3D;true</span><br><span class="line">spring.cloud.config.discovery.serviceId&#x3D;config-server</span><br><span class="line">server.port&#x3D;8881</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>spring.cloud.config.discovery.enabled 是从配置中心读取文件。</li>
<li>spring.cloud.config.discovery.serviceId 配置中心的servieId，即服务名。</li>
</ul>
<p>这时发现，在读取配置文件不再写ip地址，而是服务名，这时如果配置服务部署多份，通过负载均衡，从而高可用。</p>
<p>依次启动eureka-servr,config-server,config-client<br>访问网址：<a target="_blank" rel="noopener" href="http://localhost:8889/">http://localhost:8889/</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-1639fdb713faa405.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>访问<a target="_blank" rel="noopener" href="http://localhost:8881/hi%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E6%98%BE%E7%A4%BA%EF%BC%9A">http://localhost:8881/hi，浏览器显示：</a></p>
<blockquote>
<p>foo version 3</p>
</blockquote>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter7">https://github.com/forezp/SpringCloudLearning/tree/master/chapter7</a></p>
<h3 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_spring_cloud_config">spring_cloud_config</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud config</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第10篇：高可用的服务注册中心</title>
    <url>/2017/06/01/springcloud-2017-06-10-sc-ha-eureka/</url>
    <content><![CDATA[<p>文章 <a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a> 介绍了服务注册与发现，其中服务注册中心Eureka Server，是一个实例，当成千上万个服务向它注册的时候，它的负载是非常高的，这在生产环境上是不太合适的，这篇文章主要介绍怎么将Eureka Server集群化。</p>
<span id="more"></span>

<h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><blockquote>
<p>Eureka can be made even more resilient and available by running multiple instances and asking them to register with each other. In fact, this is the default behaviour, so all you need to do to make it work is add a valid serviceUrl to a peer, e.g.</p>
<p> 摘自官网</p>
</blockquote>
<p>Eureka通过运行多个实例，使其更具有高可用性。事实上，这是它默认的熟性，你需要做的就是给对等的实例一个合法的关联serviceurl。</p>
<p>这篇文章我们基于<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter1">第一篇文章的工程</a>，来做修改。</p>
<h3 id="二、改造工作"><a href="#二、改造工作" class="headerlink" title="二、改造工作"></a>二、改造工作</h3><p>在eureka-server工程中resources文件夹下，创建配置文件application-peer1.yml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: peer1</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer1</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;peer2:8769&#x2F;eureka&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>并且创建另外一个配置文件application-peer2.yml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server:</span><br><span class="line">  port: 8769</span><br><span class="line"></span><br><span class="line">spring:</span><br><span class="line">  profiles: peer2</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    hostname: peer2</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;peer1:8761&#x2F;eureka&#x2F;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这时eureka-server就已经改造完毕。</p>
<blockquote>
<p>ou could use this configuration to test the peer awareness on a single host (there’s not much value in doing that in production) by manipulating /etc/hosts to resolve the host names.</p>
</blockquote>
<p>按照官方文档的指示，需要改变etc/hosts，linux系统通过vim /etc/hosts ,加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1 peer1</span><br><span class="line">127.0.0.1 peer2</span><br></pre></td></tr></table></figure>
<p> windows电脑，在c:/windows/systems/drivers/etc/hosts 修改。</p>
<p>这时需要改造下service-hi:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;peer1:8761&#x2F;eureka&#x2F;</span><br><span class="line">server:</span><br><span class="line">  port: 8762</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-hi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="三、启动工程"><a href="#三、启动工程" class="headerlink" title="三、启动工程"></a>三、启动工程</h3><p>启动eureka-server：</p>
<blockquote>
<p>java -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=peer1</p>
</blockquote>
<p>java -jar eureka-server-0.0.1-SNAPSHOT.jar - -spring.profiles.active=peer2</p>
<blockquote>
</blockquote>
<p>启动service-hi:</p>
<blockquote>
<p>java -jar service-hi-0.0.1-SNAPSHOT.jar</p>
</blockquote>
<p>访问：localhost:8761,如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-659c68e405bd70bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="Paste_Image.png"></p>
<p>你会发现注册了service-hi，并且有个peer2节点，同理访问localhost:8769你会发现有个peer1节点。</p>
<p>client只向8761注册，但是你打开8769，你也会发现，8769也有 client的注册信息。</p>
<p>个人感受：这是通过看官方文档的写的demo ，但是需要手动改host是不是不符合Spring Cloud 的高上大？</p>
<blockquote>
<h3 id="Prefer-IP-Address"><a href="#Prefer-IP-Address" class="headerlink" title="Prefer IP Address"></a>Prefer IP Address</h3><p>In some cases, it is preferable for Eureka to advertise the IP Adresses of services rather than the hostname. Set eureka.instance.preferIpAddress to true and when the application registers with eureka, it will use its IP Address rather than its hostname.</p>
<p>摘自官网</p>
</blockquote>
<p>eureka.instance.preferIpAddress=true是通过设置ip让eureka让其他服务注册它。也许能通过去改变去通过改变host的方式。</p>
<p>此时的架构图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-a052854a3084fdd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="有点丑e.png"></p>
<p>Eureka-eserver peer1 8761,Eureka-eserver peer2 8769相互感应，当有服务注册时，两个Eureka-eserver是对等的，它们都存有相同的信息，这就是通过服务器的冗余来增加可靠性，当有一台服务器宕机了，服务并不会终止，因为另一台服务存有相同的数据。</p>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter10">https://github.com/forezp/SpringCloudLearning/tree/master/chapter10</a></p>
<h3 id="四、参考文献"><a href="#四、参考文献" class="headerlink" title="四、参考文献"></a>四、参考文献</h3><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_high_availability_zones_and_regions">high_availability_zones</a></p>
<h3 id="相关文章推荐："><a href="#相关文章推荐：" class="headerlink" title="相关文章推荐："></a>相关文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Eureka</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第9篇：Sleuth</title>
    <url>/2017/06/08/springcloud-2017-06-09-sc09-sleuth/</url>
    <content><![CDATA[<p>这篇文章主要讲述服务追踪组件zipkin，Spring Cloud Sleuth集成了zipkin组件。</p>
<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><blockquote>
<p>Add sleuth to the classpath of a Spring Boot application (see below for Maven and Gradle examples), and you will see the correlation data being collected in logs, as long as you are logging requests.</p>
<p>——  <a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-sleuth">摘自官网</a></p>
</blockquote>
<p>Spring Cloud Sleuth 主要功能就是在分布式系统中提供追踪解决方案，并且兼容支持了 zipkin，你只需要在pom文件中引入相应的依赖即可。</p>
<span id="more"></span>

<h3 id="二、服务追踪分析"><a href="#二、服务追踪分析" class="headerlink" title="二、服务追踪分析"></a>二、服务追踪分析</h3><p>微服务架构上通过业务来划分服务的，通过REST调用，对外暴露的一个接口，可能需要很多个服务协同才能完成这个接口功能，如果链路上任何一个服务出现问题或者网络超时，都会形成导致接口调用失败。随着业务的不断扩张，服务之间互相调用会越来越复杂。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-dd72907e82f89fd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>随着服务的越来越多，对调用链的分析会越来越复杂。它们之间的调用关系也许如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-4b7d1b6abe595390.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<h3 id="三、术语"><a href="#三、术语" class="headerlink" title="三、术语"></a>三、术语</h3><ul>
<li>Span：基本工作单元，例如，在一个新建的span中发送一个RPC等同于发送一个回应请求给RPC，span通过一个64位ID唯一标识，trace以另一个64位ID表示，span还有其他数据信息，比如摘要、时间戳事件、关键值注释(tags)、span的ID、以及进度ID(通常是IP地址)<br>span在不断的启动和停止，同时记录了时间信息，当你创建了一个span，你必须在未来的某个时刻停止它。</li>
<li>Trace：一系列spans组成的一个树状结构，例如，如果你正在跑一个分布式大数据工程，你可能需要创建一个trace。</li>
<li>Annotation：用来及时记录一个事件的存在，一些核心annotations用来定义一个请求的开始和结束<ul>
<li>cs - Client Sent -客户端发起一个请求，这个annotion描述了这个span的开始</li>
<li>sr - Server Received -服务端获得请求并准备开始处理它，如果将其sr减去cs时间戳便可得到网络延迟</li>
<li>ss - Server Sent -注解表明请求处理的完成(当请求返回客户端)，如果ss减去sr时间戳便可得到服务端需要的处理请求时间</li>
<li>cr - Client Received -表明span的结束，客户端成功接收到服务端的回复，如果cr减去cs时间戳便可得到客户端从服务端获取回复的所有所需时间<br>将Span和Trace在一个系统中使用Zipkin注解的过程图形化：</li>
</ul>
</li>
</ul>
<p>将Span和Trace在一个系统中使用Zipkin注解的过程图形化：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-4b865f2a2c271def.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="Paste_Image.png"></p>
<h3 id="四、构建工程"><a href="#四、构建工程" class="headerlink" title="四、构建工程"></a>四、构建工程</h3><p>基本知识讲解完毕，下面我们来实战，本文的案例主要有三个工程组成:一个server-zipkin,它的主要作用使用ZipkinServer 的功能，收集调用数据，并展示；一个service-hi,对外暴露hi接口；一个service-miya,对外暴露miya接口；这两个service可以相互调用；并且只有调用了，server-zipkin才会收集数据的，这就是为什么叫服务追踪了。</p>
<h4 id="4-1-构建server-zipkin"><a href="#4-1-构建server-zipkin" class="headerlink" title="4.1 构建server-zipkin"></a>4.1 构建server-zipkin</h4><p>建一个spring-boot工程取名为server-zipkin，在其pom引入依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;io.zipkin.java&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;zipkin-server&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;io.zipkin.java&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;zipkin-autoconfigure-ui&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Camden.SR6&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>在其程序入口类, 加上注解@EnableZipkinServer，开启ZipkinServer的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableZipkinServer</span><br><span class="line">public class ServerZipkinApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServerZipkinApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在配置文件application.yml指定服务端口为： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server.port&#x3D;9411</span><br></pre></td></tr></table></figure>
<h4 id="4-2-创建service-hi"><a href="#4-2-创建service-hi" class="headerlink" title="4.2 创建service-hi"></a>4.2 创建service-hi</h4><p> 在其pom引入起步依赖spring-cloud-starter-zipkin，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;!--compile(&#39;org.springframework.cloud:spring-cloud-starter-zipkin&#39;)--&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-zipkin&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RC1&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其配置文件application.yml指定zipkin server的地址，头通过配置“spring.zipkin.base-url”指定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">server.port&#x3D;8988</span><br><span class="line">spring.zipkin.base-url&#x3D;http:&#x2F;&#x2F;localhost:9411</span><br><span class="line">spring.application.name&#x3D;service-hi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>通过引入spring-cloud-starter-zipkin依赖和设置spring.zipkin.base-url就可以了。</p>
<p>对外暴露接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line">public class ServiceHiApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceHiApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static final Logger LOG &#x3D; Logger.getLogger(ServiceHiApplication.class.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public RestTemplate getRestTemplate()&#123;</span><br><span class="line">		return new RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;&#x2F;hi&quot;)</span><br><span class="line">	public String callHome()&#123;</span><br><span class="line">		LOG.log(Level.INFO, &quot;calling trace service-hi  &quot;);</span><br><span class="line">		return restTemplate.getForObject(&quot;http:&#x2F;&#x2F;localhost:8989&#x2F;miya&quot;, String.class);</span><br><span class="line">	&#125;</span><br><span class="line">	@RequestMapping(&quot;&#x2F;info&quot;)</span><br><span class="line">	public String info()&#123;</span><br><span class="line">		LOG.log(Level.INFO, &quot;calling trace service-hi &quot;);</span><br><span class="line"></span><br><span class="line">		return &quot;i&#39;m service-hi&quot;;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public AlwaysSampler defaultSampler()&#123;</span><br><span class="line">		return new AlwaysSampler();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-3-创建service-miya"><a href="#4-3-创建service-miya" class="headerlink" title="4.3 创建service-miya"></a>4.3 创建service-miya</h4><p>创建过程痛service-hi，引入相同的依赖，配置下spring.zipkin.base-url。</p>
<p>对外暴露接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@RestController</span><br><span class="line">public class ServiceMiyaApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceMiyaApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	private static final Logger LOG &#x3D; Logger.getLogger(ServiceMiyaApplication.class.getName());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;&#x2F;hi&quot;)</span><br><span class="line">	public String home()&#123;</span><br><span class="line">		LOG.log(Level.INFO, &quot;hi is being called&quot;);</span><br><span class="line">		return &quot;hi i&#39;m miya!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;&#x2F;miya&quot;)</span><br><span class="line">	public String info()&#123;</span><br><span class="line">		LOG.log(Level.INFO, &quot;info is being called&quot;);</span><br><span class="line">		return restTemplate.getForObject(&quot;http:&#x2F;&#x2F;localhost:8988&#x2F;info&quot;,String.class);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Autowired</span><br><span class="line">	private RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">	@Bean</span><br><span class="line">	public RestTemplate getRestTemplate()&#123;</span><br><span class="line">		return new RestTemplate();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="4-4-启动工程，演示追踪"><a href="#4-4-启动工程，演示追踪" class="headerlink" title="4.4 启动工程，演示追踪"></a>4.4 启动工程，演示追踪</h4><p>依次启动上面的三个工程，打开浏览器访问：<a target="_blank" rel="noopener" href="http://localhost:9411/%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%A5%E4%B8%8B%E7%95%8C%E9%9D%A2%EF%BC%9A">http://localhost:9411/，会出现以下界面：</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-d5461a49188ec624.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>访问：<a target="_blank" rel="noopener" href="http://localhost:8989/miya%EF%BC%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E5%87%BA%E7%8E%B0%EF%BC%9A">http://localhost:8989/miya，浏览器出现：</a></p>
<blockquote>
<p>i’m service-hi</p>
</blockquote>
<p>再打开<a target="_blank" rel="noopener" href="http://localhost:9411/%E7%9A%84%E7%95%8C%E9%9D%A2%EF%BC%8C%E7%82%B9%E5%87%BBDependencies,%E5%8F%AF%E4%BB%A5%E5%8F%91%E7%8E%B0%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB%EF%BC%9A">http://localhost:9411/的界面，点击Dependencies,可以发现服务的依赖关系：</a></p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-48cfbe426b23b7a5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>点击find traces,可以看到具体服务相互调用的数据：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-3fe448b513ad867b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600" alt="Paste_Image.png"></p>
<p>本文源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter9">https://github.com/forezp/SpringCloudLearning/tree/master/chapter9</a></p>
<h3 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h3><p><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-sleuth">spring-cloud-sleuth</a></p>
<p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/60165">利用Zipkin对Spring Cloud应用进行服务追踪分析</a></p>
<p><a target="_blank" rel="noopener" href="http://blog.csdn.net/u010257992/article/details/52474639"> Spring Cloud Sleuth使用简介</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud sleuth</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第11篇：docker部署springcloud工程</title>
    <url>/2017/06/11/springcloud-2017-06-11-sc11-docker/</url>
    <content><![CDATA[<h2 id="一、docker简介"><a href="#一、docker简介" class="headerlink" title="一、docker简介"></a>一、docker简介</h2><p>Docker是一个开源的引擎，可以轻松的为任何应用创建一个轻量级的、可移植的、自给自足的容器。开发者在笔记本上编译测试通过的容器可以批量地在生产环境中部署，包括VMs（虚拟机）、bare metal、OpenStack 集群和其他的基础应用平台。 </p>
<span id="more"></span>

<p>Docker通常用于如下场景：</p>
<ul>
<li>web应用的自动化打包和发布；</li>
<li>自动化测试和持续集成、发布；</li>
<li>在服务型环境中部署和调整数据库或其他的后台应用；</li>
<li>从头编译或者扩展现有的OpenShift或Cloud Foundry平台来搭建自己的PaaS环境。</li>
</ul>
<p>Docker 的优点</p>
<ul>
<li><p>1、简化程序：<br>Docker 让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，便可以实现虚拟化。Docker改变了虚拟化的方式，使开发者可以直接将自己的成果放入Docker中进行管理。方便快捷已经是 Docker的最大优势，过去需要用数天乃至数周的    任务，在Docker容器的处理下，只需要数秒就能完成。</p>
</li>
<li><p>2、避免选择恐惧症：<br>如果你有选择恐惧症，还是资深患者。Docker 帮你    打包你的纠结！比如 Docker 镜像；Docker 镜像中包含了运行环境和配置，所以 Docker 可以简化部署多种应用实例工作。比如 Web 应用、后台应用、数据库应用、大数据应用比如 Hadoop 集群、消息队列等等都可以打包成一个镜像部署。</p>
</li>
<li><p>3、节省开支：<br>一方面，云计算时代到来，使开发者不必为了追求效果而配置高额的硬件，Docker 改变了高性能必然高价格的思维定势。Docker 与云的结合，让云空间得到更充分的利用。不仅解决了硬件管理的问题，也改变了虚拟化的方式。</p>
</li>
</ul>
<p>上面文字参考了相关文章；另，关于docker 的安装和基本的使用见<a target="_blank" rel="noopener" href="http://www.runoob.com/docker/docker-tutorial.html">相关教程</a>。</p>
<h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><p>环境条件：</p>
<ul>
<li>linux系统，不建议windows</li>
<li>docker最新版本</li>
<li>jdk 1.8</li>
<li>maven3.0</li>
</ul>
<p>本文采用的工程来自第一篇文章的工程，采用maven的方式去构建项目，并采用docker-maven-plugin去构建docker镜像。</p>
<h2 id="三、改造工程、构建镜像"><a href="#三、改造工程、构建镜像" class="headerlink" title="三、改造工程、构建镜像"></a>三、改造工程、构建镜像</h2><h5 id="改造eureka-server工程"><a href="#改造eureka-server工程" class="headerlink" title="改造eureka-server工程"></a>改造eureka-server工程</h5><p>在pom文件加上插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">			&lt;!-- tag::plugin[] --&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;com.spotify&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;docker-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;0.4.3&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;configuration&gt;</span><br><span class="line">					&lt;imageName&gt;$&#123;docker.image.prefix&#125;&#x2F;$&#123;project.artifactId&#125;&lt;&#x2F;imageName&gt;</span><br><span class="line">					&lt;dockerDirectory&gt;src&#x2F;main&#x2F;docker&lt;&#x2F;dockerDirectory&gt;</span><br><span class="line">					&lt;resources&gt;</span><br><span class="line">						&lt;resource&gt;</span><br><span class="line">							&lt;targetPath&gt;&#x2F;&lt;&#x2F;targetPath&gt;</span><br><span class="line">							&lt;directory&gt;$&#123;project.build.directory&#125;&lt;&#x2F;directory&gt;</span><br><span class="line">							&lt;include&gt;$&#123;project.build.finalName&#125;.jar&lt;&#x2F;include&gt;</span><br><span class="line">						&lt;&#x2F;resource&gt;</span><br><span class="line">					&lt;&#x2F;resources&gt;</span><br><span class="line">				&lt;&#x2F;configuration&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">			&lt;!-- end::plugin[] --&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Spotify 的 docker-maven-plugin 插件是用maven插件方式构建docker镜像的。</p>
<ul>
<li>imageName指定了镜像的名字，本例为 forep/eureka-server</li>
<li>dockerDirectory指定 Dockerfile 的位置</li>
<li>resources是指那些需要和 Dockerfile 放在一起，在构建镜像时使用的文件，一般应用 jar 包需要纳入。</li>
</ul>
<p>修改下配置文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 8761</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">  client:</span><br><span class="line">    registerWithEureka: false</span><br><span class="line">    fetchRegistry: false</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="编写dockerfile文件："><a href="#编写dockerfile文件：" class="headerlink" title="编写dockerfile文件："></a>编写dockerfile文件：</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM frolvlad&#x2F;alpine-oraclejdk8:slim</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD eureka-server-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">#RUN bash -c &#39;touch &#x2F;app.jar&#39;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br><span class="line">EXPOSE 8761</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="docker-file编写指令："><a href="#docker-file编写指令：" class="headerlink" title="docker file编写指令："></a>docker file编写指令：</h4><ul>
<li>FROM</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM &lt;image&gt;</span><br><span class="line">FROM &lt;image&gt;:&lt;tag&gt;</span><br><span class="line">FROM &lt;image&gt; &lt;digest&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>FROM指令必须指定且需要在Dockerfile其他指令的前面，指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。后续的指令都依赖于该指令指定的image。当在同一个Dockerfile中建立多个镜像时，可以使用多个FROM指令。</p>
<ul>
<li>VOLUME</li>
</ul>
<p>格式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">VOLUME [&quot;&#x2F;data&quot;]</span><br></pre></td></tr></table></figure>
<p>使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用，也可以共享给其他容器。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。</p>
<ul>
<li>ADD</li>
</ul>
<p>从src目录复制文件到容器的dest。其中src可以是Dockerfile所在目录的相对路径，也可以是一个URL，还可以是一个压缩包</p>
<ul>
<li>ENTRYPOINT</li>
</ul>
<p>指定Docker容器启动时执行的命令，可以多次设置，但是只有最后一个有效。</p>
<ul>
<li>EXPOSE</li>
</ul>
<p>为Docker容器设置对外的端口号。在启动时，可以使用-p选项或者-P选项。</p>
<h4 id="构建镜像"><a href="#构建镜像" class="headerlink" title="构建镜像"></a>构建镜像</h4><p>执行构建docker镜像maven命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn package docker:build</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<p><img src="http://upload-images.jianshu.io/upload_images/2279594-7b307969f9b753f9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>构建eureka-server镜像成功。</p>
<h4 id="同理构建service-hi镜像"><a href="#同理构建service-hi镜像" class="headerlink" title="同理构建service-hi镜像"></a>同理构建service-hi镜像</h4><ul>
<li>pom文件导入同eurek-server</li>
<li>修改下配置文件：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;eureka-server:8761&#x2F;eureka&#x2F; # 这个需要改为eureka-server</span><br><span class="line">server:</span><br><span class="line">  port: 8763</span><br><span class="line">spring:</span><br><span class="line">  application:</span><br><span class="line">    name: service-hi</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在这里说下：defaultZone发现服务的host改为镜像名。</p>
<ul>
<li><p>dockefile 编写同eureka-server</p>
</li>
<li><p>构建镜像：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean</span><br><span class="line">mvn package docker:build</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/2279594-6e3a82c7216fbc7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>这时我们运行docke的eureka-server 和service-hi镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -p 8761: 8761 -t forezp&#x2F;eureka-server</span><br><span class="line">docker run -p 8763: 8763 -t forezp&#x2F;service-hi</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>访问localhost:8761</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-9199ffddc0bde596.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<h2 id="四、采用docker-compose启动镜像"><a href="#四、采用docker-compose启动镜像" class="headerlink" title="四、采用docker-compose启动镜像"></a>四、采用docker-compose启动镜像</h2><p>Compose 是一个用于定义和运行多容器的Docker应用的工具。使用Compose，你可以在一个配置文件（yaml格式）中配置你应用的服务，然后使用一个命令，即可创建并启动配置中引用的所有服务。下面我们进入Compose的实战吧。</p>
<p>采用docker-compose的方式编排镜像，启动镜像：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  eureka-server:</span><br><span class="line">    image: forezp&#x2F;eureka-server</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 8761:8761</span><br><span class="line"></span><br><span class="line">  service-hi:</span><br><span class="line">    image: forezp&#x2F;service-hi</span><br><span class="line">    restart: always</span><br><span class="line">    ports:</span><br><span class="line">      - 8763:8763</span><br></pre></td></tr></table></figure>


<p>输入命令： docker-compose up</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2279594-a500c3ed7a4513ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>发现2个镜像按照指定的顺序启动了。</p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter11">https://github.com/forezp/SpringCloudLearning/tree/master/chapter11</a></p>
<h2 id="五、采用docker-compose编排并启动镜像"><a href="#五、采用docker-compose编排并启动镜像" class="headerlink" title="五、采用docker-compose编排并启动镜像"></a>五、采用docker-compose编排并启动镜像</h2><p>docker-compose也可以构建镜像，现在我们采用docker-compose的方式构建镜像。</p>
<p>现在以eureka-server为例：<br>将Dockerfile移到eureka-server的主目录，改写ADD的相对路径：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">FROM frolvlad&#x2F;alpine-oraclejdk8:slim</span><br><span class="line">VOLUME &#x2F;tmp</span><br><span class="line">ADD .&#x2F;target&#x2F;eureka-server-0.0.1-SNAPSHOT.jar app.jar</span><br><span class="line">#RUN bash -c &#39;touch &#x2F;app.jar&#39;</span><br><span class="line">ENTRYPOINT [&quot;java&quot;,&quot;-Djava.security.egd&#x3D;file:&#x2F;dev&#x2F;.&#x2F;urandom&quot;,&quot;-jar&quot;,&quot;&#x2F;app.jar&quot;]</span><br><span class="line">EXPOSE 8761</span><br></pre></td></tr></table></figure>
<p>同理修改service-hi目录；</p>
<p>编写构建镜像docker-compose-dev文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line">services:</span><br><span class="line">  eureka-server:</span><br><span class="line">    build: eureka-server</span><br><span class="line">    ports:</span><br><span class="line">      - 8761:8761</span><br><span class="line"></span><br><span class="line">  service-hi:</span><br><span class="line">    build: service-hi</span><br><span class="line">    ports:</span><br><span class="line">      - 8763:8763</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>命令构建镜像并启动：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose -f docker-compose.yml -f docker-compose-dev.yml up </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="http://upload-images.jianshu.io/upload_images/2279594-994f016ca3bd2bcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Paste_Image.png"></p>
<p>源码下载：<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter11-2">https://github.com/forezp/SpringCloudLearning/tree/master/chapter11-2</a></p>
<h2 id="六、参考文献"><a href="#六、参考文献" class="headerlink" title="六、参考文献"></a>六、参考文献</h2><p><a target="_blank" rel="noopener" href="http://www.runoob.com/docker/docker-tutorial.html">docker教程</a></p>
<p><a target="_blank" rel="noopener" href="https://yq.aliyun.com/articles/47344">用 Docker 构建、运行、发布一个 Spring Boot 应用</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/docker/compose">docker-compose</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud docker</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第13篇：Turbine</title>
    <url>/2017/06/13/springcloud-2017-06-13-sc13-turbine/</url>
    <content><![CDATA[<p>上一篇文章讲述了如何利用Hystrix Dashboard去监控断路器的Hystrix command。当我们有很多个服务的时候，这就需要聚合所以服务的Hystrix Dashboard的数据了。这就需要用到Spring Cloud的另一个组件了，即Hystrix Turbine。</p>
<span id="more"></span>

<h2 id="一、Hystrix-Turbine简介"><a href="#一、Hystrix-Turbine简介" class="headerlink" title="一、Hystrix Turbine简介"></a>一、Hystrix Turbine简介</h2><p>看单个的Hystrix Dashboard的数据并没有什么多大的价值，要想看这个系统的Hystrix Dashboard数据就需要用到Hystrix Turbine。Hystrix Turbine将每个服务Hystrix Dashboard数据进行了整合。Hystrix Turbine的使用非常简单，只需要引入相应的依赖和加上注解和配置就可以了。</p>
<h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><p>本文使用的工程为上一篇文章的工程，在此基础上进行改造。因为我们需要多个服务的Dashboard，所以需要再建一个服务，取名为service-lucy，它的基本配置同service-hi，具体见<a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter13">源码</a>,在这里就不详细说明。</p>
<h2 id="三、创建service-turbine"><a href="#三、创建service-turbine" class="headerlink" title="三、创建service-turbine"></a>三、创建service-turbine</h2><p>引入相应的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-turbine&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-netflix-turbine&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其入口类ServiceTurbineApplication加上注解@EnableTurbine，开启turbine，@EnableTurbine注解包含了@EnableDiscoveryClient注解，即开启了注册服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">@SpringBootApplication</span><br><span class="line">@EnableTurbine</span><br><span class="line">public class ServiceTurbineApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">			new SpringApplicationBuilder(ServiceTurbineApplication.class).web(true).run(args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置文件application.yml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  application.name: service-turbine</span><br><span class="line">server:</span><br><span class="line">  port: 8769</span><br><span class="line">security.basic.enabled: false</span><br><span class="line">turbine:</span><br><span class="line">  aggregator:</span><br><span class="line">    clusterConfig: default   # 指定聚合哪些集群，多个使用&quot;,&quot;分割，默认为default。可使用http:&#x2F;&#x2F;...&#x2F;turbine.stream?cluster&#x3D;&#123;clusterConfig之一&#125;访问</span><br><span class="line">  appConfig: service-hi,service-lucy  ### 配置Eureka中的serviceId列表，表明监控哪些服务</span><br><span class="line">  clusterNameExpression: new String(&quot;default&quot;)</span><br><span class="line">  # 1. clusterNameExpression指定集群名称，默认表达式appName；此时：turbine.aggregator.clusterConfig需要配置想要监控的应用名称</span><br><span class="line">  # 2. 当clusterNameExpression: default时，turbine.aggregator.clusterConfig可以不写，因为默认就是default</span><br><span class="line">  # 3. 当clusterNameExpression: metadata[&#39;cluster&#39;]时，假设想要监控的应用配置了eureka.instance.metadata-map.cluster: ABC，则需要配置，同时turbine.aggregator.clusterConfig: ABC</span><br><span class="line">eureka:</span><br><span class="line">  client:</span><br><span class="line">    serviceUrl:</span><br><span class="line">      defaultZone: http:&#x2F;&#x2F;localhost:8761&#x2F;eureka&#x2F;</span><br><span class="line">      </span><br><span class="line">     </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>配置文件注解写的很清楚。</p>
<h2 id="四、Turbine演示"><a href="#四、Turbine演示" class="headerlink" title="四、Turbine演示"></a>四、Turbine演示</h2><p>依次开启eureka-server、service-hi、service-lucy、service-turbine工程。</p>
<p>打开浏览器输入：<a target="_blank" rel="noopener" href="http://localhost:8769/turbine.stream,%E7%95%8C%E9%9D%A2%E5%A6%82%E4%B8%8B%EF%BC%9A">http://localhost:8769/turbine.stream,界面如下：</a></p>
<p><img src="http://img.blog.csdn.net/20170416135735474?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>依次请求：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8762/hi?name=forezp">http://localhost:8762/hi?name=forezp</a> </p>
</blockquote>
<p><a target="_blank" rel="noopener" href="http://localhost:8763/hi?name=forezp">http://localhost:8763/hi?name=forezp</a></p>
<p>打开:<a target="_blank" rel="noopener" href="http://localhost:8763/hystrix,%E8%BE%93%E5%85%A5%E7%9B%91%E6%8E%A7%E6%B5%81http://localhost:8769/turbine.stream">http://localhost:8763/hystrix,输入监控流http://localhost:8769/turbine.stream</a></p>
<p><img src="http://img.blog.csdn.net/20170416140029540?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>点击monitor stream 进入页面：</p>
<p><img src="http://img.blog.csdn.net/20170416140256754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>可以看到这个页面聚合了2个service的hystrix dashbord数据。</p>
<p>源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter13">https://github.com/forezp/SpringCloudLearning/tree/master/chapter13</a></p>
<h2 id="五、参考文献"><a href="#五、参考文献" class="headerlink" title="五、参考文献"></a>五、参考文献</h2><p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_circuit_breaker_hystrix_dashboard">hystrix_dashboard</a></p>
<p><a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/spring-cloud.html#_turbine">turbine</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Turbine</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第14篇：Consule</title>
    <url>/2017/06/14/springcloud-2017-06-14-sc14-consul/</url>
    <content><![CDATA[<p>这篇文章主要介绍 spring cloud consul 组件，它是一个提供服务发现和配置的工具。consul具有分布式、高可用、高扩展性。</p>
<span id="more"></span>

<h2 id="一、consul-简介"><a href="#一、consul-简介" class="headerlink" title="一、consul 简介"></a>一、consul 简介</h2><p>consul 具有以下性质：</p>
<ul>
<li>服务发现：consul通过http 方式注册服务，并且服务与服务之间相互感应。</li>
<li>服务健康监测</li>
<li>key/value 存储</li>
<li>多数据中心</li>
</ul>
<p>consul可运行在mac windows linux 等机器上。</p>
<h2 id="二、consul安装"><a href="#二、consul安装" class="headerlink" title="二、consul安装"></a>二、consul安装</h2><p>linux</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ mkdir -p $GOPATH&#x2F;src&#x2F;github.com&#x2F;hashicorp &amp;&amp; cd $!</span><br><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;hashicorp&#x2F;consul.git</span><br><span class="line">$ cd consul</span><br><span class="line">$ make bootstrap</span><br><span class="line">$ make bootstrap</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>windows下安装：<br>见<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70188595">consul怎么在windows下安装</a></p>
<h2 id="三、构建工程"><a href="#三、构建工程" class="headerlink" title="三、构建工程"></a>三、构建工程</h2><p>构建一个consul-miya的springboot工程，导入依赖pring-cloud-starter-consul-discovery，其依赖文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span><br><span class="line"></span><br><span class="line">	&lt;groupId&gt;com.forezp&lt;&#x2F;groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;consul-miya&lt;&#x2F;artifactId&gt;</span><br><span class="line">	&lt;version&gt;0.0.1-SNAPSHOT&lt;&#x2F;version&gt;</span><br><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span><br><span class="line"></span><br><span class="line">	&lt;name&gt;consul-miya&lt;&#x2F;name&gt;</span><br><span class="line">	&lt;description&gt;Demo project for Spring Boot&lt;&#x2F;description&gt;</span><br><span class="line"></span><br><span class="line">	&lt;parent&gt;</span><br><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;version&gt;1.5.2.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">		&lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;</span><br><span class="line">	&lt;&#x2F;parent&gt;</span><br><span class="line"></span><br><span class="line">	&lt;properties&gt;</span><br><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span><br><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span><br><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span><br><span class="line">	&lt;&#x2F;properties&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencies&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-consul-discovery&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">	&lt;&#x2F;dependencies&gt;</span><br><span class="line"></span><br><span class="line">	&lt;dependencyManagement&gt;</span><br><span class="line">		&lt;dependencies&gt;</span><br><span class="line">			&lt;dependency&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;</span><br><span class="line">				&lt;version&gt;Dalston.RELEASE&lt;&#x2F;version&gt;</span><br><span class="line">				&lt;type&gt;pom&lt;&#x2F;type&gt;</span><br><span class="line">				&lt;scope&gt;import&lt;&#x2F;scope&gt;</span><br><span class="line">			&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;&#x2F;dependencies&gt;</span><br><span class="line">	&lt;&#x2F;dependencyManagement&gt;</span><br><span class="line"></span><br><span class="line">	&lt;build&gt;</span><br><span class="line">		&lt;plugins&gt;</span><br><span class="line">			&lt;plugin&gt;</span><br><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">			&lt;&#x2F;plugin&gt;</span><br><span class="line">		&lt;&#x2F;plugins&gt;</span><br><span class="line">	&lt;&#x2F;build&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;&#x2F;project&gt;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>在其入口文件ConsulMiyaApplication加入注解@EnableDiscoveryClient，开启服务发现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableDiscoveryClient</span><br><span class="line">@RestController</span><br><span class="line">public class ConsulMiyaApplication &#123;</span><br><span class="line"></span><br><span class="line">	@RequestMapping(&quot;&#x2F;hi&quot;)</span><br><span class="line">	public String home() &#123;</span><br><span class="line">		return &quot;hi ,i&#39;m miya&quot;;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		new SpringApplicationBuilder(ConsulMiyaApplication.class).web(true).run(args);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在其配置文件application.yml指定consul服务的端口为8500：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span><br><span class="line">  cloud:</span><br><span class="line">    consul:</span><br><span class="line">      host: localhost</span><br><span class="line">      port: 8500</span><br><span class="line">      discovery:</span><br><span class="line">        healthCheckPath: $&#123;management.contextPath&#125;&#x2F;health</span><br><span class="line">        healthCheckInterval: 15s</span><br><span class="line">        instance-id: consul-miya</span><br><span class="line">  application:</span><br><span class="line">    name: consul-miya</span><br><span class="line">server:</span><br><span class="line">  port: 8502</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>启动工程，访问localhost:8500,可以发现consul-miya被注册了。</p>
<p>源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter14">https://github.com/forezp/SpringCloudLearning/tree/master/chapter14</a></p>
<h4 id="四、参考资料"><a href="#四、参考资料" class="headerlink" title="四、参考资料"></a>四、参考资料</h4><p><a target="_blank" rel="noopener" href="https://github.com/HashiCorp/consul">HashiCorp/consul</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-cloud/spring-cloud-consul/blob/master/docs/src/main/asciidoc/spring-cloud-consul.adoc#install-consul">Spring Cloud Consul</a></p>
<p><a target="_blank" rel="noopener" href="https://www.consul.io/docs/upgrading.html">consul.io</a></p>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud Consule</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud教程第12篇：Hystrix Dashboard</title>
    <url>/2017/06/12/springcloud-2017-06-12-sc12-hystix-dashboard/</url>
    <content><![CDATA[<p>在我的第四篇文章<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69934399">断路器</a>讲述了如何使用断路器，并简单的介绍了下Hystrix Dashboard组件，这篇文章更加详细的介绍Hystrix Dashboard。</p>
<span id="more"></span>

<h2 id="一、Hystrix-Dashboard简介"><a href="#一、Hystrix-Dashboard简介" class="headerlink" title="一、Hystrix Dashboard简介"></a>一、Hystrix Dashboard简介</h2><p>在微服务架构中为例保证程序的可用性，防止程序出错导致网络阻塞，出现了断路器模型。断路器的状况反应了一个程序的可用性和健壮性，它是一个重要指标。Hystrix Dashboard是作为断路器状态的一个组件，提供了数据监控和友好的图形化界面。</p>
<h2 id="二、准备工作"><a href="#二、准备工作" class="headerlink" title="二、准备工作"></a>二、准备工作</h2><p>本文的的工程栗子，来源于<a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">第一篇文章</a>的栗子，在它的基础上进行改造。</p>
<h2 id="三、开始改造service-hi"><a href="#三、开始改造service-hi" class="headerlink" title="三、开始改造service-hi"></a>三、开始改造service-hi</h2><p>在pom的工程文件引入相应的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line"></span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br><span class="line">		&lt;dependency&gt;</span><br><span class="line">			&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span><br><span class="line">			&lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;</span><br><span class="line">		&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>其中，这三个依赖是必须的，缺一不可。</p>
<p>在程序的入口ServiceHiApplication类，加上@EnableHystrix注解开启断路器，这个是必须的，并且需要在程序中声明断路点HystrixCommand；加上@EnableHystrixDashboard注解，开启HystrixDashboard</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@EnableEurekaClient</span><br><span class="line">@RestController</span><br><span class="line">@EnableHystrix</span><br><span class="line">@EnableHystrixDashboard</span><br><span class="line">public class ServiceHiApplication &#123;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) &#123;</span><br><span class="line">		SpringApplication.run(ServiceHiApplication.class, args);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Value(&quot;$&#123;server.port&#125;&quot;)</span><br><span class="line">	String port;</span><br><span class="line">	@RequestMapping(&quot;&#x2F;hi&quot;)</span><br><span class="line">	@HystrixCommand(fallbackMethod &#x3D; &quot;hiError&quot;)</span><br><span class="line">	public String home(@RequestParam String name) &#123;</span><br><span class="line">		return &quot;hi &quot;+name+&quot;,i am from port:&quot; +port;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public String hiError(String name) &#123;</span><br><span class="line">		return &quot;hi,&quot;+name+&quot;,sorry,error!&quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>运行程序： 依次开启eureka-server 和service-hi.</p>
<h2 id="四、Hystrix-Dashboard图形展示"><a href="#四、Hystrix-Dashboard图形展示" class="headerlink" title="四、Hystrix Dashboard图形展示"></a>四、Hystrix Dashboard图形展示</h2><p>打开<a target="_blank" rel="noopener" href="http://localhost:8762/hystrix.stream%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E4%B8%80%E4%BA%9B%E5%85%B7%E4%BD%93%E7%9A%84%E6%95%B0%E6%8D%AE%EF%BC%9A">http://localhost:8762/hystrix.stream，可以看到一些具体的数据：</a></p>
<p><img src="http://img.blog.csdn.net/20170416111909110?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>打开locahost:8762/hystrix 可以看见以下界面：</p>
<p><img src="http://img.blog.csdn.net/20170416110739541?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>在界面依次输入：locahost:8762/hystrix.stream 、2000 、miya<br>；点确定。</p>
<p>在另一个窗口输入： <a target="_blank" rel="noopener" href="http://localhost:8762/hi?name=forezp">http://localhost:8762/hi?name=forezp</a></p>
<p>重新刷新hystrix.stream网页，你会看到良好的图形化界面：</p>
<p><img src="http://img.blog.csdn.net/20170416111243262?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvZm9yZXpw/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p>
<p>源码下载：<br><a target="_blank" rel="noopener" href="https://github.com/forezp/SpringCloudLearning/tree/master/chapter12">https://github.com/forezp/SpringCloudLearning/tree/master/chapter12</a></p>
<h2 id="五、参考资料"><a href="#五、参考资料" class="headerlink" title="五、参考资料"></a>五、参考资料</h2><p><a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/tree/master/hystrix-dashboard">hystrix-dashboard</a></p>
<h3 id="优秀文章推荐："><a href="#优秀文章推荐：" class="headerlink" title="优秀文章推荐："></a>优秀文章推荐：</h3><ul>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70148833">史上最简单的 SpringCloud 教程 | 终章</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/69696915">史上最简单的 SpringCloud 教程 | 第一篇: 服务的注册与发现（Eureka）</a></li>
<li><a target="_blank" rel="noopener" href="http://blog.csdn.net/forezp/article/details/70037513">史上最简单的SpringCloud教程 | 第七篇: 高可用的分布式配置中心(Spring Cloud Config)</a></li>
</ul>
]]></content>
      <categories>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>SpringCloud HystrixDashboard</tag>
      </tags>
  </entry>
  <entry>
    <title>官方翻墙服务，多条线路，IP不怕被墙</title>
    <url>/2022/08/15/vpn-vpn/</url>
    <content><![CDATA[<h1>Just My Socks：搬瓦工官方翻墙服务，多条线路，IP不怕被墙</h1>
<h2>力荐！Just My Socks - 非常靠谱稳定的shadowsocks/V2ray代理服务！</h2>
<h2>文章目录</h2>
<ol id="user-content-content-index-contents">
     <li><a href="#user-content-just1">Just My Socks介绍</a></li>
     <li><a href="#user-content-just2">Just My Socks购买</a></li>
     <li><a href="#user-content-just3">Just My Socks优惠码</a></li>
     <li><a href="#user-content-just4">Just My Socks注册</a></li>
     <li><a href="#user-content-just5">Just My Socks信息查看</a></li>
     <li><a href="#user-content-just6">Just My Socks怎么用</a></li>
</ol>
<p class="keepp">
Just My Socks是目前非常火热的一个Shadowsocks/V2ray服务商（机场），由搬瓦工官方推出，每个服务提供5条线路，包括最快的CN2 GIA线路。Just My Socks最大的优势是保证IP不被墙，如果IP被墙，会自动更换新的可用IP给用户。对于只是需要翻墙看看YouTube、ins或者谷歌以及谷歌学术的朋友，Just My Socks是一个非常合适的选择。
</p>

<span id="more"></span>

<h2 id="user-content-just1"><span id="just_my_socks">一、Just My Socks介绍</span></h2>
<p class="keepp">
Just My Socks是<strong>搬瓦工官方</strong>出品的Shadowsocks/V2ray代理服务，支持支付宝付款，提供ss账号，每个账号有5条线路，包括<strong>搬瓦工CN2 GIA线路</strong>，性价比很高且非常稳定，比买VPS灵活划算且省得折腾，<strong>保证IP可用，被封自动切换</strong>。
</p>
<p class="keepp">
<strong>Just My Socks靠谱吗？</strong>不同于其他机场，Just My Socks是搬瓦工官方推出的，已经稳定运行了近1年了（2018年10月推出的），可以说非常靠谱。
</p>
<p class="keepp">
<strong>Just My Socks怎么样？</strong>每个ss账号有5个线路，包括最快的搬瓦工CN2 GIA线路，速度很快。
</p>
<p class="keepp">
<strong>哪些人适合用Just My Socks？</strong>如果你只是为了翻墙看看YouTube、刷刷ins，或者谷歌，那么你完全不需要折腾VPS，自建ss，Just My Socks可以非常方便的达到这些需求。<strong>Just My Socks缺点</strong>：无法看Netflix。
</p>
<p class="keepp">
<strong>支持的协议：TCP或UDP？</strong>
Just My Socks 100仅支持TCP协议，该协议足以用于浏览网络以及使用YouTube等大多数流媒体服务。从Just My Socks 500开始的所有套餐均支持TCP和UDP协议（请参阅下面的注释）。语音协议（如WhatsApp和某些VOIP实现）可能需要UDP协议。如果您的套餐是Just My Socks 100，并且您想使用UDP协议，那么您将需要升级到Just My Socks 500套餐。
</p>
<h2 id="user-content-just2"><span id="just_my_socks-2">二、Just My Socks购买</span></h2>
<p class="keepp">目前，Just My Socks一共有4种方案：</p>
<table id="tablepress-1">
<thead>
<tr>
<th>方案名称</th>
<th>带宽</th>
<th>流量</th>
<th>价格</th>
<th>设备限制</th>
<th>购买链接</th>
</tr>
</thead>
<tbody>
<tr>
<td>Just My Socks 100</td>
<td>1 GB</td>
<td>100 GB /月</td>
<td>$2.88 / 月</td>
<td>最多3个设备同时在线(当前断货)</td>
<td><a rel="nofollow noopener" target="_blank" href="https://justmysocks3.net/members/aff.php?aff=17752">立即购买</a></td>
</tr>
<tr>
<td>Just My Socks 500</td>
<td>2.5 GB</td>
<td>500 GB / 月</td>
<td>$5.88 / 月</td>
<td>最多5个设备同时在线</td>
<td><a rel="nofollow noopener" target="_blank" href="https://justmysocks3.net/members/aff.php?aff=17752">立即购买</a></td>
</tr>
<tr>
<td>Just My Socks 1000</td>
<td>5 GB</td>
<td>1TB / 月</td>
<td>$9.88 / 月</td>
<td>不限制设备数量</td>
<td><a rel="nofollow noopener" target="_blank" href="https://justmysocks3.net/members/aff.php?aff=17752">立即购买</a></td>
</tr>
<tr>
<td>Just My Socks 5000</td>
<td>5 GB</td>
<td>5TB / 月</td>
<td>$48.99 / 月</td>
<td>不限制设备数量</td>
<td><a rel="nofollow noopener" target="_blank" href="https://justmysocks3.net/members/aff.php?aff=17752">立即购买</a></td>
</tr>
</tbody>
</table>
<p class="keepp">
<strong>我该选择哪一款Just My Socks？</strong>一般来说，如果只是谷歌查资料，直接选择最便宜的方案就行，如果你爱看视频，并且非常频繁，那么就选择500或者1000的，需要注意的是<span style="color: #ff0000;">便宜方案都有设备限制</span>，如果你想多个人一起用，那么建议选择1000的，不限制设备数量。
</p>
<p class="keepp">
选择合适的Just My Socks方案后，点击“立即购买”进入购买页，确认配置无误后，建议年付（Annually），只需要付10个月的价格，点击Continue继续：
<br class="keepp">
Just My Socks 官网：<a rel="nofollow noopener" target="_blank" href="https://justmysocks3.net/members/aff.php?aff=17752">Just My Socks 官网</a>
</p>
<a href="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617105821.png" target="_blank" rel="noopener noreferrer"><img style="max-width:100%" src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617105821.png" alt="Just My Socks 购买教程，若图片无法显示请点击查看" /></a>
<h2 id="user-content-just3"><span id="just_my_socks-3">三、Just My Socks优惠码</span></h2>
<p class="keepp">
在购买Just My Socks时，我们可以使用Just My Socks优惠码：<strong>JMS9272283</strong>获取5.2%循环优惠，输入优惠码后点击Validate Code即可使用优惠码，点击Checkout付款：
<br class="keepp">
<a href="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617110034.png" target="_blank" rel="noopener noreferrer"><img style="max-width:100%" src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617110034.png" alt="Just My Socks优惠码，若图片无法显示请点击查看" /></a>
</p>
<h2 id="user-content-just4"><span id="just_my_socks-4">四、Just My Socks注册</span></h2>
<p class="keepp">
这里需要填写你Just My Socks账号的信息：<strong>不要挂代理注册，如实填写</strong>，否则可能被认为欺诈，其中省份直接写拼音即可（例如Shandong），选择支付方式为Paypal（Paypal更安全）或 Alipay（支付宝），勾选同意服务条款后，点击Complete Order完成订单：
<br class="keepp">
<a href="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617110207.png" target="_blank" rel="noopener noreferrer"><img style="max-width:100%" src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617110207.png" alt="Just My Socks 注册信息，若图片无法显示请点击查看" /></a>
<br class="keepp">
用支付宝付款完成后，你的Just My Socks服务就购买完成了。
</p>
<h2 id="user-content-just5"><span id="just_my_socks-5">五、Just My Socks信息查看</span></h2>
<p class="keepp">
完成Just My Socks购买后，登陆<a rel="nofollow noopener" target="_blank" href="https://justmysocks3.net/members/aff.php?aff=17752">Just My Socks 官网</a>，选择Services->My Services，就可以看到你刚才买的服务了，点击这个服务查看详情：
<br class="keepp">
<a href="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617110310.png" target="_blank" rel="noopener noreferrer"><img style="max-width:100%" src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617110310.png" alt="Just My Socks 我的服务，若图片无法显示请点击查看" /></a>
</p>
<p class="keepp">
这里就可以看到Shadowsocks/V2ray详情了，包括加密方式，端口，密码和IP（有5个节点，域名形式发放）等等：
<br class="keepp">
<a href="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617110404.png" target="_blank" rel="noopener noreferrer"><img style="max-width:100%" src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617110404.png" alt="Just My Socks shadowsocks详情，若图片无法显示请点击查看" /></a>
</p>
<h2 id="user-content-just6"><span id="just_my_socks-6">六、Just My Socks怎么用</span></h2>

<p>有了Shadowsocks/V2ray账号后，接下来怎么用？剩下的只需要下载安装Shadowsocks/V2ray客户端（<em><strong>注意：Just My Socks不支持SSR，不要使用SSR客户端，请使用下图中的<a rel="nofollow noopener" target="_blank" href="https://justmysocks3.net/members/aff.php?aff=17752">Just My Socks 官网</a>的下载链接下载客户端</strong></em>），然后将购买的服务器导入客户端即可使用啦。</p>
<p><b>第1～5条线路介绍</b></p>
<p>cXs1，cXs2和cXs5通过CN2 GT网络与其他中国联通和中国移动直接连接进行路由。</p>
<p>服务器cXs3通过中国电信提供的CN2 GIA网络进行路由（仅中国电信路由）。</p>
<p>服务器cXs4通过高级中国移动混合路由（在返回路径上具有CN2 GIA）（仅中国移动路由）。</p>
<p>注意2020-08-11作为实验，某些cXs4服务器在返回路径上对所有3个运营商（CU / CM / CT）使用具有GIA支持的荷兰POP</p>
<p><b>第6条线路：什么是Freedom服务器（s801）？</b></p>
<p>Freedom服务器可以提供更多的数据传输，具体取决于当前的乘数。该服务器提供了较便宜的路由，并且不提供任何形式的保证。用它来节省您的每月数据传输津贴。</p>
<p>例如，如果当前数据传输倍数= 10，那么您下载的所有内容中只有1/10会计入每月数据配额。</p>
<p>实际示例：假设您下载20GB的文件。如果您使用s1..s5范围内的服务器进行下载，则系统将计入所有20GB的数据传输（加上任何TCP开销）。 但是，如果您使用服务器s801进行此传输，并且当前乘数为10，则系统将仅占该传输的1/10（20 GB / 10 = 2 GB）</p>
<p>注意：数据传输乘数可以随时更改。官方不提供有关服务器s801的任何质量或正常运行时间保证。它是出于礼貌提供的，可以随时脱机使用。</p>
<p>备注：上面是官方解释，简单点就是最后一条线路没有前面5条线路好，所以使用它时流量消耗会进行打折，相当于可以节省流量，但速度要慢点，主要取决于自己的需求。</p>
<h3>在just_my_socks网站，参考下图下载对应操作系统的客户端</h3>
<img style="max-width:100%" src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617110554.png" alt="SS客户端下载，若图片无法显示请点击查看" />
<img style="max-width:100%" src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/20210617110636.png" alt="SS client download，若图片无法显示请点击查看" />
<p class="keepp"><strong>反馈交流：</strong><a target="_blank" href="https://github.com/ChengKeJ/JustMySocks/issues"  rel="nofollow noopener">如果有任何问题，欢迎大家交流！</a></p>
<p class="keepp"><strong>免责声明：</strong>我们推荐的任何产品和服务已努力确保可靠持久，但我们不为此承担任何责任。本库一切资源仅用作交流学习，请勿用作商业或违法行为！如造成任何后果，本库概不负责！</p>

]]></content>
      <categories>
        <category>vpn</category>
      </categories>
      <tags>
        <tag>vpn</tag>
      </tags>
  </entry>
  <entry>
    <title>Google Drive 和 Dropbox 系统设计概述</title>
    <url>/2023/08/25/systemDesign-gd/</url>
    <content><![CDATA[<p>在现代信息世界中，我们有许多照片、文件、视频等需要存储。我相信几乎所有人都尝试过使用 Google Drive 或 Dropbox。</p>
<h3 id="功能需求"><a href="#功能需求" class="headerlink" title="功能需求"></a>功能需求</h3><ol>
<li>用户可以从任何设备上传和下载文件。</li>
<li>用户可以通过替换相同的文件名来更新文件。</li>
<li>用户可以通过电子邮件链接将文件和文件夹分享给其他人。</li>
<li>用户可以随时从任何设备删除文件和文件夹。</li>
<li>删除的文件和文件夹将在回收站中存储 15 天。</li>
<li>系统应该支持离线编辑。用户可以在离线状态下添加/修改文件和文件夹名称，一旦网络恢复，更改将与远程服务器同步。</li>
<li>用户可以进行文件版本管理，以恢复文件的先前版本。（系统可以支持多次更改的同一文件的多个版本，带宽和所需空间将显著增加）</li>
<li>系统可以支持跨设备的文件和文件夹同步。</li>
<li>系统允许每个用户免费上传高达 10 GB 的文件。</li>
<li>系统将为不同存储大小提供不同的市场计划。</li>
</ol>
<span id="more"></span>

<h3 id="非功能需求"><a href="#非功能需求" class="headerlink" title="非功能需求"></a>非功能需求</h3><ol>
<li>系统必须高度可靠。任何上传的文件都不得丢失。用户可以恢复其重要文件。</li>
<li>系统可以支持每周 7 天 24 小时。</li>
<li>用户可以随时升级其计划，并立即使用系统。</li>
<li>用户必须能够轻松地将其系统与其他应用程序集成。例如，系统支持通过其他应用程序共享文档。</li>
<li>系统可以提供延迟或并发利用（这意味着以高效的方法从云中反复上传和下载完整文件）。</li>
</ol>
<h3 id="存储估算"><a href="#存储估算" class="headerlink" title="存储估算"></a>存储估算</h3><ol>
<li>用户数量 = 5 亿</li>
<li>活跃用户数量 = 1 亿</li>
<li>用户平均存储的文件数量 = 300</li>
<li>每个文件的平均大小 = 200 KB</li>
<li>总文件数量 = 5 亿 * 300 = 1500 亿</li>
<li>需要的总存储空间 = 1500 亿 * 200 KB = 30 PB</li>
</ol>
<h3 id="系统组件"><a href="#系统组件" class="headerlink" title="系统组件"></a>系统组件</h3><ol>
<li><strong>客户端</strong>（安装在您的桌面或移动应用程序中，用于访问与存储相关的应用程序）<ul>
<li>监视用户机器上的工作区文件夹，并通过与远程服务器同步文件来维护一致性。因此，它必须由 4 个基本组件组成，即<strong>监视器、分块器、索引器和内部数据库</strong>。</li>
<li><strong>监视器</strong>将监视本地工作区文件夹，并通知索引器用户执行的任何操作（添加、删除、替换和更新文件或文件夹），并追踪来自其他设备的任何更改，这些更改由同步服务广播。</li>
<li><strong>分块器</strong>将文件分成更小的块，并从这些块中重建文件，以便完整的文件可以在没有任何丢失块的情况下传输。分块算法将检测用户修改的文件部分，并仅将已修改的部分传输到云存储，从而节省带宽和同步时间。</li>
<li><strong>索引器</strong>将处理来自监视器的事件，并更新内部元数据数据库。一旦成功从云存储下载或上传了块，索引器将与远程同步服务通信，广播更改给其他客户端，并更新远程元数据数据库。</li>
<li><strong>内部元数据数据库</strong>将跟踪所有文件、块、任何已更新的版本以及其在文件系统中的位置。</li>
<li>客户端应用程序将通过请求上传、下载和编辑 API 与后端云存储服务器进行通信。客户端还与远程同步服务进行交互，以处理任何文件元数据更新，例如文件名、大小、修改日期等。</li>
</ul>
</li>
<li><strong>元数据数据库</strong><ul>
<li>保持有关文件、块、用户、设备、工作区和存储位置的版本和元数据信息。</li>
<li>元数据数据库可以是关系数据库，如 MySQL，也可以是 NoSQL 数据库服务，如 DynamoDB。</li>
<li>同步服务在多个用户同时处理同一文件时，提供文件的一致视图。</li>
<li>由于 NoSQL 数据存储不支持 ACID 属性，编程代码会将 ACID 属性与 NoSQL 数据库结合在一起，用于同步服务的逻辑。</li>
</ul>
</li>
<li><strong>同步服务</strong><ul>
<li>更新客户端创建的文件或文件夹。</li>
<li>将客户端的本地数据库与存储在远程元数据数据库中的信息同步。</li>
<li>使用 HTTP 长轮询从云存储获取响应，或在脱机一段时间后将文件和更新发送到云存储，一旦重新脱机，将向所有设备或用户发送通知。</li>
<li>同步服务还尝试在客户端和云存储之间传输更少的数据，以实现更快的响应时间，因此使用差异化算法来减少需要同步的数据量。不再将整个文件从客户端传输到服务器，而是传输两个版本文件之间的差异。仅传输已更改的部分（块）。这减少了终端用户的带宽消耗和</li>
</ul>
</li>
</ol>
<p>云数据存储。服务器和客户端将计算哈希值，以查看是否更新修改的块。该过程称为数据去重。</p>
<ol start="4">
<li><strong>消息队列服务</strong><ul>
<li>这是一个处理读写请求数量的消息中间件。</li>
<li>一个可扩展的消息队列服务，支持客户端和同步服务之间的异步通信。</li>
<li>可用性和可靠性必须被设计得最适合消息队列服务。</li>
<li><strong>请求队列</strong>：此队列将在所有客户端之间共享。当客户端执行任何更新和请求时，此请求将发送到消息队列服务，然后由同步服务进一步处理，最后更新元数据数据库。</li>
<li><strong>响应队列</strong>：每个客户端都有一个相关的响应队列，因为每个客户端都有一个单独的响应队列。</li>
<li>一旦文件更新，同步服务将通知所有响应队列有关更改的信息，然后响应队列将通知每个客户端进行的更改。</li>
</ul>
</li>
<li><strong>云/块存储</strong><ul>
<li>存储文件的块</li>
<li>使用 Amazon S3 服务</li>
<li>客户端将使用 API 服务与云存储进行交互</li>
</ul>
</li>
</ol>
<p><img src="https://miro.medium.com/v2/resize:fit:1380/0*zJz9WxZ9MEEO3zmE.png" alt="0*zJz9WxZ9MEEO3zmE.png"></p>
<ul>
<li><p><strong>文件处理工作流程</strong>：客户端 A 将块上传到云存储，然后更新元数据并提交更改，然后获得确认。服务器将通知客户端 B 和 C 有关更改的信息。客户端 B 和 C 接收元数据更改并下载更新的块。</p>
</li>
<li><p><strong>数据去重</strong>：消除数据的重复副本。这还可以减少相同数据传输（发送的字节数）以提高传输速率。对于每个传入的块，都会打上一个哈希标签，然后计算并将该哈希与现有块的所有其他哈希进行比较。</p>
<p>a) <strong>后处理去重</strong>：新块存储在存储设备上，并且将分析块以了解它们是否是重复的。优点是，客户端不需要等待哈希计算或查找完成，然后再存储数据，这会提高存储性能。缺点是短时间内会存储不必要的重复数据，并且会传输和消耗带宽。</p>
<p>b) <strong>内联去重</strong>：去重哈希计算可以实时执行，以便系统可以识别重复块，然后仅存储不存在的块。优点是优化网络和存储使用。缺点是消耗用户的时间并降低存储性能。</p>
</li>
</ul>
<ol start="6">
<li><strong>缓存</strong><ul>
<li>在 Google Drive / Dropbox 系统设计中有两种类型的缓存</li>
<li>用于块存储的缓存</li>
<li>使用像 Memcache 这样的现成解决方案的缓存，可以存储带有其相应 ID/哈希的整个块和块服务器</li>
<li>可以采用最近最少使用（LRU）缓存策略。</li>
</ul>
</li>
<li><strong>负载均衡器（LB）</strong><ul>
<li>在客户端和块服务器之间</li>
<li>在客户端和元数据服务器之间</li>
<li>在后端服务器之间平均分配传入的请求</li>
</ul>
</li>
<li><strong>安全性/权限和文件共享</strong><ul>
<li>上传/下载的文件将与远程服务器同步</li>
<li>不允许对单个文件进行多个操作（并发问题）</li>
<li>如果在某个过程中出现了某些连接问题，客户端必须重新上传或下载整个文件，或者恢复下载或上传块。</li>
</ul>
</li>
</ol>
<p><strong>系统 API</strong></p>
<ol>
<li>Upload(string uploadToken, fileInfo file, userInfo user)</li>
<li>Edit(string authToken, fileInfo file, userInfo user)</li>
<li>Delete(string authToken, fileInfo file, userInfo user)</li>
<li>Download(string authToken, fileInfo file, userInfo user)</li>
<li>GenerateToken (string userName, string password)</li>
</ol>
<p><strong>高级系统架构</strong></p>
<p><strong>详细系统架构</strong></p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/0*ujFLQbJIrcSd7LKu" alt="Image.png"></p>
]]></content>
      <categories>
        <category>system design</category>
      </categories>
      <tags>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title>通知系统设计：如何将其集成到我们的基础架构中</title>
    <url>/2023/08/12/systemDesign-msg/</url>
    <content><![CDATA[<h2 id="什么是面向企业的通知？"><a href="#什么是面向企业的通知？" class="headerlink" title="什么是面向企业的通知？"></a>什么是面向企业的通知？</h2><p>毫无疑问，没有任何数字化企业可以在没有通知的情况下生存。通过通过电子邮件、短信或推送通知等各种渠道发送及时通知，企业可以提高客户参与度和留存率，促使重复购买。通知还为企业提供了一个机会，可以收集客户反馈和见解，这可以用于改善其产品或服务。</p>
<p>最终，一个设计良好的通知服务可以帮助企业与客户建立牢固持久的关系，从而实现长期的成功。因此，无论何时，所有产品都需要为技术提供通知集成的要求。</p>
<h2 id="规划集成"><a href="#规划集成" class="headerlink" title="规划集成"></a>规划集成</h2><p>由于通知的功能性/非功能性要求在公司/企业之间基本相似，并且每个人都了解什么是通知功能，因此我们可以迅速记录一些业务需求，并立即开始讨论技术方面的问题。</p>
<span id="more"></span>

<ol>
<li>从业务角度看，系统中发生的任何事情都可以触发通知。</li>
<li>要发送的通知可以定向到一个或多个接收者或一组接收者。</li>
<li>我们需要支持不同的通知渠道：电子邮件、短信、Android/iOS设备的推送、应用内通知。</li>
<li>通知应该是本地化的，必须能够支持不同的语言和时区。</li>
<li>用户应该能够访问他们以前/旧的通知（也称为通知中心）。</li>
<li>一些推送通知或电子邮件通知不应该在用户的通知中心中被记录/显示（例如有关折扣的营销警报或其他短期警报），反之亦然，一些在用户的通知中心中可见的通知不应该生成警报，如推送通知（或已发送电子邮件）。</li>
<li>用户应该能够自定义通知的消耗方式（频率、类别、渠道等），例如为某种类型的通知设置首选渠道，甚至关闭它。</li>
</ol>
<p>因此，上述要求是大多数公司中关于通知的基本业务需求。我们需要设计一个满足这些需求的服务/基础架构，并通过满足一些直接影响整体开发的关键技术需求来鼓励无缝的开发过程。其中一些是：</p>
<ol>
<li>设置代码应易于理解/维护。</li>
<li>集成新通知简单、快速和直接，无需修改任何现有代码，只需按照用于先前通知的模式/约定进行扩展即可。</li>
<li>更改现有通知很容易，而不会影响其他部分（例如，删除特定类型的推送通道，而无需触及任何设置代码，而不会影响其他通知）。</li>
<li>轻松添加新的通道/提供商的方法（例如，浏览器通知、WhatsApp消息）。</li>
<li>一种非常简单的方式来添加/编辑特定通知的新翻译（本地化）。并且快速甚至立即反映新的翻译到工作系统中。</li>
<li>添加用户自定义通知设置不是一件头痛的事情。</li>
<li>整体服务易于测试，因此覆盖集成/后端端到端测试不会耗费太多时间。</li>
<li>易于调试特定情况。</li>
</ol>
<p><strong>现在让我们进入技术设计的详细说明</strong></p>
<p>由于我们的基础架构由多个小型服务组成，每个服务都在整个系统中具有清晰的职责，因此我们的通知系统也将是一个或几个小型服务，通过同步和异步方法与其他服务进行通信。至少，我们将需要一个后端服务来处理触发器并执行与通知相关的核心操作。</p>
<h2 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h2><p>主要而言，任何通知都将始于一个事件，无论是来自业务服务还是特殊的事件服务。事件本身将被发布到事件总线中。稍后，通知服务（核心服务）将获取通知需要的数据，使用事件提供的数据。然后，它将使用准备/映射的数据来构建一个通知案例，这是处理通知的声明性机制。</p>
<p>在发送通知之前，它应该被“转换”为特定提供程序/通道期望的一种内容/有效载荷类型。为此，我们使用模板化服务来获取根据特定模板使用数据（参数）和用户语言填充的电子邮件内容。</p>
<p>对于推送通知或短信通知，这更容易，因为它只是一个文本。因此，我们使用用户语言简单地获取翻译文本并替换参数/属性。</p>
<p>在翻译方面，每次调用本地化服务都没有意义，因此解决方案可能是临时在每个通知服务副本中本地持久化与通知相关的翻译，并通过简单地轮询以获取本地化服务中的新更改来维护更新。或者我们可以采用基于事件的方法。或者通过维护的分布式缓存机制也可以轻松解决此问题。</p>
<p>在我们拥有内容/有效载荷之后，通知服务只需通过发送它来向提供程序（通道提供程序）发出 HTTP 调用，然后铃铃铃，我们得到了推送通知。</p>
<p>此外，通知服务将为用户公开端点，以便获取其通知，将这些标记为已读/未读等。它还将为管理应用程序公开另一组端点，用于管理通知、相关配置等。或者甚至用于创建营销通知，例如警示整个商店折扣。</p>
<p>基础架构中的通知块将如下图所示：</p>
<p><img src="https://miro.medium.com/v2/resize:fit:601/1*__c9SfKrNN9Mz91-7-LENA.png" alt="1*__c9SfKrNN9Mz91-7-LENA.png"></p>
<p>微服务中的通知系统</p>
<p>在我们确定了高层架构之后，就是深入研究特定组件并通过更具体的设计决策来使这些组件更加清晰。我们可以决定这个服务将使用哪种编程语言。此外，数据库用于存储数据。为了利用严格的模式（在这里我们没有任何任意的数据，一切都是预先决定的）、关系、约束和 ACID，我们选择了关系数据库，如 MySQL 或 PostgreSQL。</p>
<h2 id="服务架构"><a href="#服务架构" class="headerlink" title="服务架构"></a>服务架构</h2><p>现在让我们设计实体及其关系。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:700/1*75wkf5igdSJ9xJUpKstZSQ.png" alt="1*75wkf5igdSJ9xJUpKstZSQ.png"></p>
<p>微服务实体关系图</p>
<p>上述 ERD 可能会稍微更改以根据公司的需求进行定制。但是，它很简单，已规范化到 5NF，不仅是一个起点，而且是一个最终的模式，只要我们没有可能影响 ERD 的特定要求。当然，我们存在一些冗余，但这不是在服务/数据库级别上，而是在基础架构级别上。例如，这里有一个用户表的小副本，这在微服务中是完全正常的。另一个注意点是，我们不想为用户记录生成主键（PKs），而是使用我们在用户服务中的主用户表中具有的相同 UUID（因为我们知道如果用户未注册，即用户没有在用户服务中的记录，他将不会在此处记录）。在我们的情况下，这种方法的优点大于缺点。</p>
<p>现在让我们更详细地描述服务。</p>
<p><strong>消费者</strong></p>
<p>通知服务有特定于领域的消费者，例如订单消费者，它具有订单相关事件的消费者处理程序。当触发它时，它调用特定于领域的服务，如订单服务。</p>
<p><strong>服务</strong></p>
<p>订单服务构建一个名为 Case（通知案例）的实体。订单服务还可以根据需要与其他微服务进行同步通信，以获取构建特定通知案例所需的更多数据。</p>
<p><strong>案例</strong></p>
<p>一个 Case 是一个实体，表示一个特定的通知案例，它有一个类型，这是一个具体的通知类型。每个案例都继承了一个称为 BaseCase 的类，它是一个包含一些可重用逻辑、一些抽象属性和方法的抽象类。因此，每个案例都必须在被视为完整通知案例之前实现一些基本要求。在每次触发通知时，都会创建 Case 的新实例，该实例表示发送给一个或多个接收者的特定通知，以及有关如何处理此确切通知的一些指令。它已准备好由通知引擎处理。</p>
<p><strong>通知引擎</strong></p>
<p>它是一个小引擎，知道如何处理任何通知案例。我们可以说通知引擎知道如何做，但不知道要做什么。但通知案例对如何做没有任何想法/指示，但知道应该做什么。因此，案例与引擎的协作完成了整个工作。通知引擎是一个小型处理器，可以执行与通知相关的所有例程，例如调用通知服务以在数据库中创建通知和通知接收者记录；调用模板化和翻译服务以准备通知有效载荷；调用通知传输模块（通道提供商）以发送实际通知（如果需要）；甚至知道如何处理可能在流程中发生的常见异常。</p>
<p>通过采用这种架构，我们可以编写尽可能少的代码来创建新的通知。这就像只需添加特定事件的消费者并创建一个新的通知 Case 类，这就是为一个通知添加更多通知的全部工作。</p>
<p><strong>模板化模块</strong></p>
<p>基本上是一个用于模板化服务的 HTTP 提供程序。它使用 HTTP 请求根据特定模板使用数据（参数）和用户语言构建电子邮件内容。</p>
<p>对于推送通知，它接受翻译后的文本和属性，并返回准备发送的有效载荷。</p>
<p><strong>本地化模块</strong></p>
<p>此模块具有两个关键功能：</p>
<ol>
<li><p>从本地化微服务请求完整的翻译并维护它。有几种解决方案可以解决翻译的维护问题，如上述，通过轮询获取新的翻译更新、基于事件的更新，或分布式缓存。所有方法都有其优缺点。</p>
</li>
<li><p>翻译通知类型。通知案例的翻译变得很容易，因为每个通知案例都有一个通知类型，并且通知翻译键可以通过遵循使用通知类型的约定来创建。例如，</p>
<p>`app.notifications.cases..title</p>
<p>app.notifications.cases..body`。</p>
<p>因此，现在我们可以通过使用此键来获取任何通知案例的正文翻译。</p>
</li>
</ol>
<p><strong>用户模块</strong></p>
<p>它是公司用户的一个小副本。包括为了发送电子邮件而进行的相同 id，以及用户类型。它还可以具有一些对于通知服务非常重要的额外字段。</p>
<p>对于推送通知，每个用户可以有一个或多个设备。设备是根据接收者 id（用户 id）在需要构建接收者的通知时获取的，并且也用于通过设备令牌发送通知。</p>
<p><strong>通道提供商</strong></p>
<p>这是处理引擎的最后一步，因此它只需调用 <code>provider.send(payload, device)</code>。我们创建自定义客户端，例如，对于 APNS 调用，我们使用 http2 和 p12 证书创建 APNS 客户端，该客户端知道如何发送和处理来自 APNS 的响应，同时<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/sending_notification_requests_to_apns">发送推送通知</a>。对于电子邮件或 Android 通知也是类似。这样便宜又可靠。正是我们想要的。</p>
<p><strong>暴露的 API</strong></p>
<p>我们公开了两种类型的 API：</p>
<ol>
<li><p>针对客户（常规用户）至少要</p>
<p>• 发送设备令牌和其他设备相关信息</p>
<p>• 列出通知</p>
<p>• 将一个或多个通知标记为已读/未读</p>
<p>• 更改与通知相关的首选项</p>
</li>
<li><p>针对“管理员”用户以</p>
<p>• 管理通知</p>
<p>• 管理各种配置</p>
<p>• 发送/操作新/现有通知</p>
<p>• 监视</p>
</li>
</ol>
<p>通知核心服务的简要图示如下：😉</p>
<p><img src="https://miro.medium.com/v2/resize:fit:700/1*3hVxlKhVGBgRqERO2hGqIg.png" alt="1*3hVxlKhVGBgRqERO2hGqIg.png"></p>
<p>通知服务架构</p>
<blockquote>
<p><em>💡</em>构建通知系统可能会很复杂，但通过采用微服务架构并在识别和隔离每个微服务时做出正确的决策，可以大大减少代码重复并增加系统的模块化和可扩展性。</p>
</blockquote>
<blockquote>
<p>将微服务架构视为可组合的构建块是关键，</p>
</blockquote>
<p>通过清晰定义各个组件的职责和交互方式，可以在系统中保持良好的解耦，使系统更容易维护、扩展和创新。</p>
]]></content>
      <categories>
        <category>system design</category>
      </categories>
      <tags>
        <tag>system design</tag>
      </tags>
  </entry>
  <entry>
    <title>系统设计蓝图 / 备忘单</title>
    <url>/2023/08/12/systemDesign-system-road/</url>
    <content><![CDATA[<p>开发一个强大、可扩展和高效的系统可能会令人望而却步。然而，了解关键概念和组件可以使这个过程更可管理。在本博客文章中，我们将探讨系统设计的关键概念和组件，如DNS、负载均衡、API网关等，以及一个简明的备忘单，可以帮助开发人员设计不同复杂性的系统。</p>
<h1 id="系统设计蓝图-备忘单"><a href="#系统设计蓝图-备忘单" class="headerlink" title="系统设计蓝图 / 备忘单"></a>系统设计蓝图 / 备忘单</h1><p>这是一份全面的视觉指南，为开发人员提供了一个快速、简单的参考，涵盖了系统设计中的关键概念和最佳实践。这个便捷的备忘单或蓝图涵盖了诸如DNS、负载均衡、API网关、视频和图像处理、缓存、数据库、唯一ID生成、支付和推荐服务等标准组件，以及聊天和流媒体协议。有了这个宝贵的资源，你将能够应对设计和实施可扩展、高效和可靠系统的挑战。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:2000/1*QSFihi7zXbR5X915MDmKyQ.png" alt="1*QSFihi7zXbR5X915MDmKyQ.png"></p>
<span id="more"></span>
<h1 id="第一部分：系统设计原则"><a href="#第一部分：系统设计原则" class="headerlink" title="第一部分：系统设计原则"></a>第一部分：系统设计原则</h1><h2 id="1-1：模块化"><a href="#1-1：模块化" class="headerlink" title="1.1：模块化"></a>1.1：模块化</h2><p>将系统划分为更小、更可管理的模块有助于减少复杂性、提高可维护性和增加可重用性。</p>
<h2 id="1-2：抽象化"><a href="#1-2：抽象化" class="headerlink" title="1.2：抽象化"></a>1.2：抽象化</h2><p>隐藏实现细节，只显示必要的特性有助于简化复杂的系统并促进模块化。</p>
<h2 id="1-3：分层"><a href="#1-3：分层" class="headerlink" title="1.3：分层"></a>1.3：分层</h2><p>将系统组织成不同的层次，每个层次提供特定的功能集，促进关注点分离，增强可维护性。</p>
<h2 id="1-4：可扩展性"><a href="#1-4：可扩展性" class="headerlink" title="1.4：可扩展性"></a>1.4：可扩展性</h2><p>通过添加更多资源（横向扩展）或优化系统容量（纵向扩展）来设计系统以处理增加的负载。</p>
<h2 id="1-5：性能"><a href="#1-5：性能" class="headerlink" title="1.5：性能"></a>1.5：性能</h2><p>优化系统的响应时间、吞吐量和资源利用率对于成功的设计至关重要。</p>
<h2 id="1-6：安全性"><a href="#1-6：安全性" class="headerlink" title="1.6：安全性"></a>1.6：安全性</h2><p>通过实施适当的安全措施和实践，确保系统的机密性、完整性和可用性。</p>
<h2 id="1-7：容错和弹性"><a href="#1-7：容错和弹性" class="headerlink" title="1.7：容错和弹性"></a>1.7：容错和弹性</h2><p>设计系统以经受故障，并从错误中恢复，确保可靠性和可用性。</p>
<h1 id="第二部分：系统设计的关键组件"><a href="#第二部分：系统设计的关键组件" class="headerlink" title="第二部分：系统设计的关键组件"></a>第二部分：系统设计的关键组件</h1><h2 id="2-1：DNS（域名系统）"><a href="#2-1：DNS（域名系统）" class="headerlink" title="2.1：DNS（域名系统）"></a>2.1：DNS（域名系统）</h2><p>DNS是一个分层和去中心化的命名系统，用于将连接到Internet或私有网络的计算机、服务或其他资源的人类可读域名（<a target="_blank" rel="noopener" href="http://例如www.example.com/">例如www.example.com</a>）转换为IP地址，使用户能够更有效地访问网站和服务。</p>
<p><img src="https://miro.medium.com/v2/resize:fit:1400/1*ER77NyMrUYhlYcdj81rgxA.png" alt="1*ER77NyMrUYhlYcdj81rgxA.png"></p>
<h2 id="2-2：负载均衡"><a href="#2-2：负载均衡" class="headerlink" title="2.2：负载均衡"></a>2.2：负载均衡</h2><p>负载均衡是指将网络流量分布到多个服务器上，以确保没有单个服务器被过载。这种方法可以提高系统的可用性、可靠性和性能。常见的负载均衡算法包括循环调度、最小连接数和IP哈希</p>
<h2 id="2-3：API网关"><a href="#2-3：API网关" class="headerlink" title="2.3：API网关"></a>2.3：API网关</h2><p>API网关是在分布式系统中充当客户端和微服务之间中介的服务器。它管理和路由请求，强制执行安全策略，并可以提供附加功能，如缓存、日志记录和监控。</p>
<h2 id="2-4：内容分发网络（CDN）"><a href="#2-4：内容分发网络（CDN）" class="headerlink" title="2.4：内容分发网络（CDN）"></a>2.4：内容分发网络（CDN）</h2><p>CDN是一个分布在各个位置的服务器网络，旨在以较低的延迟和更高的带宽向用户提供内容。CDN在靠近终端用户的边缘服务器上缓存内容，提高系统的性能，并减少对源服务器的负载</p>
<h2 id="2-5：消息队列"><a href="#2-5：消息队列" class="headerlink" title="2.5：消息队列"></a>2.5：消息队列</h2><p>消息队列通过临时将消息存储在队列中促进分布式系统组件之间的通信。它们支持异步处理，并帮助解耦组件，提高系统的可扩展性和容错性。</p>
<h2 id="2-6：通信协议"><a href="#2-6：通信协议" class="headerlink" title="2.6：通信协议"></a>2.6：通信协议</h2><p>系统设计中使用不同的通信协议，如HTTP/HTTPS、WebSocket和gRPC。这些协议具有各自的优点和权衡，选择取决于延迟、安全性和数据传输要求等因素。</p>
<h2 id="2-7：缓存"><a href="#2-7：缓存" class="headerlink" title="2.7：缓存"></a>2.7：缓存</h2><p>缓存是一种临时技术，用于存</p>
<p>储数据的副本，以便在将来的请求中更快地检索。它有助于减少延迟、服务器负载和带宽消耗。常见的缓存机制包括内存缓存、分布式缓存和浏览器缓存</p>
<h2 id="2-8：数据库"><a href="#2-8：数据库" class="headerlink" title="2.8：数据库"></a>2.8：数据库</h2><p>选择适合系统的数据库取决于数据结构、可扩展性、一致性和延迟。常见的数据库类型包括关系数据库（如MySQL、PostgreSQL）、NoSQL数据库（如MongoDB、Cassandra）和NewSQL数据库（如Cockroach DB、Google Spanner）。</p>
<h2 id="2-9：复制技术"><a href="#2-9：复制技术" class="headerlink" title="2.9：复制技术"></a>2.9：复制技术</h2><p>复制是在不同节点上维护多个数据副本以增加可靠性、可用性和容错性的过程。常见的复制技术包括同步复制、异步复制和半同步复制。</p>
<h2 id="2-10：分布式唯一ID生成"><a href="#2-10：分布式唯一ID生成" class="headerlink" title="2.10：分布式唯一ID生成"></a>2.10：分布式唯一ID生成</h2><p>在分布式系统中创建唯一标识符可能具有挑战性，但对于保持数据一致性和完整性非常重要。</p>
<h1 id="第三部分：使用签名URL以块的形式上传视频和图像"><a href="#第三部分：使用签名URL以块的形式上传视频和图像" class="headerlink" title="第三部分：使用签名URL以块的形式上传视频和图像"></a>第三部分：使用签名URL以块的形式上传视频和图像</h1><p>在本节中，我们将探讨如何使用签名URL以块的形式上传大型视频和图像文件。这种方法可以显著提高文件上传的效率和可靠性，特别是在网络条件不理想的情况下。</p>
<h2 id="3-1：什么是签名URL？"><a href="#3-1：什么是签名URL？" class="headerlink" title="3.1：什么是签名URL？"></a>3.1：什么是签名URL？</h2><p>签名URL是专门设计的URL，授予对特定资源（如云存储中的对象）的临时安全访问权限。这些URL包含一个认证签名，允许用户在有限的时间内执行特定操作，例如上传或下载文件。常见的云存储提供商如Amazon S3和Google Cloud Storage支持生成签名URL。以下是签名URL的一个示例：</p>
<p><a target="_blank" rel="noopener" href="https://example-bucket.s3.amazonaws.com/my-file.txt">https://example-bucket.s3.amazonaws.com/my-file.txt</a>?</p>
<p>X-Amz-Algorithm=AWS4-HMAC-SHA256&amp;</p>
<p>X-Amz-Credential=AKIAIOSFODNN7EXAMPLE%2F20220407%2Fus-east-1%2Fs3%2Faws4_request&amp;</p>
<p>X-Amz-Date=20220407T123456Z&amp;</p>
<p>X-Amz-Expires=3600&amp;</p>
<p>X-Amz-SignedHeaders=host&amp;</p>
<p>X-Amz-Signature=a9c8a7d1644c7b351ef3034f4a1b4c9047e891c7203eb3a9f29d8c7a74676d88</p>
<h2 id="3-2：以块的形式上传"><a href="#3-2：以块的形式上传" class="headerlink" title="3.2：以块的形式上传"></a>3.2：以块的形式上传</h2><p>将大型文件作为单个请求上传可能会导致超时、高内存消耗以及由于网络不稳定而增加故障风险。相反，将大型文件分成较小的块，并按顺序或并行方式上传，可以提高上传效率和可靠性。这种方法被称为“块式”或“多部分”上传。</p>
<h2 id="3-3：结合签名URL和块式上传"><a href="#3-3：结合签名URL和块式上传" class="headerlink" title="3.3：结合签名URL和块式上传"></a>3.3：结合签名URL和块式上传</h2><p>要使用签名URL以块的形式上传视频和图像文件，请按照以下一般步骤进行操作：</p>
<ol>
<li><strong>将文件分成较小的块</strong>：在客户端上使用JavaScript将大型文件拆分成较小的块。块的大小可以根据需要进行调整，但平衡请求数量和每个块的大小以优化上传性能是重要的。</li>
<li><strong>为每个块请求签名URL</strong>：向服务器发送请求，为每个块生成一个具有适当权限和过期时间的签名URL，并将其返回给客户端。</li>
<li><strong>使用签名URL上传块</strong>：使用签名URL将每个块上传到云存储服务。根据所需的并发级别和网络条件，可以顺序或并行地进行这些上传。</li>
<li><strong>确认成功上传并重新组装</strong>：一旦所有块都成功上传，通知服务器确认上传过程的完成。然后，服务器可以重新组装块为原始文件，并执行任何必要的处理或验证。</li>
<li><strong>处理上传失败</strong>：如果任何块上传失败，可以使用新的签名URL重试上传，或者实施错误处理策略以确保平滑的用户体验。</li>
</ol>
<p>通过使用签名URL和块式上传，开发人员可以高效、安全地处理大型视频和图像上传，提高系统的可靠性和性能。</p>
<h1 id="第四部分：聊天和流媒体协议"><a href="#第四部分：聊天和流媒体协议" class="headerlink" title="第四部分：聊天和流媒体协议"></a>第四部分：聊天和流媒体协议</h1><p>本节将讨论各种聊天和流媒体协议，促进客户端和服务器之间的实时通信和数据流传输。了解这些协议可以帮助开发人员构建响应快、交互式的应用程序。</p>
<h2 id="4-1：RTMP（实时消息传输协议）"><a href="#4-1：RTMP（实时消息传输协议）" class="headerlink" title="4.1：RTMP（实时消息传输协议）"></a>4.1：RTMP（实时消息传输协议）</h2><p>RTMP是由Adobe Systems开发的用于在Internet上流式传输音频、视频和数据的专有协议。它通常用于视频流应用程序，提供客户端和服务器之间的低延迟通信。然而，由于其依赖Flash Player，它在近年来的流行度有所下降。</p>
<h2 id="4-2：WebRTC（Web实时通信）"><a href="#4-2：WebRTC（Web实时通信）" class="headerlink" title="4.2：WebRTC（Web实时通信）"></a>4.2：WebRTC（Web实时通信）</h2><p>WebRTC是一个开源项目，可以在Web浏览器和移动应用程序中实现实时音频、视频和数据通信。它支持点对点连接，降</p>
<p>低延迟和服务器负载。WebRTC广泛应用于视频会议、在线游戏和其他需要实时通信的应用程序。</p>
<h2 id="4-3：WebSocket"><a href="#4-3：WebSocket" class="headerlink" title="4.3：WebSocket"></a>4.3：WebSocket</h2><p>WebSocket是一种通信协议，可以在客户端和服务器之间建立双向、全双工的通信连接。由于其低延迟和高效的通信能力，WebSocket通常用于聊天、通知和实时更新等实时应用程序。</p>
<h2 id="4-4：SSE（服务器推送事件）"><a href="#4-4：SSE（服务器推送事件）" class="headerlink" title="4.4：SSE（服务器推送事件）"></a>4.4：SSE（服务器推送事件）</h2><p>服务器推送事件（SSE）是一种技术，使服务器能够通过HTTP连接向客户端推送更新。它设计用于服务器向客户端进行单向实时通信，适用于实时更新、新闻提要和通知等应用程序。</p>
<h2 id="4-5：HTTP短轮询"><a href="#4-5：HTTP短轮询" class="headerlink" title="4.5：HTTP短轮询"></a>4.5：HTTP短轮询</h2><p>短轮询涉及客户端反复向服务器发送HTTP请求以检查新的更新。虽然实现简单，但短轮询可能会导致高服务器负载和增加的延迟，特别是当更新不频繁时。</p>
<h2 id="4-6：HTTP长轮询"><a href="#4-6：HTTP长轮询" class="headerlink" title="4.6：HTTP长轮询"></a>4.6：HTTP长轮询</h2><p>长轮询是对短轮询的改进，其中客户端发送请求到服务器，服务器保持请求打开，直到有新数据可用。这种方法减少了请求的数量和服务器负载，但仍可能存在延迟问题，并需要对服务器资源进行谨慎管理。</p>
<h2 id="4-7：Webhook"><a href="#4-7：Webhook" class="headerlink" title="4.7：Webhook"></a>4.7：Webhook</h2><p>Webhook是由系统中特定事件触发的用户定义的HTTP回调。当事件发生时，源站点向为Webhook配置的URL发出HTTP请求。这种方法允许不同系统或服务之间进行高效的事件驱动通信。</p>
<h2 id="4-8：流式API"><a href="#4-8：流式API" class="headerlink" title="4.8：流式API"></a>4.8：流式API</h2><p>流式API允许客户端从服务器消费连续的数据流，通常使用HTTP或WebSocket连接。这些API设计用于需要实时更新的应用程序，例如社交媒体动态、股票市场数据或实时分析。</p>
<p>通过了解和利用这些聊天和流媒体协议，开发人员可以构建响应快、实时的应用程序，满足各种用例，并提供引人入胜的用户体验。</p>
<h1 id="第五部分：系统设计中的常见组件"><a href="#第五部分：系统设计中的常见组件" class="headerlink" title="第五部分：系统设计中的常见组件"></a>第五部分：系统设计中的常见组件</h1><p>本节将探讨现代系统设计中常见的一些标准组件。了解这些组件可以帮助开发人员将其无缝集成到系统中，并增强整体功能。</p>
<h2 id="5-1：支付服务"><a href="#5-1：支付服务" class="headerlink" title="5.1：支付服务"></a>5.1：支付服务</h2><p>支付服务处理客户和企业之间的交易。集成可靠的支付服务对于电子商务和订阅型平台至关重要。常见的支付服务提供商包括Stripe、PayPal和Square。这些服务通常提供API以便于安全的交易处理和管理重复付款、退款等。</p>
<h2 id="5-2：分析服务"><a href="#5-2：分析服务" class="headerlink" title="5.2：分析服务"></a>5.2：分析服务</h2><p>分析服务实现数据收集、处理和可视化，帮助企业做出明智决策。这些服务可以跟踪用户行为、监控系统性能和分析趋势。常见的分析服务提供商包括Google Analytics、Mixpanel和Amplitude。将分析服务集成到系统中可以帮助企业优化其产品并改善用户体验。</p>
<h2 id="5-3：通知"><a href="#5-3：通知" class="headerlink" title="5.3：通知"></a>5.3：通知</h2><p>通知服务使用户及时了解更新、警报和重要信息。这些服务可以通过电子邮件、短信和推送通知等多种渠道传递通知。通知服务提供商的示例包括Firebase Cloud Messaging (FCM)、Amazon Simple Notification Service (SNS)和Twilio。</p>
<h2 id="5-4：搜索"><a href="#5-4：搜索" class="headerlink" title="5.4：搜索"></a>5.4：搜索</h2><p>集成强大的搜索组件对于具有大量数据或内容的系统至关重要。搜索服务应提供快速、相关和可扩展的搜索功能。Elasticsearch、Apache Solr和Amazon CloudSearch是实现搜索功能的常用选择。这些服务通常支持全文搜索、分面搜索和过滤，使用户能够快速高效地找到所需的信息。</p>
<h2 id="5-5：推荐服务"><a href="#5-5：推荐服务" class="headerlink" title="5.5：推荐服务"></a>5.5：推荐服务</h2><p>推荐服务使用算法根据用户的偏好、行为和其他因素提供个性化建议。这些服务可以显著提高用户参与度和满意度。生成推荐的技术包括协同过滤、基于内容的过滤和混合方法。机器学习算法，如矩阵分解和深度学习，也可以用于生成更复杂的推荐。</p>
<p>通过将这些标准组件整合到系统设计中，开发人员可以增强其应用程序的功能，并为用户提供更流畅和引人入胜的体验。</p>
<h1 id="第六部分：系统设计的最佳实践"><a href="#第六部分：系统设计的最佳实践" class="headerlink" title="第六部分：系统设计的最佳实践"></a>第六部分：系统设计的最佳实践</h1><h2 id="6-1：需求收集"><a href="#6-1：需求收集" class="headerlink" title="6.1：需求收集"></a>6.1：需求收集</h2><p>在开始设计过程之前，充分了解并记录系统需求。</p>
<h2 id="6-2：设计模式"><a href="#6-2：设计模式" class="headerlink" title="6.2：设计模式"></a>6.2：设计模式</h2><p>利用经过验证的设计模式来解决反复出现的设计问题，改进整体架构。</p>
<h2 id="6-3：文档"><a href="#6-3：文档" class="headerlink" title="6.3：文档"></a>6.3：文档</h2><p>记录设计决策、假设和基本原理，以确保更好的沟通和可维护性。</p>
<h2 id="6-4：迭代设计"><a href="#6-4：迭代设计" class="headerlink" title="6.4：迭代设计"></a>6.4：迭代设计</h2><p>通过多次迭代和反馈改进设计，使其不断演进和改进。</p>
<h2 id="6-5：测试和验证"><a href="#6-5：测试和验证" class="headerlink" title="6.5：测试和验证"></a>6.5：测试和验证</h2><p>根据要求验证设计并进行测试，以识别和解决潜在问题。</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>总之，系统设计是一个多方面、复杂的过程，需要深入了解各种组件、协议和技术。本博客文章概述了关键主题，如DNS、负载均衡、API网关、</p>
<p>缓存、数据库和聊天/流媒体协议等。同时，提供了一个系统设计蓝图/备忘单，可帮助开发人员设计和实施各种复杂性的系统。</p>
<p>通过理解系统设计原则和最佳实践，开发人员可以设计出强大、可扩展和高效的系统，满足用户需求并提供卓越的用户体验。</p>
<p>然而，需要注意的是，系统设计是一个不断演化和改进的过程。根据具体的应用场景和需求，开发人员应灵活应对，并根据实际情况做出相应的调整和优化。随着技术的不断发展和创新，也要保持对新技术和趋势的关注，以不断提升系统设计的能力和效果。</p>
]]></content>
      <categories>
        <category>system design</category>
      </categories>
      <tags>
        <tag>system design</tag>
      </tags>
  </entry>
</search>
