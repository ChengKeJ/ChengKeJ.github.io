---
layout: post
title:  "操作系统-下"
categories: OS
tags:  OS
date: 2022/11/29 20:47:25
---
### Linux操作系统概览

### 物理内存

- 物理内存分 NUMA 节点，分别进行管理；
- 每个 NUMA 节点分成多个内存区域；
- 每个内存区域分成多个物理页面；
- 伙伴系统将多个连续的页面作为一个大的内存块分配给上层；
- kswapd 负责物理页面的换入换出；
- Slub Allocator 将从伙伴系统申请的大内存块切成小块，分配给其他系统

<!--more-->

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/54F862A0-8386-49BF-8B3F-DEE9C8A646AE_2/gyolywXXfXQonISDGUYFDIkKa9pLydFhUuO59MXYMccz/Image.png)


### 用户态的内存映射机制

- 用户态内存映射函数 mmap，包括用它来做匿名映射和文件映射。
- 用户态的页表结构，存储位置在 mm_struct 中。
- 在用户态访问没有映射的内存会引发缺页异常，分配物理页表、补齐页表。如果是匿名映射则分配物理内存；如果是 swap，则将 swap 文件读入；如果是文件映射，则将文件读入。

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/C4FFEB6E-626D-4F7C-A07C-B7909051941F_2/YRRQqzrK4RPGRwz3EvB7e76eBrpiJvDfVMEnBe1ePmgz/Image.png)

### 内存管理体系

物理内存根据 NUMA 架构分节点。每个节点里面再分区域。每个区域里面再分页。

物理页面通过伙伴系统进行分配。分配的物理页面要变成虚拟地址让上层可以访问，kswapd 可以根据物理页面的使用情况对页面进行换入换出。

对于内存的分配需求，可能来自内核态，也可能来自用户态。

对于内核态，kmalloc 在分配大内存的时候，以及 vmalloc 分配不连续物理页的时候，直接使用伙伴系统，分配后转换为虚拟地址，访问的时候需要通过内核页表进行映射。

对于 kmem_cache 以及 kmalloc 分配小内存，则使用 slub 分配器，将伙伴系统分配出来的大块内存切成一小块一小块进行分配。

kmem_cache 和 kmalloc 的部分不会被换出，因为用这两个函数分配的内存多用于保持内核关键的数据结构。内核态中 vmalloc 分配的部分会被换出，因而当访问的时候，发现不在，就会调用 do_page_fault。

对于用户态的内存分配，或者直接调用 mmap 系统调用分配，或者调用 malloc。调用 malloc 的时候，如果分配小的内存，就用 sys_brk 系统调用；如果分配大的内存，还是用 sys_mmap 系统调用。正常情况下，用户态的内存都是可以换出的，因而一旦发现内存中不存在，就会调用 do_page_fault。

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/AAC4B331-77B6-490B-AD71-D52671D0CD4B_2/ReuYEXAMBNYZdkWFnsIweuNA5bWuXjakI3cOoF17P24z/Image.png)

### 文件系统

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/3635231F-E1A2-4D50-9AA1-F6180AEE5E32_2/iBnsEdRlLYuPwGGHc7FP7JeimBUgBFKMfQsc8JBJlj8z/Image.png)

### 进程通信

进程间通信的各种模式

- 类似瀑布开发模式的管道
- 类似邮件模式的消息队列
- 类似会议室联合开发的共享内存加信号量
- 类似应急预案的信号

当你自己使用的时候，可以根据不同的通信需要，选择不同的模式。

- 管道，请你记住这是命令行中常用的模式，面试问到的话，不要忘了。
- 消息队列其实很少使用，因为有太多的用户级别的消息队列，功能更强大。
- 共享内存加信号量是常用的模式。这个需要牢记，常见到一些知名的以 C 语言开发的开源软件都会用到它。
- 信号更加常用，机制也比较复杂。  我们后面会有单独的一节来解析。

### 信号处理机制

- 在用户程序里面，有两个函数可以调用，一个是 signal，一个是 sigaction，推荐使用 sigaction。
- 用户程序调用的是 Glibc 里面的函数，signal 调用的是 __sysv_signal，里面默认设置了一些参数，使得 signal 的功能受到了限制，sigaction 调用的是 __sigaction，参数用户可以任意设定。
- 无论是 __sysv_signal 还是 __sigaction，调用的都是统一的一个系统调用 rt_sigaction。
- 在内核中，rt_sigaction 调用的是 do_sigaction 设置信号处理函数。在每一个进程的 task_struct 里面，都有一个 sighand 指向 struct sighand_struct，里面是一个数组，下标是信号，里面的内容是信号处理函数

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/2BFFB341-CBA5-415D-B622-4660FA7E21F4_2/KaQpKUuNBQZOs0H0AjSyb429l4rWcPVzPDcRBlRp5e4z/Image.png)

### socket

两种网络协议模型

TCP/UDP->IPv4->ARP

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/C4628019-6678-4EB3-A3B8-4D5690D4B98C_2/r2y0FpjvrnqkwP1Wc4DbyzQcpqT9yLX4yEM3FvHk6kMz/Image.png)

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/6E92901F-753E-4B8E-91C3-877D3363C0D5_2/Sf7zAu9vqNfmrx1LSVt31uqOEbz4tc89owaFvFZijPIz/Image.png)

### socket 使用

在传输层有两个主流的协议 TCP 和 UDP，所以我们的 socket 程序设计也是主要操作这两个协议

当然，无论是用 socket 操作 TCP，还是 UDP，我们首先都要调用 socket 函数。

```other
int socket(int domain, int type, int protocol);
```

socket 函数用于创建一个 socket 的文件描述符，唯一标识一个 socket。我们把它叫作文件描述符，因为在内核中，我们会创建类似文件系统的数据结构，并且后续的操作都有用到它。

socket 函数有三个参数。

- domain：表示使用什么 IP 层协议。AF_INET 表示 IPv4，AF_INET6 表示 IPv6。
- type：表示 socket 类型。SOCK_STREAM，顾名思义就是 TCP 面向流的，SOCK_DGRAM 就是 UDP 面向数据报的，SOCK_RAW 可以直接操作 IP 层，或者非 TCP 和 UDP 的协议。例如 ICMP。
- protocol 表示的协议，包括 IPPROTO_TCP、IPPTOTO_UDP。

通信结束后，我们还要像关闭文件一样，关闭 socket。

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/97946327-C21F-4382-9662-C41528A79BAB_2/EAvPXq6hczBRBQIMLCTnxysVegNqp1yLDhGljpld8ycz/Image.png)

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/F64B2722-8919-4559-93F6-0B6CC46A32F5_2/rha3Ow2oy8QOMKG1yDMfRAXHwC1bVsS8a0j0ovvcx5gz/Image.png)

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/D6E491A5-7013-421B-8098-F07A09F6D26D_2/UgVyZJPW4RQwvKEdsW0y4syUJUY0R8XEpVfXTyjbG5Mz/Image.png)

TCP 协议的 socket 调用的过程

- 服务端和客户端都调用 socket，得到文件描述符；
- 服务端调用 listen，进行监听；
- 服务端调用 accept，等待客户端连接；
- 客户端调用 connect，连接服务端；
- 服务端 accept 返回用于传输的 socket 的文件描述符；
- 客户端调用 write 写入数据；
- 服务端调用 read 读取数据。

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/A19CFA41-22C4-44E4-8658-26EA7A6DAF34_2/2sfEA0VpYPWw3jrxDzNbHuahg9gzndSpiJCtQV0Zp0wz/Image.png)

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/4BB3A853-9927-404F-AA28-CF4D698D83EE_2/nx9zzzwm2GMnxBjnX60KCYFeRxDKUIYjXxNkL9OQVxcz/Image.png)

### 发送网络包

- VFS 层：write 系统调用找到 struct file，根据里面的 file_operations 的定义，调用 sock_write_iter 函数。sock_write_iter 函数调用 sock_sendmsg 函数。
- Socket 层：从 struct file 里面的 private_data 得到 struct socket，根据里面 ops 的定义，调用 inet_sendmsg 函数。
- Sock 层：从 struct socket 里面的 sk 得到 struct sock，根据里面 sk_prot 的定义，调用 tcp_sendmsg 函数。
- TCP 层：tcp_sendmsg 函数会调用 tcp_write_xmit 函数，tcp_write_xmit 函数会调用 tcp_transmit_skb，在这里实现了 TCP 层面向连接的逻辑。
- IP 层：扩展 struct sock，得到 struct inet_connection_sock，根据里面 icsk_af_ops 的定义，调用 ip_queue_xmit 函数。
- IP 层：ip_route_output_ports 函数里面会调用 fib_lookup 查找路由表。FIB 全称是 Forwarding Information Base，转发信息表，也就是路由表。
- 在 IP 层里面要做的另一个事情是填写 IP 层的头。
- 在 IP 层还要做的一件事情就是通过 iptables 规则。
- MAC 层：IP 层调用 ip_finish_output 进行 MAC 层。
- MAC 层需要 ARP 获得 MAC 地址，因而要调用 ___neigh_lookup_noref 查找属于同一个网段的邻居，他会调用 neigh_probe 发送 ARP。
- 有了 MAC 地址，就可以调用 dev_queue_xmit 发送二层网络包了，它会调用 __dev_xmit_skb 会将请求放入队列。
- 设备层：网络包的发送回触发一个软中断 NET_TX_SOFTIRQ 来处理队列中的数据。这个软中断的处理函数是 net_tx_action。
- 在软中断处理函数中，会将网络包从队列上拿下来，调用网络设备的传输函数 ixgb_xmit_frame，将网络包发的设备的队列上去。

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/270716AA-E236-465E-80A1-292DCF65B298_2/HMTyLROXlkM3o1cfy02cIdPByVX09deaLD45R7cKI98z/Image.png)

### 接收网络包

- 硬件网卡接收到网络包之后，通过 DMA 技术，将网络包放入 Ring Buffer；
- 硬件网卡通过中断通知 CPU 新的网络包的到来；
- 网卡驱动程序会注册中断处理函数 ixgb_intr；
- 中断处理函数处理完需要暂时屏蔽中断的核心流程之后，通过软中断 NET_RX_SOFTIRQ 触发接下来的处理过程；
- NET_RX_SOFTIRQ 软中断处理函数 net_rx_action，net_rx_action 会调用 napi_poll，进而调用 ixgb_clean_rx_irq，从 Ring Buffer 中读取数据到内核 struct sk_buff；
- 调用 netif_receive_skb 进入内核网络协议栈，进行一些关于 VLAN 的二层逻辑处理后，调用 ip_rcv 进入三层 IP 层；
- 在 IP 层，会处理 iptables 规则，然后调用 ip_local_deliver 交给更上层 TCP 层；
- 在 TCP 层调用 tcp_v4_rcv，这里面有三个队列需要处理，如果当前的 Socket 不是正在被读；取，则放入 backlog 队列，如果正在被读取，不需要很实时的话，则放入 prequeue 队列，其他情况调用 tcp_v4_do_rcv；
- 在 tcp_v4_do_rcv 中，如果是处于 TCP_ESTABLISHED 状态，调用 tcp_rcv_established，其他的状态，调用 tcp_rcv_state_process；
- 在 tcp_rcv_established 中，调用 tcp_data_queue，如果序列号能够接的上，则放入 sk_receive_queue 队列；如果序列号接不上，则暂时放入 out_of_order_queue 队列，等序列号能够接上的时候，再放入 sk_receive_queue 队列。

至此内核接收网络包的过程到此结束，接下来就是用户态读取网络包的过程，这个过程分成几个层次。

- VFS 层：read 系统调用找到 struct file，根据里面的 file_operations 的定义，调用 sock_read_iter 函数。sock_read_iter 函数调用 sock_recvmsg 函数。
- Socket 层：从 struct file 里面的 private_data 得到 struct socket，根据里面 ops 的定义，调用 inet_recvmsg 函数。
- Sock 层：从 struct socket 里面的 sk 得到 struct sock，根据里面 sk_prot 的定义，调用 tcp_recvmsg 函数。
- TCP 层：tcp_recvmsg 函数会依次读取 receive_queue 队列、prequeue 队列和 backlog 队列。

![Image.png](https://res.craft.do/user/full/27f84843-d4d8-568d-3b2d-db22e5d6ce15/doc/ED937B27-BC42-42DC-ABC6-04212DE63155/0C89A4BD-8DAA-4F0B-B89D-53F0E8CA786B_2/bvnNjlSpIY0yAwtpnKqgzZqPyypszsw79x3ii9IXPa0z/Image.png)

