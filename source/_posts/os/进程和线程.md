
---
layout: post
title:  "操作系统里的进程和线程"
categories: OS
tags:  OS
date: 2021/09/28 20:46:25
---

![图怪兽_81f15acdf27c9e27dd3e2e54d3360863_79599](https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/%E5%9B%BE%E6%80%AA%E5%85%BD_81f15acdf27c9e27dd3e2e54d3360863_79599.png)


##### 什么是进程?

一个进程就是一个正在执行的程序的实例，进程也包括程序计数器、寄存器和变量的当前值。从概念上来说，每个

进程都有各自的虚拟 CPU，但是实际情况是 CPU 会在各个进程之间进行来回切换。

##### 进程模型?

一个进程就是一个正在执行的程序的实例，进程也包括`程序计数器`、`寄存器`和`变量的当前值`。从概念上来说，每个

进程都有各自的`虚拟 CPU`，但是实际情况是 CPU 会在各个进程之间进行来回切换。

<!--more-->



**举例**

4 道程序被抽象为 4 个拥有各自控制流程（即每个自己的程序计数器）的进程，并且每个程序都独立的运行。当

然，实际上只有一个物理程序计数器，每个程序要运行时，其逻辑程序计数器会装载到物理程序计数器中。当程序

运行结束后，其物理程序计数器就会是真正的程序计数器，然后再把它放回进程的逻辑计数器中。

**概述**

进程是某一类特定活动的总和，它有程序、输入输出以及状态。单个处理器可以被若干进程共享，它使用某

种调度算法决定何时停止一个进程的工作，并转而为另外一个进程提供服务

##### 进程状态

每个进程是一个独立的实体，有其自己的程序计数器和内部状态，但是，进程之间存在关联关系

1. `运行态`，运行态指的就是进程实际占用 CPU 时间片运行时 (获得CPU 时间片)
2. `就绪态`，就绪态指的是可运行，但因为其他进程正在运行而处于就绪状态 (还没有获得CPU 时间片)
3. `阻塞态`，除非某种外部事件发生，否则进程不能运行

**程序调度** 指的是，决定哪个进程优先被运行和运行多久

**操作系统最底层的就是调度程序**，在它上面有许多进程。所有关于中断处理、启动进程和停止进程的具体细节都隐

藏在调度程序中。事实上，调度程序只是一段非常小的程序

##### 进程的实现

操作系统为了执行进程间的切换，会维护着一张表格，这张表就是 `进程表(process table)`。每个进程占用一个

进程表项。该表项包含了进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状况、所打开文件的状态、

账号和调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后能再

次启动，就像从未被中断过一样。

<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210927135216802.png" alt="image-20210927135216802" style="zoom:50%;" />

##### 为什么要用线程?

- 多线程之间会共享同一块地址空间和所有可用数据的能力，这是进程所不具备的
- 线程要比进程`更轻量级`，由于线程更轻，所以它比进程更容易创建，也更容易撤销。在许多系统中，创建一个线程要比创建一个进程快 10 - 100 倍。
- 第三个原因可能是性能方面的探讨，如果多个线程都是 CPU 密集型的，那么并不能获得性能上的增强，但是如果存在着大量的计算和大量的 I/O 处理，拥有多个线程能在这些活动中彼此重叠进行，从而会加快应用程序的执行速度

##### 线程模型?

进程中拥有一个执行的线程，通常简写为 `线程(thread)`。线程会有程序计数器，用来记录接着要执行哪一条指

令；线程还拥有寄存器，用来保存线程当前正在使用的变量；线程还会有堆栈，用来记录程序的执行路径。尽管线

程必须在某个进程中执行，但是进程和线程完完全全是两个不同的概念，并且他们可以分开处理。进程用于把资源

集中在一起，而**线程则是 CPU 上调度执行的实体**。

在多个线程中，各个线程共享同一地址空间和其他资源。在多个进程中，进程共享物理内存、磁盘、打印机和其他

资源。

<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210927141721690.png" alt="image-20210927141721690" style="zoom:50%;" />

##### 线程状态

和进程一样，线程可以处于下面这几种状态：**运行中、阻塞、就绪和终止**

##### 线程的实现

- 在用户空间中实现线程
- 在内核空间中实现线程
- 在用户和内核空间中混合实现线程

用户态VS内核态线程

1. 当一个线程阻塞时，内核可以进行选择，是运行在同一个进程中的另一个线程（如果有就绪线程的话）还是运

   行一个另一个进程中的线程。但是在用户实现中，运行时系统始终运行自己的线程，直到内核剥夺它的 CPU 

   时间片（或者没有可运行的线程存在了）为止。

2. 在内核中创建或者销毁线程的开销比较大

3. 用户级线程和内核级线程之间的主要差别在于`性能`。用户级线程的切换需要少量的机器指令（想象一下Java程

   序的线程切换），而内核线程需要完整的上下文切换，修改内存映像，使高速缓存失效，这会导致了若干数量

   级的延迟。另一方面，在使用内核级线程时，一旦线程阻塞在 I/O 上就不需要在用户级线程中那样将整个进程

   挂起

##### 进程通信

* `竞态条件`  `临界区` `忙等互斥` ` 睡眠与唤醒` `信号量` `互斥量`  `管程` ` 消息传递` `屏障` `避免锁`

##### 调度

如果只有一个 CPU 可用，那么必须选择接下来哪个进程/线程可以运行。操作系统中有一个叫做 `调度程序`

`(scheduler)` 的角色存在，它就是做这件事儿的，该程序使用的算法叫做 `调度算法(scheduling algorithm)`

* **批处理系统中的调度:** `先来先服务`, `最短作业优先`, `最短剩余优先`

* **实时系统中的调度:** 

  实时系统可以分为两类，`硬实时(hard real time)` 和 `软实时(soft real time)` 系统，前者意味着必须要满

  足绝对的截止时间；后者的含义是虽然不希望偶尔错失截止时间，但是可以容忍。

* **交互式系统中的调度:** 

  `轮询调度` 一种最古老、最简单、最公平并且最广泛使用的算法就是 `轮询算法(round-robin)`。每个进程都会被

  分配一个时间段，称为`时间片(quantum)`，在这个时间片内允许进程运行

  `优先级调度`轮询调度假设了所有的进程是同等重要的。但事实情况可能不是这样。例如，在一所大学中的等

  级制度，首先是院长，然后是教授、秘书、后勤人员，最后是学生。这种将外部情况考虑在内就实现了`优先`

  `级调度(priority scheduling)`

##### 概览图

<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210927092731492.png" alt="image-20210927092731492" style="zoom:80%;" />

#### 文章参考： 

《现代操作系统》第四版

《Modern Operation System》fourth

 https://baike.baidu.com/item/SATA硬盘/3947233?fr=aladdin

 https://baike.baidu.com/item/虚拟地址/1329947?fr=aladdin
 
 https://www.cnblogs.com/cxuanBlog/p/12448298.html
