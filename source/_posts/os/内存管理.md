---
layout: post
title:  "操作系统里的内存管理"
categories: OS
tags:  OS
date: 2021/09/28 20:47:25
---

![图怪兽_f2433484b95076e61f00e5b8b98a68f0_68721](https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/%E5%9B%BE%E6%80%AA%E5%85%BD_f2433484b95076e61f00e5b8b98a68f0_68721.jpg)

##### 存储器结构

cpu -> 寄存器 -> 高速缓存 -> 主存 -> 磁盘


##### 一种存储器抽象：地址空间

定义: 存储位置列表,存放可执行程序,程序的数据以及堆栈

地址空间是进程可以用来寻址内存的地址集。每个进程都有它自己的地址空间，独立于其他进程的地址空间，但是

某些进程会希望可以共享地址空间 

<!--more-->


##### 映射内存? 基址寄存器和变址寄存器

每个 CPU 配置两个特殊硬件寄存器，通常叫做`基址寄存器(basic register)`和`变址寄存器(limit register)`。当

使用基址寄存器和变址寄存器时，程序会装载到内存中的连续位置并且在装载期间无需重定位。当一个进程运行

时，程序的起始物理地址装载到基址寄存器中，程序的长度则装载到变址寄存器中.

- 基址寄存器：存储数据内存的起始位置
- 变址寄存器：存储应用程序的长度


<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210928135552448.png" alt="image-20210927200421691" style="zoom:50%;" />


##### 程序运行所需内存超过物理内存?

最简单的一种方式就是`交换(swapping)`技术，即把一个进程完整的调入内存，然后再内存中运行一段时间，再把

它放回磁盘。空闲进程会存储在磁盘中，所以这些进程在没有运行时不会占用太多内存。另外一种策略叫做`虚拟`

`内存(virtual memory)`，虚拟内存技术能够允许应用程序部分的运行在内存中.

* **交换**

  交换在内存创建了多个 `空闲区(hole)`，内存会把所有的空闲区尽可能向下移动合并成为一个大的空闲区。这

  项技术称为`内存紧缩(memory compaction)`,但这项技术会消耗很多CPU的时间,通常不使用

* **虚拟内存**

  虚拟内存的基本思想是, **每个程序都有自己的地址空间，这个地址空间被划分为多个称为`页面(page)`的块**。

  每一页都是连续的地址范围。这些页被映射到物理内存，但并不是所有的页都必须在内存中才能运行程序。当

  程序引用到一部分在物理内存中的地址空间时，硬件会立刻执行必要的映射。当程序引用到一部分不在物理内

  存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令.

##### 虚拟内存中的分页

在使用虚拟内存时，虚拟地址不会直接发送到内存总线上。相反，会使用 `MMU(Memory Management Unit)` 内存

管理单元把虚拟地址映射为物理内存地址

  ![image-20210928152422814](https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210928152422814.png)

![image-20210928152951607](https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210928152951607.png)

##### 大体流程

CPU -> 虚拟内存地址空间(被分成`页面`块) -> MMU (内存单元管理) -> 物理内存-> 总线 -> 操作设备

##### 虚拟地址到物理地址的映射?

* 转换检测缓冲区 TLB (硬件层面)

  从硬件方面来解决这个问题，为计算机设置一个小型的硬件设备，能够将虚拟地址直接映射到物理地址，而不

  必再访问页表。这种设备被称为`转换检测缓冲区(Translation Lookaside Buffer, TLB)`

![image-20210928154218704](https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210928154218704.png)

##### 页面置换算法

| 算法                  | 注释                     |
| :-------------------- | :----------------------- |
| 最优算法              | 不可实现，但可以用作基准 |
| NRU(最近未使用) 算法  | 和 LRU 算法很相似        |
| FIFO(先进先出) 算法   | 有可能会抛弃重要的页面   |
| 第二次机会算法        | 比 FIFO 有较大的改善     |
| 时钟算法              | 实际使用                 |
| LRU(最近最少)算法     | 比较优秀，但是很难实现   |
| NFU(最不经常食用)算法 | 和 LRU 很类似            |
| 老化算法              | 近似 LRU 的高效算法      |
| 工作集算法            | 实施起来开销很大         |
| 工作集时钟算法        | 比较有效的算法           |

#### 概览

<img src="https://cdn.jsdelivr.net/gh/ChengKeJ/pic@master/img/image-20210927200421691.png" alt="image-20210927200421691" style="zoom:50%;" />
